function accessor(fn,fields,name){fn.fields=fields||[];fn.fname=name;return fn}function accessorName(fn){return fn==null?null:fn.fname}function accessorFields(fn){return fn==null?null:fn.fields}function getter$1(path){return path.length===1?get1(path[0]):getN(path)}const get1=field=>function(obj){return obj[field]};const getN=path=>{const len=path.length;return function(obj){for(let i=0;i<len;++i){obj=obj[path[i]]}return obj}};function error(message){throw Error(message)}function splitAccessPath(p){const path=[],n=p.length;let q=null,b=0,s="",i,j,c;p=p+"";function push(){path.push(s+p.substring(i,j));s="";i=j+1}for(i=j=0;j<n;++j){c=p[j];if(c==="\\"){s+=p.substring(i,j++);i=j}else if(c===q){push();q=null;b=-1}else if(q){continue}else if(i===b&&c==='"'){i=j+1;q=c}else if(i===b&&c==="'"){i=j+1;q=c}else if(c==="."&&!b){if(j>i){push()}else{i=j+1}}else if(c==="["){if(j>i)push();b=i=j+1}else if(c==="]"){if(!b)error("Access path missing open bracket: "+p);if(b>0)push();b=0;i=j+1}}if(b)error("Access path missing closing bracket: "+p);if(q)error("Access path missing closing quote: "+p);if(j>i){j++;push()}return path}function field$1(field,name,opt){const path=splitAccessPath(field);field=path.length===1?path[0]:field;return accessor((opt&&opt.get||getter$1)(path),[field],name||field)}const id=field$1("id");const identity$6=accessor((_=>_),[],"identity");const zero$4=accessor((()=>0),[],"zero");const one$2=accessor((()=>1),[],"one");const truthy=accessor((()=>true),[],"true");const falsy=accessor((()=>false),[],"false");function log$1$1(method,level,input){const args=[level].concat([].slice.call(input));console[method].apply(console,args)}const None$2=0;const Error$1=1;const Warn=2;const Info=3;const Debug=4;function logger(_,method){let handler=arguments.length>2&&arguments[2]!==undefined?arguments[2]:log$1$1;let level=_||None$2;return{level(_){if(arguments.length){level=+_;return this}else{return level}},error(){if(level>=Error$1)handler("error","ERROR",arguments);return this},warn(){if(level>=Warn)handler("warn","WARN",arguments);return this},info(){if(level>=Info)handler("log","INFO",arguments);return this},debug(){if(level>=Debug)handler("log","DEBUG",arguments);return this}}}var isArray=Array.isArray;function isObject(_){return _===Object(_)}const isLegalKey=key=>key!=="__proto__";function mergeConfig(){for(var _len=arguments.length,configs=new Array(_len),_key=0;_key<_len;_key++){configs[_key]=arguments[_key]}return configs.reduce(((out,source)=>{for(const key in source){if(key==="signals"){out.signals=mergeNamed(out.signals,source.signals)}else{const r=key==="legend"?{layout:1}:key==="style"?true:null;writeConfig(out,key,source[key],r)}}return out}),{})}function writeConfig(output,key,value,recurse){if(!isLegalKey(key))return;let k,o;if(isObject(value)&&!isArray(value)){o=isObject(output[key])?output[key]:output[key]={};for(k in value){if(recurse&&(recurse===true||recurse[k])){writeConfig(o,k,value[k])}else if(isLegalKey(k)){o[k]=value[k]}}}else{output[key]=value}}function mergeNamed(a,b){if(a==null)return b;const map={},out=[];function add(_){if(!map[_.name]){map[_.name]=1;out.push(_)}}b.forEach(add);a.forEach(add);return out}function peek$1(array){return array[array.length-1]}function toNumber(_){return _==null||_===""?null:+_}const exp$2=sign=>x=>sign*Math.exp(x);const log$4=sign=>x=>Math.log(sign*x);const symlog$1=c=>x=>Math.sign(x)*Math.log1p(Math.abs(x/c));const symexp=c=>x=>Math.sign(x)*Math.expm1(Math.abs(x))*c;const pow$4=exponent=>x=>x<0?-Math.pow(-x,exponent):Math.pow(x,exponent);function pan(domain,delta,lift,ground){const d0=lift(domain[0]),d1=lift(peek$1(domain)),dd=(d1-d0)*delta;return[ground(d0-dd),ground(d1-dd)]}function panLinear(domain,delta){return pan(domain,delta,toNumber,identity$6)}function panLog(domain,delta){var sign=Math.sign(domain[0]);return pan(domain,delta,log$4(sign),exp$2(sign))}function panPow(domain,delta,exponent){return pan(domain,delta,pow$4(exponent),pow$4(1/exponent))}function panSymlog(domain,delta,constant){return pan(domain,delta,symlog$1(constant),symexp(constant))}function zoom$2(domain,anchor,scale,lift,ground){const d0=lift(domain[0]),d1=lift(peek$1(domain)),da=anchor!=null?lift(anchor):(d0+d1)/2;return[ground(da+(d0-da)*scale),ground(da+(d1-da)*scale)]}function zoomLinear(domain,anchor,scale){return zoom$2(domain,anchor,scale,toNumber,identity$6)}function zoomLog(domain,anchor,scale){const sign=Math.sign(domain[0]);return zoom$2(domain,anchor,scale,log$4(sign),exp$2(sign))}function zoomPow(domain,anchor,scale,exponent){return zoom$2(domain,anchor,scale,pow$4(exponent),pow$4(1/exponent))}function zoomSymlog(domain,anchor,scale,constant){return zoom$2(domain,anchor,scale,symlog$1(constant),symexp(constant))}function quarter(date){return 1+~~(new Date(date).getMonth()/3)}function utcquarter(date){return 1+~~(new Date(date).getUTCMonth()/3)}function array$5(_){return _!=null?isArray(_)?_:[_]:[]}function clampRange(range,min,max){let lo=range[0],hi=range[1],span;if(hi<lo){span=hi;hi=lo;lo=span}span=hi-lo;return span>=max-min?[min,max]:[lo=Math.min(Math.max(lo,min),max-span),lo+span]}function isFunction(_){return typeof _==="function"}const DESCENDING="descending";function compare$1(fields,orders,opt){opt=opt||{};orders=array$5(orders)||[];const ord=[],get=[],fmap={},gen=opt.comparator||comparator;array$5(fields).forEach(((f,i)=>{if(f==null)return;ord.push(orders[i]===DESCENDING?-1:1);get.push(f=isFunction(f)?f:field$1(f,null,opt));(accessorFields(f)||[]).forEach((_=>fmap[_]=1))}));return get.length===0?null:accessor(gen(get,ord),Object.keys(fmap))}const ascending$2=(u,v)=>(u<v||u==null)&&v!=null?-1:(u>v||v==null)&&u!=null?1:(v=v instanceof Date?+v:v,u=u instanceof Date?+u:u)!==u&&v===v?-1:v!==v&&u===u?1:0;const comparator=(fields,orders)=>fields.length===1?compare1(fields[0],orders[0]):compareN(fields,orders,fields.length);const compare1=(field,order)=>function(a,b){return ascending$2(field(a),field(b))*order};const compareN=(fields,orders,n)=>{orders.push(0);return function(a,b){let f,c=0,i=-1;while(c===0&&++i<n){f=fields[i];c=ascending$2(f(a),f(b))}return c*orders[i]}};function constant$5(_){return isFunction(_)?_:()=>_}function debounce(delay,handler){let tid;return e=>{if(tid)clearTimeout(tid);tid=setTimeout((()=>(handler(e),tid=null)),delay)}}function extend$1(_){for(let x,k,i=1,len=arguments.length;i<len;++i){x=arguments[i];for(k in x){_[k]=x[k]}}return _}function extent(array,f){let i=0,n,v,min,max;if(array&&(n=array.length)){if(f==null){for(v=array[i];i<n&&(v==null||v!==v);v=array[++i]);min=max=v;for(;i<n;++i){v=array[i];if(v!=null){if(v<min)min=v;if(v>max)max=v}}}else{for(v=f(array[i]);i<n&&(v==null||v!==v);v=f(array[++i]));min=max=v;for(;i<n;++i){v=f(array[i]);if(v!=null){if(v<min)min=v;if(v>max)max=v}}}}return[min,max]}function extentIndex(array,f){const n=array.length;let i=-1,a,b,c,u,v;if(f==null){while(++i<n){b=array[i];if(b!=null&&b>=b){a=c=b;break}}if(i===n)return[-1,-1];u=v=i;while(++i<n){b=array[i];if(b!=null){if(a>b){a=b;u=i}if(c<b){c=b;v=i}}}}else{while(++i<n){b=f(array[i],i,array);if(b!=null&&b>=b){a=c=b;break}}if(i===n)return[-1,-1];u=v=i;while(++i<n){b=f(array[i],i,array);if(b!=null){if(a>b){a=b;u=i}if(c<b){c=b;v=i}}}}return[u,v]}const hop=Object.prototype.hasOwnProperty;function has$1(object,property){return hop.call(object,property)}const NULL={};function fastmap(input){let obj={},test;function has$1$1(key){return has$1(obj,key)&&obj[key]!==NULL}const map={size:0,empty:0,object:obj,has:has$1$1,get(key){return has$1$1(key)?obj[key]:undefined},set(key,value){if(!has$1$1(key)){++map.size;if(obj[key]===NULL)--map.empty}obj[key]=value;return this},delete(key){if(has$1$1(key)){--map.size;++map.empty;obj[key]=NULL}return this},clear(){map.size=map.empty=0;map.object=obj={}},test(_){if(arguments.length){test=_;return map}else{return test}},clean(){const next={};let size=0;for(const key in obj){const value=obj[key];if(value!==NULL&&(!test||!test(value))){next[key]=value;++size}}map.size=size;map.empty=0;map.object=obj=next}};if(input)Object.keys(input).forEach((key=>{map.set(key,input[key])}));return map}function flush(range,value,threshold,left,right,center){if(!threshold&&threshold!==0)return center;const t=+threshold;let a=range[0],b=peek$1(range),l;if(b<a){l=a;a=b;b=l}l=Math.abs(value-a);const r=Math.abs(b-value);return l<r&&l<=t?left:r<=t?right:center}function inherits(child,parent,members){const proto=child.prototype=Object.create(parent.prototype);Object.defineProperty(proto,"constructor",{value:child,writable:true,enumerable:true,configurable:true});return extend$1(proto,members)}function inrange(value,range,left,right){let r0=range[0],r1=range[range.length-1],t;if(r0>r1){t=r0;r0=r1;r1=t}left=left===undefined||left;right=right===undefined||right;return(left?r0<=value:r0<value)&&(right?value<=r1:value<r1)}function isBoolean$2(_){return typeof _==="boolean"}function isDate$1(_){return Object.prototype.toString.call(_)==="[object Date]"}function isIterable(_){return _&&isFunction(_[Symbol.iterator])}function isNumber$1(_){return typeof _==="number"}function isRegExp(_){return Object.prototype.toString.call(_)==="[object RegExp]"}function isString(_){return typeof _==="string"}function key(fields,flat,opt){if(fields){fields=flat?array$5(fields).map((f=>f.replace(/\\(.)/g,"$1"))):array$5(fields)}const len=fields&&fields.length,gen=opt&&opt.get||getter$1,map=f=>gen(flat?[f]:splitAccessPath(f));let fn;if(!len){fn=function(){return""}}else if(len===1){const get=map(fields[0]);fn=function(_){return""+get(_)}}else{const get=fields.map(map);fn=function(_){let s=""+get[0](_),i=0;while(++i<len)s+="|"+get[i](_);return s}}return accessor(fn,fields,"key")}function lerp(array,frac){const lo=array[0],hi=peek$1(array),f=+frac;return!f?lo:f===1?hi:lo+f*(hi-lo)}const DEFAULT_MAX_SIZE=1e4;function lruCache(maxsize){maxsize=+maxsize||DEFAULT_MAX_SIZE;let curr,prev,size;const clear=()=>{curr={};prev={};size=0};const update=(key,value)=>{if(++size>maxsize){prev=curr;curr={};size=1}return curr[key]=value};clear();return{clear:clear,has:key=>has$1(curr,key)||has$1(prev,key),get:key=>has$1(curr,key)?curr[key]:has$1(prev,key)?update(key,prev[key]):undefined,set:(key,value)=>has$1(curr,key)?curr[key]=value:update(key,value)}}function merge$3(compare,array0,array1,output){const n0=array0.length,n1=array1.length;if(!n1)return array0;if(!n0)return array1;const merged=output||new array0.constructor(n0+n1);let i0=0,i1=0,i=0;for(;i0<n0&&i1<n1;++i){merged[i]=compare(array0[i0],array1[i1])>0?array1[i1++]:array0[i0++]}for(;i0<n0;++i0,++i){merged[i]=array0[i0]}for(;i1<n1;++i1,++i){merged[i]=array1[i1]}return merged}function repeat(str,reps){let s="";while(--reps>=0)s+=str;return s}function pad$2(str,length,padchar,align){const c=padchar||" ",s=str+"",n=length-s.length;return n<=0?s:align==="left"?repeat(c,n)+s:align==="center"?repeat(c,~~(n/2))+s+repeat(c,Math.ceil(n/2)):s+repeat(c,n)}function span(array){return array&&peek$1(array)-array[0]||0}function $(x){return isArray(x)?"["+x.map($)+"]":isObject(x)||isString(x)?JSON.stringify(x).replace("\u2028","\\u2028").replace("\u2029","\\u2029"):x}function toBoolean(_){return _==null||_===""?null:!_||_==="false"||_==="0"?false:!!_}const defaultParser=_=>isNumber$1(_)?_:isDate$1(_)?_:Date.parse(_);function toDate(_,parser){parser=parser||defaultParser;return _==null||_===""?null:parser(_)}function toString$1(_){return _==null||_===""?null:_+""}function toSet(_){const s={},n=_.length;for(let i=0;i<n;++i)s[_[i]]=true;return s}function truncate$1(str,length,align,ellipsis){const e=ellipsis!=null?ellipsis:"…",s=str+"",n=s.length,l=Math.max(0,length-e.length);return n<=length?s:align==="left"?e+s.slice(n-l):align==="center"?s.slice(0,Math.ceil(l/2))+e+s.slice(n-~~(l/2)):s.slice(0,l)+e}function visitArray(array,filter,visitor){if(array){if(filter){const n=array.length;for(let i=0;i<n;++i){const t=filter(array[i]);if(t)visitor(t,i,array)}}else{array.forEach(visitor)}}}var EOL={},EOF={},QUOTE=34,NEWLINE=10,RETURN=13;function objectConverter(columns){return new Function("d","return {"+columns.map((function(name,i){return JSON.stringify(name)+": d["+i+'] || ""'})).join(",")+"}")}function customConverter(columns,f){var object=objectConverter(columns);return function(row,i){return f(object(row),i,columns)}}function inferColumns(rows){var columnSet=Object.create(null),columns=[];rows.forEach((function(row){for(var column in row){if(!(column in columnSet)){columns.push(columnSet[column]=column)}}}));return columns}function pad$1(value,width){var s=value+"",length=s.length;return length<width?new Array(width-length+1).join(0)+s:s}function formatYear$1(year){return year<0?"-"+pad$1(-year,6):year>9999?"+"+pad$1(year,6):pad$1(year,4)}function formatDate(date){var hours=date.getUTCHours(),minutes=date.getUTCMinutes(),seconds=date.getUTCSeconds(),milliseconds=date.getUTCMilliseconds();return isNaN(date)?"Invalid Date":formatYear$1(date.getUTCFullYear())+"-"+pad$1(date.getUTCMonth()+1,2)+"-"+pad$1(date.getUTCDate(),2)+(milliseconds?"T"+pad$1(hours,2)+":"+pad$1(minutes,2)+":"+pad$1(seconds,2)+"."+pad$1(milliseconds,3)+"Z":seconds?"T"+pad$1(hours,2)+":"+pad$1(minutes,2)+":"+pad$1(seconds,2)+"Z":minutes||hours?"T"+pad$1(hours,2)+":"+pad$1(minutes,2)+"Z":"")}function dsvFormat(delimiter){var reFormat=new RegExp('["'+delimiter+"\n\r]"),DELIMITER=delimiter.charCodeAt(0);function parse(text,f){var convert,columns,rows=parseRows(text,(function(row,i){if(convert)return convert(row,i-1);columns=row,convert=f?customConverter(row,f):objectConverter(row)}));rows.columns=columns||[];return rows}function parseRows(text,f){var rows=[],N=text.length,I=0,n=0,t,eof=N<=0,eol=false;if(text.charCodeAt(N-1)===NEWLINE)--N;if(text.charCodeAt(N-1)===RETURN)--N;function token(){if(eof)return EOF;if(eol)return eol=false,EOL;var i,j=I,c;if(text.charCodeAt(j)===QUOTE){while(I++<N&&text.charCodeAt(I)!==QUOTE||text.charCodeAt(++I)===QUOTE);if((i=I)>=N)eof=true;else if((c=text.charCodeAt(I++))===NEWLINE)eol=true;else if(c===RETURN){eol=true;if(text.charCodeAt(I)===NEWLINE)++I}return text.slice(j+1,i-1).replace(/""/g,'"')}while(I<N){if((c=text.charCodeAt(i=I++))===NEWLINE)eol=true;else if(c===RETURN){eol=true;if(text.charCodeAt(I)===NEWLINE)++I}else if(c!==DELIMITER)continue;return text.slice(j,i)}return eof=true,text.slice(j,N)}while((t=token())!==EOF){var row=[];while(t!==EOL&&t!==EOF)row.push(t),t=token();if(f&&(row=f(row,n++))==null)continue;rows.push(row)}return rows}function preformatBody(rows,columns){return rows.map((function(row){return columns.map((function(column){return formatValue(row[column])})).join(delimiter)}))}function format(rows,columns){if(columns==null)columns=inferColumns(rows);return[columns.map(formatValue).join(delimiter)].concat(preformatBody(rows,columns)).join("\n")}function formatBody(rows,columns){if(columns==null)columns=inferColumns(rows);return preformatBody(rows,columns).join("\n")}function formatRows(rows){return rows.map(formatRow).join("\n")}function formatRow(row){return row.map(formatValue).join(delimiter)}function formatValue(value){return value==null?"":value instanceof Date?formatDate(value):reFormat.test(value+="")?'"'+value.replace(/"/g,'""')+'"':value}return{parse:parse,parseRows:parseRows,format:format,formatBody:formatBody,formatRows:formatRows,formatRow:formatRow,formatValue:formatValue}}function identity$5(x){return x}function transform$3(transform){if(transform==null)return identity$5;var x0,y0,kx=transform.scale[0],ky=transform.scale[1],dx=transform.translate[0],dy=transform.translate[1];return function(input,i){if(!i)x0=y0=0;var j=2,n=input.length,output=new Array(n);output[0]=(x0+=input[0])*kx+dx;output[1]=(y0+=input[1])*ky+dy;while(j<n)output[j]=input[j],++j;return output}}function reverse$2(array,n){var t,j=array.length,i=j-n;while(i<--j)t=array[i],array[i++]=array[j],array[j]=t}function feature(topology,o){if(typeof o==="string")o=topology.objects[o];return o.type==="GeometryCollection"?{type:"FeatureCollection",features:o.geometries.map((function(o){return feature$1(topology,o)}))}:feature$1(topology,o)}function feature$1(topology,o){var id=o.id,bbox=o.bbox,properties=o.properties==null?{}:o.properties,geometry=object$1(topology,o);return id==null&&bbox==null?{type:"Feature",properties:properties,geometry:geometry}:bbox==null?{type:"Feature",id:id,properties:properties,geometry:geometry}:{type:"Feature",id:id,bbox:bbox,properties:properties,geometry:geometry}}function object$1(topology,o){var transformPoint=transform$3(topology.transform),arcs=topology.arcs;function arc(i,points){if(points.length)points.pop();for(var a=arcs[i<0?~i:i],k=0,n=a.length;k<n;++k){points.push(transformPoint(a[k],k))}if(i<0)reverse$2(points,n)}function point(p){return transformPoint(p)}function line(arcs){var points=[];for(var i=0,n=arcs.length;i<n;++i)arc(arcs[i],points);if(points.length<2)points.push(points[0]);return points}function ring(arcs){var points=line(arcs);while(points.length<4)points.push(points[0]);return points}function polygon(arcs){return arcs.map(ring)}function geometry(o){var type=o.type,coordinates;switch(type){case"GeometryCollection":return{type:type,geometries:o.geometries.map(geometry)};case"Point":coordinates=point(o.coordinates);break;case"MultiPoint":coordinates=o.coordinates.map(point);break;case"LineString":coordinates=line(o.arcs);break;case"MultiLineString":coordinates=o.arcs.map(line);break;case"Polygon":coordinates=polygon(o.arcs);break;case"MultiPolygon":coordinates=o.arcs.map(polygon);break;default:return null}return{type:type,coordinates:coordinates}}return geometry(o)}function stitch(topology,arcs){var stitchedArcs={},fragmentByStart={},fragmentByEnd={},fragments=[],emptyIndex=-1;arcs.forEach((function(i,j){var arc=topology.arcs[i<0?~i:i],t;if(arc.length<3&&!arc[1][0]&&!arc[1][1]){t=arcs[++emptyIndex],arcs[emptyIndex]=i,arcs[j]=t}}));arcs.forEach((function(i){var e=ends(i),start=e[0],end=e[1],f,g;if(f=fragmentByEnd[start]){delete fragmentByEnd[f.end];f.push(i);f.end=end;if(g=fragmentByStart[end]){delete fragmentByStart[g.start];var fg=g===f?f:f.concat(g);fragmentByStart[fg.start=f.start]=fragmentByEnd[fg.end=g.end]=fg}else{fragmentByStart[f.start]=fragmentByEnd[f.end]=f}}else if(f=fragmentByStart[end]){delete fragmentByStart[f.start];f.unshift(i);f.start=start;if(g=fragmentByEnd[start]){delete fragmentByEnd[g.end];var gf=g===f?f:g.concat(f);fragmentByStart[gf.start=g.start]=fragmentByEnd[gf.end=f.end]=gf}else{fragmentByStart[f.start]=fragmentByEnd[f.end]=f}}else{f=[i];fragmentByStart[f.start=start]=fragmentByEnd[f.end=end]=f}}));function ends(i){var arc=topology.arcs[i<0?~i:i],p0=arc[0],p1;if(topology.transform)p1=[0,0],arc.forEach((function(dp){p1[0]+=dp[0],p1[1]+=dp[1]}));else p1=arc[arc.length-1];return i<0?[p1,p0]:[p0,p1]}function flush(fragmentByEnd,fragmentByStart){for(var k in fragmentByEnd){var f=fragmentByEnd[k];delete fragmentByStart[f.start];delete f.start;delete f.end;f.forEach((function(i){stitchedArcs[i<0?~i:i]=1}));fragments.push(f)}}flush(fragmentByEnd,fragmentByStart);flush(fragmentByStart,fragmentByEnd);arcs.forEach((function(i){if(!stitchedArcs[i<0?~i:i])fragments.push([i])}));return fragments}function mesh(topology){return object$1(topology,meshArcs.apply(this,arguments))}function meshArcs(topology,object,filter){var arcs,i,n;if(arguments.length>1)arcs=extractArcs(topology,object,filter);else for(i=0,arcs=new Array(n=topology.arcs.length);i<n;++i)arcs[i]=i;return{type:"MultiLineString",arcs:stitch(topology,arcs)}}function extractArcs(topology,object,filter){var arcs=[],geomsByArc=[],geom;function extract0(i){var j=i<0?~i:i;(geomsByArc[j]||(geomsByArc[j]=[])).push({i:i,g:geom})}function extract1(arcs){arcs.forEach(extract0)}function extract2(arcs){arcs.forEach(extract1)}function extract3(arcs){arcs.forEach(extract2)}function geometry(o){switch(geom=o,o.type){case"GeometryCollection":o.geometries.forEach(geometry);break;case"LineString":extract1(o.arcs);break;case"MultiLineString":case"Polygon":extract2(o.arcs);break;case"MultiPolygon":extract3(o.arcs);break}}geometry(object);geomsByArc.forEach(filter==null?function(geoms){arcs.push(geoms[0].i)}:function(geoms){if(filter(geoms[0].g,geoms[geoms.length-1].g))arcs.push(geoms[0].i)});return arcs}function ascending$1(a,b){return a==null||b==null?NaN:a<b?-1:a>b?1:a>=b?0:NaN}function descending$1(a,b){return a==null||b==null?NaN:b<a?-1:b>a?1:b>=a?0:NaN}function bisector(f){let compare1,compare2,delta;if(f.length!==2){compare1=ascending$1;compare2=(d,x)=>ascending$1(f(d),x);delta=(d,x)=>f(d)-x}else{compare1=f===ascending$1||f===descending$1?f:zero$3;compare2=f;delta=f}function left(a,x,lo=0,hi=a.length){if(lo<hi){if(compare1(x,x)!==0)return hi;do{const mid=lo+hi>>>1;if(compare2(a[mid],x)<0)lo=mid+1;else hi=mid}while(lo<hi)}return lo}function right(a,x,lo=0,hi=a.length){if(lo<hi){if(compare1(x,x)!==0)return hi;do{const mid=lo+hi>>>1;if(compare2(a[mid],x)<=0)lo=mid+1;else hi=mid}while(lo<hi)}return lo}function center(a,x,lo=0,hi=a.length){const i=left(a,x,lo,hi-1);return i>lo&&delta(a[i-1],x)>-delta(a[i],x)?i-1:i}return{left:left,center:center,right:right}}function zero$3(){return 0}function number$6(x){return x===null?NaN:+x}function*numbers$2(values,valueof){if(valueof===undefined){for(let value of values){if(value!=null&&(value=+value)>=value){yield value}}}else{let index=-1;for(let value of values){if((value=valueof(value,++index,values))!=null&&(value=+value)>=value){yield value}}}}const ascendingBisect=bisector(ascending$1);const bisectRight$1=ascendingBisect.right;const bisectLeft$1=ascendingBisect.left;bisector(number$6).center;function variance(values,valueof){let count=0;let delta;let mean=0;let sum=0;if(valueof===undefined){for(let value of values){if(value!=null&&(value=+value)>=value){delta=value-mean;mean+=delta/++count;sum+=delta*(value-mean)}}}else{let index=-1;for(let value of values){if((value=valueof(value,++index,values))!=null&&(value=+value)>=value){delta=value-mean;mean+=delta/++count;sum+=delta*(value-mean)}}}if(count>1)return sum/(count-1)}function deviation(values,valueof){const v=variance(values,valueof);return v?Math.sqrt(v):v}class Adder{constructor(){this._partials=new Float64Array(32);this._n=0}add(x){const p=this._partials;let i=0;for(let j=0;j<this._n&&j<32;j++){const y=p[j],hi=x+y,lo=Math.abs(x)<Math.abs(y)?x-(hi-y):y-(hi-x);if(lo)p[i++]=lo;x=hi}p[i]=x;this._n=i+1;return this}valueOf(){const p=this._partials;let n=this._n,x,y,lo,hi=0;if(n>0){hi=p[--n];while(n>0){x=hi;y=p[--n];hi=x+y;lo=y-(hi-x);if(lo)break}if(n>0&&(lo<0&&p[n-1]<0||lo>0&&p[n-1]>0)){y=lo*2;x=hi+y;if(y==x-hi)hi=x}}return hi}}class InternMap extends Map{constructor(entries,key=keyof){super();Object.defineProperties(this,{_intern:{value:new Map},_key:{value:key}});if(entries!=null)for(const[key,value]of entries)this.set(key,value)}get(key){return super.get(intern_get(this,key))}has(key){return super.has(intern_get(this,key))}set(key,value){return super.set(intern_set(this,key),value)}delete(key){return super.delete(intern_delete(this,key))}}class InternSet extends Set{constructor(values,key=keyof){super();Object.defineProperties(this,{_intern:{value:new Map},_key:{value:key}});if(values!=null)for(const value of values)this.add(value)}has(value){return super.has(intern_get(this,value))}add(value){return super.add(intern_set(this,value))}delete(value){return super.delete(intern_delete(this,value))}}function intern_get({_intern:_intern,_key:_key},value){const key=_key(value);return _intern.has(key)?_intern.get(key):value}function intern_set({_intern:_intern,_key:_key},value){const key=_key(value);if(_intern.has(key))return _intern.get(key);_intern.set(key,value);return value}function intern_delete({_intern:_intern,_key:_key},value){const key=_key(value);if(_intern.has(key)){value=_intern.get(key);_intern.delete(key)}return value}function keyof(value){return value!==null&&typeof value==="object"?value.valueOf():value}function permute(source,keys){return Array.from(keys,(key=>source[key]))}function compareDefined(compare=ascending$1){if(compare===ascending$1)return ascendingDefined;if(typeof compare!=="function")throw new TypeError("compare is not a function");return(a,b)=>{const x=compare(a,b);if(x||x===0)return x;return(compare(b,b)===0)-(compare(a,a)===0)}}function ascendingDefined(a,b){return(a==null||!(a>=a))-(b==null||!(b>=b))||(a<b?-1:a>b?1:0)}const e10=Math.sqrt(50),e5=Math.sqrt(10),e2=Math.sqrt(2);function tickSpec(start,stop,count){const step=(stop-start)/Math.max(0,count),power=Math.floor(Math.log10(step)),error=step/Math.pow(10,power),factor=error>=e10?10:error>=e5?5:error>=e2?2:1;let i1,i2,inc;if(power<0){inc=Math.pow(10,-power)/factor;i1=Math.round(start*inc);i2=Math.round(stop*inc);if(i1/inc<start)++i1;if(i2/inc>stop)--i2;inc=-inc}else{inc=Math.pow(10,power)*factor;i1=Math.round(start/inc);i2=Math.round(stop/inc);if(i1*inc<start)++i1;if(i2*inc>stop)--i2}if(i2<i1&&.5<=count&&count<2)return tickSpec(start,stop,count*2);return[i1,i2,inc]}function ticks(start,stop,count){stop=+stop,start=+start,count=+count;if(!(count>0))return[];if(start===stop)return[start];const reverse=stop<start,[i1,i2,inc]=reverse?tickSpec(stop,start,count):tickSpec(start,stop,count);if(!(i2>=i1))return[];const n=i2-i1+1,ticks=new Array(n);if(reverse){if(inc<0)for(let i=0;i<n;++i)ticks[i]=(i2-i)/-inc;else for(let i=0;i<n;++i)ticks[i]=(i2-i)*inc}else{if(inc<0)for(let i=0;i<n;++i)ticks[i]=(i1+i)/-inc;else for(let i=0;i<n;++i)ticks[i]=(i1+i)*inc}return ticks}function tickIncrement(start,stop,count){stop=+stop,start=+start,count=+count;return tickSpec(start,stop,count)[2]}function tickStep(start,stop,count){stop=+stop,start=+start,count=+count;const reverse=stop<start,inc=reverse?tickIncrement(stop,start,count):tickIncrement(start,stop,count);return(reverse?-1:1)*(inc<0?1/-inc:inc)}function max$2(values,valueof){let max;if(valueof===undefined){for(const value of values){if(value!=null&&(max<value||max===undefined&&value>=value)){max=value}}}else{let index=-1;for(let value of values){if((value=valueof(value,++index,values))!=null&&(max<value||max===undefined&&value>=value)){max=value}}}return max}function min$2(values,valueof){let min;if(valueof===undefined){for(const value of values){if(value!=null&&(min>value||min===undefined&&value>=value)){min=value}}}else{let index=-1;for(let value of values){if((value=valueof(value,++index,values))!=null&&(min>value||min===undefined&&value>=value)){min=value}}}return min}function quickselect(array,k,left=0,right=Infinity,compare){k=Math.floor(k);left=Math.floor(Math.max(0,left));right=Math.floor(Math.min(array.length-1,right));if(!(left<=k&&k<=right))return array;compare=compare===undefined?ascendingDefined:compareDefined(compare);while(right>left){if(right-left>600){const n=right-left+1;const m=k-left+1;const z=Math.log(n);const s=.5*Math.exp(2*z/3);const sd=.5*Math.sqrt(z*s*(n-s)/n)*(m-n/2<0?-1:1);const newLeft=Math.max(left,Math.floor(k-m*s/n+sd));const newRight=Math.min(right,Math.floor(k+(n-m)*s/n+sd));quickselect(array,k,newLeft,newRight,compare)}const t=array[k];let i=left;let j=right;swap$1(array,left,k);if(compare(array[right],t)>0)swap$1(array,left,right);while(i<j){swap$1(array,i,j),++i,--j;while(compare(array[i],t)<0)++i;while(compare(array[j],t)>0)--j}if(compare(array[left],t)===0)swap$1(array,left,j);else++j,swap$1(array,j,right);if(j<=k)left=j+1;if(k<=j)right=j-1}return array}function swap$1(array,i,j){const t=array[i];array[i]=array[j];array[j]=t}function quantile$1(values,p,valueof){values=Float64Array.from(numbers$2(values,valueof));if(!(n=values.length)||isNaN(p=+p))return;if(p<=0||n<2)return min$2(values);if(p>=1)return max$2(values);var n,i=(n-1)*p,i0=Math.floor(i),value0=max$2(quickselect(values,i0).subarray(0,i0+1)),value1=min$2(values.subarray(i0+1));return value0+(value1-value0)*(i-i0)}function quantileSorted(values,p,valueof=number$6){if(!(n=values.length)||isNaN(p=+p))return;if(p<=0||n<2)return+valueof(values[0],0,values);if(p>=1)return+valueof(values[n-1],n-1,values);var n,i=(n-1)*p,i0=Math.floor(i),value0=+valueof(values[i0],i0,values),value1=+valueof(values[i0+1],i0+1,values);return value0+(value1-value0)*(i-i0)}function mean(values,valueof){let count=0;let sum=0;if(valueof===undefined){for(let value of values){if(value!=null&&(value=+value)>=value){++count,sum+=value}}}else{let index=-1;for(let value of values){if((value=valueof(value,++index,values))!=null&&(value=+value)>=value){++count,sum+=value}}}if(count)return sum/count}function median(values,valueof){return quantile$1(values,.5,valueof)}function*flatten(arrays){for(const array of arrays){yield*array}}function merge$2(arrays){return Array.from(flatten(arrays))}function range$4(start,stop,step){start=+start,stop=+stop,step=(n=arguments.length)<2?(stop=start,start=0,1):n<3?1:+step;var i=-1,n=Math.max(0,Math.ceil((stop-start)/step))|0,range=new Array(n);while(++i<n){range[i]=start+i*step}return range}function sum$1(values,valueof){let sum=0;{for(let value of values){if(value=+value){sum+=value}}}return sum}function intersection(values,...others){values=new InternSet(values);others=others.map(set$5);out:for(const value of values){for(const other of others){if(!other.has(value)){values.delete(value);continue out}}}return values}function set$5(values){return values instanceof InternSet?values:new InternSet(values)}function union(...others){const set=new InternSet;for(const other of others){for(const o of other){set.add(o)}}return set}function formatDecimal(x){return Math.abs(x=Math.round(x))>=1e21?x.toLocaleString("en").replace(/,/g,""):x.toString(10)}function formatDecimalParts(x,p){if((i=(x=p?x.toExponential(p-1):x.toExponential()).indexOf("e"))<0)return null;var i,coefficient=x.slice(0,i);return[coefficient.length>1?coefficient[0]+coefficient.slice(2):coefficient,+x.slice(i+1)]}function exponent(x){return x=formatDecimalParts(Math.abs(x)),x?x[1]:NaN}function formatGroup(grouping,thousands){return function(value,width){var i=value.length,t=[],j=0,g=grouping[0],length=0;while(i>0&&g>0){if(length+g+1>width)g=Math.max(1,width-length);t.push(value.substring(i-=g,i+g));if((length+=g+1)>width)break;g=grouping[j=(j+1)%grouping.length]}return t.reverse().join(thousands)}}function formatNumerals(numerals){return function(value){return value.replace(/[0-9]/g,(function(i){return numerals[+i]}))}}var re=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function formatSpecifier(specifier){if(!(match=re.exec(specifier)))throw new Error("invalid format: "+specifier);var match;return new FormatSpecifier({fill:match[1],align:match[2],sign:match[3],symbol:match[4],zero:match[5],width:match[6],comma:match[7],precision:match[8]&&match[8].slice(1),trim:match[9],type:match[10]})}formatSpecifier.prototype=FormatSpecifier.prototype;function FormatSpecifier(specifier){this.fill=specifier.fill===undefined?" ":specifier.fill+"";this.align=specifier.align===undefined?">":specifier.align+"";this.sign=specifier.sign===undefined?"-":specifier.sign+"";this.symbol=specifier.symbol===undefined?"":specifier.symbol+"";this.zero=!!specifier.zero;this.width=specifier.width===undefined?undefined:+specifier.width;this.comma=!!specifier.comma;this.precision=specifier.precision===undefined?undefined:+specifier.precision;this.trim=!!specifier.trim;this.type=specifier.type===undefined?"":specifier.type+""}FormatSpecifier.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(this.width===undefined?"":Math.max(1,this.width|0))+(this.comma?",":"")+(this.precision===undefined?"":"."+Math.max(0,this.precision|0))+(this.trim?"~":"")+this.type};function formatTrim(s){out:for(var n=s.length,i=1,i0=-1,i1;i<n;++i){switch(s[i]){case".":i0=i1=i;break;case"0":if(i0===0)i0=i;i1=i;break;default:if(!+s[i])break out;if(i0>0)i0=0;break}}return i0>0?s.slice(0,i0)+s.slice(i1+1):s}var prefixExponent;function formatPrefixAuto(x,p){var d=formatDecimalParts(x,p);if(!d)return x+"";var coefficient=d[0],exponent=d[1],i=exponent-(prefixExponent=Math.max(-8,Math.min(8,Math.floor(exponent/3)))*3)+1,n=coefficient.length;return i===n?coefficient:i>n?coefficient+new Array(i-n+1).join("0"):i>0?coefficient.slice(0,i)+"."+coefficient.slice(i):"0."+new Array(1-i).join("0")+formatDecimalParts(x,Math.max(0,p+i-1))[0]}function formatRounded(x,p){var d=formatDecimalParts(x,p);if(!d)return x+"";var coefficient=d[0],exponent=d[1];return exponent<0?"0."+new Array(-exponent).join("0")+coefficient:coefficient.length>exponent+1?coefficient.slice(0,exponent+1)+"."+coefficient.slice(exponent+1):coefficient+new Array(exponent-coefficient.length+2).join("0")}var formatTypes={"%":(x,p)=>(x*100).toFixed(p),b:x=>Math.round(x).toString(2),c:x=>x+"",d:formatDecimal,e:(x,p)=>x.toExponential(p),f:(x,p)=>x.toFixed(p),g:(x,p)=>x.toPrecision(p),o:x=>Math.round(x).toString(8),p:(x,p)=>formatRounded(x*100,p),r:formatRounded,s:formatPrefixAuto,X:x=>Math.round(x).toString(16).toUpperCase(),x:x=>Math.round(x).toString(16)};function identity$4(x){return x}var map$1=Array.prototype.map,prefixes=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];function formatLocale$1(locale){var group=locale.grouping===undefined||locale.thousands===undefined?identity$4:formatGroup(map$1.call(locale.grouping,Number),locale.thousands+""),currencyPrefix=locale.currency===undefined?"":locale.currency[0]+"",currencySuffix=locale.currency===undefined?"":locale.currency[1]+"",decimal=locale.decimal===undefined?".":locale.decimal+"",numerals=locale.numerals===undefined?identity$4:formatNumerals(map$1.call(locale.numerals,String)),percent=locale.percent===undefined?"%":locale.percent+"",minus=locale.minus===undefined?"−":locale.minus+"",nan=locale.nan===undefined?"NaN":locale.nan+"";function newFormat(specifier){specifier=formatSpecifier(specifier);var fill=specifier.fill,align=specifier.align,sign=specifier.sign,symbol=specifier.symbol,zero=specifier.zero,width=specifier.width,comma=specifier.comma,precision=specifier.precision,trim=specifier.trim,type=specifier.type;if(type==="n")comma=true,type="g";else if(!formatTypes[type])precision===undefined&&(precision=12),trim=true,type="g";if(zero||fill==="0"&&align==="=")zero=true,fill="0",align="=";var prefix=symbol==="$"?currencyPrefix:symbol==="#"&&/[boxX]/.test(type)?"0"+type.toLowerCase():"",suffix=symbol==="$"?currencySuffix:/[%p]/.test(type)?percent:"";var formatType=formatTypes[type],maybeSuffix=/[defgprs%]/.test(type);precision=precision===undefined?6:/[gprs]/.test(type)?Math.max(1,Math.min(21,precision)):Math.max(0,Math.min(20,precision));function format(value){var valuePrefix=prefix,valueSuffix=suffix,i,n,c;if(type==="c"){valueSuffix=formatType(value)+valueSuffix;value=""}else{value=+value;var valueNegative=value<0||1/value<0;value=isNaN(value)?nan:formatType(Math.abs(value),precision);if(trim)value=formatTrim(value);if(valueNegative&&+value===0&&sign!=="+")valueNegative=false;valuePrefix=(valueNegative?sign==="("?sign:minus:sign==="-"||sign==="("?"":sign)+valuePrefix;valueSuffix=(type==="s"?prefixes[8+prefixExponent/3]:"")+valueSuffix+(valueNegative&&sign==="("?")":"");if(maybeSuffix){i=-1,n=value.length;while(++i<n){if(c=value.charCodeAt(i),48>c||c>57){valueSuffix=(c===46?decimal+value.slice(i+1):value.slice(i))+valueSuffix;value=value.slice(0,i);break}}}}if(comma&&!zero)value=group(value,Infinity);var length=valuePrefix.length+value.length+valueSuffix.length,padding=length<width?new Array(width-length+1).join(fill):"";if(comma&&zero)value=group(padding+value,padding.length?width-valueSuffix.length:Infinity),padding="";switch(align){case"<":value=valuePrefix+value+valueSuffix+padding;break;case"=":value=valuePrefix+padding+value+valueSuffix;break;case"^":value=padding.slice(0,length=padding.length>>1)+valuePrefix+value+valueSuffix+padding.slice(length);break;default:value=padding+valuePrefix+value+valueSuffix;break}return numerals(value)}format.toString=function(){return specifier+""};return format}function formatPrefix(specifier,value){var f=newFormat((specifier=formatSpecifier(specifier),specifier.type="f",specifier)),e=Math.max(-8,Math.min(8,Math.floor(exponent(value)/3)))*3,k=Math.pow(10,-e),prefix=prefixes[8+e/3];return function(value){return f(k*value)+prefix}}return{format:newFormat,formatPrefix:formatPrefix}}var locale$2;var format$3;var formatPrefix;defaultLocale$2({thousands:",",grouping:[3],currency:["$",""]});function defaultLocale$2(definition){locale$2=formatLocale$1(definition);format$3=locale$2.format;formatPrefix=locale$2.formatPrefix;return locale$2}function precisionFixed(step){return Math.max(0,-exponent(Math.abs(step)))}function precisionPrefix(step,value){return Math.max(0,Math.max(-8,Math.min(8,Math.floor(exponent(value)/3)))*3-exponent(Math.abs(step)))}function precisionRound(step,max){step=Math.abs(step),max=Math.abs(max)-step;return Math.max(0,exponent(max)-exponent(step))+1}const t0$2=new Date,t1$1=new Date;function timeInterval$1(floori,offseti,count,field){function interval(date){return floori(date=arguments.length===0?new Date:new Date(+date)),date}interval.floor=date=>(floori(date=new Date(+date)),date);interval.ceil=date=>(floori(date=new Date(date-1)),offseti(date,1),floori(date),date);interval.round=date=>{const d0=interval(date),d1=interval.ceil(date);return date-d0<d1-date?d0:d1};interval.offset=(date,step)=>(offseti(date=new Date(+date),step==null?1:Math.floor(step)),date);interval.range=(start,stop,step)=>{const range=[];start=interval.ceil(start);step=step==null?1:Math.floor(step);if(!(start<stop)||!(step>0))return range;let previous;do{range.push(previous=new Date(+start)),offseti(start,step),floori(start)}while(previous<start&&start<stop);return range};interval.filter=test=>timeInterval$1((date=>{if(date>=date)while(floori(date),!test(date))date.setTime(date-1)}),((date,step)=>{if(date>=date){if(step<0)while(++step<=0){while(offseti(date,-1),!test(date)){}}else while(--step>=0){while(offseti(date,+1),!test(date)){}}}}));if(count){interval.count=(start,end)=>{t0$2.setTime(+start),t1$1.setTime(+end);floori(t0$2),floori(t1$1);return Math.floor(count(t0$2,t1$1))};interval.every=step=>{step=Math.floor(step);return!isFinite(step)||!(step>0)?null:!(step>1)?interval:interval.filter(field?d=>field(d)%step===0:d=>interval.count(0,d)%step===0)}}return interval}const millisecond=timeInterval$1((()=>{}),((date,step)=>{date.setTime(+date+step)}),((start,end)=>end-start));millisecond.every=k=>{k=Math.floor(k);if(!isFinite(k)||!(k>0))return null;if(!(k>1))return millisecond;return timeInterval$1((date=>{date.setTime(Math.floor(date/k)*k)}),((date,step)=>{date.setTime(+date+step*k)}),((start,end)=>(end-start)/k))};millisecond.range;const durationSecond$1=1e3;const durationMinute$1=durationSecond$1*60;const durationHour$1=durationMinute$1*60;const durationDay$1=durationHour$1*24;const durationWeek$1=durationDay$1*7;const durationMonth$1=durationDay$1*30;const durationYear$1=durationDay$1*365;const second=timeInterval$1((date=>{date.setTime(date-date.getMilliseconds())}),((date,step)=>{date.setTime(+date+step*durationSecond$1)}),((start,end)=>(end-start)/durationSecond$1),(date=>date.getUTCSeconds()));second.range;const timeMinute=timeInterval$1((date=>{date.setTime(date-date.getMilliseconds()-date.getSeconds()*durationSecond$1)}),((date,step)=>{date.setTime(+date+step*durationMinute$1)}),((start,end)=>(end-start)/durationMinute$1),(date=>date.getMinutes()));timeMinute.range;const utcMinute=timeInterval$1((date=>{date.setUTCSeconds(0,0)}),((date,step)=>{date.setTime(+date+step*durationMinute$1)}),((start,end)=>(end-start)/durationMinute$1),(date=>date.getUTCMinutes()));utcMinute.range;const timeHour=timeInterval$1((date=>{date.setTime(date-date.getMilliseconds()-date.getSeconds()*durationSecond$1-date.getMinutes()*durationMinute$1)}),((date,step)=>{date.setTime(+date+step*durationHour$1)}),((start,end)=>(end-start)/durationHour$1),(date=>date.getHours()));timeHour.range;const utcHour=timeInterval$1((date=>{date.setUTCMinutes(0,0,0)}),((date,step)=>{date.setTime(+date+step*durationHour$1)}),((start,end)=>(end-start)/durationHour$1),(date=>date.getUTCHours()));utcHour.range;const timeDay=timeInterval$1((date=>date.setHours(0,0,0,0)),((date,step)=>date.setDate(date.getDate()+step)),((start,end)=>(end-start-(end.getTimezoneOffset()-start.getTimezoneOffset())*durationMinute$1)/durationDay$1),(date=>date.getDate()-1));timeDay.range;const utcDay=timeInterval$1((date=>{date.setUTCHours(0,0,0,0)}),((date,step)=>{date.setUTCDate(date.getUTCDate()+step)}),((start,end)=>(end-start)/durationDay$1),(date=>date.getUTCDate()-1));utcDay.range;const unixDay=timeInterval$1((date=>{date.setUTCHours(0,0,0,0)}),((date,step)=>{date.setUTCDate(date.getUTCDate()+step)}),((start,end)=>(end-start)/durationDay$1),(date=>Math.floor(date/durationDay$1)));unixDay.range;function timeWeekday(i){return timeInterval$1((date=>{date.setDate(date.getDate()-(date.getDay()+7-i)%7);date.setHours(0,0,0,0)}),((date,step)=>{date.setDate(date.getDate()+step*7)}),((start,end)=>(end-start-(end.getTimezoneOffset()-start.getTimezoneOffset())*durationMinute$1)/durationWeek$1))}const timeSunday=timeWeekday(0);const timeMonday=timeWeekday(1);const timeTuesday=timeWeekday(2);const timeWednesday=timeWeekday(3);const timeThursday=timeWeekday(4);const timeFriday=timeWeekday(5);const timeSaturday=timeWeekday(6);timeSunday.range;timeMonday.range;timeTuesday.range;timeWednesday.range;timeThursday.range;timeFriday.range;timeSaturday.range;function utcWeekday(i){return timeInterval$1((date=>{date.setUTCDate(date.getUTCDate()-(date.getUTCDay()+7-i)%7);date.setUTCHours(0,0,0,0)}),((date,step)=>{date.setUTCDate(date.getUTCDate()+step*7)}),((start,end)=>(end-start)/durationWeek$1))}const utcSunday=utcWeekday(0);const utcMonday=utcWeekday(1);const utcTuesday=utcWeekday(2);const utcWednesday=utcWeekday(3);const utcThursday=utcWeekday(4);const utcFriday=utcWeekday(5);const utcSaturday=utcWeekday(6);utcSunday.range;utcMonday.range;utcTuesday.range;utcWednesday.range;utcThursday.range;utcFriday.range;utcSaturday.range;const timeMonth=timeInterval$1((date=>{date.setDate(1);date.setHours(0,0,0,0)}),((date,step)=>{date.setMonth(date.getMonth()+step)}),((start,end)=>end.getMonth()-start.getMonth()+(end.getFullYear()-start.getFullYear())*12),(date=>date.getMonth()));timeMonth.range;const utcMonth=timeInterval$1((date=>{date.setUTCDate(1);date.setUTCHours(0,0,0,0)}),((date,step)=>{date.setUTCMonth(date.getUTCMonth()+step)}),((start,end)=>end.getUTCMonth()-start.getUTCMonth()+(end.getUTCFullYear()-start.getUTCFullYear())*12),(date=>date.getUTCMonth()));utcMonth.range;const timeYear=timeInterval$1((date=>{date.setMonth(0,1);date.setHours(0,0,0,0)}),((date,step)=>{date.setFullYear(date.getFullYear()+step)}),((start,end)=>end.getFullYear()-start.getFullYear()),(date=>date.getFullYear()));timeYear.every=k=>!isFinite(k=Math.floor(k))||!(k>0)?null:timeInterval$1((date=>{date.setFullYear(Math.floor(date.getFullYear()/k)*k);date.setMonth(0,1);date.setHours(0,0,0,0)}),((date,step)=>{date.setFullYear(date.getFullYear()+step*k)}));timeYear.range;const utcYear=timeInterval$1((date=>{date.setUTCMonth(0,1);date.setUTCHours(0,0,0,0)}),((date,step)=>{date.setUTCFullYear(date.getUTCFullYear()+step)}),((start,end)=>end.getUTCFullYear()-start.getUTCFullYear()),(date=>date.getUTCFullYear()));utcYear.every=k=>!isFinite(k=Math.floor(k))||!(k>0)?null:timeInterval$1((date=>{date.setUTCFullYear(Math.floor(date.getUTCFullYear()/k)*k);date.setUTCMonth(0,1);date.setUTCHours(0,0,0,0)}),((date,step)=>{date.setUTCFullYear(date.getUTCFullYear()+step*k)}));utcYear.range;function ticker(year,month,week,day,hour,minute){const tickIntervals=[[second,1,durationSecond$1],[second,5,5*durationSecond$1],[second,15,15*durationSecond$1],[second,30,30*durationSecond$1],[minute,1,durationMinute$1],[minute,5,5*durationMinute$1],[minute,15,15*durationMinute$1],[minute,30,30*durationMinute$1],[hour,1,durationHour$1],[hour,3,3*durationHour$1],[hour,6,6*durationHour$1],[hour,12,12*durationHour$1],[day,1,durationDay$1],[day,2,2*durationDay$1],[week,1,durationWeek$1],[month,1,durationMonth$1],[month,3,3*durationMonth$1],[year,1,durationYear$1]];function ticks(start,stop,count){const reverse=stop<start;if(reverse)[start,stop]=[stop,start];const interval=count&&typeof count.range==="function"?count:tickInterval(start,stop,count);const ticks=interval?interval.range(start,+stop+1):[];return reverse?ticks.reverse():ticks}function tickInterval(start,stop,count){const target=Math.abs(stop-start)/count;const i=bisector((([,,step])=>step)).right(tickIntervals,target);if(i===tickIntervals.length)return year.every(tickStep(start/durationYear$1,stop/durationYear$1,count));if(i===0)return millisecond.every(Math.max(tickStep(start,stop,count),1));const[t,step]=tickIntervals[target/tickIntervals[i-1][2]<tickIntervals[i][2]/target?i-1:i];return t.every(step)}return[ticks,tickInterval]}const[utcTicks,utcTickInterval]=ticker(utcYear,utcMonth,utcSunday,unixDay,utcHour,utcMinute);const[timeTicks,timeTickInterval]=ticker(timeYear,timeMonth,timeSunday,timeDay,timeHour,timeMinute);const YEAR="year";const QUARTER="quarter";const MONTH="month";const WEEK="week";const DATE$1="date";const DAY="day";const DAYOFYEAR="dayofyear";const HOURS="hours";const MINUTES="minutes";const SECONDS="seconds";const MILLISECONDS="milliseconds";const TIME_UNITS=[YEAR,QUARTER,MONTH,WEEK,DATE$1,DAY,DAYOFYEAR,HOURS,MINUTES,SECONDS,MILLISECONDS];const UNITS=TIME_UNITS.reduce(((o,u,i)=>(o[u]=1+i,o)),{});function timeUnits(units){const u=array$5(units).slice(),m={};if(!u.length)error("Missing time unit.");u.forEach((unit=>{if(has$1(UNITS,unit)){m[unit]=1}else{error(`Invalid time unit: ${unit}.`)}}));const numTypes=(m[WEEK]||m[DAY]?1:0)+(m[QUARTER]||m[MONTH]||m[DATE$1]?1:0)+(m[DAYOFYEAR]?1:0);if(numTypes>1){error(`Incompatible time units: ${units}`)}u.sort(((a,b)=>UNITS[a]-UNITS[b]));return u}const defaultSpecifiers={[YEAR]:"%Y ",[QUARTER]:"Q%q ",[MONTH]:"%b ",[DATE$1]:"%d ",[WEEK]:"W%U ",[DAY]:"%a ",[DAYOFYEAR]:"%j ",[HOURS]:"%H:00",[MINUTES]:"00:%M",[SECONDS]:":%S",[MILLISECONDS]:".%L",[`${YEAR}-${MONTH}`]:"%Y-%m ",[`${YEAR}-${MONTH}-${DATE$1}`]:"%Y-%m-%d ",[`${HOURS}-${MINUTES}`]:"%H:%M"};function timeUnitSpecifier(units,specifiers){const s=extend$1({},defaultSpecifiers,specifiers),u=timeUnits(units),n=u.length;let fmt="",start=0,end,key;for(start=0;start<n;){for(end=u.length;end>start;--end){key=u.slice(start,end).join("-");if(s[key]!=null){fmt+=s[key];start=end;break}}}return fmt.trim()}const t0$1=new Date;function localYear(y){t0$1.setFullYear(y);t0$1.setMonth(0);t0$1.setDate(1);t0$1.setHours(0,0,0,0);return t0$1}function dayofyear(d){return localDayOfYear(new Date(d))}function week(d){return localWeekNum(new Date(d))}function localDayOfYear(d){return timeDay.count(localYear(d.getFullYear())-1,d)}function localWeekNum(d){return timeSunday.count(localYear(d.getFullYear())-1,d)}function localFirst(y){return localYear(y).getDay()}function localDate$1(y,m,d,H,M,S,L){if(0<=y&&y<100){const date=new Date(-1,m,d,H,M,S,L);date.setFullYear(y);return date}return new Date(y,m,d,H,M,S,L)}function utcdayofyear(d){return utcDayOfYear(new Date(d))}function utcweek(d){return utcWeekNum(new Date(d))}function utcDayOfYear(d){const y=Date.UTC(d.getUTCFullYear(),0,1);return utcDay.count(y-1,d)}function utcWeekNum(d){const y=Date.UTC(d.getUTCFullYear(),0,1);return utcSunday.count(y-1,d)}function utcFirst(y){t0$1.setTime(Date.UTC(y,0,1));return t0$1.getUTCDay()}function utcDate$1(y,m,d,H,M,S,L){if(0<=y&&y<100){const date=new Date(Date.UTC(-1,m,d,H,M,S,L));date.setUTCFullYear(d.y);return date}return new Date(Date.UTC(y,m,d,H,M,S,L))}function floor(units,step,get,inv,newDate){const s=step||1,b=peek$1(units),_=(unit,p,key)=>{key=key||unit;return getUnit(get[key],inv[key],unit===b&&s,p)};const t=new Date,u=toSet(units),y=u[YEAR]?_(YEAR):constant$5(2012),m=u[MONTH]?_(MONTH):u[QUARTER]?_(QUARTER):zero$4,d=u[WEEK]&&u[DAY]?_(DAY,1,WEEK+DAY):u[WEEK]?_(WEEK,1):u[DAY]?_(DAY,1):u[DATE$1]?_(DATE$1,1):u[DAYOFYEAR]?_(DAYOFYEAR,1):one$2,H=u[HOURS]?_(HOURS):zero$4,M=u[MINUTES]?_(MINUTES):zero$4,S=u[SECONDS]?_(SECONDS):zero$4,L=u[MILLISECONDS]?_(MILLISECONDS):zero$4;return function(v){t.setTime(+v);const year=y(t);return newDate(year,m(t),d(t,year),H(t),M(t),S(t),L(t))}}function getUnit(f,inv,step,phase){const u=step<=1?f:phase?(d,y)=>phase+step*Math.floor((f(d,y)-phase)/step):(d,y)=>step*Math.floor(f(d,y)/step);return inv?(d,y)=>inv(u(d,y),y):u}function weekday(week,day,firstDay){return day+week*7-(firstDay+6)%7}const localGet={[YEAR]:d=>d.getFullYear(),[QUARTER]:d=>Math.floor(d.getMonth()/3),[MONTH]:d=>d.getMonth(),[DATE$1]:d=>d.getDate(),[HOURS]:d=>d.getHours(),[MINUTES]:d=>d.getMinutes(),[SECONDS]:d=>d.getSeconds(),[MILLISECONDS]:d=>d.getMilliseconds(),[DAYOFYEAR]:d=>localDayOfYear(d),[WEEK]:d=>localWeekNum(d),[WEEK+DAY]:(d,y)=>weekday(localWeekNum(d),d.getDay(),localFirst(y)),[DAY]:(d,y)=>weekday(1,d.getDay(),localFirst(y))};const localInv={[QUARTER]:q=>3*q,[WEEK]:(w,y)=>weekday(w,0,localFirst(y))};function timeFloor(units,step){return floor(units,step||1,localGet,localInv,localDate$1)}const utcGet={[YEAR]:d=>d.getUTCFullYear(),[QUARTER]:d=>Math.floor(d.getUTCMonth()/3),[MONTH]:d=>d.getUTCMonth(),[DATE$1]:d=>d.getUTCDate(),[HOURS]:d=>d.getUTCHours(),[MINUTES]:d=>d.getUTCMinutes(),[SECONDS]:d=>d.getUTCSeconds(),[MILLISECONDS]:d=>d.getUTCMilliseconds(),[DAYOFYEAR]:d=>utcDayOfYear(d),[WEEK]:d=>utcWeekNum(d),[DAY]:(d,y)=>weekday(1,d.getUTCDay(),utcFirst(y)),[WEEK+DAY]:(d,y)=>weekday(utcWeekNum(d),d.getUTCDay(),utcFirst(y))};const utcInv={[QUARTER]:q=>3*q,[WEEK]:(w,y)=>weekday(w,0,utcFirst(y))};function utcFloor(units,step){return floor(units,step||1,utcGet,utcInv,utcDate$1)}const timeIntervals={[YEAR]:timeYear,[QUARTER]:timeMonth.every(3),[MONTH]:timeMonth,[WEEK]:timeSunday,[DATE$1]:timeDay,[DAY]:timeDay,[DAYOFYEAR]:timeDay,[HOURS]:timeHour,[MINUTES]:timeMinute,[SECONDS]:second,[MILLISECONDS]:millisecond};const utcIntervals={[YEAR]:utcYear,[QUARTER]:utcMonth.every(3),[MONTH]:utcMonth,[WEEK]:utcSunday,[DATE$1]:utcDay,[DAY]:utcDay,[DAYOFYEAR]:utcDay,[HOURS]:utcHour,[MINUTES]:utcMinute,[SECONDS]:second,[MILLISECONDS]:millisecond};function timeInterval(unit){return timeIntervals[unit]}function utcInterval(unit){return utcIntervals[unit]}function offset$3(ival,date,step){return ival?ival.offset(date,step):undefined}function timeOffset(unit,date,step){return offset$3(timeInterval(unit),date,step)}function utcOffset(unit,date,step){return offset$3(utcInterval(unit),date,step)}function sequence$1(ival,start,stop,step){return ival?ival.range(start,stop,step):undefined}function timeSequence(unit,start,stop,step){return sequence$1(timeInterval(unit),start,stop,step)}function utcSequence(unit,start,stop,step){return sequence$1(utcInterval(unit),start,stop,step)}const durationSecond=1e3,durationMinute=durationSecond*60,durationHour=durationMinute*60,durationDay=durationHour*24,durationWeek=durationDay*7,durationMonth=durationDay*30,durationYear=durationDay*365;const Milli=[YEAR,MONTH,DATE$1,HOURS,MINUTES,SECONDS,MILLISECONDS],Seconds=Milli.slice(0,-1),Minutes=Seconds.slice(0,-1),Hours=Minutes.slice(0,-1),Day=Hours.slice(0,-1),Week=[YEAR,WEEK],Month=[YEAR,MONTH],Year=[YEAR];const intervals=[[Seconds,1,durationSecond],[Seconds,5,5*durationSecond],[Seconds,15,15*durationSecond],[Seconds,30,30*durationSecond],[Minutes,1,durationMinute],[Minutes,5,5*durationMinute],[Minutes,15,15*durationMinute],[Minutes,30,30*durationMinute],[Hours,1,durationHour],[Hours,3,3*durationHour],[Hours,6,6*durationHour],[Hours,12,12*durationHour],[Day,1,durationDay],[Week,1,durationWeek],[Month,1,durationMonth],[Month,3,3*durationMonth],[Year,1,durationYear]];function bin$1(opt){const ext=opt.extent,max=opt.maxbins||40,target=Math.abs(span(ext))/max;let i=bisector((i=>i[2])).right(intervals,target),units,step;if(i===intervals.length){units=Year,step=tickStep(ext[0]/durationYear,ext[1]/durationYear,max)}else if(i){i=intervals[target/intervals[i-1][2]<intervals[i][2]/target?i-1:i];units=i[0];step=i[1]}else{units=Milli;step=Math.max(tickStep(ext[0],ext[1],max),1)}return{units:units,step:step}}function localDate(d){if(0<=d.y&&d.y<100){var date=new Date(-1,d.m,d.d,d.H,d.M,d.S,d.L);date.setFullYear(d.y);return date}return new Date(d.y,d.m,d.d,d.H,d.M,d.S,d.L)}function utcDate(d){if(0<=d.y&&d.y<100){var date=new Date(Date.UTC(-1,d.m,d.d,d.H,d.M,d.S,d.L));date.setUTCFullYear(d.y);return date}return new Date(Date.UTC(d.y,d.m,d.d,d.H,d.M,d.S,d.L))}function newDate(y,m,d){return{y:y,m:m,d:d,H:0,M:0,S:0,L:0}}function formatLocale(locale){var locale_dateTime=locale.dateTime,locale_date=locale.date,locale_time=locale.time,locale_periods=locale.periods,locale_weekdays=locale.days,locale_shortWeekdays=locale.shortDays,locale_months=locale.months,locale_shortMonths=locale.shortMonths;var periodRe=formatRe(locale_periods),periodLookup=formatLookup(locale_periods),weekdayRe=formatRe(locale_weekdays),weekdayLookup=formatLookup(locale_weekdays),shortWeekdayRe=formatRe(locale_shortWeekdays),shortWeekdayLookup=formatLookup(locale_shortWeekdays),monthRe=formatRe(locale_months),monthLookup=formatLookup(locale_months),shortMonthRe=formatRe(locale_shortMonths),shortMonthLookup=formatLookup(locale_shortMonths);var formats={a:formatShortWeekday,A:formatWeekday,b:formatShortMonth,B:formatMonth,c:null,d:formatDayOfMonth,e:formatDayOfMonth,f:formatMicroseconds,g:formatYearISO,G:formatFullYearISO,H:formatHour24,I:formatHour12,j:formatDayOfYear,L:formatMilliseconds,m:formatMonthNumber,M:formatMinutes,p:formatPeriod,q:formatQuarter,Q:formatUnixTimestamp,s:formatUnixTimestampSeconds,S:formatSeconds,u:formatWeekdayNumberMonday,U:formatWeekNumberSunday,V:formatWeekNumberISO,w:formatWeekdayNumberSunday,W:formatWeekNumberMonday,x:null,X:null,y:formatYear,Y:formatFullYear,Z:formatZone,"%":formatLiteralPercent};var utcFormats={a:formatUTCShortWeekday,A:formatUTCWeekday,b:formatUTCShortMonth,B:formatUTCMonth,c:null,d:formatUTCDayOfMonth,e:formatUTCDayOfMonth,f:formatUTCMicroseconds,g:formatUTCYearISO,G:formatUTCFullYearISO,H:formatUTCHour24,I:formatUTCHour12,j:formatUTCDayOfYear,L:formatUTCMilliseconds,m:formatUTCMonthNumber,M:formatUTCMinutes,p:formatUTCPeriod,q:formatUTCQuarter,Q:formatUnixTimestamp,s:formatUnixTimestampSeconds,S:formatUTCSeconds,u:formatUTCWeekdayNumberMonday,U:formatUTCWeekNumberSunday,V:formatUTCWeekNumberISO,w:formatUTCWeekdayNumberSunday,W:formatUTCWeekNumberMonday,x:null,X:null,y:formatUTCYear,Y:formatUTCFullYear,Z:formatUTCZone,"%":formatLiteralPercent};var parses={a:parseShortWeekday,A:parseWeekday,b:parseShortMonth,B:parseMonth,c:parseLocaleDateTime,d:parseDayOfMonth,e:parseDayOfMonth,f:parseMicroseconds,g:parseYear,G:parseFullYear,H:parseHour24,I:parseHour24,j:parseDayOfYear,L:parseMilliseconds,m:parseMonthNumber,M:parseMinutes,p:parsePeriod,q:parseQuarter,Q:parseUnixTimestamp,s:parseUnixTimestampSeconds,S:parseSeconds,u:parseWeekdayNumberMonday,U:parseWeekNumberSunday,V:parseWeekNumberISO,w:parseWeekdayNumberSunday,W:parseWeekNumberMonday,x:parseLocaleDate,X:parseLocaleTime,y:parseYear,Y:parseFullYear,Z:parseZone,"%":parseLiteralPercent};formats.x=newFormat(locale_date,formats);formats.X=newFormat(locale_time,formats);formats.c=newFormat(locale_dateTime,formats);utcFormats.x=newFormat(locale_date,utcFormats);utcFormats.X=newFormat(locale_time,utcFormats);utcFormats.c=newFormat(locale_dateTime,utcFormats);function newFormat(specifier,formats){return function(date){var string=[],i=-1,j=0,n=specifier.length,c,pad,format;if(!(date instanceof Date))date=new Date(+date);while(++i<n){if(specifier.charCodeAt(i)===37){string.push(specifier.slice(j,i));if((pad=pads[c=specifier.charAt(++i)])!=null)c=specifier.charAt(++i);else pad=c==="e"?" ":"0";if(format=formats[c])c=format(date,pad);string.push(c);j=i+1}}string.push(specifier.slice(j,i));return string.join("")}}function newParse(specifier,Z){return function(string){var d=newDate(1900,undefined,1),i=parseSpecifier(d,specifier,string+="",0),week,day;if(i!=string.length)return null;if("Q"in d)return new Date(d.Q);if("s"in d)return new Date(d.s*1e3+("L"in d?d.L:0));if(Z&&!("Z"in d))d.Z=0;if("p"in d)d.H=d.H%12+d.p*12;if(d.m===undefined)d.m="q"in d?d.q:0;if("V"in d){if(d.V<1||d.V>53)return null;if(!("w"in d))d.w=1;if("Z"in d){week=utcDate(newDate(d.y,0,1)),day=week.getUTCDay();week=day>4||day===0?utcMonday.ceil(week):utcMonday(week);week=utcDay.offset(week,(d.V-1)*7);d.y=week.getUTCFullYear();d.m=week.getUTCMonth();d.d=week.getUTCDate()+(d.w+6)%7}else{week=localDate(newDate(d.y,0,1)),day=week.getDay();week=day>4||day===0?timeMonday.ceil(week):timeMonday(week);week=timeDay.offset(week,(d.V-1)*7);d.y=week.getFullYear();d.m=week.getMonth();d.d=week.getDate()+(d.w+6)%7}}else if("W"in d||"U"in d){if(!("w"in d))d.w="u"in d?d.u%7:"W"in d?1:0;day="Z"in d?utcDate(newDate(d.y,0,1)).getUTCDay():localDate(newDate(d.y,0,1)).getDay();d.m=0;d.d="W"in d?(d.w+6)%7+d.W*7-(day+5)%7:d.w+d.U*7-(day+6)%7}if("Z"in d){d.H+=d.Z/100|0;d.M+=d.Z%100;return utcDate(d)}return localDate(d)}}function parseSpecifier(d,specifier,string,j){var i=0,n=specifier.length,m=string.length,c,parse;while(i<n){if(j>=m)return-1;c=specifier.charCodeAt(i++);if(c===37){c=specifier.charAt(i++);parse=parses[c in pads?specifier.charAt(i++):c];if(!parse||(j=parse(d,string,j))<0)return-1}else if(c!=string.charCodeAt(j++)){return-1}}return j}function parsePeriod(d,string,i){var n=periodRe.exec(string.slice(i));return n?(d.p=periodLookup.get(n[0].toLowerCase()),i+n[0].length):-1}function parseShortWeekday(d,string,i){var n=shortWeekdayRe.exec(string.slice(i));return n?(d.w=shortWeekdayLookup.get(n[0].toLowerCase()),i+n[0].length):-1}function parseWeekday(d,string,i){var n=weekdayRe.exec(string.slice(i));return n?(d.w=weekdayLookup.get(n[0].toLowerCase()),i+n[0].length):-1}function parseShortMonth(d,string,i){var n=shortMonthRe.exec(string.slice(i));return n?(d.m=shortMonthLookup.get(n[0].toLowerCase()),i+n[0].length):-1}function parseMonth(d,string,i){var n=monthRe.exec(string.slice(i));return n?(d.m=monthLookup.get(n[0].toLowerCase()),i+n[0].length):-1}function parseLocaleDateTime(d,string,i){return parseSpecifier(d,locale_dateTime,string,i)}function parseLocaleDate(d,string,i){return parseSpecifier(d,locale_date,string,i)}function parseLocaleTime(d,string,i){return parseSpecifier(d,locale_time,string,i)}function formatShortWeekday(d){return locale_shortWeekdays[d.getDay()]}function formatWeekday(d){return locale_weekdays[d.getDay()]}function formatShortMonth(d){return locale_shortMonths[d.getMonth()]}function formatMonth(d){return locale_months[d.getMonth()]}function formatPeriod(d){return locale_periods[+(d.getHours()>=12)]}function formatQuarter(d){return 1+~~(d.getMonth()/3)}function formatUTCShortWeekday(d){return locale_shortWeekdays[d.getUTCDay()]}function formatUTCWeekday(d){return locale_weekdays[d.getUTCDay()]}function formatUTCShortMonth(d){return locale_shortMonths[d.getUTCMonth()]}function formatUTCMonth(d){return locale_months[d.getUTCMonth()]}function formatUTCPeriod(d){return locale_periods[+(d.getUTCHours()>=12)]}function formatUTCQuarter(d){return 1+~~(d.getUTCMonth()/3)}return{format:function(specifier){var f=newFormat(specifier+="",formats);f.toString=function(){return specifier};return f},parse:function(specifier){var p=newParse(specifier+="",false);p.toString=function(){return specifier};return p},utcFormat:function(specifier){var f=newFormat(specifier+="",utcFormats);f.toString=function(){return specifier};return f},utcParse:function(specifier){var p=newParse(specifier+="",true);p.toString=function(){return specifier};return p}}}var pads={"-":"",_:" ",0:"0"},numberRe=/^\s*\d+/,percentRe=/^%/,requoteRe=/[\\^$*+?|[\]().{}]/g;function pad(value,fill,width){var sign=value<0?"-":"",string=(sign?-value:value)+"",length=string.length;return sign+(length<width?new Array(width-length+1).join(fill)+string:string)}function requote(s){return s.replace(requoteRe,"\\$&")}function formatRe(names){return new RegExp("^(?:"+names.map(requote).join("|")+")","i")}function formatLookup(names){return new Map(names.map(((name,i)=>[name.toLowerCase(),i])))}function parseWeekdayNumberSunday(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.w=+n[0],i+n[0].length):-1}function parseWeekdayNumberMonday(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.u=+n[0],i+n[0].length):-1}function parseWeekNumberSunday(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.U=+n[0],i+n[0].length):-1}function parseWeekNumberISO(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.V=+n[0],i+n[0].length):-1}function parseWeekNumberMonday(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.W=+n[0],i+n[0].length):-1}function parseFullYear(d,string,i){var n=numberRe.exec(string.slice(i,i+4));return n?(d.y=+n[0],i+n[0].length):-1}function parseYear(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.y=+n[0]+(+n[0]>68?1900:2e3),i+n[0].length):-1}function parseZone(d,string,i){var n=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i,i+6));return n?(d.Z=n[1]?0:-(n[2]+(n[3]||"00")),i+n[0].length):-1}function parseQuarter(d,string,i){var n=numberRe.exec(string.slice(i,i+1));return n?(d.q=n[0]*3-3,i+n[0].length):-1}function parseMonthNumber(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.m=n[0]-1,i+n[0].length):-1}function parseDayOfMonth(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.d=+n[0],i+n[0].length):-1}function parseDayOfYear(d,string,i){var n=numberRe.exec(string.slice(i,i+3));return n?(d.m=0,d.d=+n[0],i+n[0].length):-1}function parseHour24(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.H=+n[0],i+n[0].length):-1}function parseMinutes(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.M=+n[0],i+n[0].length):-1}function parseSeconds(d,string,i){var n=numberRe.exec(string.slice(i,i+2));return n?(d.S=+n[0],i+n[0].length):-1}function parseMilliseconds(d,string,i){var n=numberRe.exec(string.slice(i,i+3));return n?(d.L=+n[0],i+n[0].length):-1}function parseMicroseconds(d,string,i){var n=numberRe.exec(string.slice(i,i+6));return n?(d.L=Math.floor(n[0]/1e3),i+n[0].length):-1}function parseLiteralPercent(d,string,i){var n=percentRe.exec(string.slice(i,i+1));return n?i+n[0].length:-1}function parseUnixTimestamp(d,string,i){var n=numberRe.exec(string.slice(i));return n?(d.Q=+n[0],i+n[0].length):-1}function parseUnixTimestampSeconds(d,string,i){var n=numberRe.exec(string.slice(i));return n?(d.s=+n[0],i+n[0].length):-1}function formatDayOfMonth(d,p){return pad(d.getDate(),p,2)}function formatHour24(d,p){return pad(d.getHours(),p,2)}function formatHour12(d,p){return pad(d.getHours()%12||12,p,2)}function formatDayOfYear(d,p){return pad(1+timeDay.count(timeYear(d),d),p,3)}function formatMilliseconds(d,p){return pad(d.getMilliseconds(),p,3)}function formatMicroseconds(d,p){return formatMilliseconds(d,p)+"000"}function formatMonthNumber(d,p){return pad(d.getMonth()+1,p,2)}function formatMinutes(d,p){return pad(d.getMinutes(),p,2)}function formatSeconds(d,p){return pad(d.getSeconds(),p,2)}function formatWeekdayNumberMonday(d){var day=d.getDay();return day===0?7:day}function formatWeekNumberSunday(d,p){return pad(timeSunday.count(timeYear(d)-1,d),p,2)}function dISO(d){var day=d.getDay();return day>=4||day===0?timeThursday(d):timeThursday.ceil(d)}function formatWeekNumberISO(d,p){d=dISO(d);return pad(timeThursday.count(timeYear(d),d)+(timeYear(d).getDay()===4),p,2)}function formatWeekdayNumberSunday(d){return d.getDay()}function formatWeekNumberMonday(d,p){return pad(timeMonday.count(timeYear(d)-1,d),p,2)}function formatYear(d,p){return pad(d.getFullYear()%100,p,2)}function formatYearISO(d,p){d=dISO(d);return pad(d.getFullYear()%100,p,2)}function formatFullYear(d,p){return pad(d.getFullYear()%1e4,p,4)}function formatFullYearISO(d,p){var day=d.getDay();d=day>=4||day===0?timeThursday(d):timeThursday.ceil(d);return pad(d.getFullYear()%1e4,p,4)}function formatZone(d){var z=d.getTimezoneOffset();return(z>0?"-":(z*=-1,"+"))+pad(z/60|0,"0",2)+pad(z%60,"0",2)}function formatUTCDayOfMonth(d,p){return pad(d.getUTCDate(),p,2)}function formatUTCHour24(d,p){return pad(d.getUTCHours(),p,2)}function formatUTCHour12(d,p){return pad(d.getUTCHours()%12||12,p,2)}function formatUTCDayOfYear(d,p){return pad(1+utcDay.count(utcYear(d),d),p,3)}function formatUTCMilliseconds(d,p){return pad(d.getUTCMilliseconds(),p,3)}function formatUTCMicroseconds(d,p){return formatUTCMilliseconds(d,p)+"000"}function formatUTCMonthNumber(d,p){return pad(d.getUTCMonth()+1,p,2)}function formatUTCMinutes(d,p){return pad(d.getUTCMinutes(),p,2)}function formatUTCSeconds(d,p){return pad(d.getUTCSeconds(),p,2)}function formatUTCWeekdayNumberMonday(d){var dow=d.getUTCDay();return dow===0?7:dow}function formatUTCWeekNumberSunday(d,p){return pad(utcSunday.count(utcYear(d)-1,d),p,2)}function UTCdISO(d){var day=d.getUTCDay();return day>=4||day===0?utcThursday(d):utcThursday.ceil(d)}function formatUTCWeekNumberISO(d,p){d=UTCdISO(d);return pad(utcThursday.count(utcYear(d),d)+(utcYear(d).getUTCDay()===4),p,2)}function formatUTCWeekdayNumberSunday(d){return d.getUTCDay()}function formatUTCWeekNumberMonday(d,p){return pad(utcMonday.count(utcYear(d)-1,d),p,2)}function formatUTCYear(d,p){return pad(d.getUTCFullYear()%100,p,2)}function formatUTCYearISO(d,p){d=UTCdISO(d);return pad(d.getUTCFullYear()%100,p,2)}function formatUTCFullYear(d,p){return pad(d.getUTCFullYear()%1e4,p,4)}function formatUTCFullYearISO(d,p){var day=d.getUTCDay();d=day>=4||day===0?utcThursday(d):utcThursday.ceil(d);return pad(d.getUTCFullYear()%1e4,p,4)}function formatUTCZone(){return"+0000"}function formatLiteralPercent(){return"%"}function formatUnixTimestamp(d){return+d}function formatUnixTimestampSeconds(d){return Math.floor(+d/1e3)}var locale$1;var timeFormat$2;var timeParse$1;var utcFormat$1;var utcParse$1;defaultLocale$1({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});function defaultLocale$1(definition){locale$1=formatLocale(definition);timeFormat$2=locale$1.format;timeParse$1=locale$1.parse;utcFormat$1=locale$1.utcFormat;utcParse$1=locale$1.utcParse;return locale$1}function memoize(method){const cache={};return spec=>cache[spec]||(cache[spec]=method(spec))}function trimZeroes(numberFormat,decimalChar){return x=>{const str=numberFormat(x),dec=str.indexOf(decimalChar);if(dec<0)return str;let idx=rightmostDigit(str,dec);const end=idx<str.length?str.slice(idx):"";while(--idx>dec)if(str[idx]!=="0"){++idx;break}return str.slice(0,idx)+end}}function rightmostDigit(str,dec){let i=str.lastIndexOf("e"),c;if(i>0)return i;for(i=str.length;--i>dec;){c=str.charCodeAt(i);if(c>=48&&c<=57)return i+1}}function numberLocale(locale){const format=memoize(locale.format),formatPrefix=locale.formatPrefix;return{format:format,formatPrefix:formatPrefix,formatFloat(spec){const s=formatSpecifier(spec||",");if(s.precision==null){s.precision=12;switch(s.type){case"%":s.precision-=2;break;case"e":s.precision-=1;break}return trimZeroes(format(s),format(".1f")(1)[1])}else{return format(s)}},formatSpan(start,stop,count,specifier){specifier=formatSpecifier(specifier==null?",f":specifier);const step=tickStep(start,stop,count),value=Math.max(Math.abs(start),Math.abs(stop));let precision;if(specifier.precision==null){switch(specifier.type){case"s":{if(!isNaN(precision=precisionPrefix(step,value))){specifier.precision=precision}return formatPrefix(specifier,value)}case"":case"e":case"g":case"p":case"r":{if(!isNaN(precision=precisionRound(step,value))){specifier.precision=precision-(specifier.type==="e")}break}case"f":case"%":{if(!isNaN(precision=precisionFixed(step))){specifier.precision=precision-(specifier.type==="%")*2}break}}}return format(specifier)}}}let defaultNumberLocale;resetNumberFormatDefaultLocale();function resetNumberFormatDefaultLocale(){return defaultNumberLocale=numberLocale({format:format$3,formatPrefix:formatPrefix})}function numberFormatLocale(definition){return numberLocale(formatLocale$1(definition))}function numberFormatDefaultLocale(definition){return arguments.length?defaultNumberLocale=numberFormatLocale(definition):defaultNumberLocale}function timeMultiFormat(format,interval,spec){spec=spec||{};if(!isObject(spec)){error(`Invalid time multi-format specifier: ${spec}`)}const second=interval(SECONDS),minute=interval(MINUTES),hour=interval(HOURS),day=interval(DATE$1),week=interval(WEEK),month=interval(MONTH),quarter=interval(QUARTER),year=interval(YEAR),L=format(spec[MILLISECONDS]||".%L"),S=format(spec[SECONDS]||":%S"),M=format(spec[MINUTES]||"%I:%M"),H=format(spec[HOURS]||"%I %p"),d=format(spec[DATE$1]||spec[DAY]||"%a %d"),w=format(spec[WEEK]||"%b %d"),m=format(spec[MONTH]||"%B"),q=format(spec[QUARTER]||"%B"),y=format(spec[YEAR]||"%Y");return date=>(second(date)<date?L:minute(date)<date?S:hour(date)<date?M:day(date)<date?H:month(date)<date?week(date)<date?d:w:year(date)<date?quarter(date)<date?m:q:y)(date)}function timeLocale(locale){const timeFormat=memoize(locale.format),utcFormat=memoize(locale.utcFormat);return{timeFormat:spec=>isString(spec)?timeFormat(spec):timeMultiFormat(timeFormat,timeInterval,spec),utcFormat:spec=>isString(spec)?utcFormat(spec):timeMultiFormat(utcFormat,utcInterval,spec),timeParse:memoize(locale.parse),utcParse:memoize(locale.utcParse)}}let defaultTimeLocale;resetTimeFormatDefaultLocale();function resetTimeFormatDefaultLocale(){return defaultTimeLocale=timeLocale({format:timeFormat$2,parse:timeParse$1,utcFormat:utcFormat$1,utcParse:utcParse$1})}function timeFormatLocale(definition){return timeLocale(formatLocale(definition))}function timeFormatDefaultLocale(definition){return arguments.length?defaultTimeLocale=timeFormatLocale(definition):defaultTimeLocale}const createLocale=(number,time)=>extend$1({},number,time);function locale(numberSpec,timeSpec){const number=numberSpec?numberFormatLocale(numberSpec):numberFormatDefaultLocale();const time=timeSpec?timeFormatLocale(timeSpec):timeFormatDefaultLocale();return createLocale(number,time)}function defaultLocale(numberSpec,timeSpec){const args=arguments.length;if(args&&args!==2){error("defaultLocale expects either zero or two arguments.")}return args?createLocale(numberFormatDefaultLocale(numberSpec),timeFormatDefaultLocale(timeSpec)):createLocale(numberFormatDefaultLocale(),timeFormatDefaultLocale())}const protocol_re=/^(data:|([A-Za-z]+:)?\/\/)/;const allowed_re=/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;const whitespace_re=/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;const fileProtocol="file://";function loaderFactory(fetch,fs){return options=>({options:options||{},sanitize:sanitize,load:load$1,fileAccess:!!fs,file:fileLoader(fs),http:httpLoader(fetch)})}async function load$1(uri,options){const opt=await this.sanitize(uri,options),url=opt.href;return opt.localFile?this.file(url):this.http(url,options)}async function sanitize(uri,options){options=extend$1({},this.options,options);const fileAccess=this.fileAccess,result={href:null};let isFile,loadFile,base;const isAllowed=allowed_re.test(uri.replace(whitespace_re,""));if(uri==null||typeof uri!=="string"||!isAllowed){error("Sanitize failure, invalid URI: "+$(uri))}const hasProtocol=protocol_re.test(uri);if((base=options.baseURL)&&!hasProtocol){if(!uri.startsWith("/")&&!base.endsWith("/")){uri="/"+uri}uri=base+uri}loadFile=(isFile=uri.startsWith(fileProtocol))||options.mode==="file"||options.mode!=="http"&&!hasProtocol&&fileAccess;if(isFile){uri=uri.slice(fileProtocol.length)}else if(uri.startsWith("//")){if(options.defaultProtocol==="file"){uri=uri.slice(2);loadFile=true}else{uri=(options.defaultProtocol||"http")+":"+uri}}Object.defineProperty(result,"localFile",{value:!!loadFile});result.href=uri;if(options.target){result.target=options.target+""}if(options.rel){result.rel=options.rel+""}if(options.context==="image"&&options.crossOrigin){result.crossOrigin=options.crossOrigin+""}return result}function fileLoader(fs){return fs?filename=>new Promise(((accept,reject)=>{fs.readFile(filename,((error,data)=>{if(error)reject(error);else accept(data)}))})):fileReject}async function fileReject(){error("No file system access.")}function httpLoader(fetch){return fetch?async function(url,options){const opt=extend$1({},this.options.http,options),type=options&&options.response,response=await fetch(url,opt);return!response.ok?error(response.status+""+response.statusText):isFunction(response[type])?response[type]():response.text()}:httpReject}async function httpReject(){error("No HTTP fetch method available.")}const isValid=_=>_!=null&&_===_;const isBoolean$1=_=>_==="true"||_==="false"||_===true||_===false;const isDate=_=>!Number.isNaN(Date.parse(_));const isNumber=_=>!Number.isNaN(+_)&&!(_ instanceof Date);const isInteger=_=>isNumber(_)&&Number.isInteger(+_);const typeParsers={boolean:toBoolean,integer:toNumber,number:toNumber,date:toDate,string:toString$1,unknown:identity$6};const typeTests=[isBoolean$1,isInteger,isNumber,isDate];const typeList=["boolean","integer","number","date"];function inferType(values,field){if(!values||!values.length)return"unknown";const n=values.length,m=typeTests.length,a=typeTests.map(((_,i)=>i+1));for(let i=0,t=0,j,value;i<n;++i){value=field?values[i][field]:values[i];for(j=0;j<m;++j){if(a[j]&&isValid(value)&&!typeTests[j](value)){a[j]=0;++t;if(t===typeTests.length)return"string"}}}return typeList[a.reduce(((u,v)=>u===0?v:u),0)-1]}function inferTypes(data,fields){return fields.reduce(((types,field)=>{types[field]=inferType(data,field);return types}),{})}function delimitedFormat(delimiter){const parse=function(data,format){const delim={delimiter:delimiter};return dsv(data,format?extend$1(format,delim):delim)};parse.responseType="text";return parse}function dsv(data,format){if(format.header){data=format.header.map($).join(format.delimiter)+"\n"+data}return dsvFormat(format.delimiter).parse(data+"")}dsv.responseType="text";function isBuffer(_){return typeof Buffer==="function"&&isFunction(Buffer.isBuffer)?Buffer.isBuffer(_):false}function json(data,format){const prop=format&&format.property?field$1(format.property):identity$6;return isObject(data)&&!isBuffer(data)?parseJSON(prop(data),format):prop(JSON.parse(data))}json.responseType="json";function parseJSON(data,format){if(!isArray(data)&&isIterable(data)){data=[...data]}return format&&format.copy?JSON.parse(JSON.stringify(data)):data}const filters={interior:(a,b)=>a!==b,exterior:(a,b)=>a===b};function topojson(data,format){let method,object,property,filter;data=json(data,format);if(format&&format.feature){method=feature;property=format.feature}else if(format&&format.mesh){method=mesh;property=format.mesh;filter=filters[format.filter]}else{error("Missing TopoJSON feature or mesh parameter.")}object=(object=data.objects[property])?method(data,object,filter):error("Invalid TopoJSON object: "+property);return object&&object.features||[object]}topojson.responseType="json";const format$2={dsv:dsv,csv:delimitedFormat(","),tsv:delimitedFormat("\t"),json:json,topojson:topojson};function formats$1(name,reader){if(arguments.length>1){format$2[name]=reader;return this}else{return has$1(format$2,name)?format$2[name]:null}}function responseType(type){const f=formats$1(type);return f&&f.responseType||"text"}function read(data,schema,timeParser,utcParser){schema=schema||{};const reader=formats$1(schema.type||"json");if(!reader)error("Unknown data format type: "+schema.type);data=reader(data,schema);if(schema.parse)parse$6(data,schema.parse,timeParser,utcParser);if(has$1(data,"columns"))delete data.columns;return data}function parse$6(data,types,timeParser,utcParser){if(!data.length)return;const locale=timeFormatDefaultLocale();timeParser=timeParser||locale.timeParse;utcParser=utcParser||locale.utcParse;let fields=data.columns||Object.keys(data[0]),datum,field,i,j,n,m;if(types==="auto")types=inferTypes(data,fields);fields=Object.keys(types);const parsers=fields.map((field=>{const type=types[field];let parts,pattern;if(type&&(type.startsWith("date:")||type.startsWith("utc:"))){parts=type.split(/:(.+)?/,2);pattern=parts[1];if(pattern[0]==="'"&&pattern[pattern.length-1]==="'"||pattern[0]==='"'&&pattern[pattern.length-1]==='"'){pattern=pattern.slice(1,-1)}const parse=parts[0]==="utc"?utcParser:timeParser;return parse(pattern)}if(!typeParsers[type]){throw Error("Illegal format pattern: "+field+":"+type)}return typeParsers[type]}));for(i=0,n=data.length,m=fields.length;i<n;++i){datum=data[i];for(j=0;j<m;++j){field=fields[j];datum[field]=parsers[j](datum[field])}}}const loader=loaderFactory();function UniqueList(idFunc){const $=idFunc||identity$6,list=[],ids={};list.add=_=>{const id=$(_);if(!ids[id]){ids[id]=1;list.push(_)}return list};list.remove=_=>{const id=$(_);if(ids[id]){ids[id]=0;const idx=list.indexOf(_);if(idx>=0)list.splice(idx,1)}return list};return list}async function asyncCallback(df,callback){try{await callback(df)}catch(err){df.error(err)}}const TUPLE_ID_KEY=Symbol("vega_id");let TUPLE_ID=1;function isTuple(t){return!!(t&&tupleid(t))}function tupleid(t){return t[TUPLE_ID_KEY]}function setid(t,id){t[TUPLE_ID_KEY]=id;return t}function ingest$1(datum){const t=datum===Object(datum)?datum:{data:datum};return tupleid(t)?t:setid(t,TUPLE_ID++)}function derive(t){return rederive(t,ingest$1({}))}function rederive(t,d){for(const k in t)d[k]=t[k];return d}function replace$1(t,d){return setid(d,tupleid(t))}function stableCompare(cmp,f){return!cmp?null:f?(a,b)=>cmp(a,b)||tupleid(f(a))-tupleid(f(b)):(a,b)=>cmp(a,b)||tupleid(a)-tupleid(b)}function isChangeSet(v){return v&&v.constructor===changeset}function changeset(){const add=[],rem=[],mod=[],remp=[],modp=[];let clean=null,reflow=false;return{constructor:changeset,insert(t){const d=array$5(t),n=d.length;for(let i=0;i<n;++i)add.push(d[i]);return this},remove(t){const a=isFunction(t)?remp:rem,d=array$5(t),n=d.length;for(let i=0;i<n;++i)a.push(d[i]);return this},modify(t,field,value){const m={field:field,value:constant$5(value)};if(isFunction(t)){m.filter=t;modp.push(m)}else{m.tuple=t;mod.push(m)}return this},encode(t,set){if(isFunction(t))modp.push({filter:t,field:set});else mod.push({tuple:t,field:set});return this},clean(value){clean=value;return this},reflow(){reflow=true;return this},pulse(pulse,tuples){const cur={},out={};let i,n,m,f,t,id;for(i=0,n=tuples.length;i<n;++i){cur[tupleid(tuples[i])]=1}for(i=0,n=rem.length;i<n;++i){t=rem[i];cur[tupleid(t)]=-1}for(i=0,n=remp.length;i<n;++i){f=remp[i];tuples.forEach((t=>{if(f(t))cur[tupleid(t)]=-1}))}for(i=0,n=add.length;i<n;++i){t=add[i];id=tupleid(t);if(cur[id]){cur[id]=1}else{pulse.add.push(ingest$1(add[i]))}}for(i=0,n=tuples.length;i<n;++i){t=tuples[i];if(cur[tupleid(t)]<0)pulse.rem.push(t)}function modify(t,f,v){if(v){t[f]=v(t)}else{pulse.encode=f}if(!reflow)out[tupleid(t)]=t}for(i=0,n=mod.length;i<n;++i){m=mod[i];t=m.tuple;f=m.field;id=cur[tupleid(t)];if(id>0){modify(t,f,m.value);pulse.modifies(f)}}for(i=0,n=modp.length;i<n;++i){m=modp[i];f=m.filter;tuples.forEach((t=>{if(f(t)&&cur[tupleid(t)]>0){modify(t,m.field,m.value)}}));pulse.modifies(m.field)}if(reflow){pulse.mod=rem.length||remp.length?tuples.filter((t=>cur[tupleid(t)]>0)):tuples.slice()}else{for(id in out)pulse.mod.push(out[id])}if(clean||clean==null&&(rem.length||remp.length)){pulse.clean(true)}return pulse}}}const CACHE="_:mod:_";function Parameters(){Object.defineProperty(this,CACHE,{writable:true,value:{}})}Parameters.prototype={set(name,index,value,force){const o=this,v=o[name],mod=o[CACHE];if(index!=null&&index>=0){if(v[index]!==value||force){v[index]=value;mod[index+":"+name]=-1;mod[name]=-1}}else if(v!==value||force){o[name]=value;mod[name]=isArray(value)?1+value.length:-1}return o},modified(name,index){const mod=this[CACHE];if(!arguments.length){for(const k in mod){if(mod[k])return true}return false}else if(isArray(name)){for(let k=0;k<name.length;++k){if(mod[name[k]])return true}return false}return index!=null&&index>=0?index+1<mod[name]||!!mod[index+":"+name]:!!mod[name]},clear(){this[CACHE]={};return this}};let OP_ID=0;const PULSE="pulse",NO_PARAMS=new Parameters;const SKIP$1$1=1,MODIFIED=2;function Operator(init,update,params,react){this.id=++OP_ID;this.value=init;this.stamp=-1;this.rank=-1;this.qrank=-1;this.flags=0;if(update){this._update=update}if(params)this.parameters(params,react)}function flag(bit){return function(state){const f=this.flags;if(arguments.length===0)return!!(f&bit);this.flags=state?f|bit:f&~bit;return this}}Operator.prototype={targets(){return this._targets||(this._targets=UniqueList(id))},set(value){if(this.value!==value){this.value=value;return 1}else{return 0}},skip:flag(SKIP$1$1),modified:flag(MODIFIED),parameters(params,react,initonly){react=react!==false;const argval=this._argval=this._argval||new Parameters,argops=this._argops=this._argops||[],deps=[];let name,value,n,i;const add=(name,index,value)=>{if(value instanceof Operator){if(value!==this){if(react)value.targets().add(this);deps.push(value)}argops.push({op:value,name:name,index:index})}else{argval.set(name,index,value)}};for(name in params){value=params[name];if(name===PULSE){array$5(value).forEach((op=>{if(!(op instanceof Operator)){error("Pulse parameters must be operator instances.")}else if(op!==this){op.targets().add(this);deps.push(op)}}));this.source=value}else if(isArray(value)){argval.set(name,-1,Array(n=value.length));for(i=0;i<n;++i)add(name,i,value[i])}else{add(name,-1,value)}}this.marshall().clear();if(initonly)argops.initonly=true;return deps},marshall(stamp){const argval=this._argval||NO_PARAMS,argops=this._argops;let item,i,op,mod;if(argops){const n=argops.length;for(i=0;i<n;++i){item=argops[i];op=item.op;mod=op.modified()&&op.stamp===stamp;argval.set(item.name,item.index,op.value,mod)}if(argops.initonly){for(i=0;i<n;++i){item=argops[i];item.op.targets().remove(this)}this._argops=null;this._update=null}}return argval},detach(){const argops=this._argops;let i,n,item,op;if(argops){for(i=0,n=argops.length;i<n;++i){item=argops[i];op=item.op;if(op._targets){op._targets.remove(this)}}}this.pulse=null;this.source=null},evaluate(pulse){const update=this._update;if(update){const params=this.marshall(pulse.stamp),v=update.call(this,params,pulse);params.clear();if(v!==this.value){this.value=v}else if(!this.modified()){return pulse.StopPropagation}}},run(pulse){if(pulse.stamp<this.stamp)return pulse.StopPropagation;let rv;if(this.skip()){this.skip(false);rv=0}else{rv=this.evaluate(pulse)}return this.pulse=rv||pulse}};function add$4(init,update,params,react){let shift=1,op;if(init instanceof Operator){op=init}else if(init&&init.prototype instanceof Operator){op=new init}else if(isFunction(init)){op=new Operator(null,init)}else{shift=0;op=new Operator(init,update)}this.rank(op);if(shift){react=params;params=update}if(params)this.connect(op,op.parameters(params,react));this.touch(op);return op}function connect(target,sources){const targetRank=target.rank,n=sources.length;for(let i=0;i<n;++i){if(targetRank<sources[i].rank){this.rerank(target);return}}}let STREAM_ID=0;function EventStream(filter,apply,receive){this.id=++STREAM_ID;this.value=null;if(receive)this.receive=receive;if(filter)this._filter=filter;if(apply)this._apply=apply}function stream(filter,apply,receive){return new EventStream(filter,apply,receive)}EventStream.prototype={_filter:truthy,_apply:identity$6,targets(){return this._targets||(this._targets=UniqueList(id))},consume(_){if(!arguments.length)return!!this._consume;this._consume=!!_;return this},receive(evt){if(this._filter(evt)){const val=this.value=this._apply(evt),trg=this._targets,n=trg?trg.length:0;for(let i=0;i<n;++i)trg[i].receive(val);if(this._consume){evt.preventDefault();evt.stopPropagation()}}},filter(filter){const s=stream(filter);this.targets().add(s);return s},apply(apply){const s=stream(null,apply);this.targets().add(s);return s},merge(){const s=stream();this.targets().add(s);for(let i=0,n=arguments.length;i<n;++i){arguments[i].targets().add(s)}return s},throttle(pause){let t=-1;return this.filter((()=>{const now=Date.now();if(now-t>pause){t=now;return 1}else{return 0}}))},debounce(delay){const s=stream();this.targets().add(stream(null,null,debounce(delay,(e=>{const df=e.dataflow;s.receive(e);if(df&&df.run)df.run()}))));return s},between(a,b){let active=false;a.targets().add(stream(null,null,(()=>active=true)));b.targets().add(stream(null,null,(()=>active=false)));return this.filter((()=>active))},detach(){this._filter=truthy;this._targets=null}};function events$1(source,type,filter,apply){const df=this,s=stream(filter,apply),send=function(e){e.dataflow=df;try{s.receive(e)}catch(error){df.error(error)}finally{df.run()}};let sources;if(typeof source==="string"&&typeof document!=="undefined"){sources=document.querySelectorAll(source)}else{sources=array$5(source)}const n=sources.length;for(let i=0;i<n;++i){sources[i].addEventListener(type,send)}return s}function parse$5(data,format){const locale=this.locale();return read(data,format,locale.timeParse,locale.utcParse)}function ingest(target,data,format){data=this.parse(data,format);return this.pulse(target,this.changeset().insert(data))}async function request(url,format){const df=this;let status=0,data;try{data=await df.loader().load(url,{context:"dataflow",response:responseType(format&&format.type)});try{data=df.parse(data,format)}catch(err){status=-2;df.warn("Data ingestion failed",url,err)}}catch(err){status=-1;df.warn("Loading failed",url,err)}return{data:data,status:status}}async function preload(target,url,format){const df=this,pending=df._pending||loadPending(df);pending.requests+=1;const res=await df.request(url,format);df.pulse(target,df.changeset().remove(truthy).insert(res.data||[]));pending.done();return res}function loadPending(df){let accept;const pending=new Promise((a=>accept=a));pending.requests=0;pending.done=()=>{if(--pending.requests===0){df._pending=null;accept(df)}};return df._pending=pending}const SKIP$2={skip:true};function on(source,target,update,params,options){const fn=source instanceof Operator?onOperator:onStream;fn(this,source,target,update,params,options);return this}function onStream(df,stream,target,update,params,options){const opt=extend$1({},options,SKIP$2);let func,op;if(!isFunction(target))target=constant$5(target);if(update===undefined){func=e=>df.touch(target(e))}else if(isFunction(update)){op=new Operator(null,update,params,false);func=e=>{op.evaluate(e);const t=target(e),v=op.value;isChangeSet(v)?df.pulse(t,v,options):df.update(t,v,opt)}}else{func=e=>df.update(target(e),update,opt)}stream.apply(func)}function onOperator(df,source,target,update,params,options){if(update===undefined){source.targets().add(target)}else{const opt=options||{},op=new Operator(null,updater(target,update),params,false);op.modified(opt.force);op.rank=source.rank;source.targets().add(op);if(target){op.skip(true);op.value=target.value;op.targets().add(target);df.connect(target,[op])}}}function updater(target,update){update=isFunction(update)?update:constant$5(update);return target?function(_,pulse){const value=update(_,pulse);if(!target.skip()){target.skip(value!==this.value).value=value}return value}:update}function rank(op){op.rank=++this._rank}function rerank(op){const queue=[op];let cur,list,i;while(queue.length){this.rank(cur=queue.pop());if(list=cur._targets){for(i=list.length;--i>=0;){queue.push(cur=list[i]);if(cur===op)error("Cycle detected in dataflow graph.")}}}}const StopPropagation={};const ADD=1<<0,REM=1<<1,MOD$1=1<<2,ADD_REM=ADD|REM,ADD_MOD=ADD|MOD$1,ALL=ADD|REM|MOD$1,REFLOW=1<<3,SOURCE=1<<4,NO_SOURCE=1<<5,NO_FIELDS=1<<6;function Pulse(dataflow,stamp,encode){this.dataflow=dataflow;this.stamp=stamp==null?-1:stamp;this.add=[];this.rem=[];this.mod=[];this.fields=null;this.encode=encode||null}function materialize(data,filter){const out=[];visitArray(data,filter,(_=>out.push(_)));return out}function filter$1(pulse,flags){const map={};pulse.visit(flags,(t=>{map[tupleid(t)]=1}));return t=>map[tupleid(t)]?null:t}function addFilter(a,b){return a?(t,i)=>a(t,i)&&b(t,i):b}Pulse.prototype={StopPropagation:StopPropagation,ADD:ADD,REM:REM,MOD:MOD$1,ADD_REM:ADD_REM,ADD_MOD:ADD_MOD,ALL:ALL,REFLOW:REFLOW,SOURCE:SOURCE,NO_SOURCE:NO_SOURCE,NO_FIELDS:NO_FIELDS,fork(flags){return new Pulse(this.dataflow).init(this,flags)},clone(){const p=this.fork(ALL);p.add=p.add.slice();p.rem=p.rem.slice();p.mod=p.mod.slice();if(p.source)p.source=p.source.slice();return p.materialize(ALL|SOURCE)},addAll(){let p=this;const reuse=!p.source||p.add===p.rem||!p.rem.length&&p.source.length===p.add.length;if(reuse){return p}else{p=new Pulse(this.dataflow).init(this);p.add=p.source;p.rem=[];return p}},init(src,flags){const p=this;p.stamp=src.stamp;p.encode=src.encode;if(src.fields&&!(flags&NO_FIELDS)){p.fields=src.fields}if(flags&ADD){p.addF=src.addF;p.add=src.add}else{p.addF=null;p.add=[]}if(flags&REM){p.remF=src.remF;p.rem=src.rem}else{p.remF=null;p.rem=[]}if(flags&MOD$1){p.modF=src.modF;p.mod=src.mod}else{p.modF=null;p.mod=[]}if(flags&NO_SOURCE){p.srcF=null;p.source=null}else{p.srcF=src.srcF;p.source=src.source;if(src.cleans)p.cleans=src.cleans}return p},runAfter(func){this.dataflow.runAfter(func)},changed(flags){const f=flags||ALL;return f&ADD&&this.add.length||f&REM&&this.rem.length||f&MOD$1&&this.mod.length},reflow(fork){if(fork)return this.fork(ALL).reflow();const len=this.add.length,src=this.source&&this.source.length;if(src&&src!==len){this.mod=this.source;if(len)this.filter(MOD$1,filter$1(this,ADD))}return this},clean(value){if(arguments.length){this.cleans=!!value;return this}else{return this.cleans}},modifies(_){const hash=this.fields||(this.fields={});if(isArray(_)){_.forEach((f=>hash[f]=true))}else{hash[_]=true}return this},modified(_,nomod){const fields=this.fields;return!((nomod||this.mod.length)&&fields)?false:!arguments.length?!!fields:isArray(_)?_.some((f=>fields[f])):fields[_]},filter(flags,filter){const p=this;if(flags&ADD)p.addF=addFilter(p.addF,filter);if(flags&REM)p.remF=addFilter(p.remF,filter);if(flags&MOD$1)p.modF=addFilter(p.modF,filter);if(flags&SOURCE)p.srcF=addFilter(p.srcF,filter);return p},materialize(flags){flags=flags||ALL;const p=this;if(flags&ADD&&p.addF){p.add=materialize(p.add,p.addF);p.addF=null}if(flags&REM&&p.remF){p.rem=materialize(p.rem,p.remF);p.remF=null}if(flags&MOD$1&&p.modF){p.mod=materialize(p.mod,p.modF);p.modF=null}if(flags&SOURCE&&p.srcF){p.source=p.source.filter(p.srcF);p.srcF=null}return p},visit(flags,visitor){const p=this,v=visitor;if(flags&SOURCE){visitArray(p.source,p.srcF,v);return p}if(flags&ADD)visitArray(p.add,p.addF,v);if(flags&REM)visitArray(p.rem,p.remF,v);if(flags&MOD$1)visitArray(p.mod,p.modF,v);const src=p.source;if(flags&REFLOW&&src){const sum=p.add.length+p.mod.length;if(sum===src.length);else if(sum){visitArray(src,filter$1(p,ADD_MOD),v)}else{visitArray(src,p.srcF,v)}}return p}};function MultiPulse(dataflow,stamp,pulses,encode){const p=this;let c=0;this.dataflow=dataflow;this.stamp=stamp;this.fields=null;this.encode=encode||null;this.pulses=pulses;for(const pulse of pulses){if(pulse.stamp!==stamp)continue;if(pulse.fields){const hash=p.fields||(p.fields={});for(const f in pulse.fields){hash[f]=1}}if(pulse.changed(p.ADD))c|=p.ADD;if(pulse.changed(p.REM))c|=p.REM;if(pulse.changed(p.MOD))c|=p.MOD}this.changes=c}inherits(MultiPulse,Pulse,{fork(flags){const p=new Pulse(this.dataflow).init(this,flags&this.NO_FIELDS);if(flags!==undefined){if(flags&p.ADD)this.visit(p.ADD,(t=>p.add.push(t)));if(flags&p.REM)this.visit(p.REM,(t=>p.rem.push(t)));if(flags&p.MOD)this.visit(p.MOD,(t=>p.mod.push(t)))}return p},changed(flags){return this.changes&flags},modified(_){const p=this,fields=p.fields;return!(fields&&p.changes&p.MOD)?0:isArray(_)?_.some((f=>fields[f])):fields[_]},filter(){error("MultiPulse does not support filtering.")},materialize(){error("MultiPulse does not support materialization.")},visit(flags,visitor){const p=this,pulses=p.pulses,n=pulses.length;let i=0;if(flags&p.SOURCE){for(;i<n;++i){pulses[i].visit(flags,visitor)}}else{for(;i<n;++i){if(pulses[i].stamp===p.stamp){pulses[i].visit(flags,visitor)}}}return p}});async function evaluate(encode,prerun,postrun){const df=this,async=[];if(df._pulse)return reentrant(df);if(df._pending)await df._pending;if(prerun)await asyncCallback(df,prerun);if(!df._touched.length){df.debug("Dataflow invoked, but nothing to do.");return df}const stamp=++df._clock;df._pulse=new Pulse(df,stamp,encode);df._touched.forEach((op=>df._enqueue(op,true)));df._touched=UniqueList(id);let count=0,op,next,error;try{while(df._heap.size()>0){op=df._heap.pop();if(op.rank!==op.qrank){df._enqueue(op,true);continue}next=op.run(df._getPulse(op,encode));if(next.then){next=await next}else if(next.async){async.push(next.async);next=StopPropagation}if(next!==StopPropagation){if(op._targets)op._targets.forEach((op=>df._enqueue(op)))}++count}}catch(err){df._heap.clear();error=err}df._input={};df._pulse=null;df.debug(`Pulse ${stamp}: ${count} operators`);if(error){df._postrun=[];df.error(error)}if(df._postrun.length){const pr=df._postrun.sort(((a,b)=>b.priority-a.priority));df._postrun=[];for(let i=0;i<pr.length;++i){await asyncCallback(df,pr[i].callback)}}if(postrun)await asyncCallback(df,postrun);if(async.length){Promise.all(async).then((cb=>df.runAsync(null,(()=>{cb.forEach((f=>{try{f(df)}catch(err){df.error(err)}}))}))))}return df}async function runAsync(encode,prerun,postrun){while(this._running)await this._running;const clear=()=>this._running=null;(this._running=this.evaluate(encode,prerun,postrun)).then(clear,clear);return this._running}function run(encode,prerun,postrun){return this._pulse?reentrant(this):(this.evaluate(encode,prerun,postrun),this)}function runAfter(callback,enqueue,priority){if(this._pulse||enqueue){this._postrun.push({priority:priority||0,callback:callback})}else{try{callback(this)}catch(err){this.error(err)}}}function reentrant(df){df.error("Dataflow already running. Use runAsync() to chain invocations.");return df}function enqueue(op,force){const q=op.stamp<this._clock;if(q)op.stamp=this._clock;if(q||force){op.qrank=op.rank;this._heap.push(op)}}function getPulse(op,encode){const s=op.source,stamp=this._clock;return s&&isArray(s)?new MultiPulse(this,stamp,s.map((_=>_.pulse)),encode):this._input[op.id]||singlePulse(this._pulse,s&&s.pulse)}function singlePulse(p,s){if(s&&s.stamp===p.stamp){return s}p=p.fork();if(s&&s!==StopPropagation){p.source=s.source}return p}const NO_OPT={skip:false,force:false};function touch(op,options){const opt=options||NO_OPT;if(this._pulse){this._enqueue(op)}else{this._touched.add(op)}if(opt.skip)op.skip(true);return this}function update$6(op,value,options){const opt=options||NO_OPT;if(op.set(value)||opt.force){this.touch(op,opt)}return this}function pulse(op,changeset,options){this.touch(op,options||NO_OPT);const p=new Pulse(this,this._clock+(this._pulse?0:1)),t=op.pulse&&op.pulse.source||[];p.target=op;this._input[op.id]=changeset.pulse(p,t);return this}function Heap(cmp){let nodes=[];return{clear:()=>nodes=[],size:()=>nodes.length,peek:()=>nodes[0],push:x=>{nodes.push(x);return siftdown(nodes,0,nodes.length-1,cmp)},pop:()=>{const last=nodes.pop();let item;if(nodes.length){item=nodes[0];nodes[0]=last;siftup(nodes,0,cmp)}else{item=last}return item}}}function siftdown(array,start,idx,cmp){let parent,pidx;const item=array[idx];while(idx>start){pidx=idx-1>>1;parent=array[pidx];if(cmp(item,parent)<0){array[idx]=parent;idx=pidx;continue}break}return array[idx]=item}function siftup(array,idx,cmp){const start=idx,end=array.length,item=array[idx];let cidx=(idx<<1)+1,ridx;while(cidx<end){ridx=cidx+1;if(ridx<end&&cmp(array[cidx],array[ridx])>=0){cidx=ridx}array[idx]=array[cidx];idx=cidx;cidx=(idx<<1)+1}array[idx]=item;return siftdown(array,start,idx,cmp)}function Dataflow(){this.logger(logger());this.logLevel(Error$1);this._clock=0;this._rank=0;this._locale=defaultLocale();try{this._loader=loader()}catch(e){}this._touched=UniqueList(id);this._input={};this._pulse=null;this._heap=Heap(((a,b)=>a.qrank-b.qrank));this._postrun=[]}function logMethod(method){return function(){return this._log[method].apply(this,arguments)}}Dataflow.prototype={stamp(){return this._clock},loader(_){if(arguments.length){this._loader=_;return this}else{return this._loader}},locale(_){if(arguments.length){this._locale=_;return this}else{return this._locale}},logger(logger){if(arguments.length){this._log=logger;return this}else{return this._log}},error:logMethod("error"),warn:logMethod("warn"),info:logMethod("info"),debug:logMethod("debug"),logLevel:logMethod("level"),cleanThreshold:1e4,add:add$4,connect:connect,rank:rank,rerank:rerank,pulse:pulse,touch:touch,update:update$6,changeset:changeset,ingest:ingest,parse:parse$5,preload:preload,request:request,events:events$1,on:on,evaluate:evaluate,run:run,runAsync:runAsync,runAfter:runAfter,_enqueue:enqueue,_getPulse:getPulse};function Transform(init,params){Operator.call(this,init,null,params)}inherits(Transform,Operator,{run(pulse){if(pulse.stamp<this.stamp)return pulse.StopPropagation;let rv;if(this.skip()){this.skip(false)}else{rv=this.evaluate(pulse)}rv=rv||pulse;if(rv.then){rv=rv.then((_=>this.pulse=_))}else if(rv!==pulse.StopPropagation){this.pulse=rv}return rv},evaluate(pulse){const params=this.marshall(pulse.stamp),out=this.transform(params,pulse);params.clear();return out},transform(){}});const transforms={};function definition$1(type){const t=transform$2(type);return t&&t.Definition||null}function transform$2(type){type=type&&type.toLowerCase();return has$1(transforms,type)?transforms[type]:null}function*numbers$1(values,valueof){if(valueof==null){for(let value of values){if(value!=null&&value!==""&&(value=+value)>=value){yield value}}}else{let index=-1;for(let value of values){value=valueof(value,++index,values);if(value!=null&&value!==""&&(value=+value)>=value){yield value}}}}function quantiles(array,p,f){const values=Float64Array.from(numbers$1(array,f));values.sort(ascending$1);return p.map((_=>quantileSorted(values,_)))}function quartiles(array,f){return quantiles(array,[.25,.5,.75],f)}function estimateBandwidth(array,f){const n=array.length,d=deviation(array,f),q=quartiles(array,f),h=(q[2]-q[0])/1.34,v=Math.min(d,h)||d||Math.abs(q[0])||1;return 1.06*v*Math.pow(n,-.2)}function bin(_){const maxb=_.maxbins||20,base=_.base||10,logb=Math.log(base),div=_.divide||[5,2];let min=_.extent[0],max=_.extent[1],step,level,minstep,v,i,n;const span=_.span||max-min||Math.abs(min)||1;if(_.step){step=_.step}else if(_.steps){v=span/maxb;for(i=0,n=_.steps.length;i<n&&_.steps[i]<v;++i);step=_.steps[Math.max(0,i-1)]}else{level=Math.ceil(Math.log(maxb)/logb);minstep=_.minstep||0;step=Math.max(minstep,Math.pow(base,Math.round(Math.log(span)/logb)-level));while(Math.ceil(span/step)>maxb){step*=base}for(i=0,n=div.length;i<n;++i){v=step/div[i];if(v>=minstep&&span/v<=maxb)step=v}}v=Math.log(step);const precision=v>=0?0:~~(-v/logb)+1,eps=Math.pow(base,-precision-1);if(_.nice||_.nice===undefined){v=Math.floor(min/step+eps)*step;min=min<v?v-step:v;max=Math.ceil(max/step)*step}return{start:min,stop:max===min?min+step:max,step:step}}var random=Math.random;function bootstrapCI(array,samples,alpha,f){if(!array.length)return[undefined,undefined];const values=Float64Array.from(numbers$1(array,f)),n=values.length,m=samples;let a,i,j,mu;for(j=0,mu=Array(m);j<m;++j){for(a=0,i=0;i<n;++i){a+=values[~~(random()*n)]}mu[j]=a/n}mu.sort(ascending$1);return[quantile$1(mu,alpha/2),quantile$1(mu,1-alpha/2)]}function dotbin(array,step,smooth,f){f=f||(_=>_);const n=array.length,v=new Float64Array(n);let i=0,j=1,a=f(array[0]),b=a,w=a+step,x;for(;j<n;++j){x=f(array[j]);if(x>=w){b=(a+b)/2;for(;i<j;++i)v[i]=b;w=x+step;a=x}b=x}b=(a+b)/2;for(;i<j;++i)v[i]=b;return smooth?smoothing(v,step+step/4):v}function smoothing(v,thresh){const n=v.length;let a=0,b=1,c,d;while(v[a]===v[b])++b;while(b<n){c=b+1;while(v[b]===v[c])++c;if(v[b]-v[b-1]<thresh){d=b+(a+c-b-b>>1);while(d<b)v[d++]=v[b];while(d>b)v[d--]=v[a]}a=b;b=c}return v}const SQRT2PI=Math.sqrt(2*Math.PI);const SQRT2=Math.SQRT2;let nextSample=NaN;function sampleNormal(mean,stdev){mean=mean||0;stdev=stdev==null?1:stdev;let x=0,y=0,rds,c;if(nextSample===nextSample){x=nextSample;nextSample=NaN}else{do{x=random()*2-1;y=random()*2-1;rds=x*x+y*y}while(rds===0||rds>1);c=Math.sqrt(-2*Math.log(rds)/rds);x*=c;nextSample=y*c}return mean+x*stdev}function densityNormal(value,mean,stdev){stdev=stdev==null?1:stdev;const z=(value-(mean||0))/stdev;return Math.exp(-.5*z*z)/(stdev*SQRT2PI)}function cumulativeNormal(value,mean,stdev){mean=mean||0;stdev=stdev==null?1:stdev;const z=(value-mean)/stdev,Z=Math.abs(z);let cd;if(Z>37){cd=0}else{const exp=Math.exp(-Z*Z/2);let sum;if(Z<7.07106781186547){sum=.0352624965998911*Z+.700383064443688;sum=sum*Z+6.37396220353165;sum=sum*Z+33.912866078383;sum=sum*Z+112.079291497871;sum=sum*Z+221.213596169931;sum=sum*Z+220.206867912376;cd=exp*sum;sum=.0883883476483184*Z+1.75566716318264;sum=sum*Z+16.064177579207;sum=sum*Z+86.7807322029461;sum=sum*Z+296.564248779674;sum=sum*Z+637.333633378831;sum=sum*Z+793.826512519948;sum=sum*Z+440.413735824752;cd=cd/sum}else{sum=Z+.65;sum=Z+4/sum;sum=Z+3/sum;sum=Z+2/sum;sum=Z+1/sum;cd=exp/sum/2.506628274631}}return z>0?1-cd:cd}function quantileNormal(p,mean,stdev){if(p<0||p>1)return NaN;return(mean||0)+(stdev==null?1:stdev)*SQRT2*erfinv(2*p-1)}function erfinv(x){let w=-Math.log((1-x)*(1+x)),p;if(w<6.25){w-=3.125;p=-364441206401782e-35;p=-16850591381820166e-35+p*w;p=128584807152564e-32+p*w;p=11157877678025181e-33+p*w;p=-1333171662854621e-31+p*w;p=20972767875968562e-33+p*w;p=6637638134358324e-30+p*w;p=-4054566272975207e-29+p*w;p=-8151934197605472e-29+p*w;p=26335093153082323e-28+p*w;p=-12975133253453532e-27+p*w;p=-5415412054294628e-26+p*w;p=1.0512122733215323e-9+p*w;p=-4.112633980346984e-9+p*w;p=-2.9070369957882005e-8+p*w;p=4.2347877827932404e-7+p*w;p=-13654692000834679e-22+p*w;p=-13882523362786469e-21+p*w;p=.00018673420803405714+p*w;p=-.000740702534166267+p*w;p=-.006033670871430149+p*w;p=.24015818242558962+p*w;p=1.6536545626831027+p*w}else if(w<16){w=Math.sqrt(w)-3.25;p=2.2137376921775787e-9;p=9.075656193888539e-8+p*w;p=-2.7517406297064545e-7+p*w;p=1.8239629214389228e-8+p*w;p=15027403968909828e-22+p*w;p=-4013867526981546e-21+p*w;p=29234449089955446e-22+p*w;p=12475304481671779e-21+p*w;p=-47318229009055734e-21+p*w;p=6828485145957318e-20+p*w;p=24031110387097894e-21+p*w;p=-.0003550375203628475+p*w;p=.0009532893797373805+p*w;p=-.0016882755560235047+p*w;p=.002491442096107851+p*w;p=-.003751208507569241+p*w;p=.005370914553590064+p*w;p=1.0052589676941592+p*w;p=3.0838856104922208+p*w}else if(Number.isFinite(w)){w=Math.sqrt(w)-5;p=-27109920616438573e-27;p=-2.555641816996525e-10+p*w;p=1.5076572693500548e-9+p*w;p=-3.789465440126737e-9+p*w;p=7.61570120807834e-9+p*w;p=-1.496002662714924e-8+p*w;p=2.914795345090108e-8+p*w;p=-6.771199775845234e-8+p*w;p=2.2900482228026655e-7+p*w;p=-9.9298272942317e-7+p*w;p=4526062597223154e-21+p*w;p=-1968177810553167e-20+p*w;p=7599527703001776e-20+p*w;p=-.00021503011930044477+p*w;p=-.00013871931833623122+p*w;p=1.0103004648645344+p*w;p=4.849906401408584+p*w}else{p=Infinity}return p*x}function gaussian(mean,stdev){let mu,sigma;const dist={mean(_){if(arguments.length){mu=_||0;return dist}else{return mu}},stdev(_){if(arguments.length){sigma=_==null?1:_;return dist}else{return sigma}},sample:()=>sampleNormal(mu,sigma),pdf:value=>densityNormal(value,mu,sigma),cdf:value=>cumulativeNormal(value,mu,sigma),icdf:p=>quantileNormal(p,mu,sigma)};return dist.mean(mean).stdev(stdev)}function kde(support,bandwidth){const kernel=gaussian();let n=0;const dist={data(_){if(arguments.length){support=_;n=_?_.length:0;return dist.bandwidth(bandwidth)}else{return support}},bandwidth(_){if(!arguments.length)return bandwidth;bandwidth=_;if(!bandwidth&&support)bandwidth=estimateBandwidth(support);return dist},sample(){return support[~~(random()*n)]+bandwidth*kernel.sample()},pdf(x){let y=0,i=0;for(;i<n;++i){y+=kernel.pdf((x-support[i])/bandwidth)}return y/bandwidth/n},cdf(x){let y=0,i=0;for(;i<n;++i){y+=kernel.cdf((x-support[i])/bandwidth)}return y/n},icdf(){throw Error("KDE icdf not supported.")}};return dist.data(support)}function sampleLogNormal(mean,stdev){mean=mean||0;stdev=stdev==null?1:stdev;return Math.exp(mean+sampleNormal()*stdev)}function densityLogNormal(value,mean,stdev){if(value<=0)return 0;mean=mean||0;stdev=stdev==null?1:stdev;const z=(Math.log(value)-mean)/stdev;return Math.exp(-.5*z*z)/(stdev*SQRT2PI*value)}function cumulativeLogNormal(value,mean,stdev){return cumulativeNormal(Math.log(value),mean,stdev)}function quantileLogNormal(p,mean,stdev){return Math.exp(quantileNormal(p,mean,stdev))}function lognormal(mean,stdev){let mu,sigma;const dist={mean(_){if(arguments.length){mu=_||0;return dist}else{return mu}},stdev(_){if(arguments.length){sigma=_==null?1:_;return dist}else{return sigma}},sample:()=>sampleLogNormal(mu,sigma),pdf:value=>densityLogNormal(value,mu,sigma),cdf:value=>cumulativeLogNormal(value,mu,sigma),icdf:p=>quantileLogNormal(p,mu,sigma)};return dist.mean(mean).stdev(stdev)}function mixture$1(dists,weights){let m=0,w;function normalize(x){const w=[];let sum=0,i;for(i=0;i<m;++i){sum+=w[i]=x[i]==null?1:+x[i]}for(i=0;i<m;++i){w[i]/=sum}return w}const dist={weights(_){if(arguments.length){w=normalize(weights=_||[]);return dist}return weights},distributions(_){if(arguments.length){if(_){m=_.length;dists=_}else{m=0;dists=[]}return dist.weights(weights)}return dists},sample(){const r=random();let d=dists[m-1],v=w[0],i=0;for(;i<m-1;v+=w[++i]){if(r<v){d=dists[i];break}}return d.sample()},pdf(x){let p=0,i=0;for(;i<m;++i){p+=w[i]*dists[i].pdf(x)}return p},cdf(x){let p=0,i=0;for(;i<m;++i){p+=w[i]*dists[i].cdf(x)}return p},icdf(){throw Error("Mixture icdf not supported.")}};return dist.distributions(dists).weights(weights)}function sampleUniform(min,max){if(max==null){max=min==null?1:min;min=0}return min+(max-min)*random()}function densityUniform(value,min,max){if(max==null){max=min==null?1:min;min=0}return value>=min&&value<=max?1/(max-min):0}function cumulativeUniform(value,min,max){if(max==null){max=min==null?1:min;min=0}return value<min?0:value>max?1:(value-min)/(max-min)}function quantileUniform(p,min,max){if(max==null){max=min==null?1:min;min=0}return p>=0&&p<=1?min+p*(max-min):NaN}function uniform(min,max){let a,b;const dist={min(_){if(arguments.length){a=_||0;return dist}else{return a}},max(_){if(arguments.length){b=_==null?1:_;return dist}else{return b}},sample:()=>sampleUniform(a,b),pdf:value=>densityUniform(value,a,b),cdf:value=>cumulativeUniform(value,a,b),icdf:p=>quantileUniform(p,a,b)};if(max==null){max=min==null?1:min;min=0}return dist.min(min).max(max)}function constant$4(data,x,y){let mean=0,n=0;for(const d of data){const val=y(d);if(x(d)==null||val==null||isNaN(val))continue;mean+=(val-mean)/++n}return{coef:[mean],predict:()=>mean,rSquared:0}}function ols(uX,uY,uXY,uX2){const delta=uX2-uX*uX,slope=Math.abs(delta)<1e-24?0:(uXY-uX*uY)/delta,intercept=uY-slope*uX;return[intercept,slope]}function points(data,x,y,sort){data=data.filter((d=>{let u=x(d),v=y(d);return u!=null&&(u=+u)>=u&&v!=null&&(v=+v)>=v}));if(sort){data.sort(((a,b)=>x(a)-x(b)))}const n=data.length,X=new Float64Array(n),Y=new Float64Array(n);let i=0,ux=0,uy=0,xv,yv,d;for(d of data){X[i]=xv=+x(d);Y[i]=yv=+y(d);++i;ux+=(xv-ux)/i;uy+=(yv-uy)/i}for(i=0;i<n;++i){X[i]-=ux;Y[i]-=uy}return[X,Y,ux,uy]}function visitPoints(data,x,y,callback){let i=-1,u,v;for(const d of data){u=x(d);v=y(d);if(u!=null&&(u=+u)>=u&&v!=null&&(v=+v)>=v){callback(u,v,++i)}}}function rSquared(data,x,y,uY,predict){let SSE=0,SST=0;visitPoints(data,x,y,((dx,dy)=>{const sse=dy-predict(dx),sst=dy-uY;SSE+=sse*sse;SST+=sst*sst}));return 1-SSE/SST}function linear$2(data,x,y){let X=0,Y=0,XY=0,X2=0,n=0;visitPoints(data,x,y,((dx,dy)=>{++n;X+=(dx-X)/n;Y+=(dy-Y)/n;XY+=(dx*dy-XY)/n;X2+=(dx*dx-X2)/n}));const coef=ols(X,Y,XY,X2),predict=x=>coef[0]+coef[1]*x;return{coef:coef,predict:predict,rSquared:rSquared(data,x,y,Y,predict)}}function log$3(data,x,y){let X=0,Y=0,XY=0,X2=0,n=0;visitPoints(data,x,y,((dx,dy)=>{++n;dx=Math.log(dx);X+=(dx-X)/n;Y+=(dy-Y)/n;XY+=(dx*dy-XY)/n;X2+=(dx*dx-X2)/n}));const coef=ols(X,Y,XY,X2),predict=x=>coef[0]+coef[1]*Math.log(x);return{coef:coef,predict:predict,rSquared:rSquared(data,x,y,Y,predict)}}function exp$1(data,x,y){const[xv,yv,ux,uy]=points(data,x,y);let YL=0,XY=0,XYL=0,X2Y=0,n=0,dx,ly,xy;visitPoints(data,x,y,((_,dy)=>{dx=xv[n++];ly=Math.log(dy);xy=dx*dy;YL+=(dy*ly-YL)/n;XY+=(xy-XY)/n;XYL+=(xy*ly-XYL)/n;X2Y+=(dx*xy-X2Y)/n}));const[c0,c1]=ols(XY/uy,YL/uy,XYL/uy,X2Y/uy),predict=x=>Math.exp(c0+c1*(x-ux));return{coef:[Math.exp(c0-c1*ux),c1],predict:predict,rSquared:rSquared(data,x,y,uy,predict)}}function pow$3(data,x,y){let X=0,Y=0,XY=0,X2=0,YS=0,n=0;visitPoints(data,x,y,((dx,dy)=>{const lx=Math.log(dx),ly=Math.log(dy);++n;X+=(lx-X)/n;Y+=(ly-Y)/n;XY+=(lx*ly-XY)/n;X2+=(lx*lx-X2)/n;YS+=(dy-YS)/n}));const coef=ols(X,Y,XY,X2),predict=x=>coef[0]*Math.pow(x,coef[1]);coef[0]=Math.exp(coef[0]);return{coef:coef,predict:predict,rSquared:rSquared(data,x,y,YS,predict)}}function quad(data,x,y){const[xv,yv,ux,uy]=points(data,x,y),n=xv.length;let X2=0,X3=0,X4=0,XY=0,X2Y=0,i,dx,dy,x2;for(i=0;i<n;){dx=xv[i];dy=yv[i++];x2=dx*dx;X2+=(x2-X2)/i;X3+=(x2*dx-X3)/i;X4+=(x2*x2-X4)/i;XY+=(dx*dy-XY)/i;X2Y+=(x2*dy-X2Y)/i}const X2X2=X4-X2*X2,d=X2*X2X2-X3*X3,a=(X2Y*X2-XY*X3)/d,b=(XY*X2X2-X2Y*X3)/d,c=-a*X2,predict=x=>{x=x-ux;return a*x*x+b*x+c+uy};return{coef:[c-b*ux+a*ux*ux+uy,b-2*a*ux,a],predict:predict,rSquared:rSquared(data,x,y,uy,predict)}}function poly(data,x,y,order){if(order===0)return constant$4(data,x,y);if(order===1)return linear$2(data,x,y);if(order===2)return quad(data,x,y);const[xv,yv,ux,uy]=points(data,x,y),n=xv.length,lhs=[],rhs=[],k=order+1;let i,j,l,v,c;for(i=0;i<k;++i){for(l=0,v=0;l<n;++l){v+=Math.pow(xv[l],i)*yv[l]}lhs.push(v);c=new Float64Array(k);for(j=0;j<k;++j){for(l=0,v=0;l<n;++l){v+=Math.pow(xv[l],i+j)}c[j]=v}rhs.push(c)}rhs.push(lhs);const coef=gaussianElimination(rhs),predict=x=>{x-=ux;let y=uy+coef[0]+coef[1]*x+coef[2]*x*x;for(i=3;i<k;++i)y+=coef[i]*Math.pow(x,i);return y};return{coef:uncenter(k,coef,-ux,uy),predict:predict,rSquared:rSquared(data,x,y,uy,predict)}}function uncenter(k,a,x,y){const z=Array(k);let i,j,v,c;for(i=0;i<k;++i)z[i]=0;for(i=k-1;i>=0;--i){v=a[i];c=1;z[i]+=v;for(j=1;j<=i;++j){c*=(i+1-j)/j;z[i-j]+=v*Math.pow(x,j)*c}}z[0]+=y;return z}function gaussianElimination(matrix){const n=matrix.length-1,coef=[];let i,j,k,r,t;for(i=0;i<n;++i){r=i;for(j=i+1;j<n;++j){if(Math.abs(matrix[i][j])>Math.abs(matrix[i][r])){r=j}}for(k=i;k<n+1;++k){t=matrix[k][i];matrix[k][i]=matrix[k][r];matrix[k][r]=t}for(j=i+1;j<n;++j){for(k=n;k>=i;k--){matrix[k][j]-=matrix[k][i]*matrix[i][j]/matrix[i][i]}}}for(j=n-1;j>=0;--j){t=0;for(k=j+1;k<n;++k){t+=matrix[k][j]*coef[k]}coef[j]=(matrix[n][j]-t)/matrix[j][j]}return coef}const maxiters=2,epsilon$6=1e-12;function loess(data,x,y,bandwidth){const[xv,yv,ux,uy]=points(data,x,y,true),n=xv.length,bw=Math.max(2,~~(bandwidth*n)),yhat=new Float64Array(n),residuals=new Float64Array(n),robustWeights=new Float64Array(n).fill(1);for(let iter=-1;++iter<=maxiters;){const interval=[0,bw-1];for(let i=0;i<n;++i){const dx=xv[i],i0=interval[0],i1=interval[1],edge=dx-xv[i0]>xv[i1]-dx?i0:i1;let W=0,X=0,Y=0,XY=0,X2=0;const denom=1/Math.abs(xv[edge]-dx||1);for(let k=i0;k<=i1;++k){const xk=xv[k],yk=yv[k],w=tricube(Math.abs(dx-xk)*denom)*robustWeights[k],xkw=xk*w;W+=w;X+=xkw;Y+=yk*w;XY+=yk*xkw;X2+=xk*xkw}const[a,b]=ols(X/W,Y/W,XY/W,X2/W);yhat[i]=a+b*dx;residuals[i]=Math.abs(yv[i]-yhat[i]);updateInterval(xv,i+1,interval)}if(iter===maxiters){break}const medianResidual=median(residuals);if(Math.abs(medianResidual)<epsilon$6)break;for(let i=0,arg,w;i<n;++i){arg=residuals[i]/(6*medianResidual);robustWeights[i]=arg>=1?epsilon$6:(w=1-arg*arg)*w}}return output$1(xv,yhat,ux,uy)}function tricube(x){return(x=1-x*x*x)*x*x}function updateInterval(xv,i,interval){const val=xv[i];let left=interval[0],right=interval[1]+1;if(right>=xv.length)return;while(i>left&&xv[right]-val<=val-xv[left]){interval[0]=++left;interval[1]=right;++right}}function output$1(xv,yhat,ux,uy){const n=xv.length,out=[];let i=0,cnt=0,prev=[],v;for(;i<n;++i){v=xv[i]+ux;if(prev[0]===v){prev[1]+=(yhat[i]-prev[1])/++cnt}else{cnt=0;prev[1]+=uy;prev=[v,yhat[i]];out.push(prev)}}prev[1]+=uy;return out}const MIN_RADIANS=.5*Math.PI/180;function sampleCurve(f,extent,minSteps,maxSteps){minSteps=minSteps||25;maxSteps=Math.max(minSteps,maxSteps||200);const point=x=>[x,f(x)],minX=extent[0],maxX=extent[1],span=maxX-minX,stop=span/maxSteps,prev=[point(minX)],next=[];if(minSteps===maxSteps){for(let i=1;i<maxSteps;++i){prev.push(point(minX+i/minSteps*span))}prev.push(point(maxX));return prev}else{next.push(point(maxX));for(let i=minSteps;--i>0;){next.push(point(minX+i/minSteps*span))}}let p0=prev[0];let p1=next[next.length-1];const sx=1/span;const sy=scaleY(p0[1],next);while(p1){const pm=point((p0[0]+p1[0])/2);const dx=pm[0]-p0[0]>=stop;if(dx&&angleDelta(p0,pm,p1,sx,sy)>MIN_RADIANS){next.push(pm)}else{p0=p1;prev.push(p1);next.pop()}p1=next[next.length-1]}return prev}function scaleY(init,points){let ymin=init;let ymax=init;const n=points.length;for(let i=0;i<n;++i){const y=points[i][1];if(y<ymin)ymin=y;if(y>ymax)ymax=y}return 1/(ymax-ymin)}function angleDelta(p,q,r,sx,sy){const a0=Math.atan2(sy*(r[1]-p[1]),sx*(r[0]-p[0])),a1=Math.atan2(sy*(q[1]-p[1]),sx*(q[0]-p[0]));return Math.abs(a0-a1)}function multikey(f){return x=>{const n=f.length;let i=1,k=String(f[0](x));for(;i<n;++i){k+="|"+f[i](x)}return k}}function groupkey(fields){return!fields||!fields.length?function(){return""}:fields.length===1?fields[0]:multikey(fields)}function measureName(op,field,as){return as||op+(!field?"":"_"+field)}const noop$4=()=>{};const base_op={init:noop$4,add:noop$4,rem:noop$4,idx:0};const AggregateOps={values:{init:m=>m.cell.store=true,value:m=>m.cell.data.values(),idx:-1},count:{value:m=>m.cell.num},__count__:{value:m=>m.missing+m.valid},missing:{value:m=>m.missing},valid:{value:m=>m.valid},sum:{init:m=>m.sum=0,value:m=>m.valid?m.sum:undefined,add:(m,v)=>m.sum+=+v,rem:(m,v)=>m.sum-=v},product:{init:m=>m.product=1,value:m=>m.valid?m.product:undefined,add:(m,v)=>m.product*=v,rem:(m,v)=>m.product/=v},mean:{init:m=>m.mean=0,value:m=>m.valid?m.mean:undefined,add:(m,v)=>(m.mean_d=v-m.mean,m.mean+=m.mean_d/m.valid),rem:(m,v)=>(m.mean_d=v-m.mean,m.mean-=m.valid?m.mean_d/m.valid:m.mean)},average:{value:m=>m.valid?m.mean:undefined,req:["mean"],idx:1},variance:{init:m=>m.dev=0,value:m=>m.valid>1?m.dev/(m.valid-1):undefined,add:(m,v)=>m.dev+=m.mean_d*(v-m.mean),rem:(m,v)=>m.dev-=m.mean_d*(v-m.mean),req:["mean"],idx:1},variancep:{value:m=>m.valid>1?m.dev/m.valid:undefined,req:["variance"],idx:2},stdev:{value:m=>m.valid>1?Math.sqrt(m.dev/(m.valid-1)):undefined,req:["variance"],idx:2},stdevp:{value:m=>m.valid>1?Math.sqrt(m.dev/m.valid):undefined,req:["variance"],idx:2},stderr:{value:m=>m.valid>1?Math.sqrt(m.dev/(m.valid*(m.valid-1))):undefined,req:["variance"],idx:2},distinct:{value:m=>m.cell.data.distinct(m.get),req:["values"],idx:3},ci0:{value:m=>m.cell.data.ci0(m.get),req:["values"],idx:3},ci1:{value:m=>m.cell.data.ci1(m.get),req:["values"],idx:3},median:{value:m=>m.cell.data.q2(m.get),req:["values"],idx:3},q1:{value:m=>m.cell.data.q1(m.get),req:["values"],idx:3},q3:{value:m=>m.cell.data.q3(m.get),req:["values"],idx:3},min:{init:m=>m.min=undefined,value:m=>m.min=Number.isNaN(m.min)?m.cell.data.min(m.get):m.min,add:(m,v)=>{if(v<m.min||m.min===undefined)m.min=v},rem:(m,v)=>{if(v<=m.min)m.min=NaN},req:["values"],idx:4},max:{init:m=>m.max=undefined,value:m=>m.max=Number.isNaN(m.max)?m.cell.data.max(m.get):m.max,add:(m,v)=>{if(v>m.max||m.max===undefined)m.max=v},rem:(m,v)=>{if(v>=m.max)m.max=NaN},req:["values"],idx:4},argmin:{init:m=>m.argmin=undefined,value:m=>m.argmin||m.cell.data.argmin(m.get),add:(m,v,t)=>{if(v<m.min)m.argmin=t},rem:(m,v)=>{if(v<=m.min)m.argmin=undefined},req:["min","values"],idx:3},argmax:{init:m=>m.argmax=undefined,value:m=>m.argmax||m.cell.data.argmax(m.get),add:(m,v,t)=>{if(v>m.max)m.argmax=t},rem:(m,v)=>{if(v>=m.max)m.argmax=undefined},req:["max","values"],idx:3},exponential:{init:(m,r)=>{m.exp=0;m.exp_r=r},value:m=>m.valid?m.exp*(1-m.exp_r)/(1-m.exp_r**m.valid):undefined,add:(m,v)=>m.exp=m.exp_r*m.exp+v,rem:(m,v)=>m.exp=(m.exp-v/m.exp_r**(m.valid-1))/m.exp_r},exponentialb:{value:m=>m.valid?m.exp*(1-m.exp_r):undefined,req:["exponential"],idx:1}};const ValidAggregateOps=Object.keys(AggregateOps).filter((d=>d!=="__count__"));function measure(key,value){return(out,aggregate_param)=>extend$1({name:key,aggregate_param:aggregate_param,out:out||key},base_op,value)}[...ValidAggregateOps,"__count__"].forEach((key=>{AggregateOps[key]=measure(key,AggregateOps[key])}));function createMeasure(op,param,name){return AggregateOps[op](name,param)}function compareIndex(a,b){return a.idx-b.idx}function resolve(agg){const map={};agg.forEach((a=>map[a.name]=a));const getreqs=a=>{if(!a.req)return;a.req.forEach((key=>{if(!map[key])getreqs(map[key]=AggregateOps[key]())}))};agg.forEach(getreqs);return Object.values(map).sort(compareIndex)}function init(){this.valid=0;this.missing=0;this._ops.forEach((op=>op.aggregate_param==null?op.init(this):op.init(this,op.aggregate_param)))}function add$3(v,t){if(v==null||v===""){++this.missing;return}if(v!==v)return;++this.valid;this._ops.forEach((op=>op.add(this,v,t)))}function rem(v,t){if(v==null||v===""){--this.missing;return}if(v!==v)return;--this.valid;this._ops.forEach((op=>op.rem(this,v,t)))}function set$4(t){this._out.forEach((op=>t[op.out]=op.value(this)));return t}function compileMeasures(agg,field){const get=field||identity$6,ops=resolve(agg),out=agg.slice().sort(compareIndex);function ctr(cell){this._ops=ops;this._out=out;this.cell=cell;this.init()}ctr.prototype.init=init;ctr.prototype.add=add$3;ctr.prototype.rem=rem;ctr.prototype.set=set$4;ctr.prototype.get=get;ctr.fields=agg.map((op=>op.out));return ctr}function TupleStore(key){this._key=key?field$1(key):tupleid;this.reset()}const prototype$1=TupleStore.prototype;prototype$1.reset=function(){this._add=[];this._rem=[];this._ext=null;this._get=null;this._q=null};prototype$1.add=function(v){this._add.push(v)};prototype$1.rem=function(v){this._rem.push(v)};prototype$1.values=function(){this._get=null;if(this._rem.length===0)return this._add;const a=this._add,r=this._rem,k=this._key,n=a.length,m=r.length,x=Array(n-m),map={};let i,j,v;for(i=0;i<m;++i){map[k(r[i])]=1}for(i=0,j=0;i<n;++i){if(map[k(v=a[i])]){map[k(v)]=0}else{x[j++]=v}}this._rem=[];return this._add=x};prototype$1.distinct=function(get){const v=this.values(),map={};let n=v.length,count=0,s;while(--n>=0){s=get(v[n])+"";if(!has$1(map,s)){map[s]=1;++count}}return count};prototype$1.extent=function(get){if(this._get!==get||!this._ext){const v=this.values(),i=extentIndex(v,get);this._ext=[v[i[0]],v[i[1]]];this._get=get}return this._ext};prototype$1.argmin=function(get){return this.extent(get)[0]||{}};prototype$1.argmax=function(get){return this.extent(get)[1]||{}};prototype$1.min=function(get){const m=this.extent(get)[0];return m!=null?get(m):undefined};prototype$1.max=function(get){const m=this.extent(get)[1];return m!=null?get(m):undefined};prototype$1.quartile=function(get){if(this._get!==get||!this._q){this._q=quartiles(this.values(),get);this._get=get}return this._q};prototype$1.q1=function(get){return this.quartile(get)[0]};prototype$1.q2=function(get){return this.quartile(get)[1]};prototype$1.q3=function(get){return this.quartile(get)[2]};prototype$1.ci=function(get){if(this._get!==get||!this._ci){this._ci=bootstrapCI(this.values(),1e3,.05,get);this._get=get}return this._ci};prototype$1.ci0=function(get){return this.ci(get)[0]};prototype$1.ci1=function(get){return this.ci(get)[1]};function Aggregate$1(params){Transform.call(this,null,params);this._adds=[];this._mods=[];this._alen=0;this._mlen=0;this._drop=true;this._cross=false;this._dims=[];this._dnames=[];this._measures=[];this._countOnly=false;this._counts=null;this._prev=null;this._inputs=null;this._outputs=null}Aggregate$1.Definition={type:"Aggregate",metadata:{generates:true,changes:true},params:[{name:"groupby",type:"field",array:true},{name:"ops",type:"enum",array:true,values:ValidAggregateOps},{name:"aggregate_params",type:"number",null:true,array:true},{name:"fields",type:"field",null:true,array:true},{name:"as",type:"string",null:true,array:true},{name:"drop",type:"boolean",default:true},{name:"cross",type:"boolean",default:false},{name:"key",type:"field"}]};inherits(Aggregate$1,Transform,{transform(_,pulse){const aggr=this,out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),mod=_.modified();aggr.stamp=out.stamp;if(aggr.value&&(mod||pulse.modified(aggr._inputs,true))){aggr._prev=aggr.value;aggr.value=mod?aggr.init(_):Object.create(null);pulse.visit(pulse.SOURCE,(t=>aggr.add(t)))}else{aggr.value=aggr.value||aggr.init(_);pulse.visit(pulse.REM,(t=>aggr.rem(t)));pulse.visit(pulse.ADD,(t=>aggr.add(t)))}out.modifies(aggr._outputs);aggr._drop=_.drop!==false;if(_.cross&&aggr._dims.length>1){aggr._drop=false;aggr.cross()}if(pulse.clean()&&aggr._drop){out.clean(true).runAfter((()=>this.clean()))}return aggr.changes(out)},cross(){const aggr=this,curr=aggr.value,dims=aggr._dnames,vals=dims.map((()=>({}))),n=dims.length;function collect(cells){let key,i,t,v;for(key in cells){t=cells[key].tuple;for(i=0;i<n;++i){vals[i][v=t[dims[i]]]=v}}}collect(aggr._prev);collect(curr);function generate(base,tuple,index){const name=dims[index],v=vals[index++];for(const k in v){const key=base?base+"|"+k:k;tuple[name]=v[k];if(index<n)generate(key,tuple,index);else if(!curr[key])aggr.cell(key,tuple)}}generate("",{},0)},init(_){const inputs=this._inputs=[],outputs=this._outputs=[],inputMap={};function inputVisit(get){const fields=array$5(accessorFields(get)),n=fields.length;let i=0,f;for(;i<n;++i){if(!inputMap[f=fields[i]]){inputMap[f]=1;inputs.push(f)}}}this._dims=array$5(_.groupby);this._dnames=this._dims.map((d=>{const dname=accessorName(d);inputVisit(d);outputs.push(dname);return dname}));this.cellkey=_.key?_.key:groupkey(this._dims);this._countOnly=true;this._counts=[];this._measures=[];const fields=_.fields||[null],ops=_.ops||["count"],aggregate_params=_.aggregate_params||[null],as=_.as||[],n=fields.length,map={};let field,op,aggregate_param,m,mname,outname,i;if(n!==ops.length){error("Unmatched number of fields and aggregate ops.")}for(i=0;i<n;++i){field=fields[i];op=ops[i];aggregate_param=aggregate_params[i]||null;if(field==null&&op!=="count"){error("Null aggregate field specified.")}mname=accessorName(field);outname=measureName(op,mname,as[i]);outputs.push(outname);if(op==="count"){this._counts.push(outname);continue}m=map[mname];if(!m){inputVisit(field);m=map[mname]=[];m.field=field;this._measures.push(m)}if(op!=="count")this._countOnly=false;m.push(createMeasure(op,aggregate_param,outname))}this._measures=this._measures.map((m=>compileMeasures(m,m.field)));return Object.create(null)},cellkey:groupkey(),cell(key,t){let cell=this.value[key];if(!cell){cell=this.value[key]=this.newcell(key,t);this._adds[this._alen++]=cell}else if(cell.num===0&&this._drop&&cell.stamp<this.stamp){cell.stamp=this.stamp;this._adds[this._alen++]=cell}else if(cell.stamp<this.stamp){cell.stamp=this.stamp;this._mods[this._mlen++]=cell}return cell},newcell(key,t){const cell={key:key,num:0,agg:null,tuple:this.newtuple(t,this._prev&&this._prev[key]),stamp:this.stamp,store:false};if(!this._countOnly){const measures=this._measures,n=measures.length;cell.agg=Array(n);for(let i=0;i<n;++i){cell.agg[i]=new measures[i](cell)}}if(cell.store){cell.data=new TupleStore}return cell},newtuple(t,p){const names=this._dnames,dims=this._dims,n=dims.length,x={};for(let i=0;i<n;++i){x[names[i]]=dims[i](t)}return p?replace$1(p.tuple,x):ingest$1(x)},clean(){const cells=this.value;for(const key in cells){if(cells[key].num===0){delete cells[key]}}},add(t){const key=this.cellkey(t),cell=this.cell(key,t);cell.num+=1;if(this._countOnly)return;if(cell.store)cell.data.add(t);const agg=cell.agg;for(let i=0,n=agg.length;i<n;++i){agg[i].add(agg[i].get(t),t)}},rem(t){const key=this.cellkey(t),cell=this.cell(key,t);cell.num-=1;if(this._countOnly)return;if(cell.store)cell.data.rem(t);const agg=cell.agg;for(let i=0,n=agg.length;i<n;++i){agg[i].rem(agg[i].get(t),t)}},celltuple(cell){const tuple=cell.tuple,counts=this._counts;if(cell.store){cell.data.values()}for(let i=0,n=counts.length;i<n;++i){tuple[counts[i]]=cell.num}if(!this._countOnly){const agg=cell.agg;for(let i=0,n=agg.length;i<n;++i){agg[i].set(tuple)}}return tuple},changes(out){const adds=this._adds,mods=this._mods,prev=this._prev,drop=this._drop,add=out.add,rem=out.rem,mod=out.mod;let cell,key,i,n;if(prev)for(key in prev){cell=prev[key];if(!drop||cell.num)rem.push(cell.tuple)}for(i=0,n=this._alen;i<n;++i){add.push(this.celltuple(adds[i]));adds[i]=null}for(i=0,n=this._mlen;i<n;++i){cell=mods[i];(cell.num===0&&drop?rem:mod).push(this.celltuple(cell));mods[i]=null}this._alen=this._mlen=0;this._prev=null;return out}});const EPSILON$1=1e-14;function Bin(params){Transform.call(this,null,params)}Bin.Definition={type:"Bin",metadata:{modifies:true},params:[{name:"field",type:"field",required:true},{name:"interval",type:"boolean",default:true},{name:"anchor",type:"number"},{name:"maxbins",type:"number",default:20},{name:"base",type:"number",default:10},{name:"divide",type:"number",array:true,default:[5,2]},{name:"extent",type:"number",array:true,length:2,required:true},{name:"span",type:"number"},{name:"step",type:"number"},{name:"steps",type:"number",array:true},{name:"minstep",type:"number",default:0},{name:"nice",type:"boolean",default:true},{name:"name",type:"string"},{name:"as",type:"string",array:true,length:2,default:["bin0","bin1"]}]};inherits(Bin,Transform,{transform(_,pulse){const band=_.interval!==false,bins=this._bins(_),start=bins.start,step=bins.step,as=_.as||["bin0","bin1"],b0=as[0],b1=as[1];let flag;if(_.modified()){pulse=pulse.reflow(true);flag=pulse.SOURCE}else{flag=pulse.modified(accessorFields(_.field))?pulse.ADD_MOD:pulse.ADD}pulse.visit(flag,band?t=>{const v=bins(t);t[b0]=v;t[b1]=v==null?null:start+step*(1+(v-start)/step)}:t=>t[b0]=bins(t));return pulse.modifies(band?as:b0)},_bins(_){if(this.value&&!_.modified()){return this.value}const field=_.field,bins=bin(_),step=bins.step;let start=bins.start,stop=start+Math.ceil((bins.stop-start)/step)*step,a,d;if((a=_.anchor)!=null){d=a-(start+step*Math.floor((a-start)/step));start+=d;stop+=d}const f=function(t){let v=toNumber(field(t));return v==null?null:v<start?-Infinity:v>stop?+Infinity:(v=Math.max(start,Math.min(v,stop-step)),start+step*Math.floor(EPSILON$1+(v-start)/step))};f.start=start;f.stop=bins.stop;f.step=step;return this.value=accessor(f,accessorFields(field),_.name||"bin_"+accessorName(field))}});function SortedList(idFunc,source,input){const $=idFunc;let data=source||[],add=input||[],rem={},cnt=0;return{add:t=>add.push(t),remove:t=>rem[$(t)]=++cnt,size:()=>data.length,data:(compare,resort)=>{if(cnt){data=data.filter((t=>!rem[$(t)]));rem={};cnt=0}if(resort&&compare){data.sort(compare)}if(add.length){data=compare?merge$3(compare,data,add.sort(compare)):data.concat(add);add=[]}return data}}}function Collect$1(params){Transform.call(this,[],params)}Collect$1.Definition={type:"Collect",metadata:{source:true},params:[{name:"sort",type:"compare"}]};inherits(Collect$1,Transform,{transform(_,pulse){const out=pulse.fork(pulse.ALL),list=SortedList(tupleid,this.value,out.materialize(out.ADD).add),sort=_.sort,mod=pulse.changed()||sort&&(_.modified("sort")||pulse.modified(sort.fields));out.visit(out.REM,list.remove);this.modified(mod);this.value=out.source=list.data(stableCompare(sort),mod);if(pulse.source&&pulse.source.root){this.value.root=pulse.source.root}return out}});function Compare$1(params){Operator.call(this,null,update$5,params)}inherits(Compare$1,Operator);function update$5(_){return this.value&&!_.modified()?this.value:compare$1(_.fields,_.orders)}function CountPattern(params){Transform.call(this,null,params)}CountPattern.Definition={type:"CountPattern",metadata:{generates:true,changes:true},params:[{name:"field",type:"field",required:true},{name:"case",type:"enum",values:["upper","lower","mixed"],default:"mixed"},{name:"pattern",type:"string",default:'[\\w"]+'},{name:"stopwords",type:"string",default:""},{name:"as",type:"string",array:true,length:2,default:["text","count"]}]};function tokenize(text,tcase,match){switch(tcase){case"upper":text=text.toUpperCase();break;case"lower":text=text.toLowerCase();break}return text.match(match)}inherits(CountPattern,Transform,{transform(_,pulse){const process=update=>tuple=>{var tokens=tokenize(get(tuple),_.case,match)||[],t;for(var i=0,n=tokens.length;i<n;++i){if(!stop.test(t=tokens[i]))update(t)}};const init=this._parameterCheck(_,pulse),counts=this._counts,match=this._match,stop=this._stop,get=_.field,as=_.as||["text","count"],add=process((t=>counts[t]=1+(counts[t]||0))),rem=process((t=>counts[t]-=1));if(init){pulse.visit(pulse.SOURCE,add)}else{pulse.visit(pulse.ADD,add);pulse.visit(pulse.REM,rem)}return this._finish(pulse,as)},_parameterCheck(_,pulse){let init=false;if(_.modified("stopwords")||!this._stop){this._stop=new RegExp("^"+(_.stopwords||"")+"$","i");init=true}if(_.modified("pattern")||!this._match){this._match=new RegExp(_.pattern||"[\\w']+","g");init=true}if(_.modified("field")||pulse.modified(_.field.fields)){init=true}if(init)this._counts={};return init},_finish(pulse,as){const counts=this._counts,tuples=this._tuples||(this._tuples={}),text=as[0],count=as[1],out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);let w,t,c;for(w in counts){t=tuples[w];c=counts[w]||0;if(!t&&c){tuples[w]=t=ingest$1({});t[text]=w;t[count]=c;out.add.push(t)}else if(c===0){if(t)out.rem.push(t);counts[w]=null;tuples[w]=null}else if(t[count]!==c){t[count]=c;out.mod.push(t)}}return out.modifies(as)}});function Cross(params){Transform.call(this,null,params)}Cross.Definition={type:"Cross",metadata:{generates:true},params:[{name:"filter",type:"expr"},{name:"as",type:"string",array:true,length:2,default:["a","b"]}]};inherits(Cross,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),as=_.as||["a","b"],a=as[0],b=as[1],reset=!this.value||pulse.changed(pulse.ADD_REM)||_.modified("as")||_.modified("filter");let data=this.value;if(reset){if(data)out.rem=data;data=pulse.materialize(pulse.SOURCE).source;out.add=this.value=cross(data,a,b,_.filter||truthy)}else{out.mod=data}out.source=this.value;return out.modifies(as)}});function cross(input,a,b,filter){var data=[],t={},n=input.length,i=0,j,left;for(;i<n;++i){t[a]=left=input[i];for(j=0;j<n;++j){t[b]=input[j];if(filter(t)){data.push(ingest$1(t));t={};t[a]=left}}}return data}const Distributions={kde:kde,mixture:mixture$1,normal:gaussian,lognormal:lognormal,uniform:uniform};const DISTRIBUTIONS="distributions",FUNCTION="function",FIELD="field";function parse$4(def,data){const func=def[FUNCTION];if(!has$1(Distributions,func)){error("Unknown distribution function: "+func)}const d=Distributions[func]();for(const name in def){if(name===FIELD){d.data((def.from||data()).map(def[name]))}else if(name===DISTRIBUTIONS){d[name](def[name].map((_=>parse$4(_,data))))}else if(typeof d[name]===FUNCTION){d[name](def[name])}}return d}function Density(params){Transform.call(this,null,params)}const distributions=[{key:{function:"normal"},params:[{name:"mean",type:"number",default:0},{name:"stdev",type:"number",default:1}]},{key:{function:"lognormal"},params:[{name:"mean",type:"number",default:0},{name:"stdev",type:"number",default:1}]},{key:{function:"uniform"},params:[{name:"min",type:"number",default:0},{name:"max",type:"number",default:1}]},{key:{function:"kde"},params:[{name:"field",type:"field",required:true},{name:"from",type:"data"},{name:"bandwidth",type:"number",default:0}]}];const mixture={key:{function:"mixture"},params:[{name:"distributions",type:"param",array:true,params:distributions},{name:"weights",type:"number",array:true}]};Density.Definition={type:"Density",metadata:{generates:true},params:[{name:"extent",type:"number",array:true,length:2},{name:"steps",type:"number"},{name:"minsteps",type:"number",default:25},{name:"maxsteps",type:"number",default:200},{name:"method",type:"string",default:"pdf",values:["pdf","cdf"]},{name:"distribution",type:"param",params:distributions.concat(mixture)},{name:"as",type:"string",array:true,default:["value","density"]}]};inherits(Density,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){const dist=parse$4(_.distribution,source$1(pulse)),minsteps=_.steps||_.minsteps||25,maxsteps=_.steps||_.maxsteps||200;let method=_.method||"pdf";if(method!=="pdf"&&method!=="cdf"){error("Invalid density method: "+method)}if(!_.extent&&!dist.data){error("Missing density extent parameter.")}method=dist[method];const as=_.as||["value","density"],domain=_.extent||extent(dist.data()),values=sampleCurve(method,domain,minsteps,maxsteps).map((v=>{const tuple={};tuple[as[0]]=v[0];tuple[as[1]]=v[1];return ingest$1(tuple)}));if(this.value)out.rem=this.value;this.value=out.add=out.source=values}return out}});function source$1(pulse){return()=>pulse.materialize(pulse.SOURCE).source}function fieldNames(fields,as){if(!fields)return null;return fields.map(((f,i)=>as[i]||accessorName(f)))}function partition$1$1(data,groupby,field){const groups=[],get=f=>f(t);let map,i,n,t,k,g;if(groupby==null){groups.push(data.map(field))}else{for(map={},i=0,n=data.length;i<n;++i){t=data[i];k=groupby.map(get);g=map[k];if(!g){map[k]=g=[];g.dims=k;groups.push(g)}g.push(field(t))}}return groups}const Output$5="bin";function DotBin(params){Transform.call(this,null,params)}DotBin.Definition={type:"DotBin",metadata:{modifies:true},params:[{name:"field",type:"field",required:true},{name:"groupby",type:"field",array:true},{name:"step",type:"number"},{name:"smooth",type:"boolean",default:false},{name:"as",type:"string",default:Output$5}]};const autostep=(data,field)=>span(extent(data,field))/30;inherits(DotBin,Transform,{transform(_,pulse){if(this.value&&!(_.modified()||pulse.changed())){return pulse}const source=pulse.materialize(pulse.SOURCE).source,groups=partition$1$1(pulse.source,_.groupby,identity$6),smooth=_.smooth||false,field=_.field,step=_.step||autostep(source,field),sort=stableCompare(((a,b)=>field(a)-field(b))),as=_.as||Output$5,n=groups.length;let min=Infinity,max=-Infinity,i=0,j;for(;i<n;++i){const g=groups[i].sort(sort);j=-1;for(const v of dotbin(g,step,smooth,field)){if(v<min)min=v;if(v>max)max=v;g[++j][as]=v}}this.value={start:min,stop:max,step:step};return pulse.reflow(true).modifies(as)}});function Expression$1(params){Operator.call(this,null,update$4,params);this.modified(true)}inherits(Expression$1,Operator);function update$4(_){const expr=_.expr;return this.value&&!_.modified("expr")?this.value:accessor((datum=>expr(datum,_)),accessorFields(expr),accessorName(expr))}function Extent(params){Transform.call(this,[undefined,undefined],params)}Extent.Definition={type:"Extent",metadata:{},params:[{name:"field",type:"field",required:true}]};inherits(Extent,Transform,{transform(_,pulse){const extent=this.value,field=_.field,mod=pulse.changed()||pulse.modified(field.fields)||_.modified("field");let min=extent[0],max=extent[1];if(mod||min==null){min=+Infinity;max=-Infinity}pulse.visit(mod?pulse.SOURCE:pulse.ADD,(t=>{const v=toNumber(field(t));if(v!=null){if(v<min)min=v;if(v>max)max=v}}));if(!Number.isFinite(min)||!Number.isFinite(max)){let name=accessorName(field);if(name)name=` for field "${name}"`;pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);min=max=undefined}this.value=[min,max]}});function Subflow(pulse,parent){Operator.call(this,pulse);this.parent=parent;this.count=0}inherits(Subflow,Operator,{connect(target){this.detachSubflow=target.detachSubflow;this.targets().add(target);return target.source=this},add(t){this.count+=1;this.value.add.push(t)},rem(t){this.count-=1;this.value.rem.push(t)},mod(t){this.value.mod.push(t)},init(pulse){this.value.init(pulse,pulse.NO_SOURCE)},evaluate(){return this.value}});function Facet$1(params){Transform.call(this,{},params);this._keys=fastmap();const a=this._targets=[];a.active=0;a.forEach=f=>{for(let i=0,n=a.active;i<n;++i){f(a[i],i,a)}}}inherits(Facet$1,Transform,{activate(flow){this._targets[this._targets.active++]=flow},subflow(key,flow,pulse,parent){const flows=this.value;let sf=has$1(flows,key)&&flows[key],df,p;if(!sf){p=parent||(p=this._group[key])&&p.tuple;df=pulse.dataflow;sf=new Subflow(pulse.fork(pulse.NO_SOURCE),this);df.add(sf).connect(flow(df,key,p));flows[key]=sf;this.activate(sf)}else if(sf.value.stamp<pulse.stamp){sf.init(pulse);this.activate(sf)}return sf},clean(){const flows=this.value;let detached=0;for(const key in flows){if(flows[key].count===0){const detach=flows[key].detachSubflow;if(detach)detach();delete flows[key];++detached}}if(detached){const active=this._targets.filter((sf=>sf&&sf.count>0));this.initTargets(active)}},initTargets(act){const a=this._targets,n=a.length,m=act?act.length:0;let i=0;for(;i<m;++i){a[i]=act[i]}for(;i<n&&a[i]!=null;++i){a[i]=null}a.active=m},transform(_,pulse){const df=pulse.dataflow,key=_.key,flow=_.subflow,cache=this._keys,rekey=_.modified("key"),subflow=key=>this.subflow(key,flow,pulse);this._group=_.group||{};this.initTargets();pulse.visit(pulse.REM,(t=>{const id=tupleid(t),k=cache.get(id);if(k!==undefined){cache.delete(id);subflow(k).rem(t)}}));pulse.visit(pulse.ADD,(t=>{const k=key(t);cache.set(tupleid(t),k);subflow(k).add(t)}));if(rekey||pulse.modified(key.fields)){pulse.visit(pulse.MOD,(t=>{const id=tupleid(t),k0=cache.get(id),k1=key(t);if(k0===k1){subflow(k1).mod(t)}else{cache.set(id,k1);subflow(k0).rem(t);subflow(k1).add(t)}}))}else if(pulse.changed(pulse.MOD)){pulse.visit(pulse.MOD,(t=>{subflow(cache.get(tupleid(t))).mod(t)}))}if(rekey){pulse.visit(pulse.REFLOW,(t=>{const id=tupleid(t),k0=cache.get(id),k1=key(t);if(k0!==k1){cache.set(id,k1);subflow(k0).rem(t);subflow(k1).add(t)}}))}if(pulse.clean()){df.runAfter((()=>{this.clean();cache.clean()}))}else if(cache.empty>df.cleanThreshold){df.runAfter(cache.clean)}return pulse}});function Field$1(params){Operator.call(this,null,update$3,params)}inherits(Field$1,Operator);function update$3(_){return this.value&&!_.modified()?this.value:isArray(_.name)?array$5(_.name).map((f=>field$1(f))):field$1(_.name,_.as)}function Filter(params){Transform.call(this,fastmap(),params)}Filter.Definition={type:"Filter",metadata:{changes:true},params:[{name:"expr",type:"expr",required:true}]};inherits(Filter,Transform,{transform(_,pulse){const df=pulse.dataflow,cache=this.value,output=pulse.fork(),add=output.add,rem=output.rem,mod=output.mod,test=_.expr;let isMod=true;pulse.visit(pulse.REM,(t=>{const id=tupleid(t);if(!cache.has(id))rem.push(t);else cache.delete(id)}));pulse.visit(pulse.ADD,(t=>{if(test(t,_))add.push(t);else cache.set(tupleid(t),1)}));function revisit(t){const id=tupleid(t),b=test(t,_),s=cache.get(id);if(b&&s){cache.delete(id);add.push(t)}else if(!b&&!s){cache.set(id,1);rem.push(t)}else if(isMod&&b&&!s){mod.push(t)}}pulse.visit(pulse.MOD,revisit);if(_.modified()){isMod=false;pulse.visit(pulse.REFLOW,revisit)}if(cache.empty>df.cleanThreshold)df.runAfter(cache.clean);return output}});function Flatten(params){Transform.call(this,[],params)}Flatten.Definition={type:"Flatten",metadata:{generates:true},params:[{name:"fields",type:"field",array:true,required:true},{name:"index",type:"string"},{name:"as",type:"string",array:true}]};inherits(Flatten,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,as=fieldNames(fields,_.as||[]),index=_.index||null,m=as.length;out.rem=this.value;pulse.visit(pulse.SOURCE,(t=>{const arrays=fields.map((f=>f(t))),maxlen=arrays.reduce(((l,a)=>Math.max(l,a.length)),0);let i=0,j,d,v;for(;i<maxlen;++i){d=derive(t);for(j=0;j<m;++j){d[as[j]]=(v=arrays[j][i])==null?null:v}if(index){d[index]=i}out.add.push(d)}}));this.value=out.source=out.add;if(index)out.modifies(index);return out.modifies(as)}});function Fold(params){Transform.call(this,[],params)}Fold.Definition={type:"Fold",metadata:{generates:true},params:[{name:"fields",type:"field",array:true,required:true},{name:"as",type:"string",array:true,length:2,default:["key","value"]}]};inherits(Fold,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,fnames=fields.map(accessorName),as=_.as||["key","value"],k=as[0],v=as[1],n=fields.length;out.rem=this.value;pulse.visit(pulse.SOURCE,(t=>{for(let i=0,d;i<n;++i){d=derive(t);d[k]=fnames[i];d[v]=fields[i](t);out.add.push(d)}}));this.value=out.source=out.add;return out.modifies(as)}});function Formula(params){Transform.call(this,null,params)}Formula.Definition={type:"Formula",metadata:{modifies:true},params:[{name:"expr",type:"expr",required:true},{name:"as",type:"string",required:true},{name:"initonly",type:"boolean"}]};inherits(Formula,Transform,{transform(_,pulse){const func=_.expr,as=_.as,mod=_.modified(),flag=_.initonly?pulse.ADD:mod?pulse.SOURCE:pulse.modified(func.fields)||pulse.modified(as)?pulse.ADD_MOD:pulse.ADD;if(mod){pulse=pulse.materialize().reflow(true)}if(!_.initonly){pulse.modifies(as)}return pulse.visit(flag,(t=>t[as]=func(t,_)))}});function Generate(params){Transform.call(this,[],params)}inherits(Generate,Transform,{transform(_,pulse){const out=pulse.fork(pulse.ALL),gen=_.generator;let data=this.value,num=_.size-data.length,add,rem,t;if(num>0){for(add=[];--num>=0;){add.push(t=ingest$1(gen(_)));data.push(t)}out.add=out.add.length?out.materialize(out.ADD).add.concat(add):add}else{rem=data.slice(0,-num);out.rem=out.rem.length?out.materialize(out.REM).rem.concat(rem):rem;data=data.slice(-num)}out.source=this.value=data;return out}});const Methods$1={value:"value",median:median,mean:mean,min:min$2,max:max$2};const Empty$1=[];function Impute(params){Transform.call(this,[],params)}Impute.Definition={type:"Impute",metadata:{changes:true},params:[{name:"field",type:"field",required:true},{name:"key",type:"field",required:true},{name:"keyvals",array:true},{name:"groupby",type:"field",array:true},{name:"method",type:"enum",default:"value",values:["value","mean","median","max","min"]},{name:"value",default:0}]};function getValue(_){var m=_.method||Methods$1.value,v;if(Methods$1[m]==null){error("Unrecognized imputation method: "+m)}else if(m===Methods$1.value){v=_.value!==undefined?_.value:0;return()=>v}else{return Methods$1[m]}}function getField$1(_){const f=_.field;return t=>t?f(t):NaN}inherits(Impute,Transform,{transform(_,pulse){var out=pulse.fork(pulse.ALL),impute=getValue(_),field=getField$1(_),fName=accessorName(_.field),kName=accessorName(_.key),gNames=(_.groupby||[]).map(accessorName),groups=partition$4(pulse.source,_.groupby,_.key,_.keyvals),curr=[],prev=this.value,m=groups.domain.length,group,value,gVals,kVal,g,i,j,l,n,t;for(g=0,l=groups.length;g<l;++g){group=groups[g];gVals=group.values;value=NaN;for(j=0;j<m;++j){if(group[j]!=null)continue;kVal=groups.domain[j];t={_impute:true};for(i=0,n=gVals.length;i<n;++i)t[gNames[i]]=gVals[i];t[kName]=kVal;t[fName]=Number.isNaN(value)?value=impute(group,field):value;curr.push(ingest$1(t))}}if(curr.length)out.add=out.materialize(out.ADD).add.concat(curr);if(prev.length)out.rem=out.materialize(out.REM).rem.concat(prev);this.value=curr;return out}});function partition$4(data,groupby,key,keyvals){var get=f=>f(t),groups=[],domain=keyvals?keyvals.slice():[],kMap={},gMap={},gVals,gKey,group,i,j,k,n,t;domain.forEach(((k,i)=>kMap[k]=i+1));for(i=0,n=data.length;i<n;++i){t=data[i];k=key(t);j=kMap[k]||(kMap[k]=domain.push(k));gKey=(gVals=groupby?groupby.map(get):Empty$1)+"";if(!(group=gMap[gKey])){group=gMap[gKey]=[];groups.push(group);group.values=gVals}group[j-1]=t}groups.domain=domain;return groups}function JoinAggregate(params){Aggregate$1.call(this,params)}JoinAggregate.Definition={type:"JoinAggregate",metadata:{modifies:true},params:[{name:"groupby",type:"field",array:true},{name:"fields",type:"field",null:true,array:true},{name:"ops",type:"enum",array:true,values:ValidAggregateOps},{name:"as",type:"string",null:true,array:true},{name:"key",type:"field"}]};inherits(JoinAggregate,Aggregate$1,{transform(_,pulse){const aggr=this,mod=_.modified();let cells;if(aggr.value&&(mod||pulse.modified(aggr._inputs,true))){cells=aggr.value=mod?aggr.init(_):{};pulse.visit(pulse.SOURCE,(t=>aggr.add(t)))}else{cells=aggr.value=aggr.value||this.init(_);pulse.visit(pulse.REM,(t=>aggr.rem(t)));pulse.visit(pulse.ADD,(t=>aggr.add(t)))}aggr.changes();pulse.visit(pulse.SOURCE,(t=>{extend$1(t,cells[aggr.cellkey(t)].tuple)}));return pulse.reflow(mod).modifies(this._outputs)},changes(){const adds=this._adds,mods=this._mods;let i,n;for(i=0,n=this._alen;i<n;++i){this.celltuple(adds[i]);adds[i]=null}for(i=0,n=this._mlen;i<n;++i){this.celltuple(mods[i]);mods[i]=null}this._alen=this._mlen=0}});function KDE(params){Transform.call(this,null,params)}KDE.Definition={type:"KDE",metadata:{generates:true},params:[{name:"groupby",type:"field",array:true},{name:"field",type:"field",required:true},{name:"cumulative",type:"boolean",default:false},{name:"counts",type:"boolean",default:false},{name:"bandwidth",type:"number",default:0},{name:"extent",type:"number",array:true,length:2},{name:"resolve",type:"enum",values:["shared","independent"],default:"independent"},{name:"steps",type:"number"},{name:"minsteps",type:"number",default:25},{name:"maxsteps",type:"number",default:200},{name:"as",type:"string",array:true,default:["value","density"]}]};inherits(KDE,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){const source=pulse.materialize(pulse.SOURCE).source,groups=partition$1$1(source,_.groupby,_.field),names=(_.groupby||[]).map(accessorName),bandwidth=_.bandwidth,method=_.cumulative?"cdf":"pdf",as=_.as||["value","density"],values=[];let domain=_.extent,minsteps=_.steps||_.minsteps||25,maxsteps=_.steps||_.maxsteps||200;if(method!=="pdf"&&method!=="cdf"){error("Invalid density method: "+method)}if(_.resolve==="shared"){if(!domain)domain=extent(source,_.field);minsteps=maxsteps=_.steps||maxsteps}groups.forEach((g=>{const density=kde(g,bandwidth)[method],scale=_.counts?g.length:1,local=domain||extent(g);sampleCurve(density,local,minsteps,maxsteps).forEach((v=>{const t={};for(let i=0;i<names.length;++i){t[names[i]]=g.dims[i]}t[as[0]]=v[0];t[as[1]]=v[1]*scale;values.push(ingest$1(t))}))}));if(this.value)out.rem=this.value;this.value=out.add=out.source=values}return out}});function Key$1(params){Operator.call(this,null,update$2,params)}inherits(Key$1,Operator);function update$2(_){return this.value&&!_.modified()?this.value:key(_.fields,_.flat)}function Load$1(params){Transform.call(this,[],params);this._pending=null}inherits(Load$1,Transform,{transform(_,pulse){const df=pulse.dataflow;if(this._pending){return output(this,pulse,this._pending)}if(stop(_))return pulse.StopPropagation;if(_.values){return output(this,pulse,df.parse(_.values,_.format))}else if(_.async){const p=df.request(_.url,_.format).then((res=>{this._pending=array$5(res.data);return df=>df.touch(this)}));return{async:p}}else{return df.request(_.url,_.format).then((res=>output(this,pulse,array$5(res.data))))}}});function stop(_){return _.modified("async")&&!(_.modified("values")||_.modified("url")||_.modified("format"))}function output(op,pulse,data){data.forEach(ingest$1);const out=pulse.fork(pulse.NO_FIELDS&pulse.NO_SOURCE);out.rem=op.value;op.value=out.source=out.add=data;op._pending=null;if(out.rem.length)out.clean(true);return out}function Lookup(params){Transform.call(this,{},params)}Lookup.Definition={type:"Lookup",metadata:{modifies:true},params:[{name:"index",type:"index",params:[{name:"from",type:"data",required:true},{name:"key",type:"field",required:true}]},{name:"values",type:"field",array:true},{name:"fields",type:"field",array:true,required:true},{name:"as",type:"string",array:true},{name:"default",default:null}]};inherits(Lookup,Transform,{transform(_,pulse){const keys=_.fields,index=_.index,values=_.values,defaultValue=_.default==null?null:_.default,reset=_.modified(),n=keys.length;let flag=reset?pulse.SOURCE:pulse.ADD,out=pulse,as=_.as,set,m,mods;if(values){m=values.length;if(n>1&&!as){error('Multi-field lookup requires explicit "as" parameter.')}if(as&&as.length!==n*m){error('The "as" parameter has too few output field names.')}as=as||values.map(accessorName);set=function(t){for(var i=0,k=0,j,v;i<n;++i){v=index.get(keys[i](t));if(v==null)for(j=0;j<m;++j,++k)t[as[k]]=defaultValue;else for(j=0;j<m;++j,++k)t[as[k]]=values[j](v)}}}else{if(!as){error("Missing output field names.")}set=function(t){for(var i=0,v;i<n;++i){v=index.get(keys[i](t));t[as[i]]=v==null?defaultValue:v}}}if(reset){out=pulse.reflow(true)}else{mods=keys.some((k=>pulse.modified(k.fields)));flag|=mods?pulse.MOD:0}pulse.visit(flag,set);return out.modifies(as)}});function MultiExtent$1(params){Operator.call(this,null,update$1,params)}inherits(MultiExtent$1,Operator);function update$1(_){if(this.value&&!_.modified()){return this.value}const ext=_.extents,n=ext.length;let min=+Infinity,max=-Infinity,i,e;for(i=0;i<n;++i){e=ext[i];if(e[0]<min)min=e[0];if(e[1]>max)max=e[1]}return[min,max]}function MultiValues$1(params){Operator.call(this,null,update,params)}inherits(MultiValues$1,Operator);function update(_){return this.value&&!_.modified()?this.value:_.values.reduce(((data,_)=>data.concat(_)),[])}function Params$2(params){Transform.call(this,null,params)}inherits(Params$2,Transform,{transform(_,pulse){this.modified(_.modified());this.value=_;return pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS)}});function Pivot(params){Aggregate$1.call(this,params)}Pivot.Definition={type:"Pivot",metadata:{generates:true,changes:true},params:[{name:"groupby",type:"field",array:true},{name:"field",type:"field",required:true},{name:"value",type:"field",required:true},{name:"op",type:"enum",values:ValidAggregateOps,default:"sum"},{name:"limit",type:"number",default:0},{name:"key",type:"field"}]};inherits(Pivot,Aggregate$1,{_transform:Aggregate$1.prototype.transform,transform(_,pulse){return this._transform(aggregateParams(_,pulse),pulse)}});function aggregateParams(_,pulse){const key=_.field,value=_.value,op=(_.op==="count"?"__count__":_.op)||"sum",fields=accessorFields(key).concat(accessorFields(value)),keys=pivotKeys(key,_.limit||0,pulse);if(pulse.changed())_.set("__pivot__",null,null,true);return{key:_.key,groupby:_.groupby,ops:keys.map((()=>op)),fields:keys.map((k=>get$4(k,key,value,fields))),as:keys.map((k=>k+"")),modified:_.modified.bind(_)}}function get$4(k,key,value,fields){return accessor((d=>key(d)===k?value(d):NaN),fields,k+"")}function pivotKeys(key,limit,pulse){const map={},list=[];pulse.visit(pulse.SOURCE,(t=>{const k=key(t);if(!map[k]){map[k]=1;list.push(k)}}));list.sort(ascending$2);return limit?list.slice(0,limit):list}function PreFacet$1(params){Facet$1.call(this,params)}inherits(PreFacet$1,Facet$1,{transform(_,pulse){const flow=_.subflow,field=_.field,subflow=t=>this.subflow(tupleid(t),flow,pulse,t);if(_.modified("field")||field&&pulse.modified(accessorFields(field))){error("PreFacet does not support field modification.")}this.initTargets();if(field){pulse.visit(pulse.MOD,(t=>{const sf=subflow(t);field(t).forEach((_=>sf.mod(_)))}));pulse.visit(pulse.ADD,(t=>{const sf=subflow(t);field(t).forEach((_=>sf.add(ingest$1(_))))}));pulse.visit(pulse.REM,(t=>{const sf=subflow(t);field(t).forEach((_=>sf.rem(_)))}))}else{pulse.visit(pulse.MOD,(t=>subflow(t).mod(t)));pulse.visit(pulse.ADD,(t=>subflow(t).add(t)));pulse.visit(pulse.REM,(t=>subflow(t).rem(t)))}if(pulse.clean()){pulse.runAfter((()=>this.clean()))}return pulse}});function Project(params){Transform.call(this,null,params)}Project.Definition={type:"Project",metadata:{generates:true,changes:true},params:[{name:"fields",type:"field",array:true},{name:"as",type:"string",null:true,array:true}]};inherits(Project,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),fields=_.fields,as=fieldNames(_.fields,_.as||[]),derive=fields?(s,t)=>project$1(s,t,fields,as):rederive;let lut;if(this.value){lut=this.value}else{pulse=pulse.addAll();lut=this.value={}}pulse.visit(pulse.REM,(t=>{const id=tupleid(t);out.rem.push(lut[id]);lut[id]=null}));pulse.visit(pulse.ADD,(t=>{const dt=derive(t,ingest$1({}));lut[tupleid(t)]=dt;out.add.push(dt)}));pulse.visit(pulse.MOD,(t=>{out.mod.push(derive(t,lut[tupleid(t)]))}));return out}});function project$1(s,t,fields,as){for(let i=0,n=fields.length;i<n;++i){t[as[i]]=fields[i](s)}return t}function Proxy$1(params){Transform.call(this,null,params)}inherits(Proxy$1,Transform,{transform(_,pulse){this.value=_.value;return _.modified("value")?pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS):pulse.StopPropagation}});function Quantile$1(params){Transform.call(this,null,params)}Quantile$1.Definition={type:"Quantile",metadata:{generates:true,changes:true},params:[{name:"groupby",type:"field",array:true},{name:"field",type:"field",required:true},{name:"probs",type:"number",array:true},{name:"step",type:"number",default:.01},{name:"as",type:"string",array:true,default:["prob","value"]}]};const EPSILON$2=1e-14;inherits(Quantile$1,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),as=_.as||["prob","value"];if(this.value&&!_.modified()&&!pulse.changed()){out.source=this.value;return out}const source=pulse.materialize(pulse.SOURCE).source,groups=partition$1$1(source,_.groupby,_.field),names=(_.groupby||[]).map(accessorName),values=[],step=_.step||.01,p=_.probs||range$4(step/2,1-EPSILON$2,step),n=p.length;groups.forEach((g=>{const q=quantiles(g,p);for(let i=0;i<n;++i){const t={};for(let i=0;i<names.length;++i){t[names[i]]=g.dims[i]}t[as[0]]=p[i];t[as[1]]=q[i];values.push(ingest$1(t))}}));if(this.value)out.rem=this.value;this.value=out.add=out.source=values;return out}});function Relay$1(params){Transform.call(this,null,params)}inherits(Relay$1,Transform,{transform(_,pulse){let out,lut;if(this.value){lut=this.value}else{out=pulse=pulse.addAll();lut=this.value={}}if(_.derive){out=pulse.fork(pulse.NO_SOURCE);pulse.visit(pulse.REM,(t=>{const id=tupleid(t);out.rem.push(lut[id]);lut[id]=null}));pulse.visit(pulse.ADD,(t=>{const dt=derive(t);lut[tupleid(t)]=dt;out.add.push(dt)}));pulse.visit(pulse.MOD,(t=>{const dt=lut[tupleid(t)];for(const k in t){dt[k]=t[k];out.modifies(k)}out.mod.push(dt)}))}return out}});function Sample(params){Transform.call(this,[],params);this.count=0}Sample.Definition={type:"Sample",metadata:{},params:[{name:"size",type:"number",default:1e3}]};inherits(Sample,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE),mod=_.modified("size"),num=_.size,map=this.value.reduce(((m,t)=>(m[tupleid(t)]=1,m)),{});let res=this.value,cnt=this.count,cap=0;function update(t){let p,idx;if(res.length<num){res.push(t)}else{idx=~~((cnt+1)*random());if(idx<res.length&&idx>=cap){p=res[idx];if(map[tupleid(p)])out.rem.push(p);res[idx]=t}}++cnt}if(pulse.rem.length){pulse.visit(pulse.REM,(t=>{const id=tupleid(t);if(map[id]){map[id]=-1;out.rem.push(t)}--cnt}));res=res.filter((t=>map[tupleid(t)]!==-1))}if((pulse.rem.length||mod)&&res.length<num&&pulse.source){cap=cnt=res.length;pulse.visit(pulse.SOURCE,(t=>{if(!map[tupleid(t)])update(t)}));cap=-1}if(mod&&res.length>num){const n=res.length-num;for(let i=0;i<n;++i){map[tupleid(res[i])]=-1;out.rem.push(res[i])}res=res.slice(n)}if(pulse.mod.length){pulse.visit(pulse.MOD,(t=>{if(map[tupleid(t)])out.mod.push(t)}))}if(pulse.add.length){pulse.visit(pulse.ADD,update)}if(pulse.add.length||cap<0){out.add=res.filter((t=>!map[tupleid(t)]))}this.count=cnt;this.value=out.source=res;return out}});function Sequence(params){Transform.call(this,null,params)}Sequence.Definition={type:"Sequence",metadata:{generates:true,changes:true},params:[{name:"start",type:"number",required:true},{name:"stop",type:"number",required:true},{name:"step",type:"number",default:1},{name:"as",type:"string",default:"data"}]};inherits(Sequence,Transform,{transform(_,pulse){if(this.value&&!_.modified())return;const out=pulse.materialize().fork(pulse.MOD),as=_.as||"data";out.rem=this.value?pulse.rem.concat(this.value):pulse.rem;this.value=range$4(_.start,_.stop,_.step||1).map((v=>{const t={};t[as]=v;return ingest$1(t)}));out.add=pulse.add.concat(this.value);return out}});function Sieve$1(params){Transform.call(this,null,params);this.modified(true)}inherits(Sieve$1,Transform,{transform(_,pulse){this.value=pulse.source;return pulse.changed()?pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS):pulse.StopPropagation}});function TimeUnit(params){Transform.call(this,null,params)}const OUTPUT=["unit0","unit1"];TimeUnit.Definition={type:"TimeUnit",metadata:{modifies:true},params:[{name:"field",type:"field",required:true},{name:"interval",type:"boolean",default:true},{name:"units",type:"enum",values:TIME_UNITS,array:true},{name:"step",type:"number",default:1},{name:"maxbins",type:"number",default:40},{name:"extent",type:"date",array:true},{name:"timezone",type:"enum",default:"local",values:["local","utc"]},{name:"as",type:"string",array:true,length:2,default:OUTPUT}]};inherits(TimeUnit,Transform,{transform(_,pulse){const field=_.field,band=_.interval!==false,utc=_.timezone==="utc",floor=this._floor(_,pulse),offset=(utc?utcInterval:timeInterval)(floor.unit).offset,as=_.as||OUTPUT,u0=as[0],u1=as[1],step=floor.step;let min=floor.start||Infinity,max=floor.stop||-Infinity,flag=pulse.ADD;if(_.modified()||pulse.changed(pulse.REM)||pulse.modified(accessorFields(field))){pulse=pulse.reflow(true);flag=pulse.SOURCE;min=Infinity;max=-Infinity}pulse.visit(flag,(t=>{const v=field(t);let a,b;if(v==null){t[u0]=null;if(band)t[u1]=null}else{t[u0]=a=b=floor(v);if(band)t[u1]=b=offset(a,step);if(a<min)min=a;if(b>max)max=b}}));floor.start=min;floor.stop=max;return pulse.modifies(band?as:u0)},_floor(_,pulse){const utc=_.timezone==="utc";const{units:units,step:step}=_.units?{units:_.units,step:_.step||1}:bin$1({extent:_.extent||extent(pulse.materialize(pulse.SOURCE).source,_.field),maxbins:_.maxbins});const tunits=timeUnits(units),prev=this.value||{},floor=(utc?utcFloor:timeFloor)(tunits,step);floor.unit=peek$1(tunits);floor.units=tunits;floor.step=step;floor.start=prev.start;floor.stop=prev.stop;return this.value=floor}});function TupleIndex(params){Transform.call(this,fastmap(),params)}inherits(TupleIndex,Transform,{transform(_,pulse){const df=pulse.dataflow,field=_.field,index=this.value,set=t=>index.set(field(t),t);let mod=true;if(_.modified("field")||pulse.modified(field.fields)){index.clear();pulse.visit(pulse.SOURCE,set)}else if(pulse.changed()){pulse.visit(pulse.REM,(t=>index.delete(field(t))));pulse.visit(pulse.ADD,set)}else{mod=false}this.modified(mod);if(index.empty>df.cleanThreshold)df.runAfter(index.clean);return pulse.fork()}});function Values$1(params){Transform.call(this,null,params)}inherits(Values$1,Transform,{transform(_,pulse){const run=!this.value||_.modified("field")||_.modified("sort")||pulse.changed()||_.sort&&pulse.modified(_.sort.fields);if(run){this.value=(_.sort?pulse.source.slice().sort(stableCompare(_.sort)):pulse.source).map(_.field)}}});function WindowOp(op,field,param,as){const fn=WindowOps[op](field,param);return{init:fn.init||zero$4,update:function(w,t){t[as]=fn.next(w)}}}const WindowOps={row_number:function(){return{next:w=>w.index+1}},rank:function(){let rank;return{init:()=>rank=1,next:w=>{const i=w.index,data=w.data;return i&&w.compare(data[i-1],data[i])?rank=i+1:rank}}},dense_rank:function(){let drank;return{init:()=>drank=1,next:w=>{const i=w.index,d=w.data;return i&&w.compare(d[i-1],d[i])?++drank:drank}}},percent_rank:function(){const rank=WindowOps.rank(),next=rank.next;return{init:rank.init,next:w=>(next(w)-1)/(w.data.length-1)}},cume_dist:function(){let cume;return{init:()=>cume=0,next:w=>{const d=w.data,c=w.compare;let i=w.index;if(cume<i){while(i+1<d.length&&!c(d[i],d[i+1]))++i;cume=i}return(1+cume)/d.length}}},ntile:function(field,num){num=+num;if(!(num>0))error("ntile num must be greater than zero.");const cume=WindowOps.cume_dist(),next=cume.next;return{init:cume.init,next:w=>Math.ceil(num*next(w))}},lag:function(field,offset){offset=+offset||1;return{next:w=>{const i=w.index-offset;return i>=0?field(w.data[i]):null}}},lead:function(field,offset){offset=+offset||1;return{next:w=>{const i=w.index+offset,d=w.data;return i<d.length?field(d[i]):null}}},first_value:function(field){return{next:w=>field(w.data[w.i0])}},last_value:function(field){return{next:w=>field(w.data[w.i1-1])}},nth_value:function(field,nth){nth=+nth;if(!(nth>0))error("nth_value nth must be greater than zero.");return{next:w=>{const i=w.i0+(nth-1);return i<w.i1?field(w.data[i]):null}}},prev_value:function(field){let prev;return{init:()=>prev=null,next:w=>{const v=field(w.data[w.index]);return v!=null?prev=v:prev}}},next_value:function(field){let v,i;return{init:()=>(v=null,i=-1),next:w=>{const d=w.data;return w.index<=i?v:(i=find$2(field,d,w.index))<0?(i=d.length,v=null):v=field(d[i])}}}};function find$2(field,data,index){for(let n=data.length;index<n;++index){const v=field(data[index]);if(v!=null)return index}return-1}const ValidWindowOps=Object.keys(WindowOps);function WindowState(_){const ops=array$5(_.ops),fields=array$5(_.fields),params=array$5(_.params),aggregate_params=array$5(_.aggregate_params),as=array$5(_.as),outputs=this.outputs=[],windows=this.windows=[],inputs={},map={},counts=[],measures=[];let countOnly=true;function visitInputs(f){array$5(accessorFields(f)).forEach((_=>inputs[_]=1))}visitInputs(_.sort);ops.forEach(((op,i)=>{const field=fields[i],param=params[i],aggregate_param=aggregate_params[i]||null,mname=accessorName(field),name=measureName(op,mname,as[i]);visitInputs(field);outputs.push(name);if(has$1(WindowOps,op)){windows.push(WindowOp(op,field,param,name))}else{if(field==null&&op!=="count"){error("Null aggregate field specified.")}if(op==="count"){counts.push(name);return}countOnly=false;let m=map[mname];if(!m){m=map[mname]=[];m.field=field;measures.push(m)}m.push(createMeasure(op,aggregate_param,name))}}));if(counts.length||measures.length){this.cell=cell(measures,counts,countOnly)}this.inputs=Object.keys(inputs)}const prototype=WindowState.prototype;prototype.init=function(){this.windows.forEach((_=>_.init()));if(this.cell)this.cell.init()};prototype.update=function(w,t){const cell=this.cell,wind=this.windows,data=w.data,m=wind&&wind.length;let j;if(cell){for(j=w.p0;j<w.i0;++j)cell.rem(data[j]);for(j=w.p1;j<w.i1;++j)cell.add(data[j]);cell.set(t)}for(j=0;j<m;++j)wind[j].update(w,t)};function cell(measures,counts,countOnly){measures=measures.map((m=>compileMeasures(m,m.field)));const cell={num:0,agg:null,store:false,count:counts};if(!countOnly){var n=measures.length,a=cell.agg=Array(n),i=0;for(;i<n;++i)a[i]=new measures[i](cell)}if(cell.store){var store=cell.data=new TupleStore}cell.add=function(t){cell.num+=1;if(countOnly)return;if(store)store.add(t);for(let i=0;i<n;++i){a[i].add(a[i].get(t),t)}};cell.rem=function(t){cell.num-=1;if(countOnly)return;if(store)store.rem(t);for(let i=0;i<n;++i){a[i].rem(a[i].get(t),t)}};cell.set=function(t){let i,n;if(store)store.values();for(i=0,n=counts.length;i<n;++i)t[counts[i]]=cell.num;if(!countOnly)for(i=0,n=a.length;i<n;++i)a[i].set(t)};cell.init=function(){cell.num=0;if(store)store.reset();for(let i=0;i<n;++i)a[i].init()};return cell}function Window(params){Transform.call(this,{},params);this._mlen=0;this._mods=[]}Window.Definition={type:"Window",metadata:{modifies:true},params:[{name:"sort",type:"compare"},{name:"groupby",type:"field",array:true},{name:"ops",type:"enum",array:true,values:ValidWindowOps.concat(ValidAggregateOps)},{name:"params",type:"number",null:true,array:true},{name:"aggregate_params",type:"number",null:true,array:true},{name:"fields",type:"field",null:true,array:true},{name:"as",type:"string",null:true,array:true},{name:"frame",type:"number",null:true,array:true,length:2,default:[null,0]},{name:"ignorePeers",type:"boolean",default:false}]};inherits(Window,Transform,{transform(_,pulse){this.stamp=pulse.stamp;const mod=_.modified(),cmp=stableCompare(_.sort),key=groupkey(_.groupby),group=t=>this.group(key(t));let state=this.state;if(!state||mod){state=this.state=new WindowState(_)}if(mod||pulse.modified(state.inputs)){this.value={};pulse.visit(pulse.SOURCE,(t=>group(t).add(t)))}else{pulse.visit(pulse.REM,(t=>group(t).remove(t)));pulse.visit(pulse.ADD,(t=>group(t).add(t)))}for(let i=0,n=this._mlen;i<n;++i){processPartition(this._mods[i],state,cmp,_)}this._mlen=0;this._mods=[];return pulse.reflow(mod).modifies(state.outputs)},group(key){let group=this.value[key];if(!group){group=this.value[key]=SortedList(tupleid);group.stamp=-1}if(group.stamp<this.stamp){group.stamp=this.stamp;this._mods[this._mlen++]=group}return group}});function processPartition(list,state,cmp,_){const sort=_.sort,range=sort&&!_.ignorePeers,frame=_.frame||[null,0],data=list.data(cmp),n=data.length,b=range?bisector(sort):null,w={i0:0,i1:0,p0:0,p1:0,index:0,data:data,compare:sort||constant$5(-1)};state.init();for(let i=0;i<n;++i){setWindow(w,frame,i,n);if(range)adjustRange(w,b);state.update(w,data[i])}}function setWindow(w,f,i,n){w.p0=w.i0;w.p1=w.i1;w.i0=f[0]==null?0:Math.max(0,i-Math.abs(f[0]));w.i1=f[1]==null?n:Math.min(n,i+Math.abs(f[1])+1);w.index=i}function adjustRange(w,bisect){const r0=w.i0,r1=w.i1-1,c=w.compare,d=w.data,n=d.length-1;if(r0>0&&!c(d[r0],d[r0-1]))w.i0=bisect.left(d,d[r0]);if(r1<n&&!c(d[r1],d[r1+1]))w.i1=bisect.right(d,d[r1])}var tx=Object.freeze({__proto__:null,aggregate:Aggregate$1,bin:Bin,collect:Collect$1,compare:Compare$1,countpattern:CountPattern,cross:Cross,density:Density,dotbin:DotBin,expression:Expression$1,extent:Extent,facet:Facet$1,field:Field$1,filter:Filter,flatten:Flatten,fold:Fold,formula:Formula,generate:Generate,impute:Impute,joinaggregate:JoinAggregate,kde:KDE,key:Key$1,load:Load$1,lookup:Lookup,multiextent:MultiExtent$1,multivalues:MultiValues$1,params:Params$2,pivot:Pivot,prefacet:PreFacet$1,project:Project,proxy:Proxy$1,quantile:Quantile$1,relay:Relay$1,sample:Sample,sequence:Sequence,sieve:Sieve$1,subflow:Subflow,timeunit:TimeUnit,tupleindex:TupleIndex,values:Values$1,window:Window});function constant$3(x){return function constant(){return x}}const abs$2=Math.abs;const atan2$1=Math.atan2;const cos$2=Math.cos;const max$1=Math.max;const min$1=Math.min;const sin$2=Math.sin;const sqrt$3=Math.sqrt;const epsilon$5=1e-12;const pi$3=Math.PI;const halfPi$2=pi$3/2;const tau$3=2*pi$3;function acos$1(x){return x>1?0:x<-1?pi$3:Math.acos(x)}function asin$2(x){return x>=1?halfPi$2:x<=-1?-halfPi$2:Math.asin(x)}const pi$2=Math.PI,tau$2=2*pi$2,epsilon$4=1e-6,tauEpsilon=tau$2-epsilon$4;function append$1(strings){this._+=strings[0];for(let i=1,n=strings.length;i<n;++i){this._+=arguments[i]+strings[i]}}function appendRound$1(digits){let d=Math.floor(digits);if(!(d>=0))throw new Error(`invalid digits: ${digits}`);if(d>15)return append$1;const k=10**d;return function(strings){this._+=strings[0];for(let i=1,n=strings.length;i<n;++i){this._+=Math.round(arguments[i]*k)/k+strings[i]}}}let Path$1=class Path{constructor(digits){this._x0=this._y0=this._x1=this._y1=null;this._="";this._append=digits==null?append$1:appendRound$1(digits)}moveTo(x,y){this._append`M${this._x0=this._x1=+x},${this._y0=this._y1=+y}`}closePath(){if(this._x1!==null){this._x1=this._x0,this._y1=this._y0;this._append`Z`}}lineTo(x,y){this._append`L${this._x1=+x},${this._y1=+y}`}quadraticCurveTo(x1,y1,x,y){this._append`Q${+x1},${+y1},${this._x1=+x},${this._y1=+y}`}bezierCurveTo(x1,y1,x2,y2,x,y){this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1=+x},${this._y1=+y}`}arcTo(x1,y1,x2,y2,r){x1=+x1,y1=+y1,x2=+x2,y2=+y2,r=+r;if(r<0)throw new Error(`negative radius: ${r}`);let x0=this._x1,y0=this._y1,x21=x2-x1,y21=y2-y1,x01=x0-x1,y01=y0-y1,l01_2=x01*x01+y01*y01;if(this._x1===null){this._append`M${this._x1=x1},${this._y1=y1}`}else if(!(l01_2>epsilon$4));else if(!(Math.abs(y01*x21-y21*x01)>epsilon$4)||!r){this._append`L${this._x1=x1},${this._y1=y1}`}else{let x20=x2-x0,y20=y2-y0,l21_2=x21*x21+y21*y21,l20_2=x20*x20+y20*y20,l21=Math.sqrt(l21_2),l01=Math.sqrt(l01_2),l=r*Math.tan((pi$2-Math.acos((l21_2+l01_2-l20_2)/(2*l21*l01)))/2),t01=l/l01,t21=l/l21;if(Math.abs(t01-1)>epsilon$4){this._append`L${x1+t01*x01},${y1+t01*y01}`}this._append`A${r},${r},0,0,${+(y01*x20>x01*y20)},${this._x1=x1+t21*x21},${this._y1=y1+t21*y21}`}}arc(x,y,r,a0,a1,ccw){x=+x,y=+y,r=+r,ccw=!!ccw;if(r<0)throw new Error(`negative radius: ${r}`);let dx=r*Math.cos(a0),dy=r*Math.sin(a0),x0=x+dx,y0=y+dy,cw=1^ccw,da=ccw?a0-a1:a1-a0;if(this._x1===null){this._append`M${x0},${y0}`}else if(Math.abs(this._x1-x0)>epsilon$4||Math.abs(this._y1-y0)>epsilon$4){this._append`L${x0},${y0}`}if(!r)return;if(da<0)da=da%tau$2+tau$2;if(da>tauEpsilon){this._append`A${r},${r},0,1,${cw},${x-dx},${y-dy}A${r},${r},0,1,${cw},${this._x1=x0},${this._y1=y0}`}else if(da>epsilon$4){this._append`A${r},${r},0,${+(da>=pi$2)},${cw},${this._x1=x+r*Math.cos(a1)},${this._y1=y+r*Math.sin(a1)}`}}rect(x,y,w,h){this._append`M${this._x0=this._x1=+x},${this._y0=this._y1=+y}h${w=+w}v${+h}h${-w}Z`}toString(){return this._}};function path$3(){return new Path$1}path$3.prototype=Path$1.prototype;function withPath(shape){let digits=3;shape.digits=function(_){if(!arguments.length)return digits;if(_==null){digits=null}else{const d=Math.floor(_);if(!(d>=0))throw new RangeError(`invalid digits: ${_}`);digits=d}return shape};return()=>new Path$1(digits)}function arcInnerRadius(d){return d.innerRadius}function arcOuterRadius(d){return d.outerRadius}function arcStartAngle(d){return d.startAngle}function arcEndAngle(d){return d.endAngle}function arcPadAngle(d){return d&&d.padAngle}function intersect$3(x0,y0,x1,y1,x2,y2,x3,y3){var x10=x1-x0,y10=y1-y0,x32=x3-x2,y32=y3-y2,t=y32*x10-x32*y10;if(t*t<epsilon$5)return;t=(x32*(y0-y2)-y32*(x0-x2))/t;return[x0+t*x10,y0+t*y10]}function cornerTangents(x0,y0,x1,y1,r1,rc,cw){var x01=x0-x1,y01=y0-y1,lo=(cw?rc:-rc)/sqrt$3(x01*x01+y01*y01),ox=lo*y01,oy=-lo*x01,x11=x0+ox,y11=y0+oy,x10=x1+ox,y10=y1+oy,x00=(x11+x10)/2,y00=(y11+y10)/2,dx=x10-x11,dy=y10-y11,d2=dx*dx+dy*dy,r=r1-rc,D=x11*y10-x10*y11,d=(dy<0?-1:1)*sqrt$3(max$1(0,r*r*d2-D*D)),cx0=(D*dy-dx*d)/d2,cy0=(-D*dx-dy*d)/d2,cx1=(D*dy+dx*d)/d2,cy1=(-D*dx+dy*d)/d2,dx0=cx0-x00,dy0=cy0-y00,dx1=cx1-x00,dy1=cy1-y00;if(dx0*dx0+dy0*dy0>dx1*dx1+dy1*dy1)cx0=cx1,cy0=cy1;return{cx:cx0,cy:cy0,x01:-ox,y01:-oy,x11:cx0*(r1/r-1),y11:cy0*(r1/r-1)}}function arc$2$1(){var innerRadius=arcInnerRadius,outerRadius=arcOuterRadius,cornerRadius=constant$3(0),padRadius=null,startAngle=arcStartAngle,endAngle=arcEndAngle,padAngle=arcPadAngle,context=null,path=withPath(arc);function arc(){var buffer,r,r0=+innerRadius.apply(this,arguments),r1=+outerRadius.apply(this,arguments),a0=startAngle.apply(this,arguments)-halfPi$2,a1=endAngle.apply(this,arguments)-halfPi$2,da=abs$2(a1-a0),cw=a1>a0;if(!context)context=buffer=path();if(r1<r0)r=r1,r1=r0,r0=r;if(!(r1>epsilon$5))context.moveTo(0,0);else if(da>tau$3-epsilon$5){context.moveTo(r1*cos$2(a0),r1*sin$2(a0));context.arc(0,0,r1,a0,a1,!cw);if(r0>epsilon$5){context.moveTo(r0*cos$2(a1),r0*sin$2(a1));context.arc(0,0,r0,a1,a0,cw)}}else{var a01=a0,a11=a1,a00=a0,a10=a1,da0=da,da1=da,ap=padAngle.apply(this,arguments)/2,rp=ap>epsilon$5&&(padRadius?+padRadius.apply(this,arguments):sqrt$3(r0*r0+r1*r1)),rc=min$1(abs$2(r1-r0)/2,+cornerRadius.apply(this,arguments)),rc0=rc,rc1=rc,t0,t1;if(rp>epsilon$5){var p0=asin$2(rp/r0*sin$2(ap)),p1=asin$2(rp/r1*sin$2(ap));if((da0-=p0*2)>epsilon$5)p0*=cw?1:-1,a00+=p0,a10-=p0;else da0=0,a00=a10=(a0+a1)/2;if((da1-=p1*2)>epsilon$5)p1*=cw?1:-1,a01+=p1,a11-=p1;else da1=0,a01=a11=(a0+a1)/2}var x01=r1*cos$2(a01),y01=r1*sin$2(a01),x10=r0*cos$2(a10),y10=r0*sin$2(a10);if(rc>epsilon$5){var x11=r1*cos$2(a11),y11=r1*sin$2(a11),x00=r0*cos$2(a00),y00=r0*sin$2(a00),oc;if(da<pi$3){if(oc=intersect$3(x01,y01,x00,y00,x11,y11,x10,y10)){var ax=x01-oc[0],ay=y01-oc[1],bx=x11-oc[0],by=y11-oc[1],kc=1/sin$2(acos$1((ax*bx+ay*by)/(sqrt$3(ax*ax+ay*ay)*sqrt$3(bx*bx+by*by)))/2),lc=sqrt$3(oc[0]*oc[0]+oc[1]*oc[1]);rc0=min$1(rc,(r0-lc)/(kc-1));rc1=min$1(rc,(r1-lc)/(kc+1))}else{rc0=rc1=0}}}if(!(da1>epsilon$5))context.moveTo(x01,y01);else if(rc1>epsilon$5){t0=cornerTangents(x00,y00,x01,y01,r1,rc1,cw);t1=cornerTangents(x11,y11,x10,y10,r1,rc1,cw);context.moveTo(t0.cx+t0.x01,t0.cy+t0.y01);if(rc1<rc)context.arc(t0.cx,t0.cy,rc1,atan2$1(t0.y01,t0.x01),atan2$1(t1.y01,t1.x01),!cw);else{context.arc(t0.cx,t0.cy,rc1,atan2$1(t0.y01,t0.x01),atan2$1(t0.y11,t0.x11),!cw);context.arc(0,0,r1,atan2$1(t0.cy+t0.y11,t0.cx+t0.x11),atan2$1(t1.cy+t1.y11,t1.cx+t1.x11),!cw);context.arc(t1.cx,t1.cy,rc1,atan2$1(t1.y11,t1.x11),atan2$1(t1.y01,t1.x01),!cw)}}else context.moveTo(x01,y01),context.arc(0,0,r1,a01,a11,!cw);if(!(r0>epsilon$5)||!(da0>epsilon$5))context.lineTo(x10,y10);else if(rc0>epsilon$5){t0=cornerTangents(x10,y10,x11,y11,r0,-rc0,cw);t1=cornerTangents(x01,y01,x00,y00,r0,-rc0,cw);context.lineTo(t0.cx+t0.x01,t0.cy+t0.y01);if(rc0<rc)context.arc(t0.cx,t0.cy,rc0,atan2$1(t0.y01,t0.x01),atan2$1(t1.y01,t1.x01),!cw);else{context.arc(t0.cx,t0.cy,rc0,atan2$1(t0.y01,t0.x01),atan2$1(t0.y11,t0.x11),!cw);context.arc(0,0,r0,atan2$1(t0.cy+t0.y11,t0.cx+t0.x11),atan2$1(t1.cy+t1.y11,t1.cx+t1.x11),cw);context.arc(t1.cx,t1.cy,rc0,atan2$1(t1.y11,t1.x11),atan2$1(t1.y01,t1.x01),!cw)}}else context.arc(0,0,r0,a10,a00,cw)}context.closePath();if(buffer)return context=null,buffer+""||null}arc.centroid=function(){var r=(+innerRadius.apply(this,arguments)+ +outerRadius.apply(this,arguments))/2,a=(+startAngle.apply(this,arguments)+ +endAngle.apply(this,arguments))/2-pi$3/2;return[cos$2(a)*r,sin$2(a)*r]};arc.innerRadius=function(_){return arguments.length?(innerRadius=typeof _==="function"?_:constant$3(+_),arc):innerRadius};arc.outerRadius=function(_){return arguments.length?(outerRadius=typeof _==="function"?_:constant$3(+_),arc):outerRadius};arc.cornerRadius=function(_){return arguments.length?(cornerRadius=typeof _==="function"?_:constant$3(+_),arc):cornerRadius};arc.padRadius=function(_){return arguments.length?(padRadius=_==null?null:typeof _==="function"?_:constant$3(+_),arc):padRadius};arc.startAngle=function(_){return arguments.length?(startAngle=typeof _==="function"?_:constant$3(+_),arc):startAngle};arc.endAngle=function(_){return arguments.length?(endAngle=typeof _==="function"?_:constant$3(+_),arc):endAngle};arc.padAngle=function(_){return arguments.length?(padAngle=typeof _==="function"?_:constant$3(+_),arc):padAngle};arc.context=function(_){return arguments.length?(context=_==null?null:_,arc):context};return arc}function array$4(x){return typeof x==="object"&&"length"in x?x:Array.from(x)}function Linear$1(context){this._context=context}Linear$1.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;default:this._context.lineTo(x,y);break}}};function curveLinear(context){return new Linear$1(context)}function x$3(p){return p[0]}function y$3(p){return p[1]}function line$2$1(x,y){var defined=constant$3(true),context=null,curve=curveLinear,output=null,path=withPath(line);x=typeof x==="function"?x:x===undefined?x$3:constant$3(x);y=typeof y==="function"?y:y===undefined?y$3:constant$3(y);function line(data){var i,n=(data=array$4(data)).length,d,defined0=false,buffer;if(context==null)output=curve(buffer=path());for(i=0;i<=n;++i){if(!(i<n&&defined(d=data[i],i,data))===defined0){if(defined0=!defined0)output.lineStart();else output.lineEnd()}if(defined0)output.point(+x(d,i,data),+y(d,i,data))}if(buffer)return output=null,buffer+""||null}line.x=function(_){return arguments.length?(x=typeof _==="function"?_:constant$3(+_),line):x};line.y=function(_){return arguments.length?(y=typeof _==="function"?_:constant$3(+_),line):y};line.defined=function(_){return arguments.length?(defined=typeof _==="function"?_:constant$3(!!_),line):defined};line.curve=function(_){return arguments.length?(curve=_,context!=null&&(output=curve(context)),line):curve};line.context=function(_){return arguments.length?(_==null?context=output=null:output=curve(context=_),line):context};return line}function area$2$1(x0,y0,y1){var x1=null,defined=constant$3(true),context=null,curve=curveLinear,output=null,path=withPath(area);x0=typeof x0==="function"?x0:x0===undefined?x$3:constant$3(+x0);y0=typeof y0==="function"?y0:y0===undefined?constant$3(0):constant$3(+y0);y1=typeof y1==="function"?y1:y1===undefined?y$3:constant$3(+y1);function area(data){var i,j,k,n=(data=array$4(data)).length,d,defined0=false,buffer,x0z=new Array(n),y0z=new Array(n);if(context==null)output=curve(buffer=path());for(i=0;i<=n;++i){if(!(i<n&&defined(d=data[i],i,data))===defined0){if(defined0=!defined0){j=i;output.areaStart();output.lineStart()}else{output.lineEnd();output.lineStart();for(k=i-1;k>=j;--k){output.point(x0z[k],y0z[k])}output.lineEnd();output.areaEnd()}}if(defined0){x0z[i]=+x0(d,i,data),y0z[i]=+y0(d,i,data);output.point(x1?+x1(d,i,data):x0z[i],y1?+y1(d,i,data):y0z[i])}}if(buffer)return output=null,buffer+""||null}function arealine(){return line$2$1().defined(defined).curve(curve).context(context)}area.x=function(_){return arguments.length?(x0=typeof _==="function"?_:constant$3(+_),x1=null,area):x0};area.x0=function(_){return arguments.length?(x0=typeof _==="function"?_:constant$3(+_),area):x0};area.x1=function(_){return arguments.length?(x1=_==null?null:typeof _==="function"?_:constant$3(+_),area):x1};area.y=function(_){return arguments.length?(y0=typeof _==="function"?_:constant$3(+_),y1=null,area):y0};area.y0=function(_){return arguments.length?(y0=typeof _==="function"?_:constant$3(+_),area):y0};area.y1=function(_){return arguments.length?(y1=_==null?null:typeof _==="function"?_:constant$3(+_),area):y1};area.lineX0=area.lineY0=function(){return arealine().x(x0).y(y0)};area.lineY1=function(){return arealine().x(x0).y(y1)};area.lineX1=function(){return arealine().x(x1).y(y0)};area.defined=function(_){return arguments.length?(defined=typeof _==="function"?_:constant$3(!!_),area):defined};area.curve=function(_){return arguments.length?(curve=_,context!=null&&(output=curve(context)),area):curve};area.context=function(_){return arguments.length?(_==null?context=output=null:output=curve(context=_),area):context};return area}var circle$1={draw(context,size){const r=sqrt$3(size/pi$3);context.moveTo(r,0);context.arc(0,0,r,0,tau$3)}};function Symbol$1(type,size){let context=null,path=withPath(symbol);type=typeof type==="function"?type:constant$3(type||circle$1);size=typeof size==="function"?size:constant$3(size===undefined?64:+size);function symbol(){let buffer;if(!context)context=buffer=path();type.apply(this,arguments).draw(context,+size.apply(this,arguments));if(buffer)return context=null,buffer+""||null}symbol.type=function(_){return arguments.length?(type=typeof _==="function"?_:constant$3(_),symbol):type};symbol.size=function(_){return arguments.length?(size=typeof _==="function"?_:constant$3(+_),symbol):size};symbol.context=function(_){return arguments.length?(context=_==null?null:_,symbol):context};return symbol}function noop$3(){}function point$7(that,x,y){that._context.bezierCurveTo((2*that._x0+that._x1)/3,(2*that._y0+that._y1)/3,(that._x0+2*that._x1)/3,(that._y0+2*that._y1)/3,(that._x0+4*that._x1+x)/6,(that._y0+4*that._y1+y)/6)}function Basis(context){this._context=context}Basis.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN;this._point=0},lineEnd:function(){switch(this._point){case 3:point$7(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1);break}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:point$7(this,x,y);break}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y}};function curveBasis(context){return new Basis(context)}function BasisClosed(context){this._context=context}BasisClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN;this._point=0},lineEnd:function(){switch(this._point){case 1:{this._context.moveTo(this._x2,this._y2);this._context.closePath();break}case 2:{this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3);this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3);this._context.closePath();break}case 3:{this.point(this._x2,this._y2);this.point(this._x3,this._y3);this.point(this._x4,this._y4);break}}},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._x2=x,this._y2=y;break;case 1:this._point=2;this._x3=x,this._y3=y;break;case 2:this._point=3;this._x4=x,this._y4=y;this._context.moveTo((this._x0+4*this._x1+x)/6,(this._y0+4*this._y1+y)/6);break;default:point$7(this,x,y);break}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y}};function curveBasisClosed(context){return new BasisClosed(context)}function BasisOpen(context){this._context=context}BasisOpen.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN;this._point=0},lineEnd:function(){if(this._line||this._line!==0&&this._point===3)this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var x0=(this._x0+4*this._x1+x)/6,y0=(this._y0+4*this._y1+y)/6;this._line?this._context.lineTo(x0,y0):this._context.moveTo(x0,y0);break;case 3:this._point=4;default:point$7(this,x,y);break}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y}};function curveBasisOpen(context){return new BasisOpen(context)}function Bundle(context,beta){this._basis=new Basis(context);this._beta=beta}Bundle.prototype={lineStart:function(){this._x=[];this._y=[];this._basis.lineStart()},lineEnd:function(){var x=this._x,y=this._y,j=x.length-1;if(j>0){var x0=x[0],y0=y[0],dx=x[j]-x0,dy=y[j]-y0,i=-1,t;while(++i<=j){t=i/j;this._basis.point(this._beta*x[i]+(1-this._beta)*(x0+t*dx),this._beta*y[i]+(1-this._beta)*(y0+t*dy))}}this._x=this._y=null;this._basis.lineEnd()},point:function(x,y){this._x.push(+x);this._y.push(+y)}};var curveBundle=function custom(beta){function bundle(context){return beta===1?new Basis(context):new Bundle(context,beta)}bundle.beta=function(beta){return custom(+beta)};return bundle}(.85);function point$6(that,x,y){that._context.bezierCurveTo(that._x1+that._k*(that._x2-that._x0),that._y1+that._k*(that._y2-that._y0),that._x2+that._k*(that._x1-x),that._y2+that._k*(that._y1-y),that._x2,that._y2)}function Cardinal(context,tension){this._context=context;this._k=(1-tension)/6}Cardinal.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:point$6(this,this._x1,this._y1);break}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;this._x1=x,this._y1=y;break;case 2:this._point=3;default:point$6(this,x,y);break}this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y}};var curveCardinal=function custom(tension){function cardinal(context){return new Cardinal(context,tension)}cardinal.tension=function(tension){return custom(+tension)};return cardinal}(0);function CardinalClosed(context,tension){this._context=context;this._k=(1-tension)/6}CardinalClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN;this._point=0},lineEnd:function(){switch(this._point){case 1:{this._context.moveTo(this._x3,this._y3);this._context.closePath();break}case 2:{this._context.lineTo(this._x3,this._y3);this._context.closePath();break}case 3:{this.point(this._x3,this._y3);this.point(this._x4,this._y4);this.point(this._x5,this._y5);break}}},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._x3=x,this._y3=y;break;case 1:this._point=2;this._context.moveTo(this._x4=x,this._y4=y);break;case 2:this._point=3;this._x5=x,this._y5=y;break;default:point$6(this,x,y);break}this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y}};var curveCardinalClosed=function custom(tension){function cardinal(context){return new CardinalClosed(context,tension)}cardinal.tension=function(tension){return custom(+tension)};return cardinal}(0);function CardinalOpen(context,tension){this._context=context;this._k=(1-tension)/6}CardinalOpen.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._point=0},lineEnd:function(){if(this._line||this._line!==0&&this._point===3)this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:point$6(this,x,y);break}this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y}};var curveCardinalOpen=function custom(tension){function cardinal(context){return new CardinalOpen(context,tension)}cardinal.tension=function(tension){return custom(+tension)};return cardinal}(0);function point$5(that,x,y){var x1=that._x1,y1=that._y1,x2=that._x2,y2=that._y2;if(that._l01_a>epsilon$5){var a=2*that._l01_2a+3*that._l01_a*that._l12_a+that._l12_2a,n=3*that._l01_a*(that._l01_a+that._l12_a);x1=(x1*a-that._x0*that._l12_2a+that._x2*that._l01_2a)/n;y1=(y1*a-that._y0*that._l12_2a+that._y2*that._l01_2a)/n}if(that._l23_a>epsilon$5){var b=2*that._l23_2a+3*that._l23_a*that._l12_a+that._l12_2a,m=3*that._l23_a*(that._l23_a+that._l12_a);x2=(x2*b+that._x1*that._l23_2a-x*that._l12_2a)/m;y2=(y2*b+that._y1*that._l23_2a-y*that._l12_2a)/m}that._context.bezierCurveTo(x1,y1,x2,y2,that._x2,that._y2)}function CatmullRom(context,alpha){this._context=context;this._alpha=alpha}CatmullRom.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2);break}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x,y=+y;if(this._point){var x23=this._x2-x,y23=this._y2-y;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(x23*x23+y23*y23,this._alpha))}switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;default:point$5(this,x,y);break}this._l01_a=this._l12_a,this._l12_a=this._l23_a;this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a;this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y}};var curveCatmullRom=function custom(alpha){function catmullRom(context){return alpha?new CatmullRom(context,alpha):new Cardinal(context,0)}catmullRom.alpha=function(alpha){return custom(+alpha)};return catmullRom}(.5);function CatmullRomClosed(context,alpha){this._context=context;this._alpha=alpha}CatmullRomClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 1:{this._context.moveTo(this._x3,this._y3);this._context.closePath();break}case 2:{this._context.lineTo(this._x3,this._y3);this._context.closePath();break}case 3:{this.point(this._x3,this._y3);this.point(this._x4,this._y4);this.point(this._x5,this._y5);break}}},point:function(x,y){x=+x,y=+y;if(this._point){var x23=this._x2-x,y23=this._y2-y;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(x23*x23+y23*y23,this._alpha))}switch(this._point){case 0:this._point=1;this._x3=x,this._y3=y;break;case 1:this._point=2;this._context.moveTo(this._x4=x,this._y4=y);break;case 2:this._point=3;this._x5=x,this._y5=y;break;default:point$5(this,x,y);break}this._l01_a=this._l12_a,this._l12_a=this._l23_a;this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a;this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y}};var curveCatmullRomClosed=function custom(alpha){function catmullRom(context){return alpha?new CatmullRomClosed(context,alpha):new CardinalClosed(context,0)}catmullRom.alpha=function(alpha){return custom(+alpha)};return catmullRom}(.5);function CatmullRomOpen(context,alpha){this._context=context;this._alpha=alpha}CatmullRomOpen.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN;this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){if(this._line||this._line!==0&&this._point===3)this._context.closePath();this._line=1-this._line},point:function(x,y){x=+x,y=+y;if(this._point){var x23=this._x2-x,y23=this._y2-y;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(x23*x23+y23*y23,this._alpha))}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:point$5(this,x,y);break}this._l01_a=this._l12_a,this._l12_a=this._l23_a;this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a;this._x0=this._x1,this._x1=this._x2,this._x2=x;this._y0=this._y1,this._y1=this._y2,this._y2=y}};var curveCatmullRomOpen=function custom(alpha){function catmullRom(context){return alpha?new CatmullRomOpen(context,alpha):new CardinalOpen(context,0)}catmullRom.alpha=function(alpha){return custom(+alpha)};return catmullRom}(.5);function LinearClosed(context){this._context=context}LinearClosed.prototype={areaStart:noop$3,areaEnd:noop$3,lineStart:function(){this._point=0},lineEnd:function(){if(this._point)this._context.closePath()},point:function(x,y){x=+x,y=+y;if(this._point)this._context.lineTo(x,y);else this._point=1,this._context.moveTo(x,y)}};function curveLinearClosed(context){return new LinearClosed(context)}function sign$1(x){return x<0?-1:1}function slope3(that,x2,y2){var h0=that._x1-that._x0,h1=x2-that._x1,s0=(that._y1-that._y0)/(h0||h1<0&&-0),s1=(y2-that._y1)/(h1||h0<0&&-0),p=(s0*h1+s1*h0)/(h0+h1);return(sign$1(s0)+sign$1(s1))*Math.min(Math.abs(s0),Math.abs(s1),.5*Math.abs(p))||0}function slope2(that,t){var h=that._x1-that._x0;return h?(3*(that._y1-that._y0)/h-t)/2:t}function point$4(that,t0,t1){var x0=that._x0,y0=that._y0,x1=that._x1,y1=that._y1,dx=(x1-x0)/3;that._context.bezierCurveTo(x0+dx,y0+dx*t0,x1-dx,y1-dx*t1,x1,y1)}function MonotoneX(context){this._context=context}MonotoneX.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN;this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:point$4(this,this._t0,slope2(this,this._t0));break}if(this._line||this._line!==0&&this._point===1)this._context.closePath();this._line=1-this._line},point:function(x,y){var t1=NaN;x=+x,y=+y;if(x===this._x1&&y===this._y1)return;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;break;case 2:this._point=3;point$4(this,slope2(this,t1=slope3(this,x,y)),t1);break;default:point$4(this,this._t0,t1=slope3(this,x,y));break}this._x0=this._x1,this._x1=x;this._y0=this._y1,this._y1=y;this._t0=t1}};function MonotoneY(context){this._context=new ReflectContext(context)}(MonotoneY.prototype=Object.create(MonotoneX.prototype)).point=function(x,y){MonotoneX.prototype.point.call(this,y,x)};function ReflectContext(context){this._context=context}ReflectContext.prototype={moveTo:function(x,y){this._context.moveTo(y,x)},closePath:function(){this._context.closePath()},lineTo:function(x,y){this._context.lineTo(y,x)},bezierCurveTo:function(x1,y1,x2,y2,x,y){this._context.bezierCurveTo(y1,x1,y2,x2,y,x)}};function monotoneX(context){return new MonotoneX(context)}function monotoneY(context){return new MonotoneY(context)}function Natural(context){this._context=context}Natural.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=[];this._y=[]},lineEnd:function(){var x=this._x,y=this._y,n=x.length;if(n){this._line?this._context.lineTo(x[0],y[0]):this._context.moveTo(x[0],y[0]);if(n===2){this._context.lineTo(x[1],y[1])}else{var px=controlPoints(x),py=controlPoints(y);for(var i0=0,i1=1;i1<n;++i0,++i1){this._context.bezierCurveTo(px[0][i0],py[0][i0],px[1][i0],py[1][i0],x[i1],y[i1])}}}if(this._line||this._line!==0&&n===1)this._context.closePath();this._line=1-this._line;this._x=this._y=null},point:function(x,y){this._x.push(+x);this._y.push(+y)}};function controlPoints(x){var i,n=x.length-1,m,a=new Array(n),b=new Array(n),r=new Array(n);a[0]=0,b[0]=2,r[0]=x[0]+2*x[1];for(i=1;i<n-1;++i)a[i]=1,b[i]=4,r[i]=4*x[i]+2*x[i+1];a[n-1]=2,b[n-1]=7,r[n-1]=8*x[n-1]+x[n];for(i=1;i<n;++i)m=a[i]/b[i-1],b[i]-=m,r[i]-=m*r[i-1];a[n-1]=r[n-1]/b[n-1];for(i=n-2;i>=0;--i)a[i]=(r[i]-a[i+1])/b[i];b[n-1]=(x[n]+a[n-1])/2;for(i=0;i<n-1;++i)b[i]=2*x[i+1]-a[i+1];return[a,b]}function curveNatural(context){return new Natural(context)}function Step(context,t){this._context=context;this._t=t}Step.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=this._y=NaN;this._point=0},lineEnd:function(){if(0<this._t&&this._t<1&&this._point===2)this._context.lineTo(this._x,this._y);if(this._line||this._line!==0&&this._point===1)this._context.closePath();if(this._line>=0)this._t=1-this._t,this._line=1-this._line},point:function(x,y){x=+x,y=+y;switch(this._point){case 0:this._point=1;this._line?this._context.lineTo(x,y):this._context.moveTo(x,y);break;case 1:this._point=2;default:{if(this._t<=0){this._context.lineTo(this._x,y);this._context.lineTo(x,y)}else{var x1=this._x*(1-this._t)+x*this._t;this._context.lineTo(x1,this._y);this._context.lineTo(x1,y)}break}}this._x=x,this._y=y}};function curveStep(context){return new Step(context,.5)}function stepBefore(context){return new Step(context,0)}function stepAfter(context){return new Step(context,1)}function domCanvas(w,h){if(typeof document!=="undefined"&&document.createElement){const c=document.createElement("canvas");if(c&&c.getContext){c.width=w;c.height=h;return c}}return null}const domImage=()=>typeof Image!=="undefined"?Image:null;let NodeCanvas;try{NodeCanvas=require("canvas");if(!(NodeCanvas&&NodeCanvas.createCanvas)){NodeCanvas=null}}catch(error){}function nodeCanvas(w,h,type){if(NodeCanvas){try{return new NodeCanvas.Canvas(w,h,type)}catch(e){}}return null}const nodeImage=()=>NodeCanvas&&NodeCanvas.Image||null;function canvas(w,h,type){return domCanvas(w,h)||nodeCanvas(w,h,type)||null}function image$2(){return domImage()||nodeImage()||null}function initRange(domain,range){switch(arguments.length){case 0:break;case 1:this.range(domain);break;default:this.range(range).domain(domain);break}return this}function initInterpolator(domain,interpolator){switch(arguments.length){case 0:break;case 1:{if(typeof domain==="function")this.interpolator(domain);else this.range(domain);break}default:{this.domain(domain);if(typeof interpolator==="function")this.interpolator(interpolator);else this.range(interpolator);break}}return this}const implicit=Symbol("implicit");function ordinal(){var index=new InternMap,domain=[],range=[],unknown=implicit;function scale(d){let i=index.get(d);if(i===undefined){if(unknown!==implicit)return unknown;index.set(d,i=domain.push(d)-1)}return range[i%range.length]}scale.domain=function(_){if(!arguments.length)return domain.slice();domain=[],index=new InternMap;for(const value of _){if(index.has(value))continue;index.set(value,domain.push(value)-1)}return scale};scale.range=function(_){return arguments.length?(range=Array.from(_),scale):range.slice()};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown};scale.copy=function(){return ordinal(domain,range).unknown(unknown)};initRange.apply(scale,arguments);return scale}function define(constructor,factory,prototype){constructor.prototype=factory.prototype=prototype;prototype.constructor=constructor}function extend(parent,definition){var prototype=Object.create(parent.prototype);for(var key in definition)prototype[key]=definition[key];return prototype}function Color(){}var darker=.7;var brighter=1/darker;var reI="\\s*([+-]?\\d+)\\s*",reN="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",reP="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",reHex=/^#([0-9a-f]{3,8})$/,reRgbInteger=new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),reRgbPercent=new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),reRgbaInteger=new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),reRgbaPercent=new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),reHslPercent=new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),reHslaPercent=new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);var named={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};define(Color,color$3,{copy(channels){return Object.assign(new this.constructor,this,channels)},displayable(){return this.rgb().displayable()},hex:color_formatHex,formatHex:color_formatHex,formatHex8:color_formatHex8,formatHsl:color_formatHsl,formatRgb:color_formatRgb,toString:color_formatRgb});function color_formatHex(){return this.rgb().formatHex()}function color_formatHex8(){return this.rgb().formatHex8()}function color_formatHsl(){return hslConvert(this).formatHsl()}function color_formatRgb(){return this.rgb().formatRgb()}function color$3(format){var m,l;format=(format+"").trim().toLowerCase();return(m=reHex.exec(format))?(l=m[1].length,m=parseInt(m[1],16),l===6?rgbn(m):l===3?new Rgb(m>>8&15|m>>4&240,m>>4&15|m&240,(m&15)<<4|m&15,1):l===8?rgba(m>>24&255,m>>16&255,m>>8&255,(m&255)/255):l===4?rgba(m>>12&15|m>>8&240,m>>8&15|m>>4&240,m>>4&15|m&240,((m&15)<<4|m&15)/255):null):(m=reRgbInteger.exec(format))?new Rgb(m[1],m[2],m[3],1):(m=reRgbPercent.exec(format))?new Rgb(m[1]*255/100,m[2]*255/100,m[3]*255/100,1):(m=reRgbaInteger.exec(format))?rgba(m[1],m[2],m[3],m[4]):(m=reRgbaPercent.exec(format))?rgba(m[1]*255/100,m[2]*255/100,m[3]*255/100,m[4]):(m=reHslPercent.exec(format))?hsla(m[1],m[2]/100,m[3]/100,1):(m=reHslaPercent.exec(format))?hsla(m[1],m[2]/100,m[3]/100,m[4]):named.hasOwnProperty(format)?rgbn(named[format]):format==="transparent"?new Rgb(NaN,NaN,NaN,0):null}function rgbn(n){return new Rgb(n>>16&255,n>>8&255,n&255,1)}function rgba(r,g,b,a){if(a<=0)r=g=b=NaN;return new Rgb(r,g,b,a)}function rgbConvert(o){if(!(o instanceof Color))o=color$3(o);if(!o)return new Rgb;o=o.rgb();return new Rgb(o.r,o.g,o.b,o.opacity)}function rgb$1(r,g,b,opacity){return arguments.length===1?rgbConvert(r):new Rgb(r,g,b,opacity==null?1:opacity)}function Rgb(r,g,b,opacity){this.r=+r;this.g=+g;this.b=+b;this.opacity=+opacity}define(Rgb,rgb$1,extend(Color,{brighter(k){k=k==null?brighter:Math.pow(brighter,k);return new Rgb(this.r*k,this.g*k,this.b*k,this.opacity)},darker(k){k=k==null?darker:Math.pow(darker,k);return new Rgb(this.r*k,this.g*k,this.b*k,this.opacity)},rgb(){return this},clamp(){return new Rgb(clampi(this.r),clampi(this.g),clampi(this.b),clampa(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&(-.5<=this.g&&this.g<255.5)&&(-.5<=this.b&&this.b<255.5)&&(0<=this.opacity&&this.opacity<=1)},hex:rgb_formatHex,formatHex:rgb_formatHex,formatHex8:rgb_formatHex8,formatRgb:rgb_formatRgb,toString:rgb_formatRgb}));function rgb_formatHex(){return`#${hex(this.r)}${hex(this.g)}${hex(this.b)}`}function rgb_formatHex8(){return`#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity)?1:this.opacity)*255)}`}function rgb_formatRgb(){const a=clampa(this.opacity);return`${a===1?"rgb(":"rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a===1?")":`, ${a})`}`}function clampa(opacity){return isNaN(opacity)?1:Math.max(0,Math.min(1,opacity))}function clampi(value){return Math.max(0,Math.min(255,Math.round(value)||0))}function hex(value){value=clampi(value);return(value<16?"0":"")+value.toString(16)}function hsla(h,s,l,a){if(a<=0)h=s=l=NaN;else if(l<=0||l>=1)h=s=NaN;else if(s<=0)h=NaN;return new Hsl(h,s,l,a)}function hslConvert(o){if(o instanceof Hsl)return new Hsl(o.h,o.s,o.l,o.opacity);if(!(o instanceof Color))o=color$3(o);if(!o)return new Hsl;if(o instanceof Hsl)return o;o=o.rgb();var r=o.r/255,g=o.g/255,b=o.b/255,min=Math.min(r,g,b),max=Math.max(r,g,b),h=NaN,s=max-min,l=(max+min)/2;if(s){if(r===max)h=(g-b)/s+(g<b)*6;else if(g===max)h=(b-r)/s+2;else h=(r-g)/s+4;s/=l<.5?max+min:2-max-min;h*=60}else{s=l>0&&l<1?0:h}return new Hsl(h,s,l,o.opacity)}function hsl$2(h,s,l,opacity){return arguments.length===1?hslConvert(h):new Hsl(h,s,l,opacity==null?1:opacity)}function Hsl(h,s,l,opacity){this.h=+h;this.s=+s;this.l=+l;this.opacity=+opacity}define(Hsl,hsl$2,extend(Color,{brighter(k){k=k==null?brighter:Math.pow(brighter,k);return new Hsl(this.h,this.s,this.l*k,this.opacity)},darker(k){k=k==null?darker:Math.pow(darker,k);return new Hsl(this.h,this.s,this.l*k,this.opacity)},rgb(){var h=this.h%360+(this.h<0)*360,s=isNaN(h)||isNaN(this.s)?0:this.s,l=this.l,m2=l+(l<.5?l:1-l)*s,m1=2*l-m2;return new Rgb(hsl2rgb(h>=240?h-240:h+120,m1,m2),hsl2rgb(h,m1,m2),hsl2rgb(h<120?h+240:h-120,m1,m2),this.opacity)},clamp(){return new Hsl(clamph(this.h),clampt(this.s),clampt(this.l),clampa(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&(0<=this.l&&this.l<=1)&&(0<=this.opacity&&this.opacity<=1)},formatHsl(){const a=clampa(this.opacity);return`${a===1?"hsl(":"hsla("}${clamph(this.h)}, ${clampt(this.s)*100}%, ${clampt(this.l)*100}%${a===1?")":`, ${a})`}`}}));function clamph(value){value=(value||0)%360;return value<0?value+360:value}function clampt(value){return Math.max(0,Math.min(1,value||0))}function hsl2rgb(h,m1,m2){return(h<60?m1+(m2-m1)*h/60:h<180?m2:h<240?m1+(m2-m1)*(240-h)/60:m1)*255}const radians$1=Math.PI/180;const degrees$2=180/Math.PI;const K=18,Xn=.96422,Yn=1,Zn=.82521,t0=4/29,t1=6/29,t2=3*t1*t1,t3=t1*t1*t1;function labConvert(o){if(o instanceof Lab)return new Lab(o.l,o.a,o.b,o.opacity);if(o instanceof Hcl)return hcl2lab(o);if(!(o instanceof Rgb))o=rgbConvert(o);var r=rgb2lrgb(o.r),g=rgb2lrgb(o.g),b=rgb2lrgb(o.b),y=xyz2lab((.2225045*r+.7168786*g+.0606169*b)/Yn),x,z;if(r===g&&g===b)x=z=y;else{x=xyz2lab((.4360747*r+.3850649*g+.1430804*b)/Xn);z=xyz2lab((.0139322*r+.0971045*g+.7141733*b)/Zn)}return new Lab(116*y-16,500*(x-y),200*(y-z),o.opacity)}function lab$1(l,a,b,opacity){return arguments.length===1?labConvert(l):new Lab(l,a,b,opacity==null?1:opacity)}function Lab(l,a,b,opacity){this.l=+l;this.a=+a;this.b=+b;this.opacity=+opacity}define(Lab,lab$1,extend(Color,{brighter(k){return new Lab(this.l+K*(k==null?1:k),this.a,this.b,this.opacity)},darker(k){return new Lab(this.l-K*(k==null?1:k),this.a,this.b,this.opacity)},rgb(){var y=(this.l+16)/116,x=isNaN(this.a)?y:y+this.a/500,z=isNaN(this.b)?y:y-this.b/200;x=Xn*lab2xyz(x);y=Yn*lab2xyz(y);z=Zn*lab2xyz(z);return new Rgb(lrgb2rgb(3.1338561*x-1.6168667*y-.4906146*z),lrgb2rgb(-.9787684*x+1.9161415*y+.033454*z),lrgb2rgb(.0719453*x-.2289914*y+1.4052427*z),this.opacity)}}));function xyz2lab(t){return t>t3?Math.pow(t,1/3):t/t2+t0}function lab2xyz(t){return t>t1?t*t*t:t2*(t-t0)}function lrgb2rgb(x){return 255*(x<=.0031308?12.92*x:1.055*Math.pow(x,1/2.4)-.055)}function rgb2lrgb(x){return(x/=255)<=.04045?x/12.92:Math.pow((x+.055)/1.055,2.4)}function hclConvert(o){if(o instanceof Hcl)return new Hcl(o.h,o.c,o.l,o.opacity);if(!(o instanceof Lab))o=labConvert(o);if(o.a===0&&o.b===0)return new Hcl(NaN,0<o.l&&o.l<100?0:NaN,o.l,o.opacity);var h=Math.atan2(o.b,o.a)*degrees$2;return new Hcl(h<0?h+360:h,Math.sqrt(o.a*o.a+o.b*o.b),o.l,o.opacity)}function hcl$2(h,c,l,opacity){return arguments.length===1?hclConvert(h):new Hcl(h,c,l,opacity==null?1:opacity)}function Hcl(h,c,l,opacity){this.h=+h;this.c=+c;this.l=+l;this.opacity=+opacity}function hcl2lab(o){if(isNaN(o.h))return new Lab(o.l,0,0,o.opacity);var h=o.h*radians$1;return new Lab(o.l,Math.cos(h)*o.c,Math.sin(h)*o.c,o.opacity)}define(Hcl,hcl$2,extend(Color,{brighter(k){return new Hcl(this.h,this.c,this.l+K*(k==null?1:k),this.opacity)},darker(k){return new Hcl(this.h,this.c,this.l-K*(k==null?1:k),this.opacity)},rgb(){return hcl2lab(this).rgb()}}));var A=-.14861,B$1=+1.78277,C$1=-.29227,D$1=-.90649,E=+1.97294,ED=E*D$1,EB=E*B$1,BC_DA=B$1*C$1-D$1*A;function cubehelixConvert(o){if(o instanceof Cubehelix)return new Cubehelix(o.h,o.s,o.l,o.opacity);if(!(o instanceof Rgb))o=rgbConvert(o);var r=o.r/255,g=o.g/255,b=o.b/255,l=(BC_DA*b+ED*r-EB*g)/(BC_DA+ED-EB),bl=b-l,k=(E*(g-l)-C$1*bl)/D$1,s=Math.sqrt(k*k+bl*bl)/(E*l*(1-l)),h=s?Math.atan2(k,bl)*degrees$2-120:NaN;return new Cubehelix(h<0?h+360:h,s,l,o.opacity)}function cubehelix$2(h,s,l,opacity){return arguments.length===1?cubehelixConvert(h):new Cubehelix(h,s,l,opacity==null?1:opacity)}function Cubehelix(h,s,l,opacity){this.h=+h;this.s=+s;this.l=+l;this.opacity=+opacity}define(Cubehelix,cubehelix$2,extend(Color,{brighter(k){k=k==null?brighter:Math.pow(brighter,k);return new Cubehelix(this.h,this.s,this.l*k,this.opacity)},darker(k){k=k==null?darker:Math.pow(darker,k);return new Cubehelix(this.h,this.s,this.l*k,this.opacity)},rgb(){var h=isNaN(this.h)?0:(this.h+120)*radians$1,l=+this.l,a=isNaN(this.s)?0:this.s*l*(1-l),cosh=Math.cos(h),sinh=Math.sin(h);return new Rgb(255*(l+a*(A*cosh+B$1*sinh)),255*(l+a*(C$1*cosh+D$1*sinh)),255*(l+a*(E*cosh)),this.opacity)}}));function basis(t1,v0,v1,v2,v3){var t2=t1*t1,t3=t2*t1;return((1-3*t1+3*t2-t3)*v0+(4-6*t2+3*t3)*v1+(1+3*t1+3*t2-3*t3)*v2+t3*v3)/6}function basis$1(values){var n=values.length-1;return function(t){var i=t<=0?t=0:t>=1?(t=1,n-1):Math.floor(t*n),v1=values[i],v2=values[i+1],v0=i>0?values[i-1]:2*v1-v2,v3=i<n-1?values[i+2]:2*v2-v1;return basis((t-i/n)*n,v0,v1,v2,v3)}}function basisClosed(values){var n=values.length;return function(t){var i=Math.floor(((t%=1)<0?++t:t)*n),v0=values[(i+n-1)%n],v1=values[i%n],v2=values[(i+1)%n],v3=values[(i+2)%n];return basis((t-i/n)*n,v0,v1,v2,v3)}}var constant$2=x=>()=>x;function linear$1(a,d){return function(t){return a+t*d}}function exponential(a,b,y){return a=Math.pow(a,y),b=Math.pow(b,y)-a,y=1/y,function(t){return Math.pow(a+t*b,y)}}function hue$1(a,b){var d=b-a;return d?linear$1(a,d>180||d<-180?d-360*Math.round(d/360):d):constant$2(isNaN(a)?b:a)}function gamma(y){return(y=+y)===1?nogamma:function(a,b){return b-a?exponential(a,b,y):constant$2(isNaN(a)?b:a)}}function nogamma(a,b){var d=b-a;return d?linear$1(a,d):constant$2(isNaN(a)?b:a)}var rgb=function rgbGamma(y){var color=gamma(y);function rgb(start,end){var r=color((start=rgb$1(start)).r,(end=rgb$1(end)).r),g=color(start.g,end.g),b=color(start.b,end.b),opacity=nogamma(start.opacity,end.opacity);return function(t){start.r=r(t);start.g=g(t);start.b=b(t);start.opacity=opacity(t);return start+""}}rgb.gamma=rgbGamma;return rgb}(1);function rgbSpline(spline){return function(colors){var n=colors.length,r=new Array(n),g=new Array(n),b=new Array(n),i,color;for(i=0;i<n;++i){color=rgb$1(colors[i]);r[i]=color.r||0;g[i]=color.g||0;b[i]=color.b||0}r=spline(r);g=spline(g);b=spline(b);color.opacity=1;return function(t){color.r=r(t);color.g=g(t);color.b=b(t);return color+""}}}var rgbBasis=rgbSpline(basis$1);var rgbBasisClosed=rgbSpline(basisClosed);function numberArray(a,b){if(!b)b=[];var n=a?Math.min(b.length,a.length):0,c=b.slice(),i;return function(t){for(i=0;i<n;++i)c[i]=a[i]*(1-t)+b[i]*t;return c}}function isNumberArray(x){return ArrayBuffer.isView(x)&&!(x instanceof DataView)}function array$3(a,b){return(isNumberArray(b)?numberArray:genericArray)(a,b)}function genericArray(a,b){var nb=b?b.length:0,na=a?Math.min(nb,a.length):0,x=new Array(na),c=new Array(nb),i;for(i=0;i<na;++i)x[i]=interpolate$1$1(a[i],b[i]);for(;i<nb;++i)c[i]=b[i];return function(t){for(i=0;i<na;++i)c[i]=x[i](t);return c}}function date$1(a,b){var d=new Date;return a=+a,b=+b,function(t){return d.setTime(a*(1-t)+b*t),d}}function interpolateNumber(a,b){return a=+a,b=+b,function(t){return a*(1-t)+b*t}}function object(a,b){var i={},c={},k;if(a===null||typeof a!=="object")a={};if(b===null||typeof b!=="object")b={};for(k in b){if(k in a){i[k]=interpolate$1$1(a[k],b[k])}else{c[k]=b[k]}}return function(t){for(k in i)c[k]=i[k](t);return c}}var reA=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,reB=new RegExp(reA.source,"g");function zero$2(b){return function(){return b}}function one$1(b){return function(t){return b(t)+""}}function string(a,b){var bi=reA.lastIndex=reB.lastIndex=0,am,bm,bs,i=-1,s=[],q=[];a=a+"",b=b+"";while((am=reA.exec(a))&&(bm=reB.exec(b))){if((bs=bm.index)>bi){bs=b.slice(bi,bs);if(s[i])s[i]+=bs;else s[++i]=bs}if((am=am[0])===(bm=bm[0])){if(s[i])s[i]+=bm;else s[++i]=bm}else{s[++i]=null;q.push({i:i,x:interpolateNumber(am,bm)})}bi=reB.lastIndex}if(bi<b.length){bs=b.slice(bi);if(s[i])s[i]+=bs;else s[++i]=bs}return s.length<2?q[0]?one$1(q[0].x):zero$2(b):(b=q.length,function(t){for(var i=0,o;i<b;++i)s[(o=q[i]).i]=o.x(t);return s.join("")})}function interpolate$1$1(a,b){var t=typeof b,c;return b==null||t==="boolean"?constant$2(b):(t==="number"?interpolateNumber:t==="string"?(c=color$3(b))?(b=c,rgb):string:b instanceof color$3?rgb:b instanceof Date?date$1:isNumberArray(b)?numberArray:Array.isArray(b)?genericArray:typeof b.valueOf!=="function"&&typeof b.toString!=="function"||isNaN(b)?object:interpolateNumber)(a,b)}function discrete$1(range){var n=range.length;return function(t){return range[Math.max(0,Math.min(n-1,Math.floor(t*n)))]}}function hue(a,b){var i=hue$1(+a,+b);return function(t){var x=i(t);return x-360*Math.floor(x/360)}}function interpolateRound(a,b){return a=+a,b=+b,function(t){return Math.round(a*(1-t)+b*t)}}var degrees$1=180/Math.PI;var identity$3={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1};function decompose(a,b,c,d,e,f){var scaleX,scaleY,skewX;if(scaleX=Math.sqrt(a*a+b*b))a/=scaleX,b/=scaleX;if(skewX=a*c+b*d)c-=a*skewX,d-=b*skewX;if(scaleY=Math.sqrt(c*c+d*d))c/=scaleY,d/=scaleY,skewX/=scaleY;if(a*d<b*c)a=-a,b=-b,skewX=-skewX,scaleX=-scaleX;return{translateX:e,translateY:f,rotate:Math.atan2(b,a)*degrees$1,skewX:Math.atan(skewX)*degrees$1,scaleX:scaleX,scaleY:scaleY}}var svgNode;function parseCss(value){const m=new(typeof DOMMatrix==="function"?DOMMatrix:WebKitCSSMatrix)(value+"");return m.isIdentity?identity$3:decompose(m.a,m.b,m.c,m.d,m.e,m.f)}function parseSvg(value){if(value==null)return identity$3;if(!svgNode)svgNode=document.createElementNS("http://www.w3.org/2000/svg","g");svgNode.setAttribute("transform",value);if(!(value=svgNode.transform.baseVal.consolidate()))return identity$3;value=value.matrix;return decompose(value.a,value.b,value.c,value.d,value.e,value.f)}function interpolateTransform(parse,pxComma,pxParen,degParen){function pop(s){return s.length?s.pop()+" ":""}function translate(xa,ya,xb,yb,s,q){if(xa!==xb||ya!==yb){var i=s.push("translate(",null,pxComma,null,pxParen);q.push({i:i-4,x:interpolateNumber(xa,xb)},{i:i-2,x:interpolateNumber(ya,yb)})}else if(xb||yb){s.push("translate("+xb+pxComma+yb+pxParen)}}function rotate(a,b,s,q){if(a!==b){if(a-b>180)b+=360;else if(b-a>180)a+=360;q.push({i:s.push(pop(s)+"rotate(",null,degParen)-2,x:interpolateNumber(a,b)})}else if(b){s.push(pop(s)+"rotate("+b+degParen)}}function skewX(a,b,s,q){if(a!==b){q.push({i:s.push(pop(s)+"skewX(",null,degParen)-2,x:interpolateNumber(a,b)})}else if(b){s.push(pop(s)+"skewX("+b+degParen)}}function scale(xa,ya,xb,yb,s,q){if(xa!==xb||ya!==yb){var i=s.push(pop(s)+"scale(",null,",",null,")");q.push({i:i-4,x:interpolateNumber(xa,xb)},{i:i-2,x:interpolateNumber(ya,yb)})}else if(xb!==1||yb!==1){s.push(pop(s)+"scale("+xb+","+yb+")")}}return function(a,b){var s=[],q=[];a=parse(a),b=parse(b);translate(a.translateX,a.translateY,b.translateX,b.translateY,s,q);rotate(a.rotate,b.rotate,s,q);skewX(a.skewX,b.skewX,s,q);scale(a.scaleX,a.scaleY,b.scaleX,b.scaleY,s,q);a=b=null;return function(t){var i=-1,n=q.length,o;while(++i<n)s[(o=q[i]).i]=o.x(t);return s.join("")}}}var interpolateTransformCss=interpolateTransform(parseCss,"px, ","px)","deg)");var interpolateTransformSvg=interpolateTransform(parseSvg,", ",")",")");var epsilon2$1=1e-12;function cosh(x){return((x=Math.exp(x))+1/x)/2}function sinh(x){return((x=Math.exp(x))-1/x)/2}function tanh(x){return((x=Math.exp(2*x))-1)/(x+1)}var zoom$1=function zoomRho(rho,rho2,rho4){function zoom(p0,p1){var ux0=p0[0],uy0=p0[1],w0=p0[2],ux1=p1[0],uy1=p1[1],w1=p1[2],dx=ux1-ux0,dy=uy1-uy0,d2=dx*dx+dy*dy,i,S;if(d2<epsilon2$1){S=Math.log(w1/w0)/rho;i=function(t){return[ux0+t*dx,uy0+t*dy,w0*Math.exp(rho*t*S)]}}else{var d1=Math.sqrt(d2),b0=(w1*w1-w0*w0+rho4*d2)/(2*w0*rho2*d1),b1=(w1*w1-w0*w0-rho4*d2)/(2*w1*rho2*d1),r0=Math.log(Math.sqrt(b0*b0+1)-b0),r1=Math.log(Math.sqrt(b1*b1+1)-b1);S=(r1-r0)/rho;i=function(t){var s=t*S,coshr0=cosh(r0),u=w0/(rho2*d1)*(coshr0*tanh(rho*s+r0)-sinh(r0));return[ux0+u*dx,uy0+u*dy,w0*coshr0/cosh(rho*s+r0)]}}i.duration=S*1e3*rho/Math.SQRT2;return i}zoom.rho=function(_){var _1=Math.max(.001,+_),_2=_1*_1,_4=_2*_2;return zoomRho(_1,_2,_4)};return zoom}(Math.SQRT2,2,4);function hsl(hue){return function(start,end){var h=hue((start=hsl$2(start)).h,(end=hsl$2(end)).h),s=nogamma(start.s,end.s),l=nogamma(start.l,end.l),opacity=nogamma(start.opacity,end.opacity);return function(t){start.h=h(t);start.s=s(t);start.l=l(t);start.opacity=opacity(t);return start+""}}}var hsl$1=hsl(hue$1);var hslLong=hsl(nogamma);function lab(start,end){var l=nogamma((start=lab$1(start)).l,(end=lab$1(end)).l),a=nogamma(start.a,end.a),b=nogamma(start.b,end.b),opacity=nogamma(start.opacity,end.opacity);return function(t){start.l=l(t);start.a=a(t);start.b=b(t);start.opacity=opacity(t);return start+""}}function hcl(hue){return function(start,end){var h=hue((start=hcl$2(start)).h,(end=hcl$2(end)).h),c=nogamma(start.c,end.c),l=nogamma(start.l,end.l),opacity=nogamma(start.opacity,end.opacity);return function(t){start.h=h(t);start.c=c(t);start.l=l(t);start.opacity=opacity(t);return start+""}}}var hcl$1=hcl(hue$1);var hclLong=hcl(nogamma);function cubehelix(hue){return function cubehelixGamma(y){y=+y;function cubehelix(start,end){var h=hue((start=cubehelix$2(start)).h,(end=cubehelix$2(end)).h),s=nogamma(start.s,end.s),l=nogamma(start.l,end.l),opacity=nogamma(start.opacity,end.opacity);return function(t){start.h=h(t);start.s=s(t);start.l=l(Math.pow(t,y));start.opacity=opacity(t);return start+""}}cubehelix.gamma=cubehelixGamma;return cubehelix}(1)}var cubehelix$1=cubehelix(hue$1);var cubehelixLong=cubehelix(nogamma);function piecewise(interpolate,values){if(values===undefined)values=interpolate,interpolate=interpolate$1$1;var i=0,n=values.length-1,v=values[0],I=new Array(n<0?0:n);while(i<n)I[i]=interpolate(v,v=values[++i]);return function(t){var i=Math.max(0,Math.min(n-1,Math.floor(t*=n)));return I[i](t-i)}}function quantize$2(interpolator,n){var samples=new Array(n);for(var i=0;i<n;++i)samples[i]=interpolator(i/(n-1));return samples}var $$1=Object.freeze({__proto__:null,interpolate:interpolate$1$1,interpolateArray:array$3,interpolateBasis:basis$1,interpolateBasisClosed:basisClosed,interpolateCubehelix:cubehelix$1,interpolateCubehelixLong:cubehelixLong,interpolateDate:date$1,interpolateDiscrete:discrete$1,interpolateHcl:hcl$1,interpolateHclLong:hclLong,interpolateHsl:hsl$1,interpolateHslLong:hslLong,interpolateHue:hue,interpolateLab:lab,interpolateNumber:interpolateNumber,interpolateNumberArray:numberArray,interpolateObject:object,interpolateRgb:rgb,interpolateRgbBasis:rgbBasis,interpolateRgbBasisClosed:rgbBasisClosed,interpolateRound:interpolateRound,interpolateString:string,interpolateTransformCss:interpolateTransformCss,interpolateTransformSvg:interpolateTransformSvg,interpolateZoom:zoom$1,piecewise:piecewise,quantize:quantize$2});function constants(x){return function(){return x}}function number$5(x){return+x}var unit=[0,1];function identity$2(x){return x}function normalize$2(a,b){return(b-=a=+a)?function(x){return(x-a)/b}:constants(isNaN(b)?NaN:.5)}function clamper(a,b){var t;if(a>b)t=a,a=b,b=t;return function(x){return Math.max(a,Math.min(b,x))}}function bimap(domain,range,interpolate){var d0=domain[0],d1=domain[1],r0=range[0],r1=range[1];if(d1<d0)d0=normalize$2(d1,d0),r0=interpolate(r1,r0);else d0=normalize$2(d0,d1),r0=interpolate(r0,r1);return function(x){return r0(d0(x))}}function polymap(domain,range,interpolate){var j=Math.min(domain.length,range.length)-1,d=new Array(j),r=new Array(j),i=-1;if(domain[j]<domain[0]){domain=domain.slice().reverse();range=range.slice().reverse()}while(++i<j){d[i]=normalize$2(domain[i],domain[i+1]);r[i]=interpolate(range[i],range[i+1])}return function(x){var i=bisectRight$1(domain,x,1,j)-1;return r[i](d[i](x))}}function copy$2(source,target){return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown())}function transformer$3(){var domain=unit,range=unit,interpolate=interpolate$1$1,transform,untransform,unknown,clamp=identity$2,piecewise,output,input;function rescale(){var n=Math.min(domain.length,range.length);if(clamp!==identity$2)clamp=clamper(domain[0],domain[n-1]);piecewise=n>2?polymap:bimap;output=input=null;return scale}function scale(x){return x==null||isNaN(x=+x)?unknown:(output||(output=piecewise(domain.map(transform),range,interpolate)))(transform(clamp(x)))}scale.invert=function(y){return clamp(untransform((input||(input=piecewise(range,domain.map(transform),interpolateNumber)))(y)))};scale.domain=function(_){return arguments.length?(domain=Array.from(_,number$5),rescale()):domain.slice()};scale.range=function(_){return arguments.length?(range=Array.from(_),rescale()):range.slice()};scale.rangeRound=function(_){return range=Array.from(_),interpolate=interpolateRound,rescale()};scale.clamp=function(_){return arguments.length?(clamp=_?true:identity$2,rescale()):clamp!==identity$2};scale.interpolate=function(_){return arguments.length?(interpolate=_,rescale()):interpolate};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown};return function(t,u){transform=t,untransform=u;return rescale()}}function continuous$1(){return transformer$3()(identity$2,identity$2)}function tickFormat$1(start,stop,count,specifier){var step=tickStep(start,stop,count),precision;specifier=formatSpecifier(specifier==null?",f":specifier);switch(specifier.type){case"s":{var value=Math.max(Math.abs(start),Math.abs(stop));if(specifier.precision==null&&!isNaN(precision=precisionPrefix(step,value)))specifier.precision=precision;return formatPrefix(specifier,value)}case"":case"e":case"g":case"p":case"r":{if(specifier.precision==null&&!isNaN(precision=precisionRound(step,Math.max(Math.abs(start),Math.abs(stop)))))specifier.precision=precision-(specifier.type==="e");break}case"f":case"%":{if(specifier.precision==null&&!isNaN(precision=precisionFixed(step)))specifier.precision=precision-(specifier.type==="%")*2;break}}return format$3(specifier)}function linearish(scale){var domain=scale.domain;scale.ticks=function(count){var d=domain();return ticks(d[0],d[d.length-1],count==null?10:count)};scale.tickFormat=function(count,specifier){var d=domain();return tickFormat$1(d[0],d[d.length-1],count==null?10:count,specifier)};scale.nice=function(count){if(count==null)count=10;var d=domain();var i0=0;var i1=d.length-1;var start=d[i0];var stop=d[i1];var prestep;var step;var maxIter=10;if(stop<start){step=start,start=stop,stop=step;step=i0,i0=i1,i1=step}while(maxIter-- >0){step=tickIncrement(start,stop,count);if(step===prestep){d[i0]=start;d[i1]=stop;return domain(d)}else if(step>0){start=Math.floor(start/step)*step;stop=Math.ceil(stop/step)*step}else if(step<0){start=Math.ceil(start*step)/step;stop=Math.floor(stop*step)/step}else{break}prestep=step}return scale};return scale}function linear(){var scale=continuous$1();scale.copy=function(){return copy$2(scale,linear())};initRange.apply(scale,arguments);return linearish(scale)}function identity$1(domain){var unknown;function scale(x){return x==null||isNaN(x=+x)?unknown:x}scale.invert=scale;scale.domain=scale.range=function(_){return arguments.length?(domain=Array.from(_,number$5),scale):domain.slice()};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown};scale.copy=function(){return identity$1(domain).unknown(unknown)};domain=arguments.length?Array.from(domain,number$5):[0,1];return linearish(scale)}function nice$1(domain,interval){domain=domain.slice();var i0=0,i1=domain.length-1,x0=domain[i0],x1=domain[i1],t;if(x1<x0){t=i0,i0=i1,i1=t;t=x0,x0=x1,x1=t}domain[i0]=interval.floor(x0);domain[i1]=interval.ceil(x1);return domain}function transformLog(x){return Math.log(x)}function transformExp(x){return Math.exp(x)}function transformLogn(x){return-Math.log(-x)}function transformExpn(x){return-Math.exp(-x)}function pow10(x){return isFinite(x)?+("1e"+x):x<0?0:x}function powp(base){return base===10?pow10:base===Math.E?Math.exp:x=>Math.pow(base,x)}function logp(base){return base===Math.E?Math.log:base===10&&Math.log10||base===2&&Math.log2||(base=Math.log(base),x=>Math.log(x)/base)}function reflect(f){return(x,k)=>-f(-x,k)}function loggish(transform){const scale=transform(transformLog,transformExp);const domain=scale.domain;let base=10;let logs;let pows;function rescale(){logs=logp(base),pows=powp(base);if(domain()[0]<0){logs=reflect(logs),pows=reflect(pows);transform(transformLogn,transformExpn)}else{transform(transformLog,transformExp)}return scale}scale.base=function(_){return arguments.length?(base=+_,rescale()):base};scale.domain=function(_){return arguments.length?(domain(_),rescale()):domain()};scale.ticks=count=>{const d=domain();let u=d[0];let v=d[d.length-1];const r=v<u;if(r)[u,v]=[v,u];let i=logs(u);let j=logs(v);let k;let t;const n=count==null?10:+count;let z=[];if(!(base%1)&&j-i<n){i=Math.floor(i),j=Math.ceil(j);if(u>0)for(;i<=j;++i){for(k=1;k<base;++k){t=i<0?k/pows(-i):k*pows(i);if(t<u)continue;if(t>v)break;z.push(t)}}else for(;i<=j;++i){for(k=base-1;k>=1;--k){t=i>0?k/pows(-i):k*pows(i);if(t<u)continue;if(t>v)break;z.push(t)}}if(z.length*2<n)z=ticks(u,v,n)}else{z=ticks(i,j,Math.min(j-i,n)).map(pows)}return r?z.reverse():z};scale.tickFormat=(count,specifier)=>{if(count==null)count=10;if(specifier==null)specifier=base===10?"s":",";if(typeof specifier!=="function"){if(!(base%1)&&(specifier=formatSpecifier(specifier)).precision==null)specifier.trim=true;specifier=format$3(specifier)}if(count===Infinity)return specifier;const k=Math.max(1,base*count/scale.ticks().length);return d=>{let i=d/pows(Math.round(logs(d)));if(i*base<base-.5)i*=base;return i<=k?specifier(d):""}};scale.nice=()=>domain(nice$1(domain(),{floor:x=>pows(Math.floor(logs(x))),ceil:x=>pows(Math.ceil(logs(x)))}));return scale}function log$2(){const scale=loggish(transformer$3()).domain([1,10]);scale.copy=()=>copy$2(scale,log$2()).base(scale.base());initRange.apply(scale,arguments);return scale}function transformSymlog(c){return function(x){return Math.sign(x)*Math.log1p(Math.abs(x/c))}}function transformSymexp(c){return function(x){return Math.sign(x)*Math.expm1(Math.abs(x))*c}}function symlogish(transform){var c=1,scale=transform(transformSymlog(c),transformSymexp(c));scale.constant=function(_){return arguments.length?transform(transformSymlog(c=+_),transformSymexp(c)):c};return linearish(scale)}function symlog(){var scale=symlogish(transformer$3());scale.copy=function(){return copy$2(scale,symlog()).constant(scale.constant())};return initRange.apply(scale,arguments)}function transformPow(exponent){return function(x){return x<0?-Math.pow(-x,exponent):Math.pow(x,exponent)}}function transformSqrt(x){return x<0?-Math.sqrt(-x):Math.sqrt(x)}function transformSquare(x){return x<0?-x*x:x*x}function powish(transform){var scale=transform(identity$2,identity$2),exponent=1;function rescale(){return exponent===1?transform(identity$2,identity$2):exponent===.5?transform(transformSqrt,transformSquare):transform(transformPow(exponent),transformPow(1/exponent))}scale.exponent=function(_){return arguments.length?(exponent=+_,rescale()):exponent};return linearish(scale)}function pow$2(){var scale=powish(transformer$3());scale.copy=function(){return copy$2(scale,pow$2()).exponent(scale.exponent())};initRange.apply(scale,arguments);return scale}function sqrt$2(){return pow$2.apply(null,arguments).exponent(.5)}function quantile(){var domain=[],range=[],thresholds=[],unknown;function rescale(){var i=0,n=Math.max(1,range.length);thresholds=new Array(n-1);while(++i<n)thresholds[i-1]=quantileSorted(domain,i/n);return scale}function scale(x){return x==null||isNaN(x=+x)?unknown:range[bisectRight$1(thresholds,x)]}scale.invertExtent=function(y){var i=range.indexOf(y);return i<0?[NaN,NaN]:[i>0?thresholds[i-1]:domain[0],i<thresholds.length?thresholds[i]:domain[domain.length-1]]};scale.domain=function(_){if(!arguments.length)return domain.slice();domain=[];for(let d of _)if(d!=null&&!isNaN(d=+d))domain.push(d);domain.sort(ascending$1);return rescale()};scale.range=function(_){return arguments.length?(range=Array.from(_),rescale()):range.slice()};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown};scale.quantiles=function(){return thresholds.slice()};scale.copy=function(){return quantile().domain(domain).range(range).unknown(unknown)};return initRange.apply(scale,arguments)}function quantize$1(){var x0=0,x1=1,n=1,domain=[.5],range=[0,1],unknown;function scale(x){return x!=null&&x<=x?range[bisectRight$1(domain,x,0,n)]:unknown}function rescale(){var i=-1;domain=new Array(n);while(++i<n)domain[i]=((i+1)*x1-(i-n)*x0)/(n+1);return scale}scale.domain=function(_){return arguments.length?([x0,x1]=_,x0=+x0,x1=+x1,rescale()):[x0,x1]};scale.range=function(_){return arguments.length?(n=(range=Array.from(_)).length-1,rescale()):range.slice()};scale.invertExtent=function(y){var i=range.indexOf(y);return i<0?[NaN,NaN]:i<1?[x0,domain[0]]:i>=n?[domain[n-1],x1]:[domain[i-1],domain[i]]};scale.unknown=function(_){return arguments.length?(unknown=_,scale):scale};scale.thresholds=function(){return domain.slice()};scale.copy=function(){return quantize$1().domain([x0,x1]).range(range).unknown(unknown)};return initRange.apply(linearish(scale),arguments)}function threshold(){var domain=[.5],range=[0,1],unknown,n=1;function scale(x){return x!=null&&x<=x?range[bisectRight$1(domain,x,0,n)]:unknown}scale.domain=function(_){return arguments.length?(domain=Array.from(_),n=Math.min(domain.length,range.length-1),scale):domain.slice()};scale.range=function(_){return arguments.length?(range=Array.from(_),n=Math.min(domain.length,range.length-1),scale):range.slice()};scale.invertExtent=function(y){var i=range.indexOf(y);return[domain[i-1],domain[i]]};scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown};scale.copy=function(){return threshold().domain(domain).range(range).unknown(unknown)};return initRange.apply(scale,arguments)}function date(t){return new Date(t)}function number$4(t){return t instanceof Date?+t:+new Date(+t)}function calendar(ticks,tickInterval,year,month,week,day,hour,minute,second,format){var scale=continuous$1(),invert=scale.invert,domain=scale.domain;var formatMillisecond=format(".%L"),formatSecond=format(":%S"),formatMinute=format("%I:%M"),formatHour=format("%I %p"),formatDay=format("%a %d"),formatWeek=format("%b %d"),formatMonth=format("%B"),formatYear=format("%Y");function tickFormat(date){return(second(date)<date?formatMillisecond:minute(date)<date?formatSecond:hour(date)<date?formatMinute:day(date)<date?formatHour:month(date)<date?week(date)<date?formatDay:formatWeek:year(date)<date?formatMonth:formatYear)(date)}scale.invert=function(y){return new Date(invert(y))};scale.domain=function(_){return arguments.length?domain(Array.from(_,number$4)):domain().map(date)};scale.ticks=function(interval){var d=domain();return ticks(d[0],d[d.length-1],interval==null?10:interval)};scale.tickFormat=function(count,specifier){return specifier==null?tickFormat:format(specifier)};scale.nice=function(interval){var d=domain();if(!interval||typeof interval.range!=="function")interval=tickInterval(d[0],d[d.length-1],interval==null?10:interval);return interval?domain(nice$1(d,interval)):scale};scale.copy=function(){return copy$2(scale,calendar(ticks,tickInterval,year,month,week,day,hour,minute,second,format))};return scale}function time$1(){return initRange.apply(calendar(timeTicks,timeTickInterval,timeYear,timeMonth,timeSunday,timeDay,timeHour,timeMinute,second,timeFormat$2).domain([new Date(2e3,0,1),new Date(2e3,0,2)]),arguments)}function utcTime(){return initRange.apply(calendar(utcTicks,utcTickInterval,utcYear,utcMonth,utcSunday,utcDay,utcHour,utcMinute,second,utcFormat$1).domain([Date.UTC(2e3,0,1),Date.UTC(2e3,0,2)]),arguments)}function transformer$2(){var x0=0,x1=1,t0,t1,k10,transform,interpolator=identity$2,clamp=false,unknown;function scale(x){return x==null||isNaN(x=+x)?unknown:interpolator(k10===0?.5:(x=(transform(x)-t0)*k10,clamp?Math.max(0,Math.min(1,x)):x))}scale.domain=function(_){return arguments.length?([x0,x1]=_,t0=transform(x0=+x0),t1=transform(x1=+x1),k10=t0===t1?0:1/(t1-t0),scale):[x0,x1]};scale.clamp=function(_){return arguments.length?(clamp=!!_,scale):clamp};scale.interpolator=function(_){return arguments.length?(interpolator=_,scale):interpolator};function range(interpolate){return function(_){var r0,r1;return arguments.length?([r0,r1]=_,interpolator=interpolate(r0,r1),scale):[interpolator(0),interpolator(1)]}}scale.range=range(interpolate$1$1);scale.rangeRound=range(interpolateRound);scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown};return function(t){transform=t,t0=t(x0),t1=t(x1),k10=t0===t1?0:1/(t1-t0);return scale}}function copy$1(source,target){return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown())}function sequential(){var scale=linearish(transformer$2()(identity$2));scale.copy=function(){return copy$1(scale,sequential())};return initInterpolator.apply(scale,arguments)}function sequentialLog(){var scale=loggish(transformer$2()).domain([1,10]);scale.copy=function(){return copy$1(scale,sequentialLog()).base(scale.base())};return initInterpolator.apply(scale,arguments)}function sequentialSymlog(){var scale=symlogish(transformer$2());scale.copy=function(){return copy$1(scale,sequentialSymlog()).constant(scale.constant())};return initInterpolator.apply(scale,arguments)}function sequentialPow(){var scale=powish(transformer$2());scale.copy=function(){return copy$1(scale,sequentialPow()).exponent(scale.exponent())};return initInterpolator.apply(scale,arguments)}function sequentialSqrt(){return sequentialPow.apply(null,arguments).exponent(.5)}function transformer$1(){var x0=0,x1=.5,x2=1,s=1,t0,t1,t2,k10,k21,interpolator=identity$2,transform,clamp=false,unknown;function scale(x){return isNaN(x=+x)?unknown:(x=.5+((x=+transform(x))-t1)*(s*x<s*t1?k10:k21),interpolator(clamp?Math.max(0,Math.min(1,x)):x))}scale.domain=function(_){return arguments.length?([x0,x1,x2]=_,t0=transform(x0=+x0),t1=transform(x1=+x1),t2=transform(x2=+x2),k10=t0===t1?0:.5/(t1-t0),k21=t1===t2?0:.5/(t2-t1),s=t1<t0?-1:1,scale):[x0,x1,x2]};scale.clamp=function(_){return arguments.length?(clamp=!!_,scale):clamp};scale.interpolator=function(_){return arguments.length?(interpolator=_,scale):interpolator};function range(interpolate){return function(_){var r0,r1,r2;return arguments.length?([r0,r1,r2]=_,interpolator=piecewise(interpolate,[r0,r1,r2]),scale):[interpolator(0),interpolator(.5),interpolator(1)]}}scale.range=range(interpolate$1$1);scale.rangeRound=range(interpolateRound);scale.unknown=function(_){return arguments.length?(unknown=_,scale):unknown};return function(t){transform=t,t0=t(x0),t1=t(x1),t2=t(x2),k10=t0===t1?0:.5/(t1-t0),k21=t1===t2?0:.5/(t2-t1),s=t1<t0?-1:1;return scale}}function diverging(){var scale=linearish(transformer$1()(identity$2));scale.copy=function(){return copy$1(scale,diverging())};return initInterpolator.apply(scale,arguments)}function divergingLog(){var scale=loggish(transformer$1()).domain([.1,1,10]);scale.copy=function(){return copy$1(scale,divergingLog()).base(scale.base())};return initInterpolator.apply(scale,arguments)}function divergingSymlog(){var scale=symlogish(transformer$1());scale.copy=function(){return copy$1(scale,divergingSymlog()).constant(scale.constant())};return initInterpolator.apply(scale,arguments)}function divergingPow(){var scale=powish(transformer$1());scale.copy=function(){return copy$1(scale,divergingPow()).exponent(scale.exponent())};return initInterpolator.apply(scale,arguments)}function divergingSqrt(){return divergingPow.apply(null,arguments).exponent(.5)}function colors$1(specifier){var n=specifier.length/6|0,colors=new Array(n),i=0;while(i<n)colors[i]="#"+specifier.slice(i*6,++i*6);return colors}var schemeCategory10=colors$1("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");var schemeAccent=colors$1("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");var schemeDark2=colors$1("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");var schemeObservable10=colors$1("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");var schemePaired=colors$1("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");var schemePastel1=colors$1("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");var schemePastel2=colors$1("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");var schemeSet1=colors$1("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");var schemeSet2=colors$1("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");var schemeSet3=colors$1("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");function bandSpace(count,paddingInner,paddingOuter){const space=count-paddingInner+paddingOuter*2;return count?space>0?space:1:0}const Identity="identity";const Linear="linear";const Log="log";const Pow="pow";const Sqrt="sqrt";const Symlog="symlog";const Time="time";const UTC="utc";const Sequential="sequential";const Diverging="diverging";const Quantile="quantile";const Quantize="quantize";const Threshold="threshold";const Ordinal="ordinal";const Point="point";const Band="band";const BinOrdinal="bin-ordinal";const Continuous="continuous";const Discrete$1="discrete";const Discretizing="discretizing";const Interpolating="interpolating";const Temporal="temporal";function invertRange(scale){return function(_){let lo=_[0],hi=_[1],t;if(hi<lo){t=lo;lo=hi;hi=t}return[scale.invert(lo),scale.invert(hi)]}}function invertRangeExtent(scale){return function(_){const range=scale.range();let lo=_[0],hi=_[1],min=-1,max,t,i,n;if(hi<lo){t=lo;lo=hi;hi=t}for(i=0,n=range.length;i<n;++i){if(range[i]>=lo&&range[i]<=hi){if(min<0)min=i;max=i}}if(min<0)return undefined;lo=scale.invertExtent(range[min]);hi=scale.invertExtent(range[max]);return[lo[0]===undefined?lo[1]:lo[0],hi[1]===undefined?hi[0]:hi[1]]}}function band(){const scale=ordinal().unknown(undefined),domain=scale.domain,ordinalRange=scale.range;let range$1=[0,1],step,bandwidth,round=false,paddingInner=0,paddingOuter=0,align=.5;delete scale.unknown;function rescale(){const n=domain().length,reverse=range$1[1]<range$1[0],stop=range$1[1-reverse],space=bandSpace(n,paddingInner,paddingOuter);let start=range$1[reverse-0];step=(stop-start)/(space||1);if(round){step=Math.floor(step)}start+=(stop-start-step*(n-paddingInner))*align;bandwidth=step*(1-paddingInner);if(round){start=Math.round(start);bandwidth=Math.round(bandwidth)}const values=range$4(n).map((i=>start+step*i));return ordinalRange(reverse?values.reverse():values)}scale.domain=function(_){if(arguments.length){domain(_);return rescale()}else{return domain()}};scale.range=function(_){if(arguments.length){range$1=[+_[0],+_[1]];return rescale()}else{return range$1.slice()}};scale.rangeRound=function(_){range$1=[+_[0],+_[1]];round=true;return rescale()};scale.bandwidth=function(){return bandwidth};scale.step=function(){return step};scale.round=function(_){if(arguments.length){round=!!_;return rescale()}else{return round}};scale.padding=function(_){if(arguments.length){paddingOuter=Math.max(0,Math.min(1,_));paddingInner=paddingOuter;return rescale()}else{return paddingInner}};scale.paddingInner=function(_){if(arguments.length){paddingInner=Math.max(0,Math.min(1,_));return rescale()}else{return paddingInner}};scale.paddingOuter=function(_){if(arguments.length){paddingOuter=Math.max(0,Math.min(1,_));return rescale()}else{return paddingOuter}};scale.align=function(_){if(arguments.length){align=Math.max(0,Math.min(1,_));return rescale()}else{return align}};scale.invertRange=function(_){if(_[0]==null||_[1]==null)return;const reverse=range$1[1]<range$1[0],values=reverse?ordinalRange().reverse():ordinalRange(),n=values.length-1;let lo=+_[0],hi=+_[1],a,b,t;if(lo!==lo||hi!==hi)return;if(hi<lo){t=lo;lo=hi;hi=t}if(hi<values[0]||lo>range$1[1-reverse])return;a=Math.max(0,bisectRight$1(values,lo)-1);b=lo===hi?a:bisectRight$1(values,hi)-1;if(lo-values[a]>bandwidth+1e-10)++a;if(reverse){t=a;a=n-b;b=n-t}return a>b?undefined:domain().slice(a,b+1)};scale.invert=function(_){const value=scale.invertRange([_,_]);return value?value[0]:value};scale.copy=function(){return band().domain(domain()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align)};return rescale()}function pointish(scale){const copy=scale.copy;scale.padding=scale.paddingOuter;delete scale.paddingInner;scale.copy=function(){return pointish(copy())};return scale}function point$3(){return pointish(band().paddingInner(1))}var map=Array.prototype.map;function numbers(_){return map.call(_,toNumber)}const slice$1=Array.prototype.slice;function scaleBinOrdinal(){let domain=[],range=[];function scale(x){return x==null||x!==x?undefined:range[(bisectRight$1(domain,x)-1)%range.length]}scale.domain=function(_){if(arguments.length){domain=numbers(_);return scale}else{return domain.slice()}};scale.range=function(_){if(arguments.length){range=slice$1.call(_);return scale}else{return range.slice()}};scale.tickFormat=function(count,specifier){return tickFormat$1(domain[0],peek$1(domain),count==null?10:count,specifier)};scale.copy=function(){return scaleBinOrdinal().domain(scale.domain()).range(scale.range())};return scale}const scales=new Map;const VEGA_SCALE=Symbol("vega_scale");function registerScale(scale){scale[VEGA_SCALE]=true;return scale}function isRegisteredScale(scale){return scale&&scale[VEGA_SCALE]===true}function create$2(type,constructor,metadata){const ctr=function scale(){const s=constructor();if(!s.invertRange){s.invertRange=s.invert?invertRange(s):s.invertExtent?invertRangeExtent(s):undefined}s.type=type;return registerScale(s)};ctr.metadata=toSet(array$5(metadata));return ctr}function scale$4(type,scale,metadata){if(arguments.length>1){scales.set(type,create$2(type,scale,metadata));return this}else{return isValidScaleType(type)?scales.get(type):undefined}}scale$4(Identity,identity$1);scale$4(Linear,linear,Continuous);scale$4(Log,log$2,[Continuous,Log]);scale$4(Pow,pow$2,Continuous);scale$4(Sqrt,sqrt$2,Continuous);scale$4(Symlog,symlog,Continuous);scale$4(Time,time$1,[Continuous,Temporal]);scale$4(UTC,utcTime,[Continuous,Temporal]);scale$4(Sequential,sequential,[Continuous,Interpolating]);scale$4(`${Sequential}-${Linear}`,sequential,[Continuous,Interpolating]);scale$4(`${Sequential}-${Log}`,sequentialLog,[Continuous,Interpolating,Log]);scale$4(`${Sequential}-${Pow}`,sequentialPow,[Continuous,Interpolating]);scale$4(`${Sequential}-${Sqrt}`,sequentialSqrt,[Continuous,Interpolating]);scale$4(`${Sequential}-${Symlog}`,sequentialSymlog,[Continuous,Interpolating]);scale$4(`${Diverging}-${Linear}`,diverging,[Continuous,Interpolating]);scale$4(`${Diverging}-${Log}`,divergingLog,[Continuous,Interpolating,Log]);scale$4(`${Diverging}-${Pow}`,divergingPow,[Continuous,Interpolating]);scale$4(`${Diverging}-${Sqrt}`,divergingSqrt,[Continuous,Interpolating]);scale$4(`${Diverging}-${Symlog}`,divergingSymlog,[Continuous,Interpolating]);scale$4(Quantile,quantile,[Discretizing,Quantile]);scale$4(Quantize,quantize$1,Discretizing);scale$4(Threshold,threshold,Discretizing);scale$4(BinOrdinal,scaleBinOrdinal,[Discrete$1,Discretizing]);scale$4(Ordinal,ordinal,Discrete$1);scale$4(Band,band,Discrete$1);scale$4(Point,point$3,Discrete$1);function isValidScaleType(type){return scales.has(type)}function hasType(key,type){const s=scales.get(key);return s&&s.metadata[type]}function isContinuous$1(key){return hasType(key,Continuous)}function isDiscrete$2(key){return hasType(key,Discrete$1)}function isDiscretizing$1(key){return hasType(key,Discretizing)}function isLogarithmic(key){return hasType(key,Log)}function isTemporal(key){return hasType(key,Temporal)}function isInterpolating(key){return hasType(key,Interpolating)}function isQuantile$1(key){return hasType(key,Quantile)}const scaleProps=["clamp","base","constant","exponent"];function interpolateRange$1(interpolator,range){const start=range[0],span=peek$1(range)-start;return function(i){return interpolator(start+i*span)}}function interpolateColors(colors,type,gamma){return piecewise(interpolate$1(type||"rgb",gamma),colors)}function quantizeInterpolator(interpolator,count){const samples=new Array(count),n=count+1;for(let i=0;i<count;)samples[i]=interpolator(++i/n);return samples}function scaleFraction(scale$1,min,max){const delta=max-min;let i,t,s;if(!delta||!Number.isFinite(delta)){return constant$5(.5)}else{i=(t=scale$1.type).indexOf("-");t=i<0?t:t.slice(i+1);s=scale$4(t)().domain([min,max]).range([0,1]);scaleProps.forEach((m=>scale$1[m]?s[m](scale$1[m]()):0));return s}}function interpolate$1(type,gamma){const interp=$$1[method(type)];return gamma!=null&&interp&&interp.gamma?interp.gamma(gamma):interp}function method(type){return"interpolate"+type.toLowerCase().split("-").map((s=>s[0].toUpperCase()+s.slice(1))).join("")}const continuous={blues:"cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",greens:"d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",greys:"e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",oranges:"fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",purples:"e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",reds:"fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",blueGreen:"d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",bluePurple:"ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",greenBlue:"d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",orangeRed:"fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",purpleBlue:"dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",purpleBlueGreen:"dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",purpleRed:"dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",redPurple:"fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",yellowGreen:"e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",yellowOrangeBrown:"feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",yellowOrangeRed:"fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",blueOrange:"134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",brownBlueGreen:"704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",purpleGreen:"5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",purpleOrange:"4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",redBlue:"8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",redGrey:"8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",yellowGreenBlue:"eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",redYellowBlue:"a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",redYellowGreen:"a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",pinkYellowGreen:"8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",spectral:"9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",viridis:"440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",magma:"0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",inferno:"0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",plasma:"0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",cividis:"00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",rainbow:"6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",sinebow:"ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",turbo:"23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",browns:"eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",tealBlues:"bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",teals:"bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",warmGreys:"dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",goldGreen:"f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",goldOrange:"f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",goldRed:"f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",lightGreyRed:"efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",lightGreyTeal:"e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",lightMulti:"e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",lightOrange:"f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",lightTealBlue:"e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",darkBlue:"3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",darkGold:"3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",darkGreen:"3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",darkMulti:"3737371f5287197d8c29a86995ce3fffe800ffffff",darkRed:"3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"};const discrete={accent:schemeAccent,category10:schemeCategory10,category20:"1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",category20b:"393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",category20c:"3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",dark2:schemeDark2,observable10:schemeObservable10,paired:schemePaired,pastel1:schemePastel1,pastel2:schemePastel2,set1:schemeSet1,set2:schemeSet2,set3:schemeSet3,tableau10:"4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",tableau20:"4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"};function colors(palette){if(isArray(palette))return palette;const n=palette.length/6|0,c=new Array(n);for(let i=0;i<n;){c[i]="#"+palette.slice(i*6,++i*6)}return c}function apply(_,f){for(const k in _)scheme$1(k,f(_[k]))}const schemes={};apply(discrete,colors);apply(continuous,(_=>interpolateColors(colors(_))));function scheme$1(name,scheme){name=name&&name.toLowerCase();if(arguments.length>1){schemes[name]=scheme;return this}else{return schemes[name]}}const SymbolLegend="symbol";const DiscreteLegend="discrete";const GradientLegend="gradient";const defaultFormatter=value=>isArray(value)?value.map((v=>String(v))):String(value);const ascending=(a,b)=>a[1]-b[1];const descending=(a,b)=>b[1]-a[1];function tickCount(scale,count,minStep){let step;if(isNumber$1(count)){if(scale.bins){count=Math.max(count,scale.bins.length)}if(minStep!=null){count=Math.min(count,Math.floor(span(scale.domain())/minStep||1)+1)}}if(isObject(count)){step=count.step;count=count.interval}if(isString(count)){count=scale.type===Time?timeInterval(count):scale.type==UTC?utcInterval(count):error("Only time and utc scales accept interval strings.");if(step)count=count.every(step)}return count}function validTicks(scale,ticks,count){let range=scale.range(),lo=range[0],hi=peek$1(range),cmp=ascending;if(lo>hi){range=hi;hi=lo;lo=range;cmp=descending}lo=Math.floor(lo);hi=Math.ceil(hi);ticks=ticks.map((v=>[v,scale(v)])).filter((_=>lo<=_[1]&&_[1]<=hi)).sort(cmp).map((_=>_[0]));if(count>0&&ticks.length>1){const endpoints=[ticks[0],peek$1(ticks)];while(ticks.length>count&&ticks.length>=3){ticks=ticks.filter(((_,i)=>!(i%2)))}if(ticks.length<3){ticks=endpoints}}return ticks}function tickValues(scale,count){return scale.bins?validTicks(scale,scale.bins,count):scale.ticks?scale.ticks(count):scale.domain()}function tickFormat(locale,scale,count,specifier,formatType,noSkip){const type=scale.type;let format=defaultFormatter;if(type===Time||formatType===Time){format=locale.timeFormat(specifier)}else if(type===UTC||formatType===UTC){format=locale.utcFormat(specifier)}else if(isLogarithmic(type)){const varfmt=locale.formatFloat(specifier);if(noSkip||scale.bins){format=varfmt}else{const test=tickLog(scale,count,false);format=_=>test(_)?varfmt(_):""}}else if(scale.tickFormat){const d=scale.domain();format=locale.formatSpan(d[0],d[d.length-1],count,specifier)}else if(specifier){format=locale.format(specifier)}return format}function tickLog(scale,count,values){const ticks=tickValues(scale,count),base=scale.base(),logb=Math.log(base),k=Math.max(1,base*count/ticks.length);const test=d=>{let i=d/Math.pow(base,Math.round(Math.log(d)/logb));if(i*base<base-.5)i*=base;return i<=k};return values?ticks.filter(test):test}const symbols$2={[Quantile]:"quantiles",[Quantize]:"thresholds",[Threshold]:"domain"};const formats={[Quantile]:"quantiles",[Quantize]:"domain"};function labelValues(scale,count){return scale.bins?binValues(scale.bins):scale.type===Log?tickLog(scale,count,true):symbols$2[scale.type]?thresholdValues(scale[symbols$2[scale.type]]()):tickValues(scale,count)}function thresholdFormat(locale,scale,specifier){const _=scale[formats[scale.type]](),n=_.length;let d=n>1?_[1]-_[0]:_[0],i;for(i=1;i<n;++i){d=Math.min(d,_[i]-_[i-1])}return locale.formatSpan(0,d,3*10,specifier)}function thresholdValues(thresholds){const values=[-Infinity].concat(thresholds);values.max=+Infinity;return values}function binValues(bins){const values=bins.slice(0,-1);values.max=peek$1(bins);return values}const isDiscreteRange=scale=>symbols$2[scale.type]||scale.bins;function labelFormat(locale,scale,count,type,specifier,formatType,noSkip){const format=formats[scale.type]&&formatType!==Time&&formatType!==UTC?thresholdFormat(locale,scale,specifier):tickFormat(locale,scale,count,specifier,formatType,noSkip);return type===SymbolLegend&&isDiscreteRange(scale)?formatRange(format):type===DiscreteLegend?formatDiscrete(format):formatPoint(format)}const formatRange=format=>(value,index,array)=>{const limit=get$3(array[index+1],get$3(array.max,+Infinity)),lo=formatValue$1(value,format),hi=formatValue$1(limit,format);return lo&&hi?lo+" – "+hi:hi?"< "+hi:"≥ "+lo};const get$3=(value,dflt)=>value!=null?value:dflt;const formatDiscrete=format=>(value,index)=>index?format(value):null;const formatPoint=format=>value=>format(value);const formatValue$1=(value,format)=>Number.isFinite(value)?format(value):null;function labelFraction(scale){const domain=scale.domain(),count=domain.length-1;let lo=+domain[0],hi=+peek$1(domain),span=hi-lo;if(scale.type===Threshold){const adjust=count?span/count:.1;lo-=adjust;hi+=adjust;span=hi-lo}return value=>(value-lo)/span}function format$1(locale,scale,specifier,formatType){const type=formatType||scale.type;if(isString(specifier)&&isTemporal(type)){specifier=specifier.replace(/%a/g,"%A").replace(/%b/g,"%B")}return!specifier&&type===Time?locale.timeFormat("%A, %d %B %Y, %X"):!specifier&&type===UTC?locale.utcFormat("%A, %d %B %Y, %X UTC"):labelFormat(locale,scale,5,null,specifier,formatType,true)}function domainCaption(locale,scale,opt){opt=opt||{};const max=Math.max(3,opt.maxlen||7),fmt=format$1(locale,scale,opt.format,opt.formatType);if(isDiscretizing$1(scale.type)){const v=labelValues(scale).slice(1).map(fmt),n=v.length;return`${n} boundar${n===1?"y":"ies"}: ${v.join(", ")}`}else if(isDiscrete$2(scale.type)){const d=scale.domain(),n=d.length,v=n>max?d.slice(0,max-2).map(fmt).join(", ")+", ending with "+d.slice(-1).map(fmt):d.map(fmt).join(", ");return`${n} value${n===1?"":"s"}: ${v}`}else{const d=scale.domain();return`values from ${fmt(d[0])} to ${fmt(peek$1(d))}`}}let gradient_id=0;const patternPrefix="p_";function isGradient(value){return value&&value.gradient}function gradientRef(g,defs,base){const type=g.gradient;let id=g.id,prefix=type==="radial"?patternPrefix:"";if(!id){id=g.id="gradient_"+gradient_id++;if(type==="radial"){g.x1=get$2(g.x1,.5);g.y1=get$2(g.y1,.5);g.r1=get$2(g.r1,0);g.x2=get$2(g.x2,.5);g.y2=get$2(g.y2,.5);g.r2=get$2(g.r2,.5);prefix=patternPrefix}else{g.x1=get$2(g.x1,0);g.y1=get$2(g.y1,0);g.x2=get$2(g.x2,1);g.y2=get$2(g.y2,0)}}defs[id]=g;return"url("+(base||"")+"#"+prefix+id+")"}function get$2(val,def){return val!=null?val:def}function Gradient$1(p0,p1){var stops=[],gradient;return gradient={gradient:"linear",x1:p0?p0[0]:0,y1:p0?p0[1]:0,x2:p1?p1[0]:1,y2:p1?p1[1]:0,stops:stops,stop:function(offset,color){stops.push({offset:offset,color:color});return gradient}}}const lookup$4={basis:{curve:curveBasis},"basis-closed":{curve:curveBasisClosed},"basis-open":{curve:curveBasisOpen},bundle:{curve:curveBundle,tension:"beta",value:.85},cardinal:{curve:curveCardinal,tension:"tension",value:0},"cardinal-open":{curve:curveCardinalOpen,tension:"tension",value:0},"cardinal-closed":{curve:curveCardinalClosed,tension:"tension",value:0},"catmull-rom":{curve:curveCatmullRom,tension:"alpha",value:.5},"catmull-rom-closed":{curve:curveCatmullRomClosed,tension:"alpha",value:.5},"catmull-rom-open":{curve:curveCatmullRomOpen,tension:"alpha",value:.5},linear:{curve:curveLinear},"linear-closed":{curve:curveLinearClosed},monotone:{horizontal:monotoneY,vertical:monotoneX},natural:{curve:curveNatural},step:{curve:curveStep},"step-after":{curve:stepAfter},"step-before":{curve:stepBefore}};function curves(type,orientation,tension){var entry=has$1(lookup$4,type)&&lookup$4[type],curve=null;if(entry){curve=entry.curve||entry[orientation||"vertical"];if(entry.tension&&tension!=null){curve=curve[entry.tension](tension)}}return curve}const paramCounts={m:2,l:2,h:1,v:1,z:0,c:6,s:4,q:4,t:2,a:7};const commandPattern=/[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;const numberPattern=/^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;const spacePattern=/^((\s+,?\s*)|(,\s*))/;const flagPattern=/^[01]/;function parse$3(path){const commands=[];const matches=path.match(commandPattern)||[];matches.forEach((str=>{let cmd=str[0];const type=cmd.toLowerCase();const paramCount=paramCounts[type];const params=parseParams(type,paramCount,str.slice(1).trim());const count=params.length;if(count<paramCount||count&&count%paramCount!==0){throw Error("Invalid SVG path, incorrect parameter count")}commands.push([cmd,...params.slice(0,paramCount)]);if(count===paramCount){return}if(type==="m"){cmd=cmd==="M"?"L":"l"}for(let i=paramCount;i<count;i+=paramCount){commands.push([cmd,...params.slice(i,i+paramCount)])}}));return commands}function parseParams(type,paramCount,segment){const params=[];for(let index=0;paramCount&&index<segment.length;){for(let i=0;i<paramCount;++i){const pattern=type==="a"&&(i===3||i===4)?flagPattern:numberPattern;const match=segment.slice(index).match(pattern);if(match===null){throw Error("Invalid SVG path, incorrect parameter type")}index+=match[0].length;params.push(+match[0]);const ws=segment.slice(index).match(spacePattern);if(ws!==null){index+=ws[0].length}}}return params}const DegToRad=Math.PI/180;const Epsilon=1e-14;const HalfPi=Math.PI/2;const Tau=Math.PI*2;const HalfSqrt3=Math.sqrt(3)/2;var segmentCache={};var bezierCache={};var join$1=[].join;function segments(x,y,rx,ry,large,sweep,rotateX,ox,oy){const key=join$1.call(arguments);if(segmentCache[key]){return segmentCache[key]}const th=rotateX*DegToRad;const sin_th=Math.sin(th);const cos_th=Math.cos(th);rx=Math.abs(rx);ry=Math.abs(ry);const px=cos_th*(ox-x)*.5+sin_th*(oy-y)*.5;const py=cos_th*(oy-y)*.5-sin_th*(ox-x)*.5;let pl=px*px/(rx*rx)+py*py/(ry*ry);if(pl>1){pl=Math.sqrt(pl);rx*=pl;ry*=pl}const a00=cos_th/rx;const a01=sin_th/rx;const a10=-sin_th/ry;const a11=cos_th/ry;const x0=a00*ox+a01*oy;const y0=a10*ox+a11*oy;const x1=a00*x+a01*y;const y1=a10*x+a11*y;const d=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0);let sfactor_sq=1/d-.25;if(sfactor_sq<0)sfactor_sq=0;let sfactor=Math.sqrt(sfactor_sq);if(sweep==large)sfactor=-sfactor;const xc=.5*(x0+x1)-sfactor*(y1-y0);const yc=.5*(y0+y1)+sfactor*(x1-x0);const th0=Math.atan2(y0-yc,x0-xc);const th1=Math.atan2(y1-yc,x1-xc);let th_arc=th1-th0;if(th_arc<0&&sweep===1){th_arc+=Tau}else if(th_arc>0&&sweep===0){th_arc-=Tau}const segs=Math.ceil(Math.abs(th_arc/(HalfPi+.001)));const result=[];for(let i=0;i<segs;++i){const th2=th0+i*th_arc/segs;const th3=th0+(i+1)*th_arc/segs;result[i]=[xc,yc,th2,th3,rx,ry,sin_th,cos_th]}return segmentCache[key]=result}function bezier(params){const key=join$1.call(params);if(bezierCache[key]){return bezierCache[key]}var cx=params[0],cy=params[1],th0=params[2],th1=params[3],rx=params[4],ry=params[5],sin_th=params[6],cos_th=params[7];const a00=cos_th*rx;const a01=-sin_th*ry;const a10=sin_th*rx;const a11=cos_th*ry;const cos_th0=Math.cos(th0);const sin_th0=Math.sin(th0);const cos_th1=Math.cos(th1);const sin_th1=Math.sin(th1);const th_half=.5*(th1-th0);const sin_th_h2=Math.sin(th_half*.5);const t=8/3*sin_th_h2*sin_th_h2/Math.sin(th_half);const x1=cx+cos_th0-t*sin_th0;const y1=cy+sin_th0+t*cos_th0;const x3=cx+cos_th1;const y3=cy+sin_th1;const x2=x3+t*sin_th1;const y2=y3-t*cos_th1;return bezierCache[key]=[a00*x1+a01*y1,a10*x1+a11*y1,a00*x2+a01*y2,a10*x2+a11*y2,a00*x3+a01*y3,a10*x3+a11*y3]}const temp=["l",0,0,0,0,0,0,0];function scale$1$1(current,sX,sY){const c=temp[0]=current[0];if(c==="a"||c==="A"){temp[1]=sX*current[1];temp[2]=sY*current[2];temp[3]=current[3];temp[4]=current[4];temp[5]=current[5];temp[6]=sX*current[6];temp[7]=sY*current[7]}else if(c==="h"||c==="H"){temp[1]=sX*current[1]}else if(c==="v"||c==="V"){temp[1]=sY*current[1]}else{for(var i=1,n=current.length;i<n;++i){temp[i]=(i%2==1?sX:sY)*current[i]}}return temp}function pathRender(context,path,l,t,sX,sY){var current,previous=null,x=0,y=0,controlX=0,controlY=0,tempX,tempY,tempControlX,tempControlY,anchorX=0,anchorY=0;if(l==null)l=0;if(t==null)t=0;if(sX==null)sX=1;if(sY==null)sY=sX;if(context.beginPath)context.beginPath();for(var i=0,len=path.length;i<len;++i){current=path[i];if(sX!==1||sY!==1){current=scale$1$1(current,sX,sY)}switch(current[0]){case"l":x+=current[1];y+=current[2];context.lineTo(x+l,y+t);break;case"L":x=current[1];y=current[2];context.lineTo(x+l,y+t);break;case"h":x+=current[1];context.lineTo(x+l,y+t);break;case"H":x=current[1];context.lineTo(x+l,y+t);break;case"v":y+=current[1];context.lineTo(x+l,y+t);break;case"V":y=current[1];context.lineTo(x+l,y+t);break;case"m":x+=current[1];y+=current[2];anchorX=x;anchorY=y;context.moveTo(x+l,y+t);break;case"M":x=current[1];y=current[2];anchorX=x;anchorY=y;context.moveTo(x+l,y+t);break;case"c":tempX=x+current[5];tempY=y+current[6];controlX=x+current[3];controlY=y+current[4];context.bezierCurveTo(x+current[1]+l,y+current[2]+t,controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;break;case"C":x=current[5];y=current[6];controlX=current[3];controlY=current[4];context.bezierCurveTo(current[1]+l,current[2]+t,controlX+l,controlY+t,x+l,y+t);break;case"s":tempX=x+current[3];tempY=y+current[4];controlX=2*x-controlX;controlY=2*y-controlY;context.bezierCurveTo(controlX+l,controlY+t,x+current[1]+l,y+current[2]+t,tempX+l,tempY+t);controlX=x+current[1];controlY=y+current[2];x=tempX;y=tempY;break;case"S":tempX=current[3];tempY=current[4];controlX=2*x-controlX;controlY=2*y-controlY;context.bezierCurveTo(controlX+l,controlY+t,current[1]+l,current[2]+t,tempX+l,tempY+t);x=tempX;y=tempY;controlX=current[1];controlY=current[2];break;case"q":tempX=x+current[3];tempY=y+current[4];controlX=x+current[1];controlY=y+current[2];context.quadraticCurveTo(controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;break;case"Q":tempX=current[3];tempY=current[4];context.quadraticCurveTo(current[1]+l,current[2]+t,tempX+l,tempY+t);x=tempX;y=tempY;controlX=current[1];controlY=current[2];break;case"t":tempX=x+current[1];tempY=y+current[2];if(previous[0].match(/[QqTt]/)===null){controlX=x;controlY=y}else if(previous[0]==="t"){controlX=2*x-tempControlX;controlY=2*y-tempControlY}else if(previous[0]==="q"){controlX=2*x-controlX;controlY=2*y-controlY}tempControlX=controlX;tempControlY=controlY;context.quadraticCurveTo(controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;controlX=x+current[1];controlY=y+current[2];break;case"T":tempX=current[1];tempY=current[2];controlX=2*x-controlX;controlY=2*y-controlY;context.quadraticCurveTo(controlX+l,controlY+t,tempX+l,tempY+t);x=tempX;y=tempY;break;case"a":drawArc(context,x+l,y+t,[current[1],current[2],current[3],current[4],current[5],current[6]+x+l,current[7]+y+t]);x+=current[6];y+=current[7];break;case"A":drawArc(context,x+l,y+t,[current[1],current[2],current[3],current[4],current[5],current[6]+l,current[7]+t]);x=current[6];y=current[7];break;case"z":case"Z":x=anchorX;y=anchorY;context.closePath();break}previous=current}}function drawArc(context,x,y,coords){const seg=segments(coords[5],coords[6],coords[0],coords[1],coords[3],coords[4],coords[2],x,y);for(let i=0;i<seg.length;++i){const bez=bezier(seg[i]);context.bezierCurveTo(bez[0],bez[1],bez[2],bez[3],bez[4],bez[5])}}const Tan30=.5773502691896257;const builtins={circle:{draw:function(context,size){const r=Math.sqrt(size)/2;context.moveTo(r,0);context.arc(0,0,r,0,Tau)}},cross:{draw:function(context,size){var r=Math.sqrt(size)/2,s=r/2.5;context.moveTo(-r,-s);context.lineTo(-r,s);context.lineTo(-s,s);context.lineTo(-s,r);context.lineTo(s,r);context.lineTo(s,s);context.lineTo(r,s);context.lineTo(r,-s);context.lineTo(s,-s);context.lineTo(s,-r);context.lineTo(-s,-r);context.lineTo(-s,-s);context.closePath()}},diamond:{draw:function(context,size){const r=Math.sqrt(size)/2;context.moveTo(-r,0);context.lineTo(0,-r);context.lineTo(r,0);context.lineTo(0,r);context.closePath()}},square:{draw:function(context,size){var w=Math.sqrt(size),x=-w/2;context.rect(x,x,w,w)}},arrow:{draw:function(context,size){var r=Math.sqrt(size)/2,s=r/7,t=r/2.5,v=r/8;context.moveTo(-s,r);context.lineTo(s,r);context.lineTo(s,-v);context.lineTo(t,-v);context.lineTo(0,-r);context.lineTo(-t,-v);context.lineTo(-s,-v);context.closePath()}},wedge:{draw:function(context,size){var r=Math.sqrt(size)/2,h=HalfSqrt3*r,o=h-r*Tan30,b=r/4;context.moveTo(0,-h-o);context.lineTo(-b,h-o);context.lineTo(b,h-o);context.closePath()}},triangle:{draw:function(context,size){var r=Math.sqrt(size)/2,h=HalfSqrt3*r,o=h-r*Tan30;context.moveTo(0,-h-o);context.lineTo(-r,h-o);context.lineTo(r,h-o);context.closePath()}},"triangle-up":{draw:function(context,size){var r=Math.sqrt(size)/2,h=HalfSqrt3*r;context.moveTo(0,-h);context.lineTo(-r,h);context.lineTo(r,h);context.closePath()}},"triangle-down":{draw:function(context,size){var r=Math.sqrt(size)/2,h=HalfSqrt3*r;context.moveTo(0,h);context.lineTo(-r,-h);context.lineTo(r,-h);context.closePath()}},"triangle-right":{draw:function(context,size){var r=Math.sqrt(size)/2,h=HalfSqrt3*r;context.moveTo(h,0);context.lineTo(-h,-r);context.lineTo(-h,r);context.closePath()}},"triangle-left":{draw:function(context,size){var r=Math.sqrt(size)/2,h=HalfSqrt3*r;context.moveTo(-h,0);context.lineTo(h,-r);context.lineTo(h,r);context.closePath()}},stroke:{draw:function(context,size){const r=Math.sqrt(size)/2;context.moveTo(-r,0);context.lineTo(r,0)}}};function symbols$1(_){return has$1(builtins,_)?builtins[_]:customSymbol(_)}var custom={};function customSymbol(path){if(!has$1(custom,path)){const parsed=parse$3(path);custom[path]={draw:function(context,size){pathRender(context,parsed,0,0,Math.sqrt(size)/2)}}}return custom[path]}const C=.448084975506;function rectangleX(d){return d.x}function rectangleY(d){return d.y}function rectangleWidth(d){return d.width}function rectangleHeight(d){return d.height}function number$3(_){return typeof _==="function"?_:()=>+_}function clamp(value,min,max){return Math.max(min,Math.min(value,max))}function vg_rect(){var x=rectangleX,y=rectangleY,width=rectangleWidth,height=rectangleHeight,crTL=number$3(0),crTR=crTL,crBL=crTL,crBR=crTL,context=null;function rectangle(_,x0,y0){var buffer,x1=x0!=null?x0:+x.call(this,_),y1=y0!=null?y0:+y.call(this,_),w=+width.call(this,_),h=+height.call(this,_),s=Math.min(w,h)/2,tl=clamp(+crTL.call(this,_),0,s),tr=clamp(+crTR.call(this,_),0,s),bl=clamp(+crBL.call(this,_),0,s),br=clamp(+crBR.call(this,_),0,s);if(!context)context=buffer=path$3();if(tl<=0&&tr<=0&&bl<=0&&br<=0){context.rect(x1,y1,w,h)}else{var x2=x1+w,y2=y1+h;context.moveTo(x1+tl,y1);context.lineTo(x2-tr,y1);context.bezierCurveTo(x2-C*tr,y1,x2,y1+C*tr,x2,y1+tr);context.lineTo(x2,y2-br);context.bezierCurveTo(x2,y2-C*br,x2-C*br,y2,x2-br,y2);context.lineTo(x1+bl,y2);context.bezierCurveTo(x1+C*bl,y2,x1,y2-C*bl,x1,y2-bl);context.lineTo(x1,y1+tl);context.bezierCurveTo(x1,y1+C*tl,x1+C*tl,y1,x1+tl,y1);context.closePath()}if(buffer){context=null;return buffer+""||null}}rectangle.x=function(_){if(arguments.length){x=number$3(_);return rectangle}else{return x}};rectangle.y=function(_){if(arguments.length){y=number$3(_);return rectangle}else{return y}};rectangle.width=function(_){if(arguments.length){width=number$3(_);return rectangle}else{return width}};rectangle.height=function(_){if(arguments.length){height=number$3(_);return rectangle}else{return height}};rectangle.cornerRadius=function(tl,tr,br,bl){if(arguments.length){crTL=number$3(tl);crTR=tr!=null?number$3(tr):crTL;crBR=br!=null?number$3(br):crTL;crBL=bl!=null?number$3(bl):crTR;return rectangle}else{return crTL}};rectangle.context=function(_){if(arguments.length){context=_==null?null:_;return rectangle}else{return context}};return rectangle}function vg_trail(){var x,y,size,defined,context=null,ready,x1,y1,r1;function point(x2,y2,w2){const r2=w2/2;if(ready){var ux=y1-y2,uy=x2-x1;if(ux||uy){var ud=Math.hypot(ux,uy),rx=(ux/=ud)*r1,ry=(uy/=ud)*r1,t=Math.atan2(uy,ux);context.moveTo(x1-rx,y1-ry);context.lineTo(x2-ux*r2,y2-uy*r2);context.arc(x2,y2,r2,t-Math.PI,t);context.lineTo(x1+rx,y1+ry);context.arc(x1,y1,r1,t,t+Math.PI)}else{context.arc(x2,y2,r2,0,Tau)}context.closePath()}else{ready=1}x1=x2;y1=y2;r1=r2}function trail(data){var i,n=data.length,d,defined0=false,buffer;if(context==null)context=buffer=path$3();for(i=0;i<=n;++i){if(!(i<n&&defined(d=data[i],i,data))===defined0){if(defined0=!defined0)ready=0}if(defined0)point(+x(d,i,data),+y(d,i,data),+size(d,i,data))}if(buffer){context=null;return buffer+""||null}}trail.x=function(_){if(arguments.length){x=_;return trail}else{return x}};trail.y=function(_){if(arguments.length){y=_;return trail}else{return y}};trail.size=function(_){if(arguments.length){size=_;return trail}else{return size}};trail.defined=function(_){if(arguments.length){defined=_;return trail}else{return defined}};trail.context=function(_){if(arguments.length){if(_==null){context=null}else{context=_}return trail}else{return context}};return trail}function value$1(a,b){return a!=null?a:b}const x$2=item=>item.x||0,y$2=item=>item.y||0,w=item=>item.width||0,h=item=>item.height||0,xw=item=>(item.x||0)+(item.width||0),yh=item=>(item.y||0)+(item.height||0),sa=item=>item.startAngle||0,ea=item=>item.endAngle||0,pa=item=>item.padAngle||0,ir=item=>item.innerRadius||0,or=item=>item.outerRadius||0,cr=item=>item.cornerRadius||0,tl=item=>value$1(item.cornerRadiusTopLeft,item.cornerRadius)||0,tr=item=>value$1(item.cornerRadiusTopRight,item.cornerRadius)||0,br=item=>value$1(item.cornerRadiusBottomRight,item.cornerRadius)||0,bl=item=>value$1(item.cornerRadiusBottomLeft,item.cornerRadius)||0,sz=item=>value$1(item.size,64),ts=item=>item.size||1,def=item=>!(item.defined===false),type$1=item=>symbols$1(item.shape||"circle");const arcShape=arc$2$1().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),areavShape=area$2$1().x(x$2).y1(y$2).y0(yh).defined(def),areahShape=area$2$1().y(y$2).x1(x$2).x0(xw).defined(def),lineShape=line$2$1().x(x$2).y(y$2).defined(def),rectShape=vg_rect().x(x$2).y(y$2).width(w).height(h).cornerRadius(tl,tr,br,bl),symbolShape=Symbol$1().type(type$1).size(sz),trailShape=vg_trail().x(x$2).y(y$2).defined(def).size(ts);function hasCornerRadius(item){return item.cornerRadius||item.cornerRadiusTopLeft||item.cornerRadiusTopRight||item.cornerRadiusBottomRight||item.cornerRadiusBottomLeft}function arc$1$1(context,item){return arcShape.context(context)(item)}function area$1$1(context,items){const item=items[0],interp=item.interpolate||"linear";return(item.orient==="horizontal"?areahShape:areavShape).curve(curves(interp,item.orient,item.tension)).context(context)(items)}function line$1$1(context,items){const item=items[0],interp=item.interpolate||"linear";return lineShape.curve(curves(interp,item.orient,item.tension)).context(context)(items)}function rectangle(context,item,x,y){return rectShape.context(context)(item,x,y)}function shape$1(context,item){return(item.mark.shape||item.shape).context(context)(item)}function symbol$1(context,item){return symbolShape.context(context)(item)}function trail$1(context,items){return trailShape.context(context)(items)}var clip_id=1;function clip$1$1(renderer,item,size){var clip=item.clip,defs=renderer._defs,id=item.clip_id||(item.clip_id="clip"+clip_id++),c=defs.clipping[id]||(defs.clipping[id]={id:id});if(isFunction(clip)){c.path=clip(null)}else if(hasCornerRadius(size)){c.path=rectangle(null,size,0,0)}else{c.width=size.width||0;c.height=size.height||0}return"url(#"+id+")"}function Bounds(b){this.clear();if(b)this.union(b)}Bounds.prototype={clone(){return new Bounds(this)},clear(){this.x1=+Number.MAX_VALUE;this.y1=+Number.MAX_VALUE;this.x2=-Number.MAX_VALUE;this.y2=-Number.MAX_VALUE;return this},empty(){return this.x1===+Number.MAX_VALUE&&this.y1===+Number.MAX_VALUE&&this.x2===-Number.MAX_VALUE&&this.y2===-Number.MAX_VALUE},equals(b){return this.x1===b.x1&&this.y1===b.y1&&this.x2===b.x2&&this.y2===b.y2},set(x1,y1,x2,y2){if(x2<x1){this.x2=x1;this.x1=x2}else{this.x1=x1;this.x2=x2}if(y2<y1){this.y2=y1;this.y1=y2}else{this.y1=y1;this.y2=y2}return this},add(x,y){if(x<this.x1)this.x1=x;if(y<this.y1)this.y1=y;if(x>this.x2)this.x2=x;if(y>this.y2)this.y2=y;return this},expand(d){this.x1-=d;this.y1-=d;this.x2+=d;this.y2+=d;return this},round(){this.x1=Math.floor(this.x1);this.y1=Math.floor(this.y1);this.x2=Math.ceil(this.x2);this.y2=Math.ceil(this.y2);return this},scale(s){this.x1*=s;this.y1*=s;this.x2*=s;this.y2*=s;return this},translate(dx,dy){this.x1+=dx;this.x2+=dx;this.y1+=dy;this.y2+=dy;return this},rotate(angle,x,y){const p=this.rotatedPoints(angle,x,y);return this.clear().add(p[0],p[1]).add(p[2],p[3]).add(p[4],p[5]).add(p[6],p[7])},rotatedPoints(angle,x,y){var{x1:x1,y1:y1,x2:x2,y2:y2}=this,cos=Math.cos(angle),sin=Math.sin(angle),cx=x-x*cos+y*sin,cy=y-x*sin-y*cos;return[cos*x1-sin*y1+cx,sin*x1+cos*y1+cy,cos*x1-sin*y2+cx,sin*x1+cos*y2+cy,cos*x2-sin*y1+cx,sin*x2+cos*y1+cy,cos*x2-sin*y2+cx,sin*x2+cos*y2+cy]},union(b){if(b.x1<this.x1)this.x1=b.x1;if(b.y1<this.y1)this.y1=b.y1;if(b.x2>this.x2)this.x2=b.x2;if(b.y2>this.y2)this.y2=b.y2;return this},intersect(b){if(b.x1>this.x1)this.x1=b.x1;if(b.y1>this.y1)this.y1=b.y1;if(b.x2<this.x2)this.x2=b.x2;if(b.y2<this.y2)this.y2=b.y2;return this},encloses(b){return b&&this.x1<=b.x1&&this.x2>=b.x2&&this.y1<=b.y1&&this.y2>=b.y2},alignsWith(b){return b&&(this.x1==b.x1||this.x2==b.x2||this.y1==b.y1||this.y2==b.y2)},intersects(b){return b&&!(this.x2<b.x1||this.x1>b.x2||this.y2<b.y1||this.y1>b.y2)},contains(x,y){return!(x<this.x1||x>this.x2||y<this.y1||y>this.y2)},width(){return this.x2-this.x1},height(){return this.y2-this.y1}};function Item(mark){this.mark=mark;this.bounds=this.bounds||new Bounds}function GroupItem(mark){Item.call(this,mark);this.items=this.items||[]}inherits(GroupItem,Item);class ResourceLoader{constructor(customLoader){this._pending=0;this._loader=customLoader||loader()}pending(){return this._pending}sanitizeURL(uri){const loader=this;increment(loader);return loader._loader.sanitize(uri,{context:"href"}).then((opt=>{decrement(loader);return opt})).catch((()=>{decrement(loader);return null}))}loadImage(uri){const loader=this,Image=image$2();increment(loader);return loader._loader.sanitize(uri,{context:"image"}).then((opt=>{const url=opt.href;if(!url||!Image)throw{url:url};const img=new Image;const cors=has$1(opt,"crossOrigin")?opt.crossOrigin:"anonymous";if(cors!=null)img.crossOrigin=cors;img.onload=()=>decrement(loader);img.onerror=()=>decrement(loader);img.src=url;return img})).catch((e=>{decrement(loader);return{complete:false,width:0,height:0,src:e&&e.url||""}}))}ready(){const loader=this;return new Promise((accept=>{function poll(value){if(!loader.pending())accept(value);else setTimeout((()=>{poll(true)}),10)}poll(false)}))}}function increment(loader){loader._pending+=1}function decrement(loader){loader._pending-=1}function boundStroke(bounds,item,miter){if(item.stroke&&item.opacity!==0&&item.strokeOpacity!==0){const sw=item.strokeWidth!=null?+item.strokeWidth:1;bounds.expand(sw+(miter?miterAdjustment(item,sw):0))}return bounds}function miterAdjustment(item,strokeWidth){return item.strokeJoin&&item.strokeJoin!=="miter"?0:strokeWidth}const circleThreshold=Tau-1e-8;let bounds,lx,ly,rot,ma,mb,mc,md;const add$2=(x,y)=>bounds.add(x,y);const addL=(x,y)=>add$2(lx=x,ly=y);const addX=x=>add$2(x,bounds.y1);const addY=y=>add$2(bounds.x1,y);const px=(x,y)=>ma*x+mc*y;const py=(x,y)=>mb*x+md*y;const addp=(x,y)=>add$2(px(x,y),py(x,y));const addpL=(x,y)=>addL(px(x,y),py(x,y));function boundContext(_,deg){bounds=_;if(deg){rot=deg*DegToRad;ma=md=Math.cos(rot);mb=Math.sin(rot);mc=-mb}else{ma=md=1;rot=mb=mc=0}return context$1}const context$1={beginPath(){},closePath(){},moveTo:addpL,lineTo:addpL,rect(x,y,w,h){if(rot){addp(x+w,y);addp(x+w,y+h);addp(x,y+h);addpL(x,y)}else{add$2(x+w,y+h);addL(x,y)}},quadraticCurveTo(x1,y1,x2,y2){const px1=px(x1,y1),py1=py(x1,y1),px2=px(x2,y2),py2=py(x2,y2);quadExtrema(lx,px1,px2,addX);quadExtrema(ly,py1,py2,addY);addL(px2,py2)},bezierCurveTo(x1,y1,x2,y2,x3,y3){const px1=px(x1,y1),py1=py(x1,y1),px2=px(x2,y2),py2=py(x2,y2),px3=px(x3,y3),py3=py(x3,y3);cubicExtrema(lx,px1,px2,px3,addX);cubicExtrema(ly,py1,py2,py3,addY);addL(px3,py3)},arc(cx,cy,r,sa,ea,ccw){sa+=rot;ea+=rot;lx=r*Math.cos(ea)+cx;ly=r*Math.sin(ea)+cy;if(Math.abs(ea-sa)>circleThreshold){add$2(cx-r,cy-r);add$2(cx+r,cy+r)}else{const update=a=>add$2(r*Math.cos(a)+cx,r*Math.sin(a)+cy);let s,i;update(sa);update(ea);if(ea!==sa){sa=sa%Tau;if(sa<0)sa+=Tau;ea=ea%Tau;if(ea<0)ea+=Tau;if(ea<sa){ccw=!ccw;s=sa;sa=ea;ea=s}if(ccw){ea-=Tau;s=sa-sa%HalfPi;for(i=0;i<4&&s>ea;++i,s-=HalfPi)update(s)}else{s=sa-sa%HalfPi+HalfPi;for(i=0;i<4&&s<ea;++i,s=s+HalfPi)update(s)}}}}};function quadExtrema(x0,x1,x2,cb){const t=(x0-x1)/(x0+x2-2*x1);if(0<t&&t<1)cb(x0+(x1-x0)*t)}function cubicExtrema(x0,x1,x2,x3,cb){const a=x3-x0+3*x1-3*x2,b=x0+x2-2*x1,c=x0-x1;let t0=0,t1=0,r;if(Math.abs(a)>Epsilon){r=b*b+c*a;if(r>=0){r=Math.sqrt(r);t0=(-b+r)/a;t1=(-b-r)/a}}else{t0=.5*c/b}if(0<t0&&t0<1)cb(cubic(t0,x0,x1,x2,x3));if(0<t1&&t1<1)cb(cubic(t1,x0,x1,x2,x3))}function cubic(t,x0,x1,x2,x3){const s=1-t,s2=s*s,t2=t*t;return s2*s*x0+3*s2*t*x1+3*s*t2*x2+t2*t*x3}var context$2=(context$2=canvas(1,1))?context$2.getContext("2d"):null;const b=new Bounds;function intersectPath(draw){return function(item,brush){if(!context$2)return true;draw(context$2,item);b.clear().union(item.bounds).intersect(brush).round();const{x1:x1,y1:y1,x2:x2,y2:y2}=b;for(let y=y1;y<=y2;++y){for(let x=x1;x<=x2;++x){if(context$2.isPointInPath(x,y)){return true}}}return false}}function intersectPoint(item,box){return box.contains(item.x||0,item.y||0)}function intersectRect(item,box){const x=item.x||0,y=item.y||0,w=item.width||0,h=item.height||0;return box.intersects(b.set(x,y,x+w,y+h))}function intersectRule(item,box){const x=item.x||0,y=item.y||0,x2=item.x2!=null?item.x2:x,y2=item.y2!=null?item.y2:y;return intersectBoxLine(box,x,y,x2,y2)}function intersectBoxLine(box,x,y,u,v){const{x1:x1,y1:y1,x2:x2,y2:y2}=box,dx=u-x,dy=v-y;let t0=0,t1=1,p,q,r,e;for(e=0;e<4;++e){if(e===0){p=-dx;q=-(x1-x)}if(e===1){p=dx;q=x2-x}if(e===2){p=-dy;q=-(y1-y)}if(e===3){p=dy;q=y2-y}if(Math.abs(p)<1e-10&&q<0)return false;r=q/p;if(p<0){if(r>t1)return false;else if(r>t0)t0=r}else if(p>0){if(r<t0)return false;else if(r<t1)t1=r}}return true}function blend(context,item){context.globalCompositeOperation=item.blend||"source-over"}function value$2(value,dflt){return value==null?dflt:value}function addStops(gradient,stops){const n=stops.length;for(let i=0;i<n;++i){gradient.addColorStop(stops[i].offset,stops[i].color)}return gradient}function gradient$2(context,spec,bounds){const w=bounds.width(),h=bounds.height();let gradient;if(spec.gradient==="radial"){gradient=context.createRadialGradient(bounds.x1+value$2(spec.x1,.5)*w,bounds.y1+value$2(spec.y1,.5)*h,Math.max(w,h)*value$2(spec.r1,0),bounds.x1+value$2(spec.x2,.5)*w,bounds.y1+value$2(spec.y2,.5)*h,Math.max(w,h)*value$2(spec.r2,.5))}else{const x1=value$2(spec.x1,0),y1=value$2(spec.y1,0),x2=value$2(spec.x2,1),y2=value$2(spec.y2,0);if(x1===x2||y1===y2||w===h){gradient=context.createLinearGradient(bounds.x1+x1*w,bounds.y1+y1*h,bounds.x1+x2*w,bounds.y1+y2*h)}else{const image=canvas(Math.ceil(w),Math.ceil(h)),ictx=image.getContext("2d");ictx.scale(w,h);ictx.fillStyle=addStops(ictx.createLinearGradient(x1,y1,x2,y2),spec.stops);ictx.fillRect(0,0,w,h);return context.createPattern(image,"no-repeat")}}return addStops(gradient,spec.stops)}function color$2(context,item,value){return isGradient(value)?gradient$2(context,value,item.bounds):value}function fill(context,item,opacity){opacity*=item.fillOpacity==null?1:item.fillOpacity;if(opacity>0){context.globalAlpha=opacity;context.fillStyle=color$2(context,item,item.fill);return true}else{return false}}var Empty=[];function stroke(context,item,opacity){var lw=(lw=item.strokeWidth)!=null?lw:1;if(lw<=0)return false;opacity*=item.strokeOpacity==null?1:item.strokeOpacity;if(opacity>0){context.globalAlpha=opacity;context.strokeStyle=color$2(context,item,item.stroke);context.lineWidth=lw;context.lineCap=item.strokeCap||"butt";context.lineJoin=item.strokeJoin||"miter";context.miterLimit=item.strokeMiterLimit||10;if(context.setLineDash){context.setLineDash(item.strokeDash||Empty);context.lineDashOffset=item.strokeDashOffset||0}return true}else{return false}}function compare(a,b){return a.zindex-b.zindex||a.index-b.index}function zorder(scene){if(!scene.zdirty)return scene.zitems;var items=scene.items,output=[],item,i,n;for(i=0,n=items.length;i<n;++i){item=items[i];item.index=i;if(item.zindex)output.push(item)}scene.zdirty=false;return scene.zitems=output.sort(compare)}function visit(scene,visitor){var items=scene.items,i,n;if(!items||!items.length)return;const zitems=zorder(scene);if(zitems&&zitems.length){for(i=0,n=items.length;i<n;++i){if(!items[i].zindex)visitor(items[i])}items=zitems}for(i=0,n=items.length;i<n;++i){visitor(items[i])}}function pickVisit(scene,visitor){var items=scene.items,hit,i;if(!items||!items.length)return null;const zitems=zorder(scene);if(zitems&&zitems.length)items=zitems;for(i=items.length;--i>=0;){if(hit=visitor(items[i]))return hit}if(items===zitems){for(items=scene.items,i=items.length;--i>=0;){if(!items[i].zindex){if(hit=visitor(items[i]))return hit}}}return null}function drawAll(path){return function(context,scene,bounds){visit(scene,(item=>{if(!bounds||bounds.intersects(item.bounds)){drawPath(path,context,item,item)}}))}}function drawOne(path){return function(context,scene,bounds){if(scene.items.length&&(!bounds||bounds.intersects(scene.bounds))){drawPath(path,context,scene.items[0],scene.items)}}}function drawPath(path,context,item,items){var opacity=item.opacity==null?1:item.opacity;if(opacity===0)return;if(path(context,items))return;blend(context,item);if(item.fill&&fill(context,item,opacity)){context.fill()}if(item.stroke&&stroke(context,item,opacity)){context.stroke()}}function pick$1(test){test=test||truthy;return function(context,scene,x,y,gx,gy){x*=context.pixelRatio;y*=context.pixelRatio;return pickVisit(scene,(item=>{const b=item.bounds;if(b&&!b.contains(gx,gy)||!b)return;if(test(context,item,x,y,gx,gy))return item}))}}function hitPath(path,filled){return function(context,o,x,y){var item=Array.isArray(o)?o[0]:o,fill=filled==null?item.fill:filled,stroke=item.stroke&&context.isPointInStroke,lw,lc;if(stroke){lw=item.strokeWidth;lc=item.strokeCap;context.lineWidth=lw!=null?lw:1;context.lineCap=lc!=null?lc:"butt"}return path(context,o)?false:fill&&context.isPointInPath(x,y)||stroke&&context.isPointInStroke(x,y)}}function pickPath(path){return pick$1(hitPath(path))}function translate$2(x,y){return"translate("+x+","+y+")"}function rotate(a){return"rotate("+a+")"}function scale$3(scaleX,scaleY){return"scale("+scaleX+","+scaleY+")"}function translateItem(item){return translate$2(item.x||0,item.y||0)}function rotateItem(item){return translate$2(item.x||0,item.y||0)+(item.angle?" "+rotate(item.angle):"")}function transformItem(item){return translate$2(item.x||0,item.y||0)+(item.angle?" "+rotate(item.angle):"")+(item.scaleX||item.scaleY?" "+scale$3(item.scaleX||1,item.scaleY||1):"")}function markItemPath(type,shape,isect){function attr(emit,item){emit("transform",rotateItem(item));emit("d",shape(null,item))}function bound(bounds,item){shape(boundContext(bounds,item.angle),item);return boundStroke(bounds,item).translate(item.x||0,item.y||0)}function draw(context,item){var x=item.x||0,y=item.y||0,a=item.angle||0;context.translate(x,y);if(a)context.rotate(a*=DegToRad);context.beginPath();shape(context,item);if(a)context.rotate(-a);context.translate(-x,-y)}return{type:type,tag:"path",nested:false,attr:attr,bound:bound,draw:drawAll(draw),pick:pickPath(draw),isect:isect||intersectPath(draw)}}var arc$2=markItemPath("arc",arc$1$1);function pickArea(a,p){var v=a[0].orient==="horizontal"?p[1]:p[0],z=a[0].orient==="horizontal"?"y":"x",i=a.length,min=+Infinity,hit,d;while(--i>=0){if(a[i].defined===false)continue;d=Math.abs(a[i][z]-v);if(d<min){min=d;hit=a[i]}}return hit}function pickLine(a,p){var t=Math.pow(a[0].strokeWidth||1,2),i=a.length,dx,dy,dd;while(--i>=0){if(a[i].defined===false)continue;dx=a[i].x-p[0];dy=a[i].y-p[1];dd=dx*dx+dy*dy;if(dd<t)return a[i]}return null}function pickTrail(a,p){var i=a.length,dx,dy,dd;while(--i>=0){if(a[i].defined===false)continue;dx=a[i].x-p[0];dy=a[i].y-p[1];dd=dx*dx+dy*dy;dx=a[i].size||1;if(dd<dx*dx)return a[i]}return null}function markMultiItemPath(type,shape,tip){function attr(emit,item){var items=item.mark.items;if(items.length)emit("d",shape(null,items))}function bound(bounds,mark){var items=mark.items;if(items.length===0){return bounds}else{shape(boundContext(bounds),items);return boundStroke(bounds,items[0])}}function draw(context,items){context.beginPath();shape(context,items)}const hit=hitPath(draw);function pick(context,scene,x,y,gx,gy){var items=scene.items,b=scene.bounds;if(!items||!items.length||b&&!b.contains(gx,gy)){return null}x*=context.pixelRatio;y*=context.pixelRatio;return hit(context,items,x,y)?items[0]:null}return{type:type,tag:"path",nested:true,attr:attr,bound:bound,draw:drawOne(draw),pick:pick,isect:intersectPoint,tip:tip}}var area$2=markMultiItemPath("area",area$1$1,pickArea);function clip$2(context,scene){var clip=scene.clip;context.save();if(isFunction(clip)){context.beginPath();clip(context);context.clip()}else{clipGroup(context,scene.group)}}function clipGroup(context,group){context.beginPath();hasCornerRadius(group)?rectangle(context,group,0,0):context.rect(0,0,group.width||0,group.height||0);context.clip()}function offset$1(item){const sw=value$2(item.strokeWidth,1);return item.strokeOffset!=null?item.strokeOffset:item.stroke&&sw>.5&&sw<1.5?.5-Math.abs(sw-1):0}function attr$5(emit,item){emit("transform",translateItem(item))}function emitRectangle(emit,item){const off=offset$1(item);emit("d",rectangle(null,item,off,off))}function background$1(emit,item){emit("class","background");emit("aria-hidden",true);emitRectangle(emit,item)}function foreground(emit,item){emit("class","foreground");emit("aria-hidden",true);if(item.strokeForeground){emitRectangle(emit,item)}else{emit("d","")}}function content(emit,item,renderer){const url=item.clip?clip$1$1(renderer,item,item):null;emit("clip-path",url)}function bound$5(bounds,group){if(!group.clip&&group.items){const items=group.items,m=items.length;for(let j=0;j<m;++j){bounds.union(items[j].bounds)}}if((group.clip||group.width||group.height)&&!group.noBound){bounds.add(0,0).add(group.width||0,group.height||0)}boundStroke(bounds,group);return bounds.translate(group.x||0,group.y||0)}function rectanglePath(context,group,x,y){const off=offset$1(group);context.beginPath();rectangle(context,group,(x||0)+off,(y||0)+off)}const hitBackground=hitPath(rectanglePath);const hitForeground=hitPath(rectanglePath,false);const hitCorner=hitPath(rectanglePath,true);function draw$4(context,scene,bounds,markTypes){visit(scene,(group=>{const gx=group.x||0,gy=group.y||0,fore=group.strokeForeground,opacity=group.opacity==null?1:group.opacity;if((group.stroke||group.fill)&&opacity){rectanglePath(context,group,gx,gy);blend(context,group);if(group.fill&&fill(context,group,opacity)){context.fill()}if(group.stroke&&!fore&&stroke(context,group,opacity)){context.stroke()}}context.save();context.translate(gx,gy);if(group.clip)clipGroup(context,group);if(bounds)bounds.translate(-gx,-gy);visit(group,(item=>{if(item.marktype==="group"||markTypes==null||markTypes.includes(item.marktype)){this.draw(context,item,bounds,markTypes)}}));if(bounds)bounds.translate(gx,gy);context.restore();if(fore&&group.stroke&&opacity){rectanglePath(context,group,gx,gy);blend(context,group);if(stroke(context,group,opacity)){context.stroke()}}}))}function pick$2(context,scene,x,y,gx,gy){if(scene.bounds&&!scene.bounds.contains(gx,gy)||!scene.items){return null}const cx=x*context.pixelRatio,cy=y*context.pixelRatio;return pickVisit(scene,(group=>{let hit,dx,dy;const b=group.bounds;if(b&&!b.contains(gx,gy))return;dx=group.x||0;dy=group.y||0;const dw=dx+(group.width||0),dh=dy+(group.height||0),c=group.clip;if(c&&(gx<dx||gx>dw||gy<dy||gy>dh))return;context.save();context.translate(dx,dy);dx=gx-dx;dy=gy-dy;if(c&&hasCornerRadius(group)&&!hitCorner(context,group,cx,cy)){context.restore();return null}const fore=group.strokeForeground,ix=scene.interactive!==false;if(ix&&fore&&group.stroke&&hitForeground(context,group,cx,cy)){context.restore();return group}hit=pickVisit(group,(mark=>pickMark(mark,dx,dy)?this.pick(mark,x,y,dx,dy):null));if(!hit&&ix&&(group.fill||!fore&&group.stroke)&&hitBackground(context,group,cx,cy)){hit=group}context.restore();return hit||null}))}function pickMark(mark,x,y){return(mark.interactive!==false||mark.marktype==="group")&&mark.bounds&&mark.bounds.contains(x,y)}var group={type:"group",tag:"g",nested:false,attr:attr$5,bound:bound$5,draw:draw$4,pick:pick$2,isect:intersectRect,content:content,background:background$1,foreground:foreground};var metadata={xmlns:"http://www.w3.org/2000/svg","xmlns:xlink":"http://www.w3.org/1999/xlink",version:"1.1"};function getImage(item,renderer){var image=item.image;if(!image||item.url&&item.url!==image.url){image={complete:false,width:0,height:0};renderer.loadImage(item.url).then((image=>{item.image=image;item.image.url=item.url}))}return image}function imageWidth(item,image){return item.width!=null?item.width:!image||!image.width?0:item.aspect!==false&&item.height?item.height*image.width/image.height:image.width}function imageHeight(item,image){return item.height!=null?item.height:!image||!image.height?0:item.aspect!==false&&item.width?item.width*image.height/image.width:image.height}function imageXOffset(align,w){return align==="center"?w/2:align==="right"?w:0}function imageYOffset(baseline,h){return baseline==="middle"?h/2:baseline==="bottom"?h:0}function attr$4(emit,item,renderer){const img=getImage(item,renderer),w=imageWidth(item,img),h=imageHeight(item,img),x=(item.x||0)-imageXOffset(item.align,w),y=(item.y||0)-imageYOffset(item.baseline,h),i=!img.src&&img.toDataURL?img.toDataURL():img.src||"";emit("href",i,metadata["xmlns:xlink"],"xlink:href");emit("transform",translate$2(x,y));emit("width",w);emit("height",h);emit("preserveAspectRatio",item.aspect===false?"none":"xMidYMid")}function bound$4(bounds,item){const img=item.image,w=imageWidth(item,img),h=imageHeight(item,img),x=(item.x||0)-imageXOffset(item.align,w),y=(item.y||0)-imageYOffset(item.baseline,h);return bounds.set(x,y,x+w,y+h)}function draw$3(context,scene,bounds){visit(scene,(item=>{if(bounds&&!bounds.intersects(item.bounds))return;const img=getImage(item,this);let w=imageWidth(item,img);let h=imageHeight(item,img);if(w===0||h===0)return;let x=(item.x||0)-imageXOffset(item.align,w),y=(item.y||0)-imageYOffset(item.baseline,h),opacity,ar0,ar1,t;if(item.aspect!==false){ar0=img.width/img.height;ar1=item.width/item.height;if(ar0===ar0&&ar1===ar1&&ar0!==ar1){if(ar1<ar0){t=w/ar0;y+=(h-t)/2;h=t}else{t=h*ar0;x+=(w-t)/2;w=t}}}if(img.complete||img.toDataURL){blend(context,item);context.globalAlpha=(opacity=item.opacity)!=null?opacity:1;context.imageSmoothingEnabled=item.smooth!==false;context.drawImage(img,x,y,w,h)}}))}var image$1={type:"image",tag:"image",nested:false,attr:attr$4,bound:bound$4,draw:draw$3,pick:pick$1(),isect:truthy,get:getImage,xOffset:imageXOffset,yOffset:imageYOffset};var line$2=markMultiItemPath("line",line$1$1,pickLine);function attr$3(emit,item){var sx=item.scaleX||1,sy=item.scaleY||1;if(sx!==1||sy!==1){emit("vector-effect","non-scaling-stroke")}emit("transform",transformItem(item));emit("d",item.path)}function path$1(context,item){var path=item.path;if(path==null)return true;var x=item.x||0,y=item.y||0,sx=item.scaleX||1,sy=item.scaleY||1,a=(item.angle||0)*DegToRad,cache=item.pathCache;if(!cache||cache.path!==path){(item.pathCache=cache=parse$3(path)).path=path}if(a&&context.rotate&&context.translate){context.translate(x,y);context.rotate(a);pathRender(context,cache,0,0,sx,sy);context.rotate(-a);context.translate(-x,-y)}else{pathRender(context,cache,x,y,sx,sy)}}function bound$3(bounds,item){return path$1(boundContext(bounds,item.angle),item)?bounds.set(0,0,0,0):boundStroke(bounds,item,true)}var path$2={type:"path",tag:"path",nested:false,attr:attr$3,bound:bound$3,draw:drawAll(path$1),pick:pickPath(path$1),isect:intersectPath(path$1)};function attr$2(emit,item){emit("d",rectangle(null,item))}function bound$2(bounds,item){var x,y;return boundStroke(bounds.set(x=item.x||0,y=item.y||0,x+item.width||0,y+item.height||0),item)}function draw$2(context,item){context.beginPath();rectangle(context,item)}var rect$1={type:"rect",tag:"path",nested:false,attr:attr$2,bound:bound$2,draw:drawAll(draw$2),pick:pickPath(draw$2),isect:intersectRect};function attr$1(emit,item){emit("transform",translateItem(item));emit("x2",item.x2!=null?item.x2-(item.x||0):0);emit("y2",item.y2!=null?item.y2-(item.y||0):0)}function bound$1(bounds,item){var x1,y1;return boundStroke(bounds.set(x1=item.x||0,y1=item.y||0,item.x2!=null?item.x2:x1,item.y2!=null?item.y2:y1),item)}function path(context,item,opacity){var x1,y1,x2,y2;if(item.stroke&&stroke(context,item,opacity)){x1=item.x||0;y1=item.y||0;x2=item.x2!=null?item.x2:x1;y2=item.y2!=null?item.y2:y1;context.beginPath();context.moveTo(x1,y1);context.lineTo(x2,y2);return true}return false}function draw$1(context,scene,bounds){visit(scene,(item=>{if(bounds&&!bounds.intersects(item.bounds))return;var opacity=item.opacity==null?1:item.opacity;if(opacity&&path(context,item,opacity)){blend(context,item);context.stroke()}}))}function hit$1(context,item,x,y){if(!context.isPointInStroke)return false;return path(context,item,1)&&context.isPointInStroke(x,y)}var rule$2={type:"rule",tag:"line",nested:false,attr:attr$1,bound:bound$1,draw:draw$1,pick:pick$1(hit$1),isect:intersectRule};var shape=markItemPath("shape",shape$1);var symbol=markItemPath("symbol",symbol$1,intersectPoint);const widthCache=lruCache();var textMetrics={height:fontSize,measureWidth:measureWidth,estimateWidth:estimateWidth,width:estimateWidth,canvas:useCanvas};useCanvas(true);function useCanvas(use){textMetrics.width=use&&context$2?measureWidth:estimateWidth}function estimateWidth(item,text){return _estimateWidth(textValue(item,text),fontSize(item))}function _estimateWidth(text,currentFontHeight){return~~(.8*text.length*currentFontHeight)}function measureWidth(item,text){return fontSize(item)<=0||!(text=textValue(item,text))?0:_measureWidth(text,font(item))}function _measureWidth(text,currentFont){const key=`(${currentFont}) ${text}`;let width=widthCache.get(key);if(width===undefined){context$2.font=currentFont;width=context$2.measureText(text).width;widthCache.set(key,width)}return width}function fontSize(item){return item.fontSize!=null?+item.fontSize||0:11}function lineHeight(item){return item.lineHeight!=null?item.lineHeight:fontSize(item)+2}function lineArray(_){return isArray(_)?_.length>1?_:_[0]:_}function textLines(item){return lineArray(item.lineBreak&&item.text&&!isArray(item.text)?item.text.split(item.lineBreak):item.text)}function multiLineOffset(item){const tl=textLines(item);return(isArray(tl)?tl.length-1:0)*lineHeight(item)}function textValue(item,line){const text=line==null?"":(line+"").trim();return item.limit>0&&text.length?truncate(item,text):text}function widthGetter(item){if(textMetrics.width===measureWidth){const currentFont=font(item);return text=>_measureWidth(text,currentFont)}else if(textMetrics.width===estimateWidth){const currentFontHeight=fontSize(item);return text=>_estimateWidth(text,currentFontHeight)}else{return text=>textMetrics.width(item,text)}}function truncate(item,text){var limit=+item.limit,width=widthGetter(item);if(width(text)<limit)return text;var ellipsis=item.ellipsis||"…",rtl=item.dir==="rtl",lo=0,hi=text.length,mid;limit-=width(ellipsis);if(rtl){while(lo<hi){mid=lo+hi>>>1;if(width(text.slice(mid))>limit)lo=mid+1;else hi=mid}return ellipsis+text.slice(lo)}else{while(lo<hi){mid=1+(lo+hi>>>1);if(width(text.slice(0,mid))<limit)lo=mid;else hi=mid-1}return text.slice(0,lo)+ellipsis}}function fontFamily(item,quote){var font=item.font;return(quote&&font?String(font).replace(/"/g,"'"):font)||"sans-serif"}function font(item,quote){return""+(item.fontStyle?item.fontStyle+" ":"")+(item.fontVariant?item.fontVariant+" ":"")+(item.fontWeight?item.fontWeight+" ":"")+fontSize(item)+"px "+fontFamily(item,quote)}function offset$2(item){var baseline=item.baseline,h=fontSize(item);return Math.round(baseline==="top"?.79*h:baseline==="middle"?.3*h:baseline==="bottom"?-.21*h:baseline==="line-top"?.29*h+.5*lineHeight(item):baseline==="line-bottom"?.29*h-.5*lineHeight(item):0)}const textAlign={left:"start",center:"middle",right:"end"};const tempBounds$1=new Bounds;function anchorPoint(item){var x=item.x||0,y=item.y||0,r=item.radius||0,t;if(r){t=(item.theta||0)-HalfPi;x+=r*Math.cos(t);y+=r*Math.sin(t)}tempBounds$1.x1=x;tempBounds$1.y1=y;return tempBounds$1}function attr(emit,item){var dx=item.dx||0,dy=(item.dy||0)+offset$2(item),p=anchorPoint(item),x=p.x1,y=p.y1,a=item.angle||0,t;emit("text-anchor",textAlign[item.align]||"start");if(a){t=translate$2(x,y)+" "+rotate(a);if(dx||dy)t+=" "+translate$2(dx,dy)}else{t=translate$2(x+dx,y+dy)}emit("transform",t)}function bound(bounds,item,mode){var h=textMetrics.height(item),a=item.align,p=anchorPoint(item),x=p.x1,y=p.y1,dx=item.dx||0,dy=(item.dy||0)+offset$2(item)-Math.round(.8*h),tl=textLines(item),w;if(isArray(tl)){h+=lineHeight(item)*(tl.length-1);w=tl.reduce(((w,t)=>Math.max(w,textMetrics.width(item,t))),0)}else{w=textMetrics.width(item,tl)}if(a==="center"){dx-=w/2}else if(a==="right"){dx-=w}else;bounds.set(dx+=x,dy+=y,dx+w,dy+h);if(item.angle&&!mode){bounds.rotate(item.angle*DegToRad,x,y)}else if(mode===2){return bounds.rotatedPoints(item.angle*DegToRad,x,y)}return bounds}function draw$5(context,scene,bounds){visit(scene,(item=>{var opacity=item.opacity==null?1:item.opacity,p,x,y,i,lh,tl,str;if(bounds&&!bounds.intersects(item.bounds)||opacity===0||item.fontSize<=0||item.text==null||item.text.length===0)return;context.font=font(item);context.textAlign=item.align||"left";p=anchorPoint(item);x=p.x1,y=p.y1;if(item.angle){context.save();context.translate(x,y);context.rotate(item.angle*DegToRad);x=y=0}x+=item.dx||0;y+=(item.dy||0)+offset$2(item);tl=textLines(item);blend(context,item);if(isArray(tl)){lh=lineHeight(item);for(i=0;i<tl.length;++i){str=textValue(item,tl[i]);if(item.fill&&fill(context,item,opacity)){context.fillText(str,x,y)}if(item.stroke&&stroke(context,item,opacity)){context.strokeText(str,x,y)}y+=lh}}else{str=textValue(item,tl);if(item.fill&&fill(context,item,opacity)){context.fillText(str,x,y)}if(item.stroke&&stroke(context,item,opacity)){context.strokeText(str,x,y)}}if(item.angle)context.restore()}))}function hit(context,item,x,y,gx,gy){if(item.fontSize<=0)return false;if(!item.angle)return true;var p=anchorPoint(item),ax=p.x1,ay=p.y1,b=bound(tempBounds$1,item,1),a=-item.angle*DegToRad,cos=Math.cos(a),sin=Math.sin(a),px=cos*gx-sin*gy+(ax-cos*ax+sin*ay),py=sin*gx+cos*gy+(ay-sin*ax-cos*ay);return b.contains(px,py)}function intersectText(item,box){const p=bound(tempBounds$1,item,2);return intersectBoxLine(box,p[0],p[1],p[2],p[3])||intersectBoxLine(box,p[0],p[1],p[4],p[5])||intersectBoxLine(box,p[4],p[5],p[6],p[7])||intersectBoxLine(box,p[2],p[3],p[6],p[7])}var text$2={type:"text",tag:"text",nested:false,attr:attr,bound:bound,draw:draw$5,pick:pick$1(hit),isect:intersectText};var trail$2=markMultiItemPath("trail",trail$1,pickTrail);var Marks={arc:arc$2,area:area$2,group:group,image:image$1,line:line$2,path:path$2,rect:rect$1,rule:rule$2,shape:shape,symbol:symbol,text:text$2,trail:trail$2};function boundItem$1(item,func,opt){var type=Marks[item.mark.marktype],bound=func||type.bound;if(type.nested)item=item.mark;return bound(item.bounds||(item.bounds=new Bounds),item,opt)}var DUMMY={mark:null};function boundMark(mark,bounds,opt){var type=Marks[mark.marktype],bound=type.bound,items=mark.items,hasItems=items&&items.length,i,n,item,b;if(type.nested){if(hasItems){item=items[0]}else{DUMMY.mark=mark;item=DUMMY}b=boundItem$1(item,bound,opt);bounds=bounds&&bounds.union(b)||b;return bounds}bounds=bounds||mark.bounds&&mark.bounds.clear()||new Bounds;if(hasItems){for(i=0,n=items.length;i<n;++i){bounds.union(boundItem$1(items[i],bound,opt))}}return mark.bounds=bounds}const keys$3=["marktype","name","role","interactive","clip","items","zindex","x","y","width","height","align","baseline","fill","fillOpacity","opacity","blend","stroke","strokeOpacity","strokeWidth","strokeCap","strokeDash","strokeDashOffset","strokeForeground","strokeOffset","startAngle","endAngle","innerRadius","outerRadius","cornerRadius","padAngle","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight","interpolate","tension","orient","defined","url","aspect","smooth","path","scaleX","scaleY","x2","y2","size","shape","text","angle","theta","radius","dir","dx","dy","ellipsis","limit","lineBreak","lineHeight","font","fontSize","fontWeight","fontStyle","fontVariant","description","aria","ariaRole","ariaRoleDescription"];function sceneToJSON(scene,indent){return JSON.stringify(scene,keys$3,indent)}function sceneFromJSON(json){const scene=typeof json==="string"?JSON.parse(json):json;return initialize$1(scene)}function initialize$1(scene){var type=scene.marktype,items=scene.items,parent,i,n;if(items){for(i=0,n=items.length;i<n;++i){parent=type?"mark":"group";items[i][parent]=scene;if(items[i].zindex)items[i][parent].zdirty=true;if("group"===(type||parent))initialize$1(items[i])}}if(type)boundMark(scene);return scene}class Scenegraph{constructor(scene){if(arguments.length){this.root=sceneFromJSON(scene)}else{this.root=createMark({marktype:"group",name:"root",role:"frame"});this.root.items=[new GroupItem(this.root)]}}toJSON(indent){return sceneToJSON(this.root,indent||0)}mark(markdef,group,index){group=group||this.root.items[0];const mark=createMark(markdef,group);group.items[index]=mark;if(mark.zindex)mark.group.zdirty=true;return mark}}function createMark(def,group){const mark={bounds:new Bounds,clip:!!def.clip,group:group,interactive:def.interactive===false?false:true,items:[],marktype:def.marktype,name:def.name||undefined,role:def.role||undefined,zindex:def.zindex||0};if(def.aria!=null){mark.aria=def.aria}if(def.description){mark.description=def.description}return mark}function domCreate(doc,tag,ns){if(!doc&&typeof document!=="undefined"&&document.createElement){doc=document}return doc?ns?doc.createElementNS(ns,tag):doc.createElement(tag):null}function domFind(el,tag){tag=tag.toLowerCase();var nodes=el.childNodes,i=0,n=nodes.length;for(;i<n;++i)if(nodes[i].tagName.toLowerCase()===tag){return nodes[i]}}function domChild(el,index,tag,ns){var a=el.childNodes[index],b;if(!a||a.tagName.toLowerCase()!==tag.toLowerCase()){b=a||null;a=domCreate(el.ownerDocument,tag,ns);el.insertBefore(a,b)}return a}function domClear(el,index){var nodes=el.childNodes,curr=nodes.length;while(curr>index)el.removeChild(nodes[--curr]);return el}function cssClass(mark){return"mark-"+mark.marktype+(mark.role?" role-"+mark.role:"")+(mark.name?" "+mark.name:"")}function point$2(event,el){const rect=el.getBoundingClientRect();return[event.clientX-rect.left-(el.clientLeft||0),event.clientY-rect.top-(el.clientTop||0)]}function resolveItem(item,event,el,origin){var mark=item&&item.mark,mdef,p;if(mark&&(mdef=Marks[mark.marktype]).tip){p=point$2(event,el);p[0]-=origin[0];p[1]-=origin[1];while(item=item.mark.group){p[0]-=item.x||0;p[1]-=item.y||0}item=mdef.tip(mark.items,p)}return item}class Handler{constructor(customLoader,customTooltip){this._active=null;this._handlers={};this._loader=customLoader||loader();this._tooltip=customTooltip||defaultTooltip$1}initialize(el,origin,obj){this._el=el;this._obj=obj||null;return this.origin(origin)}element(){return this._el}canvas(){return this._el&&this._el.firstChild}origin(origin){if(arguments.length){this._origin=origin||[0,0];return this}else{return this._origin.slice()}}scene(scene){if(!arguments.length)return this._scene;this._scene=scene;return this}on(){}off(){}_handlerIndex(h,type,handler){for(let i=h?h.length:0;--i>=0;){if(h[i].type===type&&(!handler||h[i].handler===handler)){return i}}return-1}handlers(type){const h=this._handlers,a=[];if(type){a.push(...h[this.eventName(type)])}else{for(const k in h){a.push(...h[k])}}return a}eventName(name){const i=name.indexOf(".");return i<0?name:name.slice(0,i)}handleHref(event,item,href){this._loader.sanitize(href,{context:"href"}).then((opt=>{const e=new MouseEvent(event.type,event),a=domCreate(null,"a");for(const name in opt)a.setAttribute(name,opt[name]);a.dispatchEvent(e)})).catch((()=>{}))}handleTooltip(event,item,show){if(item&&item.tooltip!=null){item=resolveItem(item,event,this.canvas(),this._origin);const value=show&&item&&item.tooltip||null;this._tooltip.call(this._obj,this,event,item,value)}}getItemBoundingClientRect(item){const el=this.canvas();if(!el)return;const rect=el.getBoundingClientRect(),origin=this._origin,bounds=item.bounds,width=bounds.width(),height=bounds.height();let x=bounds.x1+origin[0]+rect.left,y=bounds.y1+origin[1]+rect.top;while(item.mark&&(item=item.mark.group)){x+=item.x||0;y+=item.y||0}return{x:x,y:y,width:width,height:height,left:x,top:y,right:x+width,bottom:y+height}}}function defaultTooltip$1(handler,event,item,value){handler.element().setAttribute("title",value||"")}class Renderer{constructor(loader){this._el=null;this._bgcolor=null;this._loader=new ResourceLoader(loader)}initialize(el,width,height,origin,scaleFactor){this._el=el;return this.resize(width,height,origin,scaleFactor)}element(){return this._el}canvas(){return this._el&&this._el.firstChild}background(bgcolor){if(arguments.length===0)return this._bgcolor;this._bgcolor=bgcolor;return this}resize(width,height,origin,scaleFactor){this._width=width;this._height=height;this._origin=origin||[0,0];this._scale=scaleFactor||1;return this}dirty(){}render(scene,markTypes){const r=this;r._call=function(){r._render(scene,markTypes)};r._call();r._call=null;return r}_render(){}renderAsync(scene,markTypes){const r=this.render(scene,markTypes);return this._ready?this._ready.then((()=>r)):Promise.resolve(r)}_load(method,uri){var r=this,p=r._loader[method](uri);if(!r._ready){const call=r._call;r._ready=r._loader.ready().then((redraw=>{if(redraw)call();r._ready=null}))}return p}sanitizeURL(uri){return this._load("sanitizeURL",uri)}loadImage(uri){return this._load("loadImage",uri)}}const KeyDownEvent="keydown";const KeyPressEvent="keypress";const KeyUpEvent="keyup";const DragEnterEvent="dragenter";const DragLeaveEvent="dragleave";const DragOverEvent="dragover";const PointerDownEvent="pointerdown";const PointerUpEvent="pointerup";const PointerMoveEvent="pointermove";const PointerOutEvent="pointerout";const PointerOverEvent="pointerover";const MouseDownEvent="mousedown";const MouseUpEvent="mouseup";const MouseMoveEvent="mousemove";const MouseOutEvent="mouseout";const MouseOverEvent="mouseover";const ClickEvent="click";const DoubleClickEvent="dblclick";const WheelEvent="wheel";const MouseWheelEvent="mousewheel";const TouchStartEvent="touchstart";const TouchMoveEvent="touchmove";const TouchEndEvent="touchend";const Events=[KeyDownEvent,KeyPressEvent,KeyUpEvent,DragEnterEvent,DragLeaveEvent,DragOverEvent,PointerDownEvent,PointerUpEvent,PointerMoveEvent,PointerOutEvent,PointerOverEvent,MouseDownEvent,MouseUpEvent,MouseMoveEvent,MouseOutEvent,MouseOverEvent,ClickEvent,DoubleClickEvent,WheelEvent,MouseWheelEvent,TouchStartEvent,TouchMoveEvent,TouchEndEvent];const TooltipShowEvent=PointerMoveEvent;const TooltipHideEvent=MouseOutEvent;const HrefEvent=ClickEvent;class CanvasHandler extends Handler{constructor(loader,tooltip){super(loader,tooltip);this._down=null;this._touch=null;this._first=true;this._events={};this.events=Events;this.pointermove=move([PointerMoveEvent,MouseMoveEvent],[PointerOverEvent,MouseOverEvent],[PointerOutEvent,MouseOutEvent]);this.dragover=move([DragOverEvent],[DragEnterEvent],[DragLeaveEvent]),this.pointerout=inactive([PointerOutEvent,MouseOutEvent]);this.dragleave=inactive([DragLeaveEvent])}initialize(el,origin,obj){this._canvas=el&&domFind(el,"canvas");[ClickEvent,MouseDownEvent,PointerDownEvent,PointerMoveEvent,PointerOutEvent,DragLeaveEvent].forEach((type=>eventListenerCheck(this,type)));return super.initialize(el,origin,obj)}canvas(){return this._canvas}context(){return this._canvas.getContext("2d")}DOMMouseScroll(evt){this.fire(MouseWheelEvent,evt)}pointerdown(evt){this._down=this._active;this.fire(PointerDownEvent,evt)}mousedown(evt){this._down=this._active;this.fire(MouseDownEvent,evt)}click(evt){if(this._down===this._active){this.fire(ClickEvent,evt);this._down=null}}touchstart(evt){this._touch=this.pickEvent(evt.changedTouches[0]);if(this._first){this._active=this._touch;this._first=false}this.fire(TouchStartEvent,evt,true)}touchmove(evt){this.fire(TouchMoveEvent,evt,true)}touchend(evt){this.fire(TouchEndEvent,evt,true);this._touch=null}fire(type,evt,touch){const a=touch?this._touch:this._active,h=this._handlers[type];evt.vegaType=type;if(type===HrefEvent&&a&&a.href){this.handleHref(evt,a,a.href)}else if(type===TooltipShowEvent||type===TooltipHideEvent){this.handleTooltip(evt,a,type!==TooltipHideEvent)}if(h){for(let i=0,len=h.length;i<len;++i){h[i].handler.call(this._obj,evt,a)}}}on(type,handler){const name=this.eventName(type),h=this._handlers,i=this._handlerIndex(h[name],type,handler);if(i<0){eventListenerCheck(this,type);(h[name]||(h[name]=[])).push({type:type,handler:handler})}return this}off(type,handler){const name=this.eventName(type),h=this._handlers[name],i=this._handlerIndex(h,type,handler);if(i>=0){h.splice(i,1)}return this}pickEvent(evt){const p=point$2(evt,this._canvas),o=this._origin;return this.pick(this._scene,p[0],p[1],p[0]-o[0],p[1]-o[1])}pick(scene,x,y,gx,gy){const g=this.context(),mark=Marks[scene.marktype];return mark.pick.call(this,g,scene,x,y,gx,gy)}}const eventBundle=type=>type===TouchStartEvent||type===TouchMoveEvent||type===TouchEndEvent?[TouchStartEvent,TouchMoveEvent,TouchEndEvent]:[type];function eventListenerCheck(handler,type){eventBundle(type).forEach((_=>addEventListener(handler,_)))}function addEventListener(handler,type){const canvas=handler.canvas();if(canvas&&!handler._events[type]){handler._events[type]=1;canvas.addEventListener(type,handler[type]?evt=>handler[type](evt):evt=>handler.fire(type,evt))}}function fireAll(handler,types,event){types.forEach((type=>handler.fire(type,event)))}function move(moveEvents,overEvents,outEvents){return function(evt){const a=this._active,p=this.pickEvent(evt);if(p===a){fireAll(this,moveEvents,evt)}else{if(!a||!a.exit){fireAll(this,outEvents,evt)}this._active=p;fireAll(this,overEvents,evt);fireAll(this,moveEvents,evt)}}}function inactive(types){return function(evt){fireAll(this,types,evt);this._active=null}}function devicePixelRatio(){return typeof window!=="undefined"?window.devicePixelRatio||1:1}function resize(canvas,width,height,origin,scaleFactor,opt){const inDOM=typeof HTMLElement!=="undefined"&&canvas instanceof HTMLElement&&canvas.parentNode!=null,context=canvas.getContext("2d"),ratio=inDOM?devicePixelRatio():scaleFactor;canvas.width=width*ratio;canvas.height=height*ratio;for(const key in opt){context[key]=opt[key]}if(inDOM&&ratio!==1){canvas.style.width=width+"px";canvas.style.height=height+"px"}context.pixelRatio=ratio;context.setTransform(ratio,0,0,ratio,ratio*origin[0],ratio*origin[1]);return canvas}class CanvasRenderer extends Renderer{constructor(loader){super(loader);this._options={};this._redraw=false;this._dirty=new Bounds;this._tempb=new Bounds}initialize(el,width,height,origin,scaleFactor,options){this._options=options||{};this._canvas=this._options.externalContext?null:canvas(1,1,this._options.type);if(el&&this._canvas){domClear(el,0).appendChild(this._canvas);this._canvas.setAttribute("class","marks")}return super.initialize(el,width,height,origin,scaleFactor)}resize(width,height,origin,scaleFactor){super.resize(width,height,origin,scaleFactor);if(this._canvas){resize(this._canvas,this._width,this._height,this._origin,this._scale,this._options.context)}else{const ctx=this._options.externalContext;if(!ctx)error("CanvasRenderer is missing a valid canvas or context");ctx.scale(this._scale,this._scale);ctx.translate(this._origin[0],this._origin[1])}this._redraw=true;return this}canvas(){return this._canvas}context(){return this._options.externalContext||(this._canvas?this._canvas.getContext("2d"):null)}dirty(item){const b=this._tempb.clear().union(item.bounds);let g=item.mark.group;while(g){b.translate(g.x||0,g.y||0);g=g.mark.group}this._dirty.union(b)}_render(scene,markTypes){const g=this.context(),o=this._origin,w=this._width,h=this._height,db=this._dirty,vb=viewBounds(o,w,h);g.save();const b=this._redraw||db.empty()?(this._redraw=false,vb.expand(1)):clipToBounds(g,vb.intersect(db),o);this.clear(-o[0],-o[1],w,h);this.draw(g,scene,b,markTypes);g.restore();db.clear();return this}draw(ctx,scene,bounds,markTypes){if(scene.marktype!=="group"&&markTypes!=null&&!markTypes.includes(scene.marktype)){return}const mark=Marks[scene.marktype];if(scene.clip)clip$2(ctx,scene);mark.draw.call(this,ctx,scene,bounds,markTypes);if(scene.clip)ctx.restore()}clear(x,y,w,h){const opt=this._options,g=this.context();if(opt.type!=="pdf"&&!opt.externalContext){g.clearRect(x,y,w,h)}if(this._bgcolor!=null){g.fillStyle=this._bgcolor;g.fillRect(x,y,w,h)}}}const viewBounds=(origin,width,height)=>(new Bounds).set(0,0,width,height).translate(-origin[0],-origin[1]);function clipToBounds(g,b,origin){b.expand(1).round();if(g.pixelRatio%1){b.scale(g.pixelRatio).round().scale(1/g.pixelRatio)}b.translate(-(origin[0]%1),-(origin[1]%1));g.beginPath();g.rect(b.x1,b.y1,b.width(),b.height());g.clip();return b}class SVGHandler extends Handler{constructor(loader,tooltip){super(loader,tooltip);const h=this;h._hrefHandler=listener(h,((evt,item)=>{if(item&&item.href)h.handleHref(evt,item,item.href)}));h._tooltipHandler=listener(h,((evt,item)=>{h.handleTooltip(evt,item,evt.type!==TooltipHideEvent)}))}initialize(el,origin,obj){let svg=this._svg;if(svg){svg.removeEventListener(HrefEvent,this._hrefHandler);svg.removeEventListener(TooltipShowEvent,this._tooltipHandler);svg.removeEventListener(TooltipHideEvent,this._tooltipHandler)}this._svg=svg=el&&domFind(el,"svg");if(svg){svg.addEventListener(HrefEvent,this._hrefHandler);svg.addEventListener(TooltipShowEvent,this._tooltipHandler);svg.addEventListener(TooltipHideEvent,this._tooltipHandler)}return super.initialize(el,origin,obj)}canvas(){return this._svg}on(type,handler){const name=this.eventName(type),h=this._handlers,i=this._handlerIndex(h[name],type,handler);if(i<0){const x={type:type,handler:handler,listener:listener(this,handler)};(h[name]||(h[name]=[])).push(x);if(this._svg){this._svg.addEventListener(name,x.listener)}}return this}off(type,handler){const name=this.eventName(type),h=this._handlers[name],i=this._handlerIndex(h,type,handler);if(i>=0){if(this._svg){this._svg.removeEventListener(name,h[i].listener)}h.splice(i,1)}return this}}const listener=(context,handler)=>evt=>{let item=evt.target.__data__;item=Array.isArray(item)?item[0]:item;evt.vegaType=evt.type;handler.call(context._obj,evt,item)};const ARIA_HIDDEN="aria-hidden";const ARIA_LABEL="aria-label";const ARIA_ROLE="role";const ARIA_ROLEDESCRIPTION="aria-roledescription";const GRAPHICS_OBJECT="graphics-object";const GRAPHICS_SYMBOL="graphics-symbol";const bundle=(role,roledesc,label)=>({[ARIA_ROLE]:role,[ARIA_ROLEDESCRIPTION]:roledesc,[ARIA_LABEL]:label||undefined});const AriaIgnore=toSet(["axis-domain","axis-grid","axis-label","axis-tick","axis-title","legend-band","legend-entry","legend-gradient","legend-label","legend-title","legend-symbol","title"]);const AriaGuides={axis:{desc:"axis",caption:axisCaption},legend:{desc:"legend",caption:legendCaption},"title-text":{desc:"title",caption:item=>`Title text '${titleCaption(item)}'`},"title-subtitle":{desc:"subtitle",caption:item=>`Subtitle text '${titleCaption(item)}'`}};const AriaEncode={ariaRole:ARIA_ROLE,ariaRoleDescription:ARIA_ROLEDESCRIPTION,description:ARIA_LABEL};function ariaItemAttributes(emit,item){const hide=item.aria===false;emit(ARIA_HIDDEN,hide||undefined);if(hide||item.description==null){for(const prop in AriaEncode){emit(AriaEncode[prop],undefined)}}else{const type=item.mark.marktype;emit(ARIA_LABEL,item.description);emit(ARIA_ROLE,item.ariaRole||(type==="group"?GRAPHICS_OBJECT:GRAPHICS_SYMBOL));emit(ARIA_ROLEDESCRIPTION,item.ariaRoleDescription||`${type} mark`)}}function ariaMarkAttributes(mark){return mark.aria===false?{[ARIA_HIDDEN]:true}:AriaIgnore[mark.role]?null:AriaGuides[mark.role]?ariaGuide(mark,AriaGuides[mark.role]):ariaMark(mark)}function ariaMark(mark){const type=mark.marktype;const recurse=type==="group"||type==="text"||mark.items.some((_=>_.description!=null&&_.aria!==false));return bundle(recurse?GRAPHICS_OBJECT:GRAPHICS_SYMBOL,`${type} mark container`,mark.description)}function ariaGuide(mark,opt){try{const item=mark.items[0],caption=opt.caption||(()=>"");return bundle(opt.role||GRAPHICS_SYMBOL,opt.desc,item.description||caption(item))}catch(err){return null}}function titleCaption(item){return array$5(item.text).join(" ")}function axisCaption(item){const datum=item.datum,orient=item.orient,title=datum.title?extractTitle(item):null,ctx=item.context,scale=ctx.scales[datum.scale].value,locale=ctx.dataflow.locale(),type=scale.type,xy=orient==="left"||orient==="right"?"Y":"X";return`${xy}-axis`+(title?` titled '${title}'`:"")+` for a ${isDiscrete$2(type)?"discrete":type} scale`+` with ${domainCaption(locale,scale,item)}`}function legendCaption(item){const datum=item.datum,title=datum.title?extractTitle(item):null,type=`${datum.type||""} legend`.trim(),scales=datum.scales,props=Object.keys(scales),ctx=item.context,scale=ctx.scales[scales[props[0]]].value,locale=ctx.dataflow.locale();return capitalize(type)+(title?` titled '${title}'`:"")+` for ${channelCaption(props)}`+` with ${domainCaption(locale,scale,item)}`}function extractTitle(item){try{return array$5(peek$1(item.items).items[0].text).join(" ")}catch(err){return null}}function channelCaption(props){props=props.map((p=>p+(p==="fill"||p==="stroke"?" color":"")));return props.length<2?props[0]:props.slice(0,-1).join(", ")+" and "+peek$1(props)}function capitalize(s){return s.length?s[0].toUpperCase()+s.slice(1):s}const innerText=val=>(val+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");const attrText=val=>innerText(val).replace(/"/g,"&quot;").replace(/\t/g,"&#x9;").replace(/\n/g,"&#xA;").replace(/\r/g,"&#xD;");function markup(){let buf="",outer="",inner="";const stack=[],clear=()=>outer=inner="",push=tag=>{if(outer){buf+=`${outer}>${inner}`;clear()}stack.push(tag)},attr=(name,value)=>{if(value!=null)outer+=` ${name}="${attrText(value)}"`;return m},m={open(tag){push(tag);outer="<"+tag;for(var _len=arguments.length,attrs=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){attrs[_key-1]=arguments[_key]}for(const set of attrs){for(const key in set)attr(key,set[key])}return m},close(){const tag=stack.pop();if(outer){buf+=outer+(inner?`>${inner}</${tag}>`:"/>")}else{buf+=`</${tag}>`}clear();return m},attr:attr,text:t=>(inner+=innerText(t),m),toString:()=>buf};return m}const serializeXML=node=>_serialize(markup(),node)+"";function _serialize(m,node){m.open(node.tagName);if(node.hasAttributes()){const attrs=node.attributes,n=attrs.length;for(let i=0;i<n;++i){m.attr(attrs[i].name,attrs[i].value)}}if(node.hasChildNodes()){const children=node.childNodes;for(const child of children){child.nodeType===3?m.text(child.nodeValue):_serialize(m,child)}}return m.close()}const stylesAttr={fill:"fill",fillOpacity:"fill-opacity",stroke:"stroke",strokeOpacity:"stroke-opacity",strokeWidth:"stroke-width",strokeCap:"stroke-linecap",strokeJoin:"stroke-linejoin",strokeDash:"stroke-dasharray",strokeDashOffset:"stroke-dashoffset",strokeMiterLimit:"stroke-miterlimit",opacity:"opacity"};const stylesCss={blend:"mix-blend-mode"};const rootAttributes={fill:"none","stroke-miterlimit":10};const RootIndex=0,xmlns="http://www.w3.org/2000/xmlns/",svgns=metadata.xmlns;class SVGRenderer extends Renderer{constructor(loader){super(loader);this._dirtyID=0;this._dirty=[];this._svg=null;this._root=null;this._defs=null}initialize(el,width,height,origin,scaleFactor){this._defs={};this._clearDefs();if(el){this._svg=domChild(el,0,"svg",svgns);this._svg.setAttributeNS(xmlns,"xmlns",svgns);this._svg.setAttributeNS(xmlns,"xmlns:xlink",metadata["xmlns:xlink"]);this._svg.setAttribute("version",metadata["version"]);this._svg.setAttribute("class","marks");domClear(el,1);this._root=domChild(this._svg,RootIndex,"g",svgns);setAttributes(this._root,rootAttributes);domClear(this._svg,RootIndex+1)}this.background(this._bgcolor);return super.initialize(el,width,height,origin,scaleFactor)}background(bgcolor){if(arguments.length&&this._svg){this._svg.style.setProperty("background-color",bgcolor)}return super.background(...arguments)}resize(width,height,origin,scaleFactor){super.resize(width,height,origin,scaleFactor);if(this._svg){setAttributes(this._svg,{width:this._width*this._scale,height:this._height*this._scale,viewBox:`0 0 ${this._width} ${this._height}`});this._root.setAttribute("transform",`translate(${this._origin})`)}this._dirty=[];return this}canvas(){return this._svg}svg(){const svg=this._svg,bg=this._bgcolor;if(!svg)return null;let node;if(bg){svg.removeAttribute("style");node=domChild(svg,RootIndex,"rect",svgns);setAttributes(node,{width:this._width,height:this._height,fill:bg})}const text=serializeXML(svg);if(bg){svg.removeChild(node);this._svg.style.setProperty("background-color",bg)}return text}_render(scene,markTypes){if(this._dirtyCheck()){if(this._dirtyAll)this._clearDefs();this.mark(this._root,scene,undefined,markTypes);domClear(this._root,1)}this.defs();this._dirty=[];++this._dirtyID;return this}dirty(item){if(item.dirty!==this._dirtyID){item.dirty=this._dirtyID;this._dirty.push(item)}}isDirty(item){return this._dirtyAll||!item._svg||!item._svg.ownerSVGElement||item.dirty===this._dirtyID}_dirtyCheck(){this._dirtyAll=true;const items=this._dirty;if(!items.length||!this._dirtyID)return true;const id=++this._dirtyID;let item,mark,type,mdef,i,n,o;for(i=0,n=items.length;i<n;++i){item=items[i];mark=item.mark;if(mark.marktype!==type){type=mark.marktype;mdef=Marks[type]}if(mark.zdirty&&mark.dirty!==id){this._dirtyAll=false;dirtyParents(item,id);mark.items.forEach((i=>{i.dirty=id}))}if(mark.zdirty)continue;if(item.exit){if(mdef.nested&&mark.items.length){o=mark.items[0];if(o._svg)this._update(mdef,o._svg,o)}else if(item._svg){o=item._svg.parentNode;if(o)o.removeChild(item._svg)}item._svg=null;continue}item=mdef.nested?mark.items[0]:item;if(item._update===id)continue;if(!item._svg||!item._svg.ownerSVGElement){this._dirtyAll=false;dirtyParents(item,id)}else{this._update(mdef,item._svg,item)}item._update=id}return!this._dirtyAll}mark(el,scene,prev,markTypes){if(!this.isDirty(scene)){return scene._svg}const svg=this._svg,markType=scene.marktype,mdef=Marks[markType],events=scene.interactive===false?"none":null,isGroup=mdef.tag==="g";const parent=bind$1(scene,el,prev,"g",svg);if(markType!=="group"&&markTypes!=null&&!markTypes.includes(markType)){domClear(parent,0);return scene._svg}parent.setAttribute("class",cssClass(scene));const aria=ariaMarkAttributes(scene);for(const key in aria)setAttribute(parent,key,aria[key]);if(!isGroup){setAttribute(parent,"pointer-events",events)}setAttribute(parent,"clip-path",scene.clip?clip$1$1(this,scene,scene.group):null);let sibling=null,i=0;const process=item=>{const dirty=this.isDirty(item),node=bind$1(item,parent,sibling,mdef.tag,svg);if(dirty){this._update(mdef,node,item);if(isGroup)recurse(this,node,item,markTypes)}sibling=node;++i};if(mdef.nested){if(scene.items.length)process(scene.items[0])}else{visit(scene,process)}domClear(parent,i);return parent}_update(mdef,el,item){element$1=el;values$2=el.__values__;ariaItemAttributes(emit,item);mdef.attr(emit,item,this);const extra=mark_extras[mdef.type];if(extra)extra.call(this,mdef,el,item);if(element$1)this.style(element$1,item)}style(el,item){if(item==null)return;for(const prop in stylesAttr){let value=prop==="font"?fontFamily(item):item[prop];if(value===values$2[prop])continue;const name=stylesAttr[prop];if(value==null){el.removeAttribute(name)}else{if(isGradient(value)){value=gradientRef(value,this._defs.gradient,href())}el.setAttribute(name,value+"")}values$2[prop]=value}for(const prop in stylesCss){setStyle(el,stylesCss[prop],item[prop])}}defs(){const svg=this._svg,defs=this._defs;let el=defs.el,index=0;for(const id in defs.gradient){if(!el)defs.el=el=domChild(svg,RootIndex+1,"defs",svgns);index=updateGradient(el,defs.gradient[id],index)}for(const id in defs.clipping){if(!el)defs.el=el=domChild(svg,RootIndex+1,"defs",svgns);index=updateClipping(el,defs.clipping[id],index)}if(el){index===0?(svg.removeChild(el),defs.el=null):domClear(el,index)}}_clearDefs(){const def=this._defs;def.gradient={};def.clipping={}}}function dirtyParents(item,id){for(;item&&item.dirty!==id;item=item.mark.group){item.dirty=id;if(item.mark&&item.mark.dirty!==id){item.mark.dirty=id}else return}}function updateGradient(el,grad,index){let i,n,stop;if(grad.gradient==="radial"){let pt=domChild(el,index++,"pattern",svgns);setAttributes(pt,{id:patternPrefix+grad.id,viewBox:"0,0,1,1",width:"100%",height:"100%",preserveAspectRatio:"xMidYMid slice"});pt=domChild(pt,0,"rect",svgns);setAttributes(pt,{width:1,height:1,fill:`url(${href()}#${grad.id})`});el=domChild(el,index++,"radialGradient",svgns);setAttributes(el,{id:grad.id,fx:grad.x1,fy:grad.y1,fr:grad.r1,cx:grad.x2,cy:grad.y2,r:grad.r2})}else{el=domChild(el,index++,"linearGradient",svgns);setAttributes(el,{id:grad.id,x1:grad.x1,x2:grad.x2,y1:grad.y1,y2:grad.y2})}for(i=0,n=grad.stops.length;i<n;++i){stop=domChild(el,i,"stop",svgns);stop.setAttribute("offset",grad.stops[i].offset);stop.setAttribute("stop-color",grad.stops[i].color)}domClear(el,i);return index}function updateClipping(el,clip,index){let mask;el=domChild(el,index,"clipPath",svgns);el.setAttribute("id",clip.id);if(clip.path){mask=domChild(el,0,"path",svgns);mask.setAttribute("d",clip.path)}else{mask=domChild(el,0,"rect",svgns);setAttributes(mask,{x:0,y:0,width:clip.width,height:clip.height})}domClear(el,1);return index+1}function recurse(renderer,el,group,markTypes){el=el.lastChild.previousSibling;let prev,idx=0;visit(group,(item=>{prev=renderer.mark(el,item,prev,markTypes);++idx}));domClear(el,1+idx)}function bind$1(item,el,sibling,tag,svg){let node=item._svg,doc;if(!node){doc=el.ownerDocument;node=domCreate(doc,tag,svgns);item._svg=node;if(item.mark){node.__data__=item;node.__values__={fill:"default"};if(tag==="g"){const bg=domCreate(doc,"path",svgns);node.appendChild(bg);bg.__data__=item;const cg=domCreate(doc,"g",svgns);node.appendChild(cg);cg.__data__=item;const fg=domCreate(doc,"path",svgns);node.appendChild(fg);fg.__data__=item;fg.__values__={fill:"default"}}}}if(node.ownerSVGElement!==svg||siblingCheck(node,sibling)){el.insertBefore(node,sibling?sibling.nextSibling:el.firstChild)}return node}function siblingCheck(node,sibling){return node.parentNode&&node.parentNode.childNodes.length>1&&node.previousSibling!=sibling}let element$1=null,values$2=null;const mark_extras={group(mdef,el,item){const fg=element$1=el.childNodes[2];values$2=fg.__values__;mdef.foreground(emit,item,this);values$2=el.__values__;element$1=el.childNodes[1];mdef.content(emit,item,this);const bg=element$1=el.childNodes[0];mdef.background(emit,item,this);const value=item.mark.interactive===false?"none":null;if(value!==values$2.events){setAttribute(fg,"pointer-events",value);setAttribute(bg,"pointer-events",value);values$2.events=value}if(item.strokeForeground&&item.stroke){const fill=item.fill;setAttribute(fg,"display",null);this.style(bg,item);setAttribute(bg,"stroke",null);if(fill)item.fill=null;values$2=fg.__values__;this.style(fg,item);if(fill)item.fill=fill;element$1=null}else{setAttribute(fg,"display","none")}},image(mdef,el,item){if(item.smooth===false){setStyle(el,"image-rendering","optimizeSpeed");setStyle(el,"image-rendering","pixelated")}else{setStyle(el,"image-rendering",null)}},text(mdef,el,item){const tl=textLines(item);let key,value,doc,lh;if(isArray(tl)){value=tl.map((_=>textValue(item,_)));key=value.join("\n");if(key!==values$2.text){domClear(el,0);doc=el.ownerDocument;lh=lineHeight(item);value.forEach(((t,i)=>{const ts=domCreate(doc,"tspan",svgns);ts.__data__=item;ts.textContent=t;if(i){ts.setAttribute("x",0);ts.setAttribute("dy",lh)}el.appendChild(ts)}));values$2.text=key}}else{value=textValue(item,tl);if(value!==values$2.text){el.textContent=value;values$2.text=value}}setAttribute(el,"font-family",fontFamily(item));setAttribute(el,"font-size",fontSize(item)+"px");setAttribute(el,"font-style",item.fontStyle);setAttribute(el,"font-variant",item.fontVariant);setAttribute(el,"font-weight",item.fontWeight)}};function emit(name,value,ns){if(value===values$2[name])return;if(ns){setAttributeNS(element$1,name,value,ns)}else{setAttribute(element$1,name,value)}values$2[name]=value}function setStyle(el,name,value){if(value!==values$2[name]){if(value==null){el.style.removeProperty(name)}else{el.style.setProperty(name,value+"")}values$2[name]=value}}function setAttributes(el,attrs){for(const key in attrs){setAttribute(el,key,attrs[key])}}function setAttribute(el,name,value){if(value!=null){el.setAttribute(name,value)}else{el.removeAttribute(name)}}function setAttributeNS(el,name,value,ns){if(value!=null){el.setAttributeNS(ns,name,value)}else{el.removeAttributeNS(ns,name)}}function href(){let loc;return typeof window==="undefined"?"":(loc=window.location).hash?loc.href.slice(0,-loc.hash.length):loc.href}class SVGStringRenderer extends Renderer{constructor(loader){super(loader);this._text=null;this._defs={gradient:{},clipping:{}}}svg(){return this._text}_render(scene){const m=markup();m.open("svg",extend$1({},metadata,{class:"marks",width:this._width*this._scale,height:this._height*this._scale,viewBox:`0 0 ${this._width} ${this._height}`}));const bg=this._bgcolor;if(bg&&bg!=="transparent"&&bg!=="none"){m.open("rect",{width:this._width,height:this._height,fill:bg}).close()}m.open("g",rootAttributes,{transform:"translate("+this._origin+")"});this.mark(m,scene);m.close();this.defs(m);this._text=m.close()+"";return this}mark(m,scene){const mdef=Marks[scene.marktype],tag=mdef.tag,attrList=[ariaItemAttributes,mdef.attr];m.open("g",{class:cssClass(scene),"clip-path":scene.clip?clip$1$1(this,scene,scene.group):null},ariaMarkAttributes(scene),{"pointer-events":tag!=="g"&&scene.interactive===false?"none":null});const process=item=>{const href=this.href(item);if(href)m.open("a",href);m.open(tag,this.attr(scene,item,attrList,tag!=="g"?tag:null));if(tag==="text"){const tl=textLines(item);if(isArray(tl)){const attrs={x:0,dy:lineHeight(item)};for(let i=0;i<tl.length;++i){m.open("tspan",i?attrs:null).text(textValue(item,tl[i])).close()}}else{m.text(textValue(item,tl))}}else if(tag==="g"){const fore=item.strokeForeground,fill=item.fill,stroke=item.stroke;if(fore&&stroke){item.stroke=null}m.open("path",this.attr(scene,item,mdef.background,"bgrect")).close();m.open("g",this.attr(scene,item,mdef.content));visit(item,(scene=>this.mark(m,scene)));m.close();if(fore&&stroke){if(fill)item.fill=null;item.stroke=stroke;m.open("path",this.attr(scene,item,mdef.foreground,"bgrect")).close();if(fill)item.fill=fill}else{m.open("path",this.attr(scene,item,mdef.foreground,"bgfore")).close()}}m.close();if(href)m.close()};if(mdef.nested){if(scene.items&&scene.items.length)process(scene.items[0])}else{visit(scene,process)}return m.close()}href(item){const href=item.href;let attr;if(href){if(attr=this._hrefs&&this._hrefs[href]){return attr}else{this.sanitizeURL(href).then((attr=>{attr["xlink:href"]=attr.href;attr.href=null;(this._hrefs||(this._hrefs={}))[href]=attr}))}}return null}attr(scene,item,attrs,tag){const object={},emit=(name,value,ns,prefixed)=>{object[prefixed||name]=value};if(Array.isArray(attrs)){attrs.forEach((fn=>fn(emit,item,this)))}else{attrs(emit,item,this)}if(tag){style(object,item,scene,tag,this._defs)}return object}defs(m){const gradient=this._defs.gradient,clipping=this._defs.clipping,count=Object.keys(gradient).length+Object.keys(clipping).length;if(count===0)return;m.open("defs");for(const id in gradient){const def=gradient[id],stops=def.stops;if(def.gradient==="radial"){m.open("pattern",{id:patternPrefix+id,viewBox:"0,0,1,1",width:"100%",height:"100%",preserveAspectRatio:"xMidYMid slice"});m.open("rect",{width:"1",height:"1",fill:"url(#"+id+")"}).close();m.close();m.open("radialGradient",{id:id,fx:def.x1,fy:def.y1,fr:def.r1,cx:def.x2,cy:def.y2,r:def.r2})}else{m.open("linearGradient",{id:id,x1:def.x1,x2:def.x2,y1:def.y1,y2:def.y2})}for(let i=0;i<stops.length;++i){m.open("stop",{offset:stops[i].offset,"stop-color":stops[i].color}).close()}m.close()}for(const id in clipping){const def=clipping[id];m.open("clipPath",{id:id});if(def.path){m.open("path",{d:def.path}).close()}else{m.open("rect",{x:0,y:0,width:def.width,height:def.height}).close()}m.close()}m.close()}}function style(s,item,scene,tag,defs){let styleList;if(item==null)return s;if(tag==="bgrect"&&scene.interactive===false){s["pointer-events"]="none"}if(tag==="bgfore"){if(scene.interactive===false){s["pointer-events"]="none"}s.display="none";if(item.fill!==null)return s}if(tag==="image"&&item.smooth===false){styleList=["image-rendering: optimizeSpeed;","image-rendering: pixelated;"]}if(tag==="text"){s["font-family"]=fontFamily(item);s["font-size"]=fontSize(item)+"px";s["font-style"]=item.fontStyle;s["font-variant"]=item.fontVariant;s["font-weight"]=item.fontWeight}for(const prop in stylesAttr){let value=item[prop];const name=stylesAttr[prop];if(value==="transparent"&&(name==="fill"||name==="stroke"));else if(value!=null){if(isGradient(value)){value=gradientRef(value,defs.gradient,"")}s[name]=value}}for(const prop in stylesCss){const value=item[prop];if(value!=null){styleList=styleList||[];styleList.push(`${stylesCss[prop]}: ${value};`)}}if(styleList){s.style=styleList.join(" ")}return s}const OPTS={svgMarkTypes:["text"],svgOnTop:true,debug:false};class HybridRenderer extends Renderer{constructor(loader){super(loader);this._svgRenderer=new SVGRenderer(loader);this._canvasRenderer=new CanvasRenderer(loader)}initialize(el,width,height,origin,scaleFactor){this._root_el=domChild(el,0,"div");const bottomEl=domChild(this._root_el,0,"div");const topEl=domChild(this._root_el,1,"div");this._root_el.style.position="relative";{bottomEl.style.height="100%";topEl.style.position="absolute";topEl.style.top="0";topEl.style.left="0";topEl.style.height="100%";topEl.style.width="100%"}this._svgEl=topEl;this._canvasEl=bottomEl;this._svgEl.style.pointerEvents="none";this._canvasRenderer.initialize(this._canvasEl,width,height,origin,scaleFactor);this._svgRenderer.initialize(this._svgEl,width,height,origin,scaleFactor);return super.initialize(el,width,height,origin,scaleFactor)}dirty(item){if(OPTS.svgMarkTypes.includes(item.mark.marktype)){this._svgRenderer.dirty(item)}else{this._canvasRenderer.dirty(item)}return this}_render(scene,markTypes){const allMarkTypes=markTypes??["arc","area","image","line","path","rect","rule","shape","symbol","text","trail"];const canvasMarkTypes=allMarkTypes.filter((m=>!OPTS.svgMarkTypes.includes(m)));this._svgRenderer.render(scene,OPTS.svgMarkTypes);this._canvasRenderer.render(scene,canvasMarkTypes)}resize(width,height,origin,scaleFactor){super.resize(width,height,origin,scaleFactor);this._svgRenderer.resize(width,height,origin,scaleFactor);this._canvasRenderer.resize(width,height,origin,scaleFactor);return this}background(bgcolor){{this._canvasRenderer.background(bgcolor)}return this}}class HybridHandler extends CanvasHandler{constructor(loader,tooltip){super(loader,tooltip)}initialize(el,origin,obj){const canvas=domChild(domChild(el,0,"div"),0,"div");return super.initialize(canvas,origin,obj)}}const Canvas="canvas";const Hybrid="hybrid";const PNG="png";const SVG="svg";const None$1="none";const RenderType={Canvas:Canvas,PNG:PNG,SVG:SVG,Hybrid:Hybrid,None:None$1};const modules={};modules[Canvas]=modules[PNG]={renderer:CanvasRenderer,headless:CanvasRenderer,handler:CanvasHandler};modules[SVG]={renderer:SVGRenderer,headless:SVGStringRenderer,handler:SVGHandler};modules[Hybrid]={renderer:HybridRenderer,headless:HybridRenderer,handler:HybridHandler};modules[None$1]={};function renderModule(name,_){name=String(name||"").toLowerCase();if(arguments.length>1){modules[name]=_;return this}else{return modules[name]}}function intersect$2(scene,bounds,filter){const hits=[],box=(new Bounds).union(bounds),type=scene.marktype;return type?intersectMark(scene,box,filter,hits):type==="group"?intersectGroup(scene,box,filter,hits):error("Intersect scene must be mark node or group item.")}function intersectMark(mark,box,filter,hits){if(visitMark(mark,box,filter)){const items=mark.items,type=mark.marktype,n=items.length;let i=0;if(type==="group"){for(;i<n;++i){intersectGroup(items[i],box,filter,hits)}}else{for(const test=Marks[type].isect;i<n;++i){const item=items[i];if(intersectItem(item,box,test))hits.push(item)}}}return hits}function visitMark(mark,box,filter){return mark.bounds&&box.intersects(mark.bounds)&&(mark.marktype==="group"||mark.interactive!==false&&(!filter||filter(mark)))}function intersectGroup(group,box,filter,hits){if(filter&&filter(group.mark)&&intersectItem(group,box,Marks.group.isect)){hits.push(group)}const marks=group.items,n=marks&&marks.length;if(n){const x=group.x||0,y=group.y||0;box.translate(-x,-y);for(let i=0;i<n;++i){intersectMark(marks[i],box,filter,hits)}box.translate(x,y)}return hits}function intersectItem(item,box,test){const bounds=item.bounds;return box.encloses(bounds)||box.intersects(bounds)&&test(item,box)}const clipBounds=new Bounds;function boundClip(mark){const clip=mark.clip;if(isFunction(clip)){clip(boundContext(clipBounds.clear()))}else if(clip){clipBounds.set(0,0,mark.group.width,mark.group.height)}else return;mark.bounds.intersect(clipBounds)}const Top$1="top";const Left$1="left";const Right$1="right";const Bottom$1="bottom";const TopLeft="top-left";const TopRight="top-right";const BottomLeft="bottom-left";const BottomRight="bottom-right";const Start$1="start";const Middle$1="middle";const End$1="end";const X$1="x";const Y$1="y";const Group="group";const AxisRole$1="axis";const TitleRole$1="title";const FrameRole$1="frame";const ScopeRole$1="scope";const LegendRole$1="legend";const RowHeader="row-header";const RowFooter="row-footer";const RowTitle="row-title";const ColHeader="column-header";const ColFooter="column-footer";const ColTitle="column-title";const Padding$1="padding";const Symbols$1="symbol";const Fit="fit";const FitX="fit-x";const FitY="fit-y";const Pad="pad";const None="none";const All="all";const Each="each";const Flush="flush";const Column="column";const Row="row";function Bound$1(params){Transform.call(this,null,params)}inherits(Bound$1,Transform,{transform(_,pulse){const view=pulse.dataflow,mark=_.mark,type=mark.marktype,entry=Marks[type],bound=entry.bound;let markBounds=mark.bounds,rebound;if(entry.nested){if(mark.items.length)view.dirty(mark.items[0]);markBounds=boundItem(mark,bound);mark.items.forEach((item=>{item.bounds.clear().union(markBounds)}))}else if(type===Group||_.modified()){pulse.visit(pulse.MOD,(item=>view.dirty(item)));markBounds.clear();mark.items.forEach((item=>markBounds.union(boundItem(item,bound))));switch(mark.role){case AxisRole$1:case LegendRole$1:case TitleRole$1:pulse.reflow()}}else{rebound=pulse.changed(pulse.REM);pulse.visit(pulse.ADD,(item=>{markBounds.union(boundItem(item,bound))}));pulse.visit(pulse.MOD,(item=>{rebound=rebound||markBounds.alignsWith(item.bounds);view.dirty(item);markBounds.union(boundItem(item,bound))}));if(rebound){markBounds.clear();mark.items.forEach((item=>markBounds.union(item.bounds)))}}boundClip(mark);return pulse.modifies("bounds")}});function boundItem(item,bound,opt){return bound(item.bounds.clear(),item,opt)}const COUNTER_NAME=":vega_identifier:";function Identifier$1(params){Transform.call(this,0,params)}Identifier$1.Definition={type:"Identifier",metadata:{modifies:true},params:[{name:"as",type:"string",required:true}]};inherits(Identifier$1,Transform,{transform(_,pulse){const counter=getCounter(pulse.dataflow),as=_.as;let id=counter.value;pulse.visit(pulse.ADD,(t=>t[as]=t[as]||++id));counter.set(this.value=id);return pulse}});function getCounter(view){return view._signals[COUNTER_NAME]||(view._signals[COUNTER_NAME]=view.add(0))}function Mark$2(params){Transform.call(this,null,params)}inherits(Mark$2,Transform,{transform(_,pulse){let mark=this.value;if(!mark){mark=pulse.dataflow.scenegraph().mark(_.markdef,lookup$1$1(_),_.index);mark.group.context=_.context;if(!_.context.group)_.context.group=mark.group;mark.source=this.source;mark.clip=_.clip;mark.interactive=_.interactive;this.value=mark}const Init=mark.marktype===Group?GroupItem:Item;pulse.visit(pulse.ADD,(item=>Init.call(item,mark)));if(_.modified("clip")||_.modified("interactive")){mark.clip=_.clip;mark.interactive=!!_.interactive;mark.zdirty=true;pulse.reflow()}mark.items=pulse.source;return pulse}});function lookup$1$1(_){const g=_.groups,p=_.parent;return g&&g.size===1?g.get(Object.keys(g.object)[0]):g&&p?g.lookup(p):null}function Overlap$1(params){Transform.call(this,null,params)}const methods={parity:items=>items.filter(((item,i)=>i%2?item.opacity=0:1)),greedy:(items,sep)=>{let a;return items.filter(((b,i)=>!i||!intersect$1(a.bounds,b.bounds,sep)?(a=b,1):b.opacity=0))}};const intersect$1=(a,b,sep)=>sep>Math.max(b.x1-a.x2,a.x1-b.x2,b.y1-a.y2,a.y1-b.y2);const hasOverlap=(items,pad)=>{for(var i=1,n=items.length,a=items[0].bounds,b;i<n;a=b,++i){if(intersect$1(a,b=items[i].bounds,pad))return true}};const hasBounds=item=>{const b=item.bounds;return b.width()>1&&b.height()>1};const boundTest=(scale,orient,tolerance)=>{var range=scale.range(),b=new Bounds;if(orient===Top$1||orient===Bottom$1){b.set(range[0],-Infinity,range[1],+Infinity)}else{b.set(-Infinity,range[0],+Infinity,range[1])}b.expand(tolerance||1);return item=>b.encloses(item.bounds)};const reset$1=source=>{source.forEach((item=>item.opacity=1));return source};const reflow=(pulse,_)=>pulse.reflow(_.modified()).modifies("opacity");inherits(Overlap$1,Transform,{transform(_,pulse){const reduce=methods[_.method]||methods.parity,sep=_.separation||0;let source=pulse.materialize(pulse.SOURCE).source,items,test;if(!source||!source.length)return;if(!_.method){if(_.modified("method")){reset$1(source);pulse=reflow(pulse,_)}return pulse}source=source.filter(hasBounds);if(!source.length)return;if(_.sort){source=source.slice().sort(_.sort)}items=reset$1(source);pulse=reflow(pulse,_);if(items.length>=3&&hasOverlap(items,sep)){do{items=reduce(items,sep)}while(items.length>=3&&hasOverlap(items,sep));if(items.length<3&&!peek$1(source).opacity){if(items.length>1)peek$1(items).opacity=0;peek$1(source).opacity=1}}if(_.boundScale&&_.boundTolerance>=0){test=boundTest(_.boundScale,_.boundOrient,+_.boundTolerance);source.forEach((item=>{if(!test(item))item.opacity=0}))}const bounds=items[0].mark.bounds.clear();source.forEach((item=>{if(item.opacity)bounds.union(item.bounds)}));return pulse}});function Render$1(params){Transform.call(this,null,params)}inherits(Render$1,Transform,{transform(_,pulse){const view=pulse.dataflow;pulse.visit(pulse.ALL,(item=>view.dirty(item)));if(pulse.fields&&pulse.fields["zindex"]){const item=pulse.source&&pulse.source[0];if(item)item.mark.zdirty=true}}});const tempBounds=new Bounds;function set$3(item,property,value){return item[property]===value?0:(item[property]=value,1)}function isYAxis(mark){var orient=mark.items[0].orient;return orient===Left$1||orient===Right$1}function axisIndices(datum){let index=+datum.grid;return[datum.ticks?index++:-1,datum.labels?index++:-1,index+ +datum.domain]}function axisLayout(view,axis,width,height){var item=axis.items[0],datum=item.datum,delta=item.translate!=null?item.translate:.5,orient=item.orient,indices=axisIndices(datum),range=item.range,offset=item.offset,position=item.position,minExtent=item.minExtent,maxExtent=item.maxExtent,title=datum.title&&item.items[indices[2]].items[0],titlePadding=item.titlePadding,bounds=item.bounds,dl=title&&multiLineOffset(title),x=0,y=0,i,s;tempBounds.clear().union(bounds);bounds.clear();if((i=indices[0])>-1)bounds.union(item.items[i].bounds);if((i=indices[1])>-1)bounds.union(item.items[i].bounds);switch(orient){case Top$1:x=position||0;y=-offset;s=Math.max(minExtent,Math.min(maxExtent,-bounds.y1));bounds.add(0,-s).add(range,0);if(title)axisTitleLayout(view,title,s,titlePadding,dl,0,-1,bounds);break;case Left$1:x=-offset;y=position||0;s=Math.max(minExtent,Math.min(maxExtent,-bounds.x1));bounds.add(-s,0).add(0,range);if(title)axisTitleLayout(view,title,s,titlePadding,dl,1,-1,bounds);break;case Right$1:x=width+offset;y=position||0;s=Math.max(minExtent,Math.min(maxExtent,bounds.x2));bounds.add(0,0).add(s,range);if(title)axisTitleLayout(view,title,s,titlePadding,dl,1,1,bounds);break;case Bottom$1:x=position||0;y=height+offset;s=Math.max(minExtent,Math.min(maxExtent,bounds.y2));bounds.add(0,0).add(range,s);if(title)axisTitleLayout(view,title,s,titlePadding,0,0,1,bounds);break;default:x=item.x;y=item.y}boundStroke(bounds.translate(x,y),item);if(set$3(item,"x",x+delta)|set$3(item,"y",y+delta)){item.bounds=tempBounds;view.dirty(item);item.bounds=bounds;view.dirty(item)}return item.mark.bounds.clear().union(bounds)}function axisTitleLayout(view,title,offset,pad,dl,isYAxis,sign,bounds){const b=title.bounds;if(title.auto){const v=sign*(offset+dl+pad);let dx=0,dy=0;view.dirty(title);isYAxis?dx=(title.x||0)-(title.x=v):dy=(title.y||0)-(title.y=v);title.mark.bounds.clear().union(b.translate(-dx,-dy));view.dirty(title)}bounds.union(b)}const min=(a,b)=>Math.floor(Math.min(a,b));const max=(a,b)=>Math.ceil(Math.max(a,b));function gridLayoutGroups(group){var groups=group.items,n=groups.length,i=0,mark,items;const views={marks:[],rowheaders:[],rowfooters:[],colheaders:[],colfooters:[],rowtitle:null,coltitle:null};for(;i<n;++i){mark=groups[i];items=mark.items;if(mark.marktype===Group){switch(mark.role){case AxisRole$1:case LegendRole$1:case TitleRole$1:break;case RowHeader:views.rowheaders.push(...items);break;case RowFooter:views.rowfooters.push(...items);break;case ColHeader:views.colheaders.push(...items);break;case ColFooter:views.colfooters.push(...items);break;case RowTitle:views.rowtitle=items[0];break;case ColTitle:views.coltitle=items[0];break;default:views.marks.push(...items)}}}return views}function bboxFlush(item){return(new Bounds).set(0,0,item.width||0,item.height||0)}function bboxFull(item){const b=item.bounds.clone();return b.empty()?b.set(0,0,0,0):b.translate(-(item.x||0),-(item.y||0))}function get$1(opt,key,d){const v=isObject(opt)?opt[key]:opt;return v!=null?v:d!==undefined?d:0}function offsetValue$1(v){return v<0?Math.ceil(-v):0}function gridLayout(view,groups,opt){var dirty=!opt.nodirty,bbox=opt.bounds===Flush?bboxFlush:bboxFull,bounds=tempBounds.set(0,0,0,0),alignCol=get$1(opt.align,Column),alignRow=get$1(opt.align,Row),padCol=get$1(opt.padding,Column),padRow=get$1(opt.padding,Row),ncols=opt.columns||groups.length,nrows=ncols<=0?1:Math.ceil(groups.length/ncols),n=groups.length,xOffset=Array(n),xExtent=Array(ncols),xMax=0,yOffset=Array(n),yExtent=Array(nrows),yMax=0,dx=Array(n),dy=Array(n),boxes=Array(n),m,i,c,r,b,g,px,py,x,y,offset;for(i=0;i<ncols;++i)xExtent[i]=0;for(i=0;i<nrows;++i)yExtent[i]=0;for(i=0;i<n;++i){g=groups[i];b=boxes[i]=bbox(g);g.x=g.x||0;dx[i]=0;g.y=g.y||0;dy[i]=0;c=i%ncols;r=~~(i/ncols);xMax=Math.max(xMax,px=Math.ceil(b.x2));yMax=Math.max(yMax,py=Math.ceil(b.y2));xExtent[c]=Math.max(xExtent[c],px);yExtent[r]=Math.max(yExtent[r],py);xOffset[i]=padCol+offsetValue$1(b.x1);yOffset[i]=padRow+offsetValue$1(b.y1);if(dirty)view.dirty(groups[i])}for(i=0;i<n;++i){if(i%ncols===0)xOffset[i]=0;if(i<ncols)yOffset[i]=0}if(alignCol===Each){for(c=1;c<ncols;++c){for(offset=0,i=c;i<n;i+=ncols){if(offset<xOffset[i])offset=xOffset[i]}for(i=c;i<n;i+=ncols){xOffset[i]=offset+xExtent[c-1]}}}else if(alignCol===All){for(offset=0,i=0;i<n;++i){if(i%ncols&&offset<xOffset[i])offset=xOffset[i]}for(i=0;i<n;++i){if(i%ncols)xOffset[i]=offset+xMax}}else{for(alignCol=false,c=1;c<ncols;++c){for(i=c;i<n;i+=ncols){xOffset[i]+=xExtent[c-1]}}}if(alignRow===Each){for(r=1;r<nrows;++r){for(offset=0,i=r*ncols,m=i+ncols;i<m;++i){if(offset<yOffset[i])offset=yOffset[i]}for(i=r*ncols;i<m;++i){yOffset[i]=offset+yExtent[r-1]}}}else if(alignRow===All){for(offset=0,i=ncols;i<n;++i){if(offset<yOffset[i])offset=yOffset[i]}for(i=ncols;i<n;++i){yOffset[i]=offset+yMax}}else{for(alignRow=false,r=1;r<nrows;++r){for(i=r*ncols,m=i+ncols;i<m;++i){yOffset[i]+=yExtent[r-1]}}}for(x=0,i=0;i<n;++i){x=xOffset[i]+(i%ncols?x:0);dx[i]+=x-groups[i].x}for(c=0;c<ncols;++c){for(y=0,i=c;i<n;i+=ncols){y+=yOffset[i];dy[i]+=y-groups[i].y}}if(alignCol&&get$1(opt.center,Column)&&nrows>1){for(i=0;i<n;++i){b=alignCol===All?xMax:xExtent[i%ncols];x=b-boxes[i].x2-groups[i].x-dx[i];if(x>0)dx[i]+=x/2}}if(alignRow&&get$1(opt.center,Row)&&ncols!==1){for(i=0;i<n;++i){b=alignRow===All?yMax:yExtent[~~(i/ncols)];y=b-boxes[i].y2-groups[i].y-dy[i];if(y>0)dy[i]+=y/2}}for(i=0;i<n;++i){bounds.union(boxes[i].translate(dx[i],dy[i]))}x=get$1(opt.anchor,X$1);y=get$1(opt.anchor,Y$1);switch(get$1(opt.anchor,Column)){case End$1:x-=bounds.width();break;case Middle$1:x-=bounds.width()/2}switch(get$1(opt.anchor,Row)){case End$1:y-=bounds.height();break;case Middle$1:y-=bounds.height()/2}x=Math.round(x);y=Math.round(y);bounds.clear();for(i=0;i<n;++i){groups[i].mark.bounds.clear()}for(i=0;i<n;++i){g=groups[i];g.x+=dx[i]+=x;g.y+=dy[i]+=y;bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i],dy[i])));if(dirty)view.dirty(g)}return bounds}function trellisLayout(view,group,opt){var views=gridLayoutGroups(group),groups=views.marks,bbox=opt.bounds===Flush?boundFlush:boundFull,off=opt.offset,ncols=opt.columns||groups.length,nrows=ncols<=0?1:Math.ceil(groups.length/ncols),cells=nrows*ncols,x,y,x2,y2,anchor,band,offset;const bounds=gridLayout(view,groups,opt);if(bounds.empty())bounds.set(0,0,0,0);if(views.rowheaders){band=get$1(opt.headerBand,Row,null);x=layoutHeaders(view,views.rowheaders,groups,ncols,nrows,-get$1(off,"rowHeader"),min,0,bbox,"x1",0,ncols,1,band)}if(views.colheaders){band=get$1(opt.headerBand,Column,null);y=layoutHeaders(view,views.colheaders,groups,ncols,ncols,-get$1(off,"columnHeader"),min,1,bbox,"y1",0,1,ncols,band)}if(views.rowfooters){band=get$1(opt.footerBand,Row,null);x2=layoutHeaders(view,views.rowfooters,groups,ncols,nrows,get$1(off,"rowFooter"),max,0,bbox,"x2",ncols-1,ncols,1,band)}if(views.colfooters){band=get$1(opt.footerBand,Column,null);y2=layoutHeaders(view,views.colfooters,groups,ncols,ncols,get$1(off,"columnFooter"),max,1,bbox,"y2",cells-ncols,1,ncols,band)}if(views.rowtitle){anchor=get$1(opt.titleAnchor,Row);offset=get$1(off,"rowTitle");offset=anchor===End$1?x2+offset:x-offset;band=get$1(opt.titleBand,Row,.5);layoutTitle(view,views.rowtitle,offset,0,bounds,band)}if(views.coltitle){anchor=get$1(opt.titleAnchor,Column);offset=get$1(off,"columnTitle");offset=anchor===End$1?y2+offset:y-offset;band=get$1(opt.titleBand,Column,.5);layoutTitle(view,views.coltitle,offset,1,bounds,band)}}function boundFlush(item,field){return field==="x1"?item.x||0:field==="y1"?item.y||0:field==="x2"?(item.x||0)+(item.width||0):field==="y2"?(item.y||0)+(item.height||0):undefined}function boundFull(item,field){return item.bounds[field]}function layoutHeaders(view,headers,groups,ncols,limit,offset,agg,isX,bound,bf,start,stride,back,band){var n=groups.length,init=0,edge=0,i,j,k,m,b,h,g,x,y;if(!n)return init;for(i=start;i<n;i+=stride){if(groups[i])init=agg(init,bound(groups[i],bf))}if(!headers.length)return init;if(headers.length>limit){view.warn("Grid headers exceed limit: "+limit);headers=headers.slice(0,limit)}init+=offset;for(j=0,m=headers.length;j<m;++j){view.dirty(headers[j]);headers[j].mark.bounds.clear()}for(i=start,j=0,m=headers.length;j<m;++j,i+=stride){h=headers[j];b=h.mark.bounds;for(k=i;k>=0&&(g=groups[k])==null;k-=back);if(isX){x=band==null?g.x:Math.round(g.bounds.x1+band*g.bounds.width());y=init}else{x=init;y=band==null?g.y:Math.round(g.bounds.y1+band*g.bounds.height())}b.union(h.bounds.translate(x-(h.x||0),y-(h.y||0)));h.x=x;h.y=y;view.dirty(h);edge=agg(edge,b[bf])}return edge}function layoutTitle(view,g,offset,isX,bounds,band){if(!g)return;view.dirty(g);var x=offset,y=offset;isX?x=Math.round(bounds.x1+band*bounds.width()):y=Math.round(bounds.y1+band*bounds.height());g.bounds.translate(x-(g.x||0),y-(g.y||0));g.mark.bounds.clear().union(g.bounds);g.x=x;g.y=y;view.dirty(g)}function lookup$3(config,orient){const opt=config[orient]||{};return(key,d)=>opt[key]!=null?opt[key]:config[key]!=null?config[key]:d}function offsets(legends,value){let max=-Infinity;legends.forEach((item=>{if(item.offset!=null)max=Math.max(max,item.offset)}));return max>-Infinity?max:value}function legendParams(g,orient,config,xb,yb,w,h){const _=lookup$3(config,orient),offset=offsets(g,_("offset",0)),anchor=_("anchor",Start$1),mult=anchor===End$1?1:anchor===Middle$1?.5:0;const p={align:Each,bounds:_("bounds",Flush),columns:_("direction")==="vertical"?1:g.length,padding:_("margin",8),center:_("center"),nodirty:true};switch(orient){case Left$1:p.anchor={x:Math.floor(xb.x1)-offset,column:End$1,y:mult*(h||xb.height()+2*xb.y1),row:anchor};break;case Right$1:p.anchor={x:Math.ceil(xb.x2)+offset,y:mult*(h||xb.height()+2*xb.y1),row:anchor};break;case Top$1:p.anchor={y:Math.floor(yb.y1)-offset,row:End$1,x:mult*(w||yb.width()+2*yb.x1),column:anchor};break;case Bottom$1:p.anchor={y:Math.ceil(yb.y2)+offset,x:mult*(w||yb.width()+2*yb.x1),column:anchor};break;case TopLeft:p.anchor={x:offset,y:offset};break;case TopRight:p.anchor={x:w-offset,y:offset,column:End$1};break;case BottomLeft:p.anchor={x:offset,y:h-offset,row:End$1};break;case BottomRight:p.anchor={x:w-offset,y:h-offset,column:End$1,row:End$1};break}return p}function legendLayout(view,legend){var item=legend.items[0],datum=item.datum,orient=item.orient,bounds=item.bounds,x=item.x,y=item.y,w,h;item._bounds?item._bounds.clear().union(bounds):item._bounds=bounds.clone();bounds.clear();legendGroupLayout(view,item,item.items[0].items[0]);bounds=legendBounds(item,bounds);w=2*item.padding;h=2*item.padding;if(!bounds.empty()){w=Math.ceil(bounds.width()+w);h=Math.ceil(bounds.height()+h)}if(datum.type===Symbols$1){legendEntryLayout(item.items[0].items[0].items[0].items)}if(orient!==None){item.x=x=0;item.y=y=0}item.width=w;item.height=h;boundStroke(bounds.set(x,y,x+w,y+h),item);item.mark.bounds.clear().union(bounds);return item}function legendBounds(item,b){item.items.forEach((_=>b.union(_.bounds)));b.x1=item.padding;b.y1=item.padding;return b}function legendGroupLayout(view,item,entry){var pad=item.padding,ex=pad-entry.x,ey=pad-entry.y;if(!item.datum.title){if(ex||ey)translate$1(view,entry,ex,ey)}else{var title=item.items[1].items[0],anchor=title.anchor,tpad=item.titlePadding||0,tx=pad-title.x,ty=pad-title.y;switch(title.orient){case Left$1:ex+=Math.ceil(title.bounds.width())+tpad;break;case Right$1:case Bottom$1:break;default:ey+=title.bounds.height()+tpad}if(ex||ey)translate$1(view,entry,ex,ey);switch(title.orient){case Left$1:ty+=legendTitleOffset(item,entry,title,anchor,1,1);break;case Right$1:tx+=legendTitleOffset(item,entry,title,End$1,0,0)+tpad;ty+=legendTitleOffset(item,entry,title,anchor,1,1);break;case Bottom$1:tx+=legendTitleOffset(item,entry,title,anchor,0,0);ty+=legendTitleOffset(item,entry,title,End$1,-1,0,1)+tpad;break;default:tx+=legendTitleOffset(item,entry,title,anchor,0,0)}if(tx||ty)translate$1(view,title,tx,ty);if((tx=Math.round(title.bounds.x1-pad))<0){translate$1(view,entry,-tx,0);translate$1(view,title,-tx,0)}}}function legendTitleOffset(item,entry,title,anchor,y,lr,noBar){const grad=item.datum.type!=="symbol",vgrad=title.datum.vgrad,e=grad&&(lr||!vgrad)&&!noBar?entry.items[0]:entry,s=e.bounds[y?"y2":"x2"]-item.padding,u=vgrad&&lr?s:0,v=vgrad&&lr?0:s,o=y<=0?0:multiLineOffset(title);return Math.round(anchor===Start$1?u:anchor===End$1?v-o:.5*(s-o))}function translate$1(view,item,dx,dy){item.x+=dx;item.y+=dy;item.bounds.translate(dx,dy);item.mark.bounds.translate(dx,dy);view.dirty(item)}function legendEntryLayout(entries){const widths=entries.reduce(((w,g)=>{w[g.column]=Math.max(g.bounds.x2-g.x,w[g.column]||0);return w}),{});entries.forEach((g=>{g.width=widths[g.column];g.height=g.bounds.y2-g.y}))}function titleLayout(view,mark,width,height,viewBounds){var group=mark.items[0],frame=group.frame,orient=group.orient,anchor=group.anchor,offset=group.offset,padding=group.padding,title=group.items[0].items[0],subtitle=group.items[1]&&group.items[1].items[0],end=orient===Left$1||orient===Right$1?height:width,start=0,x=0,y=0,sx=0,sy=0,pos;if(frame!==Group){orient===Left$1?(start=viewBounds.y2,end=viewBounds.y1):orient===Right$1?(start=viewBounds.y1,end=viewBounds.y2):(start=viewBounds.x1,end=viewBounds.x2)}else if(orient===Left$1){start=height,end=0}pos=anchor===Start$1?start:anchor===End$1?end:(start+end)/2;if(subtitle&&subtitle.text){switch(orient){case Top$1:case Bottom$1:sy=title.bounds.height()+padding;break;case Left$1:sx=title.bounds.width()+padding;break;case Right$1:sx=-title.bounds.width()-padding;break}tempBounds.clear().union(subtitle.bounds);tempBounds.translate(sx-(subtitle.x||0),sy-(subtitle.y||0));if(set$3(subtitle,"x",sx)|set$3(subtitle,"y",sy)){view.dirty(subtitle);subtitle.bounds.clear().union(tempBounds);subtitle.mark.bounds.clear().union(tempBounds);view.dirty(subtitle)}tempBounds.clear().union(subtitle.bounds)}else{tempBounds.clear()}tempBounds.union(title.bounds);switch(orient){case Top$1:x=pos;y=viewBounds.y1-tempBounds.height()-offset;break;case Left$1:x=viewBounds.x1-tempBounds.width()-offset;y=pos;break;case Right$1:x=viewBounds.x2+tempBounds.width()+offset;y=pos;break;case Bottom$1:x=pos;y=viewBounds.y2+offset;break;default:x=group.x;y=group.y}if(set$3(group,"x",x)|set$3(group,"y",y)){tempBounds.translate(x,y);view.dirty(group);group.bounds.clear().union(tempBounds);mark.bounds.clear().union(tempBounds);view.dirty(group)}return group.bounds}function ViewLayout$1(params){Transform.call(this,null,params)}inherits(ViewLayout$1,Transform,{transform(_,pulse){const view=pulse.dataflow;_.mark.items.forEach((group=>{if(_.layout)trellisLayout(view,group,_.layout);layoutGroup(view,group,_)}));return shouldReflow(_.mark.group)?pulse.reflow():pulse}});function shouldReflow(group){return group&&group.mark.role!=="legend-entry"}function layoutGroup(view,group,_){var items=group.items,width=Math.max(0,group.width||0),height=Math.max(0,group.height||0),viewBounds=(new Bounds).set(0,0,width,height),xBounds=viewBounds.clone(),yBounds=viewBounds.clone(),legends=[],title,mark,orient,b,i,n;for(i=0,n=items.length;i<n;++i){mark=items[i];switch(mark.role){case AxisRole$1:b=isYAxis(mark)?xBounds:yBounds;b.union(axisLayout(view,mark,width,height));break;case TitleRole$1:title=mark;break;case LegendRole$1:legends.push(legendLayout(view,mark));break;case FrameRole$1:case ScopeRole$1:case RowHeader:case RowFooter:case RowTitle:case ColHeader:case ColFooter:case ColTitle:xBounds.union(mark.bounds);yBounds.union(mark.bounds);break;default:viewBounds.union(mark.bounds)}}if(legends.length){const l={};legends.forEach((item=>{orient=item.orient||Right$1;if(orient!==None)(l[orient]||(l[orient]=[])).push(item)}));for(const orient in l){const g=l[orient];gridLayout(view,g,legendParams(g,orient,_.legends,xBounds,yBounds,width,height))}legends.forEach((item=>{const b=item.bounds;if(!b.equals(item._bounds)){item.bounds=item._bounds;view.dirty(item);item.bounds=b;view.dirty(item)}if(_.autosize&&(_.autosize.type===Fit||_.autosize.type===FitX||_.autosize.type===FitY)){switch(item.orient){case Left$1:case Right$1:viewBounds.add(b.x1,0).add(b.x2,0);break;case Top$1:case Bottom$1:viewBounds.add(0,b.y1).add(0,b.y2)}}else{viewBounds.union(b)}}))}viewBounds.union(xBounds).union(yBounds);if(title){viewBounds.union(titleLayout(view,title,width,height,viewBounds))}if(group.clip){viewBounds.set(0,0,group.width||0,group.height||0)}viewSizeLayout(view,group,viewBounds,_)}function viewSizeLayout(view,group,viewBounds,_){const auto=_.autosize||{},type=auto.type;if(view._autosize<1||!type)return;let viewWidth=view._width,viewHeight=view._height,width=Math.max(0,group.width||0),left=Math.max(0,Math.ceil(-viewBounds.x1)),height=Math.max(0,group.height||0),top=Math.max(0,Math.ceil(-viewBounds.y1));const right=Math.max(0,Math.ceil(viewBounds.x2-width)),bottom=Math.max(0,Math.ceil(viewBounds.y2-height));if(auto.contains===Padding$1){const padding=view.padding();viewWidth-=padding.left+padding.right;viewHeight-=padding.top+padding.bottom}if(type===None){left=0;top=0;width=viewWidth;height=viewHeight}else if(type===Fit){width=Math.max(0,viewWidth-left-right);height=Math.max(0,viewHeight-top-bottom)}else if(type===FitX){width=Math.max(0,viewWidth-left-right);viewHeight=height+top+bottom}else if(type===FitY){viewWidth=width+left+right;height=Math.max(0,viewHeight-top-bottom)}else if(type===Pad){viewWidth=width+left+right;viewHeight=height+top+bottom}view._resizeView(viewWidth,viewHeight,width,height,[left,top],auto.resize)}var vtx=Object.freeze({__proto__:null,bound:Bound$1,identifier:Identifier$1,mark:Mark$2,overlap:Overlap$1,render:Render$1,viewlayout:ViewLayout$1});function AxisTicks$1(params){Transform.call(this,null,params)}inherits(AxisTicks$1,Transform,{transform(_,pulse){if(this.value&&!_.modified()){return pulse.StopPropagation}var locale=pulse.dataflow.locale(),out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),ticks=this.value,scale=_.scale,tally=_.count==null?_.values?_.values.length:10:_.count,count=tickCount(scale,tally,_.minstep),format=_.format||tickFormat(locale,scale,count,_.formatSpecifier,_.formatType,!!_.values),values=_.values?validTicks(scale,_.values,count):tickValues(scale,count);if(ticks)out.rem=ticks;ticks=values.map(((value,i)=>ingest$1({index:i/(values.length-1||1),value:value,label:format(value)})));if(_.extra&&ticks.length){ticks.push(ingest$1({index:-1,extra:{value:ticks[0].value},label:""}))}out.source=ticks;out.add=ticks;this.value=ticks;return out}});function DataJoin$1(params){Transform.call(this,null,params)}function defaultItemCreate(){return ingest$1({})}function newMap(key){const map=fastmap().test((t=>t.exit));map.lookup=t=>map.get(key(t));return map}inherits(DataJoin$1,Transform,{transform(_,pulse){var df=pulse.dataflow,out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),item=_.item||defaultItemCreate,key=_.key||tupleid,map=this.value;if(isArray(out.encode)){out.encode=null}if(map&&(_.modified("key")||pulse.modified(key))){error("DataJoin does not support modified key function or fields.")}if(!map){pulse=pulse.addAll();this.value=map=newMap(key)}pulse.visit(pulse.ADD,(t=>{const k=key(t);let x=map.get(k);if(x){if(x.exit){map.empty--;out.add.push(x)}else{out.mod.push(x)}}else{x=item(t);map.set(k,x);out.add.push(x)}x.datum=t;x.exit=false}));pulse.visit(pulse.MOD,(t=>{const k=key(t),x=map.get(k);if(x){x.datum=t;out.mod.push(x)}}));pulse.visit(pulse.REM,(t=>{const k=key(t),x=map.get(k);if(t===x.datum&&!x.exit){out.rem.push(x);x.exit=true;++map.empty}}));if(pulse.changed(pulse.ADD_MOD))out.modifies("datum");if(pulse.clean()||_.clean&&map.empty>df.cleanThreshold){df.runAfter(map.clean)}return out}});function Encode$1(params){Transform.call(this,null,params)}inherits(Encode$1,Transform,{transform(_,pulse){var out=pulse.fork(pulse.ADD_REM),fmod=_.mod||false,encoders=_.encoders,encode=pulse.encode;if(isArray(encode)){if(out.changed()||encode.every((e=>encoders[e]))){encode=encode[0];out.encode=null}else{return pulse.StopPropagation}}var reenter=encode==="enter",update=encoders.update||falsy,enter=encoders.enter||falsy,exit=encoders.exit||falsy,set=(encode&&!reenter?encoders[encode]:update)||falsy;if(pulse.changed(pulse.ADD)){pulse.visit(pulse.ADD,(t=>{enter(t,_);update(t,_)}));out.modifies(enter.output);out.modifies(update.output);if(set!==falsy&&set!==update){pulse.visit(pulse.ADD,(t=>{set(t,_)}));out.modifies(set.output)}}if(pulse.changed(pulse.REM)&&exit!==falsy){pulse.visit(pulse.REM,(t=>{exit(t,_)}));out.modifies(exit.output)}if(reenter||set!==falsy){const flag=pulse.MOD|(_.modified()?pulse.REFLOW:0);if(reenter){pulse.visit(flag,(t=>{const mod=enter(t,_)||fmod;if(set(t,_)||mod)out.mod.push(t)}));if(out.mod.length)out.modifies(enter.output)}else{pulse.visit(flag,(t=>{if(set(t,_)||fmod)out.mod.push(t)}))}if(out.mod.length)out.modifies(set.output)}return out.changed()?out:pulse.StopPropagation}});function LegendEntries$1(params){Transform.call(this,[],params)}inherits(LegendEntries$1,Transform,{transform(_,pulse){if(this.value!=null&&!_.modified()){return pulse.StopPropagation}var locale=pulse.dataflow.locale(),out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),items=this.value,type=_.type||SymbolLegend,scale=_.scale,limit=+_.limit,count=tickCount(scale,_.count==null?5:_.count,_.minstep),lskip=!!_.values||type===SymbolLegend,format=_.format||labelFormat(locale,scale,count,type,_.formatSpecifier,_.formatType,lskip),values=_.values||labelValues(scale,count),domain,fraction,size,offset,ellipsis;if(items)out.rem=items;if(type===SymbolLegend){if(limit&&values.length>limit){pulse.dataflow.warn("Symbol legend count exceeds limit, filtering items.");items=values.slice(0,limit-1);ellipsis=true}else{items=values}if(isFunction(size=_.size)){if(!_.values&&scale(items[0])===0){items=items.slice(1)}offset=items.reduce(((max,value)=>Math.max(max,size(value,_))),0)}else{size=constant$5(offset=size||8)}items=items.map(((value,index)=>ingest$1({index:index,label:format(value,index,items),value:value,offset:offset,size:size(value,_)})));if(ellipsis){ellipsis=values[items.length];items.push(ingest$1({index:items.length,label:`…${values.length-items.length} entries`,value:ellipsis,offset:offset,size:size(ellipsis,_)}))}}else if(type===GradientLegend){domain=scale.domain(),fraction=scaleFraction(scale,domain[0],peek$1(domain));if(values.length<3&&!_.values&&domain[0]!==peek$1(domain)){values=[domain[0],peek$1(domain)]}items=values.map(((value,index)=>ingest$1({index:index,label:format(value,index,values),value:value,perc:fraction(value)})))}else{size=values.length-1;fraction=labelFraction(scale);items=values.map(((value,index)=>ingest$1({index:index,label:format(value,index,values),value:value,perc:index?fraction(value):0,perc2:index===size?1:fraction(values[index+1])})))}out.source=items;out.add=items;this.value=items;return out}});const sourceX=t=>t.source.x;const sourceY=t=>t.source.y;const targetX=t=>t.target.x;const targetY=t=>t.target.y;function LinkPath(params){Transform.call(this,{},params)}LinkPath.Definition={type:"LinkPath",metadata:{modifies:true},params:[{name:"sourceX",type:"field",default:"source.x"},{name:"sourceY",type:"field",default:"source.y"},{name:"targetX",type:"field",default:"target.x"},{name:"targetY",type:"field",default:"target.y"},{name:"orient",type:"enum",default:"vertical",values:["horizontal","vertical","radial"]},{name:"shape",type:"enum",default:"line",values:["line","arc","curve","diagonal","orthogonal"]},{name:"require",type:"signal"},{name:"as",type:"string",default:"path"}]};inherits(LinkPath,Transform,{transform(_,pulse){var sx=_.sourceX||sourceX,sy=_.sourceY||sourceY,tx=_.targetX||targetX,ty=_.targetY||targetY,as=_.as||"path",orient=_.orient||"vertical",shape=_.shape||"line",path=Paths.get(shape+"-"+orient)||Paths.get(shape);if(!path){error("LinkPath unsupported type: "+_.shape+(_.orient?"-"+_.orient:""))}pulse.visit(pulse.SOURCE,(t=>{t[as]=path(sx(t),sy(t),tx(t),ty(t))}));return pulse.reflow(_.modified()).modifies(as)}});const line$1=(sx,sy,tx,ty)=>"M"+sx+","+sy+"L"+tx+","+ty;const lineR=(sa,sr,ta,tr)=>line$1(sr*Math.cos(sa),sr*Math.sin(sa),tr*Math.cos(ta),tr*Math.sin(ta));const arc$1=(sx,sy,tx,ty)=>{var dx=tx-sx,dy=ty-sy,rr=Math.hypot(dx,dy)/2,ra=180*Math.atan2(dy,dx)/Math.PI;return"M"+sx+","+sy+"A"+rr+","+rr+" "+ra+" 0 1"+" "+tx+","+ty};const arcR=(sa,sr,ta,tr)=>arc$1(sr*Math.cos(sa),sr*Math.sin(sa),tr*Math.cos(ta),tr*Math.sin(ta));const curve=(sx,sy,tx,ty)=>{const dx=tx-sx,dy=ty-sy,ix=.2*(dx+dy),iy=.2*(dy-dx);return"M"+sx+","+sy+"C"+(sx+ix)+","+(sy+iy)+" "+(tx+iy)+","+(ty-ix)+" "+tx+","+ty};const curveR=(sa,sr,ta,tr)=>curve(sr*Math.cos(sa),sr*Math.sin(sa),tr*Math.cos(ta),tr*Math.sin(ta));const orthoX=(sx,sy,tx,ty)=>"M"+sx+","+sy+"V"+ty+"H"+tx;const orthoY=(sx,sy,tx,ty)=>"M"+sx+","+sy+"H"+tx+"V"+ty;const orthoR=(sa,sr,ta,tr)=>{const sc=Math.cos(sa),ss=Math.sin(sa),tc=Math.cos(ta),ts=Math.sin(ta),sf=Math.abs(ta-sa)>Math.PI?ta<=sa:ta>sa;return"M"+sr*sc+","+sr*ss+"A"+sr+","+sr+" 0 0,"+(sf?1:0)+" "+sr*tc+","+sr*ts+"L"+tr*tc+","+tr*ts};const diagonalX=(sx,sy,tx,ty)=>{const m=(sx+tx)/2;return"M"+sx+","+sy+"C"+m+","+sy+" "+m+","+ty+" "+tx+","+ty};const diagonalY=(sx,sy,tx,ty)=>{const m=(sy+ty)/2;return"M"+sx+","+sy+"C"+sx+","+m+" "+tx+","+m+" "+tx+","+ty};const diagonalR=(sa,sr,ta,tr)=>{const sc=Math.cos(sa),ss=Math.sin(sa),tc=Math.cos(ta),ts=Math.sin(ta),mr=(sr+tr)/2;return"M"+sr*sc+","+sr*ss+"C"+mr*sc+","+mr*ss+" "+mr*tc+","+mr*ts+" "+tr*tc+","+tr*ts};const Paths=fastmap({line:line$1,"line-radial":lineR,arc:arc$1,"arc-radial":arcR,curve:curve,"curve-radial":curveR,"orthogonal-horizontal":orthoX,"orthogonal-vertical":orthoY,"orthogonal-radial":orthoR,"diagonal-horizontal":diagonalX,"diagonal-vertical":diagonalY,"diagonal-radial":diagonalR});function Pie(params){Transform.call(this,null,params)}Pie.Definition={type:"Pie",metadata:{modifies:true},params:[{name:"field",type:"field"},{name:"startAngle",type:"number",default:0},{name:"endAngle",type:"number",default:6.283185307179586},{name:"sort",type:"boolean",default:false},{name:"as",type:"string",array:true,length:2,default:["startAngle","endAngle"]}]};inherits(Pie,Transform,{transform(_,pulse){var as=_.as||["startAngle","endAngle"],startAngle=as[0],endAngle=as[1],field=_.field||one$2,start=_.startAngle||0,stop=_.endAngle!=null?_.endAngle:2*Math.PI,data=pulse.source,values=data.map(field),n=values.length,a=start,k=(stop-start)/sum$1(values),index=range$4(n),i,t,v;if(_.sort){index.sort(((a,b)=>values[a]-values[b]))}for(i=0;i<n;++i){v=values[index[i]];t=data[index[i]];t[startAngle]=a;t[endAngle]=a+=v*k}this.value=values;return pulse.reflow(_.modified()).modifies(as)}});const DEFAULT_COUNT=5;function includeZero(scale){const type=scale.type;return!scale.bins&&(type===Linear||type===Pow||type===Sqrt)}function includePad(type){return isContinuous$1(type)&&type!==Sequential}const SKIP$1=toSet(["set","modified","clear","type","scheme","schemeExtent","schemeCount","domain","domainMin","domainMid","domainMax","domainRaw","domainImplicit","nice","zero","bins","range","rangeStep","round","reverse","interpolate","interpolateGamma"]);function Scale$1(params){Transform.call(this,null,params);this.modified(true)}inherits(Scale$1,Transform,{transform(_,pulse){var df=pulse.dataflow,scale$1=this.value,key=scaleKey(_);if(!scale$1||key!==scale$1.type){this.value=scale$1=scale$4(key)()}for(key in _)if(!SKIP$1[key]){if(key==="padding"&&includePad(scale$1.type))continue;isFunction(scale$1[key])?scale$1[key](_[key]):df.warn("Unsupported scale property: "+key)}configureRange(scale$1,_,configureBins(scale$1,_,configureDomain(scale$1,_,df)));return pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS)}});function scaleKey(_){var t=_.type,d="",n;if(t===Sequential)return Sequential+"-"+Linear;if(isContinuousColor(_)){n=_.rawDomain?_.rawDomain.length:_.domain?_.domain.length+ +(_.domainMid!=null):0;d=n===2?Sequential+"-":n===3?Diverging+"-":""}return(d+t||Linear).toLowerCase()}function isContinuousColor(_){const t=_.type;return isContinuous$1(t)&&t!==Time&&t!==UTC&&(_.scheme||_.range&&_.range.length&&_.range.every(isString))}function configureDomain(scale,_,df){const raw=rawDomain(scale,_.domainRaw,df);if(raw>-1)return raw;var domain=_.domain,type=scale.type,zero=_.zero||_.zero===undefined&&includeZero(scale),n,mid;if(!domain)return 0;if(zero||_.domainMin!=null||_.domainMax!=null||_.domainMid!=null){n=(domain=domain.slice()).length-1||1;if(zero){if(domain[0]>0)domain[0]=0;if(domain[n]<0)domain[n]=0}if(_.domainMin!=null)domain[0]=_.domainMin;if(_.domainMax!=null)domain[n]=_.domainMax;if(_.domainMid!=null){mid=_.domainMid;const i=mid>domain[n]?n+1:mid<domain[0]?0:n;if(i!==n)df.warn("Scale domainMid exceeds domain min or max.",mid);domain.splice(i,0,mid)}}if(includePad(type)&&_.padding&&domain[0]!==peek$1(domain)){domain=padDomain(type,domain,_.range,_.padding,_.exponent,_.constant)}scale.domain(domainCheck(type,domain,df));if(type===Ordinal){scale.unknown(_.domainImplicit?implicit:undefined)}if(_.nice&&scale.nice){scale.nice(_.nice!==true&&tickCount(scale,_.nice)||null)}return domain.length}function rawDomain(scale,raw,df){if(raw){scale.domain(domainCheck(scale.type,raw,df));return raw.length}else{return-1}}function padDomain(type,domain,range,pad,exponent,constant){var span=Math.abs(peek$1(range)-range[0]),frac=span/(span-2*pad),d=type===Log?zoomLog(domain,null,frac):type===Sqrt?zoomPow(domain,null,frac,.5):type===Pow?zoomPow(domain,null,frac,exponent||1):type===Symlog?zoomSymlog(domain,null,frac,constant||1):zoomLinear(domain,null,frac);domain=domain.slice();domain[0]=d[0];domain[domain.length-1]=d[1];return domain}function domainCheck(type,domain,df){if(isLogarithmic(type)){var s=Math.abs(domain.reduce(((s,v)=>s+(v<0?-1:v>0?1:0)),0));if(s!==domain.length){df.warn("Log scale domain includes zero: "+$(domain))}}return domain}function configureBins(scale,_,count){let bins=_.bins;if(bins&&!isArray(bins)){const domain=scale.domain(),lo=domain[0],hi=peek$1(domain),step=bins.step;let start=bins.start==null?lo:bins.start,stop=bins.stop==null?hi:bins.stop;if(!step)error("Scale bins parameter missing step property.");if(start<lo)start=step*Math.ceil(lo/step);if(stop>hi)stop=step*Math.floor(hi/step);bins=range$4(start,stop+step/2,step)}if(bins){scale.bins=bins}else if(scale.bins){delete scale.bins}if(scale.type===BinOrdinal){if(!bins){scale.bins=scale.domain()}else if(!_.domain&&!_.domainRaw){scale.domain(bins);count=bins.length}}return count}function configureRange(scale,_,count){var type=scale.type,round=_.round||false,range=_.range;if(_.rangeStep!=null){range=configureRangeStep(type,_,count)}else if(_.scheme){range=configureScheme(type,_,count);if(isFunction(range)){if(scale.interpolator){return scale.interpolator(range)}else{error(`Scale type ${type} does not support interpolating color schemes.`)}}}if(range&&isInterpolating(type)){return scale.interpolator(interpolateColors(flip(range,_.reverse),_.interpolate,_.interpolateGamma))}if(range&&_.interpolate&&scale.interpolate){scale.interpolate(interpolate$1(_.interpolate,_.interpolateGamma))}else if(isFunction(scale.round)){scale.round(round)}else if(isFunction(scale.rangeRound)){scale.interpolate(round?interpolateRound:interpolate$1$1)}if(range)scale.range(flip(range,_.reverse))}function configureRangeStep(type,_,count){if(type!==Band&&type!==Point){error("Only band and point scales support rangeStep.")}var outer=(_.paddingOuter!=null?_.paddingOuter:_.padding)||0,inner=type===Point?1:(_.paddingInner!=null?_.paddingInner:_.padding)||0;return[0,_.rangeStep*bandSpace(count,inner,outer)]}function configureScheme(type,_,count){var extent=_.schemeExtent,name,scheme$1$1;if(isArray(_.scheme)){scheme$1$1=interpolateColors(_.scheme,_.interpolate,_.interpolateGamma)}else{name=_.scheme.toLowerCase();scheme$1$1=scheme$1(name);if(!scheme$1$1)error(`Unrecognized scheme name: ${_.scheme}`)}count=type===Threshold?count+1:type===BinOrdinal?count-1:type===Quantile||type===Quantize?+_.schemeCount||DEFAULT_COUNT:count;return isInterpolating(type)?adjustScheme(scheme$1$1,extent,_.reverse):isFunction(scheme$1$1)?quantizeInterpolator(adjustScheme(scheme$1$1,extent),count):type===Ordinal?scheme$1$1:scheme$1$1.slice(0,count)}function adjustScheme(scheme,extent,reverse){return isFunction(scheme)&&(extent||reverse)?interpolateRange$1(scheme,flip(extent||[0,1],reverse)):scheme}function flip(array,reverse){return reverse?array.slice().reverse():array}function SortItems$1(params){Transform.call(this,null,params)}inherits(SortItems$1,Transform,{transform(_,pulse){const mod=_.modified("sort")||pulse.changed(pulse.ADD)||pulse.modified(_.sort.fields)||pulse.modified("datum");if(mod)pulse.source.sort(stableCompare(_.sort));this.modified(mod);return pulse}});const Zero="zero",Center$1="center",Normalize="normalize",DefOutput=["y0","y1"];function Stack(params){Transform.call(this,null,params)}Stack.Definition={type:"Stack",metadata:{modifies:true},params:[{name:"field",type:"field"},{name:"groupby",type:"field",array:true},{name:"sort",type:"compare"},{name:"offset",type:"enum",default:Zero,values:[Zero,Center$1,Normalize]},{name:"as",type:"string",array:true,length:2,default:DefOutput}]};inherits(Stack,Transform,{transform(_,pulse){var as=_.as||DefOutput,y0=as[0],y1=as[1],sort=stableCompare(_.sort),field=_.field||one$2,stack=_.offset===Center$1?stackCenter:_.offset===Normalize?stackNormalize:stackZero,groups,i,n,max;groups=partition$3(pulse.source,_.groupby,sort,field);for(i=0,n=groups.length,max=groups.max;i<n;++i){stack(groups[i],max,field,y0,y1)}return pulse.reflow(_.modified()).modifies(as)}});function stackCenter(group,max,field,y0,y1){var last=(max-group.sum)/2,m=group.length,j=0,t;for(;j<m;++j){t=group[j];t[y0]=last;t[y1]=last+=Math.abs(field(t))}}function stackNormalize(group,max,field,y0,y1){var scale=1/group.sum,last=0,m=group.length,j=0,v=0,t;for(;j<m;++j){t=group[j];t[y0]=last;t[y1]=last=scale*(v+=Math.abs(field(t)))}}function stackZero(group,max,field,y0,y1){var lastPos=0,lastNeg=0,m=group.length,j=0,v,t;for(;j<m;++j){t=group[j];v=+field(t);if(v<0){t[y0]=lastNeg;t[y1]=lastNeg+=v}else{t[y0]=lastPos;t[y1]=lastPos+=v}}}function partition$3(data,groupby,sort,field){var groups=[],get=f=>f(t),map,i,n,m,t,k,g,s,max;if(groupby==null){groups.push(data.slice())}else{for(map={},i=0,n=data.length;i<n;++i){t=data[i];k=groupby.map(get);g=map[k];if(!g){map[k]=g=[];groups.push(g)}g.push(t)}}for(k=0,max=0,m=groups.length;k<m;++k){g=groups[k];for(i=0,s=0,n=g.length;i<n;++i){s+=Math.abs(field(g[i]))}g.sum=s;if(s>max)max=s;if(sort)g.sort(sort)}groups.max=max;return groups}var encode$1=Object.freeze({__proto__:null,axisticks:AxisTicks$1,datajoin:DataJoin$1,encode:Encode$1,legendentries:LegendEntries$1,linkpath:LinkPath,pie:Pie,scale:Scale$1,sortitems:SortItems$1,stack:Stack});var epsilon$3=1e-6;var epsilon2=1e-12;var pi$1=Math.PI;var halfPi$1=pi$1/2;var quarterPi=pi$1/4;var tau$1=pi$1*2;var degrees=180/pi$1;var radians=pi$1/180;var abs$1=Math.abs;var atan=Math.atan;var atan2=Math.atan2;var cos$1=Math.cos;var ceil=Math.ceil;var exp=Math.exp;var hypot=Math.hypot;var log$1=Math.log;var pow$1=Math.pow;var sin$1=Math.sin;var sign=Math.sign||function(x){return x>0?1:x<0?-1:0};var sqrt$1=Math.sqrt;var tan=Math.tan;function acos(x){return x>1?0:x<-1?pi$1:Math.acos(x)}function asin$1(x){return x>1?halfPi$1:x<-1?-halfPi$1:Math.asin(x)}function noop$2(){}function streamGeometry(geometry,stream){if(geometry&&streamGeometryType.hasOwnProperty(geometry.type)){streamGeometryType[geometry.type](geometry,stream)}}var streamObjectType={Feature:function(object,stream){streamGeometry(object.geometry,stream)},FeatureCollection:function(object,stream){var features=object.features,i=-1,n=features.length;while(++i<n)streamGeometry(features[i].geometry,stream)}};var streamGeometryType={Sphere:function(object,stream){stream.sphere()},Point:function(object,stream){object=object.coordinates;stream.point(object[0],object[1],object[2])},MultiPoint:function(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n)object=coordinates[i],stream.point(object[0],object[1],object[2])},LineString:function(object,stream){streamLine(object.coordinates,stream,0)},MultiLineString:function(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n)streamLine(coordinates[i],stream,0)},Polygon:function(object,stream){streamPolygon(object.coordinates,stream)},MultiPolygon:function(object,stream){var coordinates=object.coordinates,i=-1,n=coordinates.length;while(++i<n)streamPolygon(coordinates[i],stream)},GeometryCollection:function(object,stream){var geometries=object.geometries,i=-1,n=geometries.length;while(++i<n)streamGeometry(geometries[i],stream)}};function streamLine(coordinates,stream,closed){var i=-1,n=coordinates.length-closed,coordinate;stream.lineStart();while(++i<n)coordinate=coordinates[i],stream.point(coordinate[0],coordinate[1],coordinate[2]);stream.lineEnd()}function streamPolygon(coordinates,stream){var i=-1,n=coordinates.length;stream.polygonStart();while(++i<n)streamLine(coordinates[i],stream,1);stream.polygonEnd()}function geoStream(object,stream){if(object&&streamObjectType.hasOwnProperty(object.type)){streamObjectType[object.type](object,stream)}else{streamGeometry(object,stream)}}var areaRingSum$1=new Adder;var areaSum$1=new Adder,lambda00$2,phi00$2,lambda0$1,cosPhi0,sinPhi0;var areaStream$1={point:noop$2,lineStart:noop$2,lineEnd:noop$2,polygonStart:function(){areaRingSum$1=new Adder;areaStream$1.lineStart=areaRingStart$1;areaStream$1.lineEnd=areaRingEnd$1},polygonEnd:function(){var areaRing=+areaRingSum$1;areaSum$1.add(areaRing<0?tau$1+areaRing:areaRing);this.lineStart=this.lineEnd=this.point=noop$2},sphere:function(){areaSum$1.add(tau$1)}};function areaRingStart$1(){areaStream$1.point=areaPointFirst$1}function areaRingEnd$1(){areaPoint$1(lambda00$2,phi00$2)}function areaPointFirst$1(lambda,phi){areaStream$1.point=areaPoint$1;lambda00$2=lambda,phi00$2=phi;lambda*=radians,phi*=radians;lambda0$1=lambda,cosPhi0=cos$1(phi=phi/2+quarterPi),sinPhi0=sin$1(phi)}function areaPoint$1(lambda,phi){lambda*=radians,phi*=radians;phi=phi/2+quarterPi;var dLambda=lambda-lambda0$1,sdLambda=dLambda>=0?1:-1,adLambda=sdLambda*dLambda,cosPhi=cos$1(phi),sinPhi=sin$1(phi),k=sinPhi0*sinPhi,u=cosPhi0*cosPhi+k*cos$1(adLambda),v=k*sdLambda*sin$1(adLambda);areaRingSum$1.add(atan2(v,u));lambda0$1=lambda,cosPhi0=cosPhi,sinPhi0=sinPhi}function geoArea$1(object){areaSum$1=new Adder;geoStream(object,areaStream$1);return areaSum$1*2}function spherical(cartesian){return[atan2(cartesian[1],cartesian[0]),asin$1(cartesian[2])]}function cartesian(spherical){var lambda=spherical[0],phi=spherical[1],cosPhi=cos$1(phi);return[cosPhi*cos$1(lambda),cosPhi*sin$1(lambda),sin$1(phi)]}function cartesianDot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]}function cartesianCross(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function cartesianAddInPlace(a,b){a[0]+=b[0],a[1]+=b[1],a[2]+=b[2]}function cartesianScale(vector,k){return[vector[0]*k,vector[1]*k,vector[2]*k]}function cartesianNormalizeInPlace(d){var l=sqrt$1(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);d[0]/=l,d[1]/=l,d[2]/=l}var lambda0,phi0,lambda1,phi1,lambda2,lambda00$1,phi00$1,p0,deltaSum,ranges,range$3;var boundsStream$1={point:boundsPoint$1,lineStart:boundsLineStart,lineEnd:boundsLineEnd,polygonStart:function(){boundsStream$1.point=boundsRingPoint;boundsStream$1.lineStart=boundsRingStart;boundsStream$1.lineEnd=boundsRingEnd;deltaSum=new Adder;areaStream$1.polygonStart()},polygonEnd:function(){areaStream$1.polygonEnd();boundsStream$1.point=boundsPoint$1;boundsStream$1.lineStart=boundsLineStart;boundsStream$1.lineEnd=boundsLineEnd;if(areaRingSum$1<0)lambda0=-(lambda1=180),phi0=-(phi1=90);else if(deltaSum>epsilon$3)phi1=90;else if(deltaSum<-epsilon$3)phi0=-90;range$3[0]=lambda0,range$3[1]=lambda1},sphere:function(){lambda0=-(lambda1=180),phi0=-(phi1=90)}};function boundsPoint$1(lambda,phi){ranges.push(range$3=[lambda0=lambda,lambda1=lambda]);if(phi<phi0)phi0=phi;if(phi>phi1)phi1=phi}function linePoint(lambda,phi){var p=cartesian([lambda*radians,phi*radians]);if(p0){var normal=cartesianCross(p0,p),equatorial=[normal[1],-normal[0],0],inflection=cartesianCross(equatorial,normal);cartesianNormalizeInPlace(inflection);inflection=spherical(inflection);var delta=lambda-lambda2,sign=delta>0?1:-1,lambdai=inflection[0]*degrees*sign,phii,antimeridian=abs$1(delta)>180;if(antimeridian^(sign*lambda2<lambdai&&lambdai<sign*lambda)){phii=inflection[1]*degrees;if(phii>phi1)phi1=phii}else if(lambdai=(lambdai+360)%360-180,antimeridian^(sign*lambda2<lambdai&&lambdai<sign*lambda)){phii=-inflection[1]*degrees;if(phii<phi0)phi0=phii}else{if(phi<phi0)phi0=phi;if(phi>phi1)phi1=phi}if(antimeridian){if(lambda<lambda2){if(angle(lambda0,lambda)>angle(lambda0,lambda1))lambda1=lambda}else{if(angle(lambda,lambda1)>angle(lambda0,lambda1))lambda0=lambda}}else{if(lambda1>=lambda0){if(lambda<lambda0)lambda0=lambda;if(lambda>lambda1)lambda1=lambda}else{if(lambda>lambda2){if(angle(lambda0,lambda)>angle(lambda0,lambda1))lambda1=lambda}else{if(angle(lambda,lambda1)>angle(lambda0,lambda1))lambda0=lambda}}}}else{ranges.push(range$3=[lambda0=lambda,lambda1=lambda])}if(phi<phi0)phi0=phi;if(phi>phi1)phi1=phi;p0=p,lambda2=lambda}function boundsLineStart(){boundsStream$1.point=linePoint}function boundsLineEnd(){range$3[0]=lambda0,range$3[1]=lambda1;boundsStream$1.point=boundsPoint$1;p0=null}function boundsRingPoint(lambda,phi){if(p0){var delta=lambda-lambda2;deltaSum.add(abs$1(delta)>180?delta+(delta>0?360:-360):delta)}else{lambda00$1=lambda,phi00$1=phi}areaStream$1.point(lambda,phi);linePoint(lambda,phi)}function boundsRingStart(){areaStream$1.lineStart()}function boundsRingEnd(){boundsRingPoint(lambda00$1,phi00$1);areaStream$1.lineEnd();if(abs$1(deltaSum)>epsilon$3)lambda0=-(lambda1=180);range$3[0]=lambda0,range$3[1]=lambda1;p0=null}function angle(lambda0,lambda1){return(lambda1-=lambda0)<0?lambda1+360:lambda1}function rangeCompare(a,b){return a[0]-b[0]}function rangeContains(range,x){return range[0]<=range[1]?range[0]<=x&&x<=range[1]:x<range[0]||range[1]<x}function geoBounds$1(feature){var i,n,a,b,merged,deltaMax,delta;phi1=lambda1=-(lambda0=phi0=Infinity);ranges=[];geoStream(feature,boundsStream$1);if(n=ranges.length){ranges.sort(rangeCompare);for(i=1,a=ranges[0],merged=[a];i<n;++i){b=ranges[i];if(rangeContains(a,b[0])||rangeContains(a,b[1])){if(angle(a[0],b[1])>angle(a[0],a[1]))a[1]=b[1];if(angle(b[0],a[1])>angle(a[0],a[1]))a[0]=b[0]}else{merged.push(a=b)}}for(deltaMax=-Infinity,n=merged.length-1,i=0,a=merged[n];i<=n;a=b,++i){b=merged[i];if((delta=angle(a[1],b[0]))>deltaMax)deltaMax=delta,lambda0=b[0],lambda1=a[1]}}ranges=range$3=null;return lambda0===Infinity||phi0===Infinity?[[NaN,NaN],[NaN,NaN]]:[[lambda0,phi0],[lambda1,phi1]]}var W0,W1,X0$1,Y0$1,Z0$1,X1$1,Y1$1,Z1$1,X2$2,Y2$2,Z2$1,lambda00,phi00,x0$4,y0$4,z0;var centroidStream$1={sphere:noop$2,point:centroidPoint$1,lineStart:centroidLineStart$1,lineEnd:centroidLineEnd$1,polygonStart:function(){centroidStream$1.lineStart=centroidRingStart$1;centroidStream$1.lineEnd=centroidRingEnd$1},polygonEnd:function(){centroidStream$1.lineStart=centroidLineStart$1;centroidStream$1.lineEnd=centroidLineEnd$1}};function centroidPoint$1(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi);centroidPointCartesian(cosPhi*cos$1(lambda),cosPhi*sin$1(lambda),sin$1(phi))}function centroidPointCartesian(x,y,z){++W0;X0$1+=(x-X0$1)/W0;Y0$1+=(y-Y0$1)/W0;Z0$1+=(z-Z0$1)/W0}function centroidLineStart$1(){centroidStream$1.point=centroidLinePointFirst}function centroidLinePointFirst(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi);x0$4=cosPhi*cos$1(lambda);y0$4=cosPhi*sin$1(lambda);z0=sin$1(phi);centroidStream$1.point=centroidLinePoint;centroidPointCartesian(x0$4,y0$4,z0)}function centroidLinePoint(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi),x=cosPhi*cos$1(lambda),y=cosPhi*sin$1(lambda),z=sin$1(phi),w=atan2(sqrt$1((w=y0$4*z-z0*y)*w+(w=z0*x-x0$4*z)*w+(w=x0$4*y-y0$4*x)*w),x0$4*x+y0$4*y+z0*z);W1+=w;X1$1+=w*(x0$4+(x0$4=x));Y1$1+=w*(y0$4+(y0$4=y));Z1$1+=w*(z0+(z0=z));centroidPointCartesian(x0$4,y0$4,z0)}function centroidLineEnd$1(){centroidStream$1.point=centroidPoint$1}function centroidRingStart$1(){centroidStream$1.point=centroidRingPointFirst}function centroidRingEnd$1(){centroidRingPoint(lambda00,phi00);centroidStream$1.point=centroidPoint$1}function centroidRingPointFirst(lambda,phi){lambda00=lambda,phi00=phi;lambda*=radians,phi*=radians;centroidStream$1.point=centroidRingPoint;var cosPhi=cos$1(phi);x0$4=cosPhi*cos$1(lambda);y0$4=cosPhi*sin$1(lambda);z0=sin$1(phi);centroidPointCartesian(x0$4,y0$4,z0)}function centroidRingPoint(lambda,phi){lambda*=radians,phi*=radians;var cosPhi=cos$1(phi),x=cosPhi*cos$1(lambda),y=cosPhi*sin$1(lambda),z=sin$1(phi),cx=y0$4*z-z0*y,cy=z0*x-x0$4*z,cz=x0$4*y-y0$4*x,m=hypot(cx,cy,cz),w=asin$1(m),v=m&&-w/m;X2$2.add(v*cx);Y2$2.add(v*cy);Z2$1.add(v*cz);W1+=w;X1$1+=w*(x0$4+(x0$4=x));Y1$1+=w*(y0$4+(y0$4=y));Z1$1+=w*(z0+(z0=z));centroidPointCartesian(x0$4,y0$4,z0)}function geoCentroid$1(object){W0=W1=X0$1=Y0$1=Z0$1=X1$1=Y1$1=Z1$1=0;X2$2=new Adder;Y2$2=new Adder;Z2$1=new Adder;geoStream(object,centroidStream$1);var x=+X2$2,y=+Y2$2,z=+Z2$1,m=hypot(x,y,z);if(m<epsilon2){x=X1$1,y=Y1$1,z=Z1$1;if(W1<epsilon$3)x=X0$1,y=Y0$1,z=Z0$1;m=hypot(x,y,z);if(m<epsilon2)return[NaN,NaN]}return[atan2(y,x)*degrees,asin$1(z/m)*degrees]}function compose(a,b){function compose(x,y){return x=a(x,y),b(x[0],x[1])}if(a.invert&&b.invert)compose.invert=function(x,y){return x=b.invert(x,y),x&&a.invert(x[0],x[1])};return compose}function rotationIdentity(lambda,phi){if(abs$1(lambda)>pi$1)lambda-=Math.round(lambda/tau$1)*tau$1;return[lambda,phi]}rotationIdentity.invert=rotationIdentity;function rotateRadians(deltaLambda,deltaPhi,deltaGamma){return(deltaLambda%=tau$1)?deltaPhi||deltaGamma?compose(rotationLambda(deltaLambda),rotationPhiGamma(deltaPhi,deltaGamma)):rotationLambda(deltaLambda):deltaPhi||deltaGamma?rotationPhiGamma(deltaPhi,deltaGamma):rotationIdentity}function forwardRotationLambda(deltaLambda){return function(lambda,phi){lambda+=deltaLambda;if(abs$1(lambda)>pi$1)lambda-=Math.round(lambda/tau$1)*tau$1;return[lambda,phi]}}function rotationLambda(deltaLambda){var rotation=forwardRotationLambda(deltaLambda);rotation.invert=forwardRotationLambda(-deltaLambda);return rotation}function rotationPhiGamma(deltaPhi,deltaGamma){var cosDeltaPhi=cos$1(deltaPhi),sinDeltaPhi=sin$1(deltaPhi),cosDeltaGamma=cos$1(deltaGamma),sinDeltaGamma=sin$1(deltaGamma);function rotation(lambda,phi){var cosPhi=cos$1(phi),x=cos$1(lambda)*cosPhi,y=sin$1(lambda)*cosPhi,z=sin$1(phi),k=z*cosDeltaPhi+x*sinDeltaPhi;return[atan2(y*cosDeltaGamma-k*sinDeltaGamma,x*cosDeltaPhi-z*sinDeltaPhi),asin$1(k*cosDeltaGamma+y*sinDeltaGamma)]}rotation.invert=function(lambda,phi){var cosPhi=cos$1(phi),x=cos$1(lambda)*cosPhi,y=sin$1(lambda)*cosPhi,z=sin$1(phi),k=z*cosDeltaGamma-y*sinDeltaGamma;return[atan2(y*cosDeltaGamma+z*sinDeltaGamma,x*cosDeltaPhi+k*sinDeltaPhi),asin$1(k*cosDeltaPhi-x*sinDeltaPhi)]};return rotation}function rotation(rotate){rotate=rotateRadians(rotate[0]*radians,rotate[1]*radians,rotate.length>2?rotate[2]*radians:0);function forward(coordinates){coordinates=rotate(coordinates[0]*radians,coordinates[1]*radians);return coordinates[0]*=degrees,coordinates[1]*=degrees,coordinates}forward.invert=function(coordinates){coordinates=rotate.invert(coordinates[0]*radians,coordinates[1]*radians);return coordinates[0]*=degrees,coordinates[1]*=degrees,coordinates};return forward}function circleStream(stream,radius,delta,direction,t0,t1){if(!delta)return;var cosRadius=cos$1(radius),sinRadius=sin$1(radius),step=direction*delta;if(t0==null){t0=radius+direction*tau$1;t1=radius-step/2}else{t0=circleRadius(cosRadius,t0);t1=circleRadius(cosRadius,t1);if(direction>0?t0<t1:t0>t1)t0+=direction*tau$1}for(var point,t=t0;direction>0?t>t1:t<t1;t-=step){point=spherical([cosRadius,-sinRadius*cos$1(t),-sinRadius*sin$1(t)]);stream.point(point[0],point[1])}}function circleRadius(cosRadius,point){point=cartesian(point),point[0]-=cosRadius;cartesianNormalizeInPlace(point);var radius=acos(-point[1]);return((-point[2]<0?-radius:radius)+tau$1-epsilon$3)%tau$1}function clipBuffer(){var lines=[],line;return{point:function(x,y,m){line.push([x,y,m])},lineStart:function(){lines.push(line=[])},lineEnd:noop$2,rejoin:function(){if(lines.length>1)lines.push(lines.pop().concat(lines.shift()))},result:function(){var result=lines;lines=[];line=null;return result}}}function pointEqual(a,b){return abs$1(a[0]-b[0])<epsilon$3&&abs$1(a[1]-b[1])<epsilon$3}function Intersection(point,points,other,entry){this.x=point;this.z=points;this.o=other;this.e=entry;this.v=false;this.n=this.p=null}function clipRejoin(segments,compareIntersection,startInside,interpolate,stream){var subject=[],clip=[],i,n;segments.forEach((function(segment){if((n=segment.length-1)<=0)return;var n,p0=segment[0],p1=segment[n],x;if(pointEqual(p0,p1)){if(!p0[2]&&!p1[2]){stream.lineStart();for(i=0;i<n;++i)stream.point((p0=segment[i])[0],p0[1]);stream.lineEnd();return}p1[0]+=2*epsilon$3}subject.push(x=new Intersection(p0,segment,null,true));clip.push(x.o=new Intersection(p0,null,x,false));subject.push(x=new Intersection(p1,segment,null,false));clip.push(x.o=new Intersection(p1,null,x,true))}));if(!subject.length)return;clip.sort(compareIntersection);link(subject);link(clip);for(i=0,n=clip.length;i<n;++i){clip[i].e=startInside=!startInside}var start=subject[0],points,point;while(1){var current=start,isSubject=true;while(current.v)if((current=current.n)===start)return;points=current.z;stream.lineStart();do{current.v=current.o.v=true;if(current.e){if(isSubject){for(i=0,n=points.length;i<n;++i)stream.point((point=points[i])[0],point[1])}else{interpolate(current.x,current.n.x,1,stream)}current=current.n}else{if(isSubject){points=current.p.z;for(i=points.length-1;i>=0;--i)stream.point((point=points[i])[0],point[1])}else{interpolate(current.x,current.p.x,-1,stream)}current=current.p}current=current.o;points=current.z;isSubject=!isSubject}while(!current.v);stream.lineEnd()}}function link(array){if(!(n=array.length))return;var n,i=0,a=array[0],b;while(++i<n){a.n=b=array[i];b.p=a;a=b}a.n=b=array[0];b.p=a}function longitude(point){return abs$1(point[0])<=pi$1?point[0]:sign(point[0])*((abs$1(point[0])+pi$1)%tau$1-pi$1)}function polygonContains(polygon,point){var lambda=longitude(point),phi=point[1],sinPhi=sin$1(phi),normal=[sin$1(lambda),-cos$1(lambda),0],angle=0,winding=0;var sum=new Adder;if(sinPhi===1)phi=halfPi$1+epsilon$3;else if(sinPhi===-1)phi=-halfPi$1-epsilon$3;for(var i=0,n=polygon.length;i<n;++i){if(!(m=(ring=polygon[i]).length))continue;var ring,m,point0=ring[m-1],lambda0=longitude(point0),phi0=point0[1]/2+quarterPi,sinPhi0=sin$1(phi0),cosPhi0=cos$1(phi0);for(var j=0;j<m;++j,lambda0=lambda1,sinPhi0=sinPhi1,cosPhi0=cosPhi1,point0=point1){var point1=ring[j],lambda1=longitude(point1),phi1=point1[1]/2+quarterPi,sinPhi1=sin$1(phi1),cosPhi1=cos$1(phi1),delta=lambda1-lambda0,sign=delta>=0?1:-1,absDelta=sign*delta,antimeridian=absDelta>pi$1,k=sinPhi0*sinPhi1;sum.add(atan2(k*sign*sin$1(absDelta),cosPhi0*cosPhi1+k*cos$1(absDelta)));angle+=antimeridian?delta+sign*tau$1:delta;if(antimeridian^lambda0>=lambda^lambda1>=lambda){var arc=cartesianCross(cartesian(point0),cartesian(point1));cartesianNormalizeInPlace(arc);var intersection=cartesianCross(normal,arc);cartesianNormalizeInPlace(intersection);var phiArc=(antimeridian^delta>=0?-1:1)*asin$1(intersection[2]);if(phi>phiArc||phi===phiArc&&(arc[0]||arc[1])){winding+=antimeridian^delta>=0?1:-1}}}}return(angle<-epsilon$3||angle<epsilon$3&&sum<-epsilon2)^winding&1}function clip$1(pointVisible,clipLine,interpolate,start){return function(sink){var line=clipLine(sink),ringBuffer=clipBuffer(),ringSink=clipLine(ringBuffer),polygonStarted=false,polygon,segments,ring;var clip={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function(){clip.point=pointRing;clip.lineStart=ringStart;clip.lineEnd=ringEnd;segments=[];polygon=[]},polygonEnd:function(){clip.point=point;clip.lineStart=lineStart;clip.lineEnd=lineEnd;segments=merge$2(segments);var startInside=polygonContains(polygon,start);if(segments.length){if(!polygonStarted)sink.polygonStart(),polygonStarted=true;clipRejoin(segments,compareIntersection,startInside,interpolate,sink)}else if(startInside){if(!polygonStarted)sink.polygonStart(),polygonStarted=true;sink.lineStart();interpolate(null,null,1,sink);sink.lineEnd()}if(polygonStarted)sink.polygonEnd(),polygonStarted=false;segments=polygon=null},sphere:function(){sink.polygonStart();sink.lineStart();interpolate(null,null,1,sink);sink.lineEnd();sink.polygonEnd()}};function point(lambda,phi){if(pointVisible(lambda,phi))sink.point(lambda,phi)}function pointLine(lambda,phi){line.point(lambda,phi)}function lineStart(){clip.point=pointLine;line.lineStart()}function lineEnd(){clip.point=point;line.lineEnd()}function pointRing(lambda,phi){ring.push([lambda,phi]);ringSink.point(lambda,phi)}function ringStart(){ringSink.lineStart();ring=[]}function ringEnd(){pointRing(ring[0][0],ring[0][1]);ringSink.lineEnd();var clean=ringSink.clean(),ringSegments=ringBuffer.result(),i,n=ringSegments.length,m,segment,point;ring.pop();polygon.push(ring);ring=null;if(!n)return;if(clean&1){segment=ringSegments[0];if((m=segment.length-1)>0){if(!polygonStarted)sink.polygonStart(),polygonStarted=true;sink.lineStart();for(i=0;i<m;++i)sink.point((point=segment[i])[0],point[1]);sink.lineEnd()}return}if(n>1&&clean&2)ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));segments.push(ringSegments.filter(validSegment))}return clip}}function validSegment(segment){return segment.length>1}function compareIntersection(a,b){return((a=a.x)[0]<0?a[1]-halfPi$1-epsilon$3:halfPi$1-a[1])-((b=b.x)[0]<0?b[1]-halfPi$1-epsilon$3:halfPi$1-b[1])}var clipAntimeridian=clip$1((function(){return true}),clipAntimeridianLine,clipAntimeridianInterpolate,[-pi$1,-halfPi$1]);function clipAntimeridianLine(stream){var lambda0=NaN,phi0=NaN,sign0=NaN,clean;return{lineStart:function(){stream.lineStart();clean=1},point:function(lambda1,phi1){var sign1=lambda1>0?pi$1:-pi$1,delta=abs$1(lambda1-lambda0);if(abs$1(delta-pi$1)<epsilon$3){stream.point(lambda0,phi0=(phi0+phi1)/2>0?halfPi$1:-halfPi$1);stream.point(sign0,phi0);stream.lineEnd();stream.lineStart();stream.point(sign1,phi0);stream.point(lambda1,phi0);clean=0}else if(sign0!==sign1&&delta>=pi$1){if(abs$1(lambda0-sign0)<epsilon$3)lambda0-=sign0*epsilon$3;if(abs$1(lambda1-sign1)<epsilon$3)lambda1-=sign1*epsilon$3;phi0=clipAntimeridianIntersect(lambda0,phi0,lambda1,phi1);stream.point(sign0,phi0);stream.lineEnd();stream.lineStart();stream.point(sign1,phi0);clean=0}stream.point(lambda0=lambda1,phi0=phi1);sign0=sign1},lineEnd:function(){stream.lineEnd();lambda0=phi0=NaN},clean:function(){return 2-clean}}}function clipAntimeridianIntersect(lambda0,phi0,lambda1,phi1){var cosPhi0,cosPhi1,sinLambda0Lambda1=sin$1(lambda0-lambda1);return abs$1(sinLambda0Lambda1)>epsilon$3?atan((sin$1(phi0)*(cosPhi1=cos$1(phi1))*sin$1(lambda1)-sin$1(phi1)*(cosPhi0=cos$1(phi0))*sin$1(lambda0))/(cosPhi0*cosPhi1*sinLambda0Lambda1)):(phi0+phi1)/2}function clipAntimeridianInterpolate(from,to,direction,stream){var phi;if(from==null){phi=direction*halfPi$1;stream.point(-pi$1,phi);stream.point(0,phi);stream.point(pi$1,phi);stream.point(pi$1,0);stream.point(pi$1,-phi);stream.point(0,-phi);stream.point(-pi$1,-phi);stream.point(-pi$1,0);stream.point(-pi$1,phi)}else if(abs$1(from[0]-to[0])>epsilon$3){var lambda=from[0]<to[0]?pi$1:-pi$1;phi=direction*lambda/2;stream.point(-lambda,phi);stream.point(0,phi);stream.point(lambda,phi)}else{stream.point(to[0],to[1])}}function clipCircle(radius){var cr=cos$1(radius),delta=2*radians,smallRadius=cr>0,notHemisphere=abs$1(cr)>epsilon$3;function interpolate(from,to,direction,stream){circleStream(stream,radius,delta,direction,from,to)}function visible(lambda,phi){return cos$1(lambda)*cos$1(phi)>cr}function clipLine(stream){var point0,c0,v0,v00,clean;return{lineStart:function(){v00=v0=false;clean=1},point:function(lambda,phi){var point1=[lambda,phi],point2,v=visible(lambda,phi),c=smallRadius?v?0:code(lambda,phi):v?code(lambda+(lambda<0?pi$1:-pi$1),phi):0;if(!point0&&(v00=v0=v))stream.lineStart();if(v!==v0){point2=intersect(point0,point1);if(!point2||pointEqual(point0,point2)||pointEqual(point1,point2))point1[2]=1}if(v!==v0){clean=0;if(v){stream.lineStart();point2=intersect(point1,point0);stream.point(point2[0],point2[1])}else{point2=intersect(point0,point1);stream.point(point2[0],point2[1],2);stream.lineEnd()}point0=point2}else if(notHemisphere&&point0&&smallRadius^v){var t;if(!(c&c0)&&(t=intersect(point1,point0,true))){clean=0;if(smallRadius){stream.lineStart();stream.point(t[0][0],t[0][1]);stream.point(t[1][0],t[1][1]);stream.lineEnd()}else{stream.point(t[1][0],t[1][1]);stream.lineEnd();stream.lineStart();stream.point(t[0][0],t[0][1],3)}}}if(v&&(!point0||!pointEqual(point0,point1))){stream.point(point1[0],point1[1])}point0=point1,v0=v,c0=c},lineEnd:function(){if(v0)stream.lineEnd();point0=null},clean:function(){return clean|(v00&&v0)<<1}}}function intersect(a,b,two){var pa=cartesian(a),pb=cartesian(b);var n1=[1,0,0],n2=cartesianCross(pa,pb),n2n2=cartesianDot(n2,n2),n1n2=n2[0],determinant=n2n2-n1n2*n1n2;if(!determinant)return!two&&a;var c1=cr*n2n2/determinant,c2=-cr*n1n2/determinant,n1xn2=cartesianCross(n1,n2),A=cartesianScale(n1,c1),B=cartesianScale(n2,c2);cartesianAddInPlace(A,B);var u=n1xn2,w=cartesianDot(A,u),uu=cartesianDot(u,u),t2=w*w-uu*(cartesianDot(A,A)-1);if(t2<0)return;var t=sqrt$1(t2),q=cartesianScale(u,(-w-t)/uu);cartesianAddInPlace(q,A);q=spherical(q);if(!two)return q;var lambda0=a[0],lambda1=b[0],phi0=a[1],phi1=b[1],z;if(lambda1<lambda0)z=lambda0,lambda0=lambda1,lambda1=z;var delta=lambda1-lambda0,polar=abs$1(delta-pi$1)<epsilon$3,meridian=polar||delta<epsilon$3;if(!polar&&phi1<phi0)z=phi0,phi0=phi1,phi1=z;if(meridian?polar?phi0+phi1>0^q[1]<(abs$1(q[0]-lambda0)<epsilon$3?phi0:phi1):phi0<=q[1]&&q[1]<=phi1:delta>pi$1^(lambda0<=q[0]&&q[0]<=lambda1)){var q1=cartesianScale(u,(-w+t)/uu);cartesianAddInPlace(q1,A);return[q,spherical(q1)]}}function code(lambda,phi){var r=smallRadius?radius:pi$1-radius,code=0;if(lambda<-r)code|=1;else if(lambda>r)code|=2;if(phi<-r)code|=4;else if(phi>r)code|=8;return code}return clip$1(visible,clipLine,interpolate,smallRadius?[0,-radius]:[-pi$1,radius-pi$1])}function clipLine(a,b,x0,y0,x1,y1){var ax=a[0],ay=a[1],bx=b[0],by=b[1],t0=0,t1=1,dx=bx-ax,dy=by-ay,r;r=x0-ax;if(!dx&&r>0)return;r/=dx;if(dx<0){if(r<t0)return;if(r<t1)t1=r}else if(dx>0){if(r>t1)return;if(r>t0)t0=r}r=x1-ax;if(!dx&&r<0)return;r/=dx;if(dx<0){if(r>t1)return;if(r>t0)t0=r}else if(dx>0){if(r<t0)return;if(r<t1)t1=r}r=y0-ay;if(!dy&&r>0)return;r/=dy;if(dy<0){if(r<t0)return;if(r<t1)t1=r}else if(dy>0){if(r>t1)return;if(r>t0)t0=r}r=y1-ay;if(!dy&&r<0)return;r/=dy;if(dy<0){if(r>t1)return;if(r>t0)t0=r}else if(dy>0){if(r<t0)return;if(r<t1)t1=r}if(t0>0)a[0]=ax+t0*dx,a[1]=ay+t0*dy;if(t1<1)b[0]=ax+t1*dx,b[1]=ay+t1*dy;return true}var clipMax=1e9,clipMin=-clipMax;function clipRectangle(x0,y0,x1,y1){function visible(x,y){return x0<=x&&x<=x1&&y0<=y&&y<=y1}function interpolate(from,to,direction,stream){var a=0,a1=0;if(from==null||(a=corner(from,direction))!==(a1=corner(to,direction))||comparePoint(from,to)<0^direction>0){do{stream.point(a===0||a===3?x0:x1,a>1?y1:y0)}while((a=(a+direction+4)%4)!==a1)}else{stream.point(to[0],to[1])}}function corner(p,direction){return abs$1(p[0]-x0)<epsilon$3?direction>0?0:3:abs$1(p[0]-x1)<epsilon$3?direction>0?2:1:abs$1(p[1]-y0)<epsilon$3?direction>0?1:0:direction>0?3:2}function compareIntersection(a,b){return comparePoint(a.x,b.x)}function comparePoint(a,b){var ca=corner(a,1),cb=corner(b,1);return ca!==cb?ca-cb:ca===0?b[1]-a[1]:ca===1?a[0]-b[0]:ca===2?a[1]-b[1]:b[0]-a[0]}return function(stream){var activeStream=stream,bufferStream=clipBuffer(),segments,polygon,ring,x__,y__,v__,x_,y_,v_,first,clean;var clipStream={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:polygonStart,polygonEnd:polygonEnd};function point(x,y){if(visible(x,y))activeStream.point(x,y)}function polygonInside(){var winding=0;for(var i=0,n=polygon.length;i<n;++i){for(var ring=polygon[i],j=1,m=ring.length,point=ring[0],a0,a1,b0=point[0],b1=point[1];j<m;++j){a0=b0,a1=b1,point=ring[j],b0=point[0],b1=point[1];if(a1<=y1){if(b1>y1&&(b0-a0)*(y1-a1)>(b1-a1)*(x0-a0))++winding}else{if(b1<=y1&&(b0-a0)*(y1-a1)<(b1-a1)*(x0-a0))--winding}}}return winding}function polygonStart(){activeStream=bufferStream,segments=[],polygon=[],clean=true}function polygonEnd(){var startInside=polygonInside(),cleanInside=clean&&startInside,visible=(segments=merge$2(segments)).length;if(cleanInside||visible){stream.polygonStart();if(cleanInside){stream.lineStart();interpolate(null,null,1,stream);stream.lineEnd()}if(visible){clipRejoin(segments,compareIntersection,startInside,interpolate,stream)}stream.polygonEnd()}activeStream=stream,segments=polygon=ring=null}function lineStart(){clipStream.point=linePoint;if(polygon)polygon.push(ring=[]);first=true;v_=false;x_=y_=NaN}function lineEnd(){if(segments){linePoint(x__,y__);if(v__&&v_)bufferStream.rejoin();segments.push(bufferStream.result())}clipStream.point=point;if(v_)activeStream.lineEnd()}function linePoint(x,y){var v=visible(x,y);if(polygon)ring.push([x,y]);if(first){x__=x,y__=y,v__=v;first=false;if(v){activeStream.lineStart();activeStream.point(x,y)}}else{if(v&&v_)activeStream.point(x,y);else{var a=[x_=Math.max(clipMin,Math.min(clipMax,x_)),y_=Math.max(clipMin,Math.min(clipMax,y_))],b=[x=Math.max(clipMin,Math.min(clipMax,x)),y=Math.max(clipMin,Math.min(clipMax,y))];if(clipLine(a,b,x0,y0,x1,y1)){if(!v_){activeStream.lineStart();activeStream.point(a[0],a[1])}activeStream.point(b[0],b[1]);if(!v)activeStream.lineEnd();clean=false}else if(v){activeStream.lineStart();activeStream.point(x,y);clean=false}}}x_=x,y_=y,v_=v}return clipStream}}function graticuleX(y0,y1,dy){var y=range$4(y0,y1-epsilon$3,dy).concat(y1);return function(x){return y.map((function(y){return[x,y]}))}}function graticuleY(x0,x1,dx){var x=range$4(x0,x1-epsilon$3,dx).concat(x1);return function(y){return x.map((function(x){return[x,y]}))}}function graticule(){var x1,x0,X1,X0,y1,y0,Y1,Y0,dx=10,dy=dx,DX=90,DY=360,x,y,X,Y,precision=2.5;function graticule(){return{type:"MultiLineString",coordinates:lines()}}function lines(){return range$4(ceil(X0/DX)*DX,X1,DX).map(X).concat(range$4(ceil(Y0/DY)*DY,Y1,DY).map(Y)).concat(range$4(ceil(x0/dx)*dx,x1,dx).filter((function(x){return abs$1(x%DX)>epsilon$3})).map(x)).concat(range$4(ceil(y0/dy)*dy,y1,dy).filter((function(y){return abs$1(y%DY)>epsilon$3})).map(y))}graticule.lines=function(){return lines().map((function(coordinates){return{type:"LineString",coordinates:coordinates}}))};graticule.outline=function(){return{type:"Polygon",coordinates:[X(X0).concat(Y(Y1).slice(1),X(X1).reverse().slice(1),Y(Y0).reverse().slice(1))]}};graticule.extent=function(_){if(!arguments.length)return graticule.extentMinor();return graticule.extentMajor(_).extentMinor(_)};graticule.extentMajor=function(_){if(!arguments.length)return[[X0,Y0],[X1,Y1]];X0=+_[0][0],X1=+_[1][0];Y0=+_[0][1],Y1=+_[1][1];if(X0>X1)_=X0,X0=X1,X1=_;if(Y0>Y1)_=Y0,Y0=Y1,Y1=_;return graticule.precision(precision)};graticule.extentMinor=function(_){if(!arguments.length)return[[x0,y0],[x1,y1]];x0=+_[0][0],x1=+_[1][0];y0=+_[0][1],y1=+_[1][1];if(x0>x1)_=x0,x0=x1,x1=_;if(y0>y1)_=y0,y0=y1,y1=_;return graticule.precision(precision)};graticule.step=function(_){if(!arguments.length)return graticule.stepMinor();return graticule.stepMajor(_).stepMinor(_)};graticule.stepMajor=function(_){if(!arguments.length)return[DX,DY];DX=+_[0],DY=+_[1];return graticule};graticule.stepMinor=function(_){if(!arguments.length)return[dx,dy];dx=+_[0],dy=+_[1];return graticule};graticule.precision=function(_){if(!arguments.length)return precision;precision=+_;x=graticuleX(y0,y1,90);y=graticuleY(x0,x1,precision);X=graticuleX(Y0,Y1,90);Y=graticuleY(X0,X1,precision);return graticule};return graticule.extentMajor([[-180,-90+epsilon$3],[180,90-epsilon$3]]).extentMinor([[-180,-80-epsilon$3],[180,80+epsilon$3]])}var identity=x=>x;var areaSum=new Adder,areaRingSum=new Adder,x00$2,y00$2,x0$3,y0$3;var areaStream={point:noop$2,lineStart:noop$2,lineEnd:noop$2,polygonStart:function(){areaStream.lineStart=areaRingStart;areaStream.lineEnd=areaRingEnd},polygonEnd:function(){areaStream.lineStart=areaStream.lineEnd=areaStream.point=noop$2;areaSum.add(abs$1(areaRingSum));areaRingSum=new Adder},result:function(){var area=areaSum/2;areaSum=new Adder;return area}};function areaRingStart(){areaStream.point=areaPointFirst}function areaPointFirst(x,y){areaStream.point=areaPoint;x00$2=x0$3=x,y00$2=y0$3=y}function areaPoint(x,y){areaRingSum.add(y0$3*x-x0$3*y);x0$3=x,y0$3=y}function areaRingEnd(){areaPoint(x00$2,y00$2)}var x0$2=Infinity,y0$2=x0$2,x1=-x0$2,y1=x1;var boundsStream={point:boundsPoint,lineStart:noop$2,lineEnd:noop$2,polygonStart:noop$2,polygonEnd:noop$2,result:function(){var bounds=[[x0$2,y0$2],[x1,y1]];x1=y1=-(y0$2=x0$2=Infinity);return bounds}};function boundsPoint(x,y){if(x<x0$2)x0$2=x;if(x>x1)x1=x;if(y<y0$2)y0$2=y;if(y>y1)y1=y}var X0=0,Y0=0,Z0=0,X1=0,Y1=0,Z1=0,X2$1=0,Y2$1=0,Z2=0,x00$1,y00$1,x0$1,y0$1;var centroidStream={point:centroidPoint,lineStart:centroidLineStart,lineEnd:centroidLineEnd,polygonStart:function(){centroidStream.lineStart=centroidRingStart;centroidStream.lineEnd=centroidRingEnd},polygonEnd:function(){centroidStream.point=centroidPoint;centroidStream.lineStart=centroidLineStart;centroidStream.lineEnd=centroidLineEnd},result:function(){var centroid=Z2?[X2$1/Z2,Y2$1/Z2]:Z1?[X1/Z1,Y1/Z1]:Z0?[X0/Z0,Y0/Z0]:[NaN,NaN];X0=Y0=Z0=X1=Y1=Z1=X2$1=Y2$1=Z2=0;return centroid}};function centroidPoint(x,y){X0+=x;Y0+=y;++Z0}function centroidLineStart(){centroidStream.point=centroidPointFirstLine}function centroidPointFirstLine(x,y){centroidStream.point=centroidPointLine;centroidPoint(x0$1=x,y0$1=y)}function centroidPointLine(x,y){var dx=x-x0$1,dy=y-y0$1,z=sqrt$1(dx*dx+dy*dy);X1+=z*(x0$1+x)/2;Y1+=z*(y0$1+y)/2;Z1+=z;centroidPoint(x0$1=x,y0$1=y)}function centroidLineEnd(){centroidStream.point=centroidPoint}function centroidRingStart(){centroidStream.point=centroidPointFirstRing}function centroidRingEnd(){centroidPointRing(x00$1,y00$1)}function centroidPointFirstRing(x,y){centroidStream.point=centroidPointRing;centroidPoint(x00$1=x0$1=x,y00$1=y0$1=y)}function centroidPointRing(x,y){var dx=x-x0$1,dy=y-y0$1,z=sqrt$1(dx*dx+dy*dy);X1+=z*(x0$1+x)/2;Y1+=z*(y0$1+y)/2;Z1+=z;z=y0$1*x-x0$1*y;X2$1+=z*(x0$1+x);Y2$1+=z*(y0$1+y);Z2+=z*3;centroidPoint(x0$1=x,y0$1=y)}function PathContext(context){this._context=context}PathContext.prototype={_radius:4.5,pointRadius:function(_){return this._radius=_,this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){if(this._line===0)this._context.closePath();this._point=NaN},point:function(x,y){switch(this._point){case 0:{this._context.moveTo(x,y);this._point=1;break}case 1:{this._context.lineTo(x,y);break}default:{this._context.moveTo(x+this._radius,y);this._context.arc(x,y,this._radius,0,tau$1);break}}},result:noop$2};var lengthSum=new Adder,lengthRing,x00,y00,x0,y0;var lengthStream={point:noop$2,lineStart:function(){lengthStream.point=lengthPointFirst},lineEnd:function(){if(lengthRing)lengthPoint(x00,y00);lengthStream.point=noop$2},polygonStart:function(){lengthRing=true},polygonEnd:function(){lengthRing=null},result:function(){var length=+lengthSum;lengthSum=new Adder;return length}};function lengthPointFirst(x,y){lengthStream.point=lengthPoint;x00=x0=x,y00=y0=y}function lengthPoint(x,y){x0-=x,y0-=y;lengthSum.add(sqrt$1(x0*x0+y0*y0));x0=x,y0=y}let cacheDigits,cacheAppend,cacheRadius,cacheCircle;class PathString{constructor(digits){this._append=digits==null?append:appendRound(digits);this._radius=4.5;this._=""}pointRadius(_){this._radius=+_;return this}polygonStart(){this._line=0}polygonEnd(){this._line=NaN}lineStart(){this._point=0}lineEnd(){if(this._line===0)this._+="Z";this._point=NaN}point(x,y){switch(this._point){case 0:{this._append`M${x},${y}`;this._point=1;break}case 1:{this._append`L${x},${y}`;break}default:{this._append`M${x},${y}`;if(this._radius!==cacheRadius||this._append!==cacheAppend){const r=this._radius;const s=this._;this._="";this._append`m0,${r}a${r},${r} 0 1,1 0,${-2*r}a${r},${r} 0 1,1 0,${2*r}z`;cacheRadius=r;cacheAppend=this._append;cacheCircle=this._;this._=s}this._+=cacheCircle;break}}}result(){const result=this._;this._="";return result.length?result:null}}function append(strings){let i=1;this._+=strings[0];for(const j=strings.length;i<j;++i){this._+=arguments[i]+strings[i]}}function appendRound(digits){const d=Math.floor(digits);if(!(d>=0))throw new RangeError(`invalid digits: ${digits}`);if(d>15)return append;if(d!==cacheDigits){const k=10**d;cacheDigits=d;cacheAppend=function append(strings){let i=1;this._+=strings[0];for(const j=strings.length;i<j;++i){this._+=Math.round(arguments[i]*k)/k+strings[i]}}}return cacheAppend}function geoPath(projection,context){let digits=3,pointRadius=4.5,projectionStream,contextStream;function path(object){if(object){if(typeof pointRadius==="function")contextStream.pointRadius(+pointRadius.apply(this,arguments));geoStream(object,projectionStream(contextStream))}return contextStream.result()}path.area=function(object){geoStream(object,projectionStream(areaStream));return areaStream.result()};path.measure=function(object){geoStream(object,projectionStream(lengthStream));return lengthStream.result()};path.bounds=function(object){geoStream(object,projectionStream(boundsStream));return boundsStream.result()};path.centroid=function(object){geoStream(object,projectionStream(centroidStream));return centroidStream.result()};path.projection=function(_){if(!arguments.length)return projection;projectionStream=_==null?(projection=null,identity):(projection=_).stream;return path};path.context=function(_){if(!arguments.length)return context;contextStream=_==null?(context=null,new PathString(digits)):new PathContext(context=_);if(typeof pointRadius!=="function")contextStream.pointRadius(pointRadius);return path};path.pointRadius=function(_){if(!arguments.length)return pointRadius;pointRadius=typeof _==="function"?_:(contextStream.pointRadius(+_),+_);return path};path.digits=function(_){if(!arguments.length)return digits;if(_==null)digits=null;else{const d=Math.floor(_);if(!(d>=0))throw new RangeError(`invalid digits: ${_}`);digits=d}if(context===null)contextStream=new PathString(digits);return path};return path.projection(projection).digits(digits).context(context)}function transformer(methods){return function(stream){var s=new TransformStream;for(var key in methods)s[key]=methods[key];s.stream=stream;return s}}function TransformStream(){}TransformStream.prototype={constructor:TransformStream,point:function(x,y){this.stream.point(x,y)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};function fit$1(projection,fitBounds,object){var clip=projection.clipExtent&&projection.clipExtent();projection.scale(150).translate([0,0]);if(clip!=null)projection.clipExtent(null);geoStream(object,projection.stream(boundsStream));fitBounds(boundsStream.result());if(clip!=null)projection.clipExtent(clip);return projection}function fitExtent(projection,extent,object){return fit$1(projection,(function(b){var w=extent[1][0]-extent[0][0],h=extent[1][1]-extent[0][1],k=Math.min(w/(b[1][0]-b[0][0]),h/(b[1][1]-b[0][1])),x=+extent[0][0]+(w-k*(b[1][0]+b[0][0]))/2,y=+extent[0][1]+(h-k*(b[1][1]+b[0][1]))/2;projection.scale(150*k).translate([x,y])}),object)}function fitSize(projection,size,object){return fitExtent(projection,[[0,0],size],object)}function fitWidth(projection,width,object){return fit$1(projection,(function(b){var w=+width,k=w/(b[1][0]-b[0][0]),x=(w-k*(b[1][0]+b[0][0]))/2,y=-k*b[0][1];projection.scale(150*k).translate([x,y])}),object)}function fitHeight(projection,height,object){return fit$1(projection,(function(b){var h=+height,k=h/(b[1][1]-b[0][1]),x=-k*b[0][0],y=(h-k*(b[1][1]+b[0][1]))/2;projection.scale(150*k).translate([x,y])}),object)}var maxDepth=16,cosMinDistance=cos$1(30*radians);function resample(project,delta2){return+delta2?resample$1(project,delta2):resampleNone(project)}function resampleNone(project){return transformer({point:function(x,y){x=project(x,y);this.stream.point(x[0],x[1])}})}function resample$1(project,delta2){function resampleLineTo(x0,y0,lambda0,a0,b0,c0,x1,y1,lambda1,a1,b1,c1,depth,stream){var dx=x1-x0,dy=y1-y0,d2=dx*dx+dy*dy;if(d2>4*delta2&&depth--){var a=a0+a1,b=b0+b1,c=c0+c1,m=sqrt$1(a*a+b*b+c*c),phi2=asin$1(c/=m),lambda2=abs$1(abs$1(c)-1)<epsilon$3||abs$1(lambda0-lambda1)<epsilon$3?(lambda0+lambda1)/2:atan2(b,a),p=project(lambda2,phi2),x2=p[0],y2=p[1],dx2=x2-x0,dy2=y2-y0,dz=dy*dx2-dx*dy2;if(dz*dz/d2>delta2||abs$1((dx*dx2+dy*dy2)/d2-.5)>.3||a0*a1+b0*b1+c0*c1<cosMinDistance){resampleLineTo(x0,y0,lambda0,a0,b0,c0,x2,y2,lambda2,a/=m,b/=m,c,depth,stream);stream.point(x2,y2);resampleLineTo(x2,y2,lambda2,a,b,c,x1,y1,lambda1,a1,b1,c1,depth,stream)}}}return function(stream){var lambda00,x00,y00,a00,b00,c00,lambda0,x0,y0,a0,b0,c0;var resampleStream={point:point,lineStart:lineStart,lineEnd:lineEnd,polygonStart:function(){stream.polygonStart();resampleStream.lineStart=ringStart},polygonEnd:function(){stream.polygonEnd();resampleStream.lineStart=lineStart}};function point(x,y){x=project(x,y);stream.point(x[0],x[1])}function lineStart(){x0=NaN;resampleStream.point=linePoint;stream.lineStart()}function linePoint(lambda,phi){var c=cartesian([lambda,phi]),p=project(lambda,phi);resampleLineTo(x0,y0,lambda0,a0,b0,c0,x0=p[0],y0=p[1],lambda0=lambda,a0=c[0],b0=c[1],c0=c[2],maxDepth,stream);stream.point(x0,y0)}function lineEnd(){resampleStream.point=point;stream.lineEnd()}function ringStart(){lineStart();resampleStream.point=ringPoint;resampleStream.lineEnd=ringEnd}function ringPoint(lambda,phi){linePoint(lambda00=lambda,phi),x00=x0,y00=y0,a00=a0,b00=b0,c00=c0;resampleStream.point=linePoint}function ringEnd(){resampleLineTo(x0,y0,lambda0,a0,b0,c0,x00,y00,lambda00,a00,b00,c00,maxDepth,stream);resampleStream.lineEnd=lineEnd;lineEnd()}return resampleStream}}var transformRadians=transformer({point:function(x,y){this.stream.point(x*radians,y*radians)}});function transformRotate(rotate){return transformer({point:function(x,y){var r=rotate(x,y);return this.stream.point(r[0],r[1])}})}function scaleTranslate(k,dx,dy,sx,sy){function transform(x,y){x*=sx;y*=sy;return[dx+k*x,dy-k*y]}transform.invert=function(x,y){return[(x-dx)/k*sx,(dy-y)/k*sy]};return transform}function scaleTranslateRotate(k,dx,dy,sx,sy,alpha){if(!alpha)return scaleTranslate(k,dx,dy,sx,sy);var cosAlpha=cos$1(alpha),sinAlpha=sin$1(alpha),a=cosAlpha*k,b=sinAlpha*k,ai=cosAlpha/k,bi=sinAlpha/k,ci=(sinAlpha*dy-cosAlpha*dx)/k,fi=(sinAlpha*dx+cosAlpha*dy)/k;function transform(x,y){x*=sx;y*=sy;return[a*x-b*y+dx,dy-b*x-a*y]}transform.invert=function(x,y){return[sx*(ai*x-bi*y+ci),sy*(fi-bi*x-ai*y)]};return transform}function projection$1(project){return projectionMutator((function(){return project}))()}function projectionMutator(projectAt){var project,k=150,x=480,y=250,lambda=0,phi=0,deltaLambda=0,deltaPhi=0,deltaGamma=0,rotate,alpha=0,sx=1,sy=1,theta=null,preclip=clipAntimeridian,x0=null,y0,x1,y1,postclip=identity,delta2=.5,projectResample,projectTransform,projectRotateTransform,cache,cacheStream;function projection(point){return projectRotateTransform(point[0]*radians,point[1]*radians)}function invert(point){point=projectRotateTransform.invert(point[0],point[1]);return point&&[point[0]*degrees,point[1]*degrees]}projection.stream=function(stream){return cache&&cacheStream===stream?cache:cache=transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream=stream)))))};projection.preclip=function(_){return arguments.length?(preclip=_,theta=undefined,reset()):preclip};projection.postclip=function(_){return arguments.length?(postclip=_,x0=y0=x1=y1=null,reset()):postclip};projection.clipAngle=function(_){return arguments.length?(preclip=+_?clipCircle(theta=_*radians):(theta=null,clipAntimeridian),reset()):theta*degrees};projection.clipExtent=function(_){return arguments.length?(postclip=_==null?(x0=y0=x1=y1=null,identity):clipRectangle(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1]),reset()):x0==null?null:[[x0,y0],[x1,y1]]};projection.scale=function(_){return arguments.length?(k=+_,recenter()):k};projection.translate=function(_){return arguments.length?(x=+_[0],y=+_[1],recenter()):[x,y]};projection.center=function(_){return arguments.length?(lambda=_[0]%360*radians,phi=_[1]%360*radians,recenter()):[lambda*degrees,phi*degrees]};projection.rotate=function(_){return arguments.length?(deltaLambda=_[0]%360*radians,deltaPhi=_[1]%360*radians,deltaGamma=_.length>2?_[2]%360*radians:0,recenter()):[deltaLambda*degrees,deltaPhi*degrees,deltaGamma*degrees]};projection.angle=function(_){return arguments.length?(alpha=_%360*radians,recenter()):alpha*degrees};projection.reflectX=function(_){return arguments.length?(sx=_?-1:1,recenter()):sx<0};projection.reflectY=function(_){return arguments.length?(sy=_?-1:1,recenter()):sy<0};projection.precision=function(_){return arguments.length?(projectResample=resample(projectTransform,delta2=_*_),reset()):sqrt$1(delta2)};projection.fitExtent=function(extent,object){return fitExtent(projection,extent,object)};projection.fitSize=function(size,object){return fitSize(projection,size,object)};projection.fitWidth=function(width,object){return fitWidth(projection,width,object)};projection.fitHeight=function(height,object){return fitHeight(projection,height,object)};function recenter(){var center=scaleTranslateRotate(k,0,0,sx,sy,alpha).apply(null,project(lambda,phi)),transform=scaleTranslateRotate(k,x-center[0],y-center[1],sx,sy,alpha);rotate=rotateRadians(deltaLambda,deltaPhi,deltaGamma);projectTransform=compose(project,transform);projectRotateTransform=compose(rotate,projectTransform);projectResample=resample(projectTransform,delta2);return reset()}function reset(){cache=cacheStream=null;return projection}return function(){project=projectAt.apply(this,arguments);projection.invert=project.invert&&invert;return recenter()}}function conicProjection(projectAt){var phi0=0,phi1=pi$1/3,m=projectionMutator(projectAt),p=m(phi0,phi1);p.parallels=function(_){return arguments.length?m(phi0=_[0]*radians,phi1=_[1]*radians):[phi0*degrees,phi1*degrees]};return p}function cylindricalEqualAreaRaw(phi0){var cosPhi0=cos$1(phi0);function forward(lambda,phi){return[lambda*cosPhi0,sin$1(phi)/cosPhi0]}forward.invert=function(x,y){return[x/cosPhi0,asin$1(y*cosPhi0)]};return forward}function conicEqualAreaRaw(y0,y1){var sy0=sin$1(y0),n=(sy0+sin$1(y1))/2;if(abs$1(n)<epsilon$3)return cylindricalEqualAreaRaw(y0);var c=1+sy0*(2*n-sy0),r0=sqrt$1(c)/n;function project(x,y){var r=sqrt$1(c-2*n*sin$1(y))/n;return[r*sin$1(x*=n),r0-r*cos$1(x)]}project.invert=function(x,y){var r0y=r0-y,l=atan2(x,abs$1(r0y))*sign(r0y);if(r0y*n<0)l-=pi$1*sign(x)*sign(r0y);return[l/n,asin$1((c-(x*x+r0y*r0y)*n*n)/(2*n))]};return project}function geoConicEqualArea(){return conicProjection(conicEqualAreaRaw).scale(155.424).center([0,33.6442])}function geoAlbers(){return geoConicEqualArea().parallels([29.5,45.5]).scale(1070).translate([480,250]).rotate([96,0]).center([-.6,38.7])}function multiplex(streams){var n=streams.length;return{point:function(x,y){var i=-1;while(++i<n)streams[i].point(x,y)},sphere:function(){var i=-1;while(++i<n)streams[i].sphere()},lineStart:function(){var i=-1;while(++i<n)streams[i].lineStart()},lineEnd:function(){var i=-1;while(++i<n)streams[i].lineEnd()},polygonStart:function(){var i=-1;while(++i<n)streams[i].polygonStart()},polygonEnd:function(){var i=-1;while(++i<n)streams[i].polygonEnd()}}}function geoAlbersUsa(){var cache,cacheStream,lower48=geoAlbers(),lower48Point,alaska=geoConicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),alaskaPoint,hawaii=geoConicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),hawaiiPoint,point,pointStream={point:function(x,y){point=[x,y]}};function albersUsa(coordinates){var x=coordinates[0],y=coordinates[1];return point=null,(lower48Point.point(x,y),point)||(alaskaPoint.point(x,y),point)||(hawaiiPoint.point(x,y),point)}albersUsa.invert=function(coordinates){var k=lower48.scale(),t=lower48.translate(),x=(coordinates[0]-t[0])/k,y=(coordinates[1]-t[1])/k;return(y>=.12&&y<.234&&x>=-.425&&x<-.214?alaska:y>=.166&&y<.234&&x>=-.214&&x<-.115?hawaii:lower48).invert(coordinates)};albersUsa.stream=function(stream){return cache&&cacheStream===stream?cache:cache=multiplex([lower48.stream(cacheStream=stream),alaska.stream(stream),hawaii.stream(stream)])};albersUsa.precision=function(_){if(!arguments.length)return lower48.precision();lower48.precision(_),alaska.precision(_),hawaii.precision(_);return reset()};albersUsa.scale=function(_){if(!arguments.length)return lower48.scale();lower48.scale(_),alaska.scale(_*.35),hawaii.scale(_);return albersUsa.translate(lower48.translate())};albersUsa.translate=function(_){if(!arguments.length)return lower48.translate();var k=lower48.scale(),x=+_[0],y=+_[1];lower48Point=lower48.translate(_).clipExtent([[x-.455*k,y-.238*k],[x+.455*k,y+.238*k]]).stream(pointStream);alaskaPoint=alaska.translate([x-.307*k,y+.201*k]).clipExtent([[x-.425*k+epsilon$3,y+.12*k+epsilon$3],[x-.214*k-epsilon$3,y+.234*k-epsilon$3]]).stream(pointStream);hawaiiPoint=hawaii.translate([x-.205*k,y+.212*k]).clipExtent([[x-.214*k+epsilon$3,y+.166*k+epsilon$3],[x-.115*k-epsilon$3,y+.234*k-epsilon$3]]).stream(pointStream);return reset()};albersUsa.fitExtent=function(extent,object){return fitExtent(albersUsa,extent,object)};albersUsa.fitSize=function(size,object){return fitSize(albersUsa,size,object)};albersUsa.fitWidth=function(width,object){return fitWidth(albersUsa,width,object)};albersUsa.fitHeight=function(height,object){return fitHeight(albersUsa,height,object)};function reset(){cache=cacheStream=null;return albersUsa}return albersUsa.scale(1070)}function azimuthalRaw(scale){return function(x,y){var cx=cos$1(x),cy=cos$1(y),k=scale(cx*cy);if(k===Infinity)return[2,0];return[k*cy*sin$1(x),k*sin$1(y)]}}function azimuthalInvert(angle){return function(x,y){var z=sqrt$1(x*x+y*y),c=angle(z),sc=sin$1(c),cc=cos$1(c);return[atan2(x*sc,z*cc),asin$1(z&&y*sc/z)]}}var azimuthalEqualAreaRaw=azimuthalRaw((function(cxcy){return sqrt$1(2/(1+cxcy))}));azimuthalEqualAreaRaw.invert=azimuthalInvert((function(z){return 2*asin$1(z/2)}));function geoAzimuthalEqualArea(){return projection$1(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180-.001)}var azimuthalEquidistantRaw=azimuthalRaw((function(c){return(c=acos(c))&&c/sin$1(c)}));azimuthalEquidistantRaw.invert=azimuthalInvert((function(z){return z}));function geoAzimuthalEquidistant(){return projection$1(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180-.001)}function mercatorRaw(lambda,phi){return[lambda,log$1(tan((halfPi$1+phi)/2))]}mercatorRaw.invert=function(x,y){return[x,2*atan(exp(y))-halfPi$1]};function geoMercator(){return mercatorProjection(mercatorRaw).scale(961/tau$1)}function mercatorProjection(project){var m=projection$1(project),center=m.center,scale=m.scale,translate=m.translate,clipExtent=m.clipExtent,x0=null,y0,x1,y1;m.scale=function(_){return arguments.length?(scale(_),reclip()):scale()};m.translate=function(_){return arguments.length?(translate(_),reclip()):translate()};m.center=function(_){return arguments.length?(center(_),reclip()):center()};m.clipExtent=function(_){return arguments.length?(_==null?x0=y0=x1=y1=null:(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1]),reclip()):x0==null?null:[[x0,y0],[x1,y1]]};function reclip(){var k=pi$1*scale(),t=m(rotation(m.rotate()).invert([0,0]));return clipExtent(x0==null?[[t[0]-k,t[1]-k],[t[0]+k,t[1]+k]]:project===mercatorRaw?[[Math.max(t[0]-k,x0),y0],[Math.min(t[0]+k,x1),y1]]:[[x0,Math.max(t[1]-k,y0)],[x1,Math.min(t[1]+k,y1)]])}return reclip()}function tany(y){return tan((halfPi$1+y)/2)}function conicConformalRaw(y0,y1){var cy0=cos$1(y0),n=y0===y1?sin$1(y0):log$1(cy0/cos$1(y1))/log$1(tany(y1)/tany(y0)),f=cy0*pow$1(tany(y0),n)/n;if(!n)return mercatorRaw;function project(x,y){if(f>0){if(y<-halfPi$1+epsilon$3)y=-halfPi$1+epsilon$3}else{if(y>halfPi$1-epsilon$3)y=halfPi$1-epsilon$3}var r=f/pow$1(tany(y),n);return[r*sin$1(n*x),f-r*cos$1(n*x)]}project.invert=function(x,y){var fy=f-y,r=sign(n)*sqrt$1(x*x+fy*fy),l=atan2(x,abs$1(fy))*sign(fy);if(fy*n<0)l-=pi$1*sign(x)*sign(fy);return[l/n,2*atan(pow$1(f/r,1/n))-halfPi$1]};return project}function geoConicConformal(){return conicProjection(conicConformalRaw).scale(109.5).parallels([30,30])}function equirectangularRaw(lambda,phi){return[lambda,phi]}equirectangularRaw.invert=equirectangularRaw;function geoEquirectangular(){return projection$1(equirectangularRaw).scale(152.63)}function conicEquidistantRaw(y0,y1){var cy0=cos$1(y0),n=y0===y1?sin$1(y0):(cy0-cos$1(y1))/(y1-y0),g=cy0/n+y0;if(abs$1(n)<epsilon$3)return equirectangularRaw;function project(x,y){var gy=g-y,nx=n*x;return[gy*sin$1(nx),g-gy*cos$1(nx)]}project.invert=function(x,y){var gy=g-y,l=atan2(x,abs$1(gy))*sign(gy);if(gy*n<0)l-=pi$1*sign(x)*sign(gy);return[l/n,g-sign(n)*sqrt$1(x*x+gy*gy)]};return project}function geoConicEquidistant(){return conicProjection(conicEquidistantRaw).scale(131.154).center([0,13.9389])}var A1=1.340264,A2=-.081106,A3=893e-6,A4=.003796,M=sqrt$1(3)/2,iterations=12;function equalEarthRaw(lambda,phi){var l=asin$1(M*sin$1(phi)),l2=l*l,l6=l2*l2*l2;return[lambda*cos$1(l)/(M*(A1+3*A2*l2+l6*(7*A3+9*A4*l2))),l*(A1+A2*l2+l6*(A3+A4*l2))]}equalEarthRaw.invert=function(x,y){var l=y,l2=l*l,l6=l2*l2*l2;for(var i=0,delta,fy,fpy;i<iterations;++i){fy=l*(A1+A2*l2+l6*(A3+A4*l2))-y;fpy=A1+3*A2*l2+l6*(7*A3+9*A4*l2);l-=delta=fy/fpy,l2=l*l,l6=l2*l2*l2;if(abs$1(delta)<epsilon2)break}return[M*x*(A1+3*A2*l2+l6*(7*A3+9*A4*l2))/cos$1(l),asin$1(sin$1(l)/M)]};function geoEqualEarth(){return projection$1(equalEarthRaw).scale(177.158)}function gnomonicRaw(x,y){var cy=cos$1(y),k=cos$1(x)*cy;return[cy*sin$1(x)/k,sin$1(y)/k]}gnomonicRaw.invert=azimuthalInvert(atan);function geoGnomonic(){return projection$1(gnomonicRaw).scale(144.049).clipAngle(60)}function geoIdentity(){var k=1,tx=0,ty=0,sx=1,sy=1,alpha=0,ca,sa,x0=null,y0,x1,y1,kx=1,ky=1,transform=transformer({point:function(x,y){var p=projection([x,y]);this.stream.point(p[0],p[1])}}),postclip=identity,cache,cacheStream;function reset(){kx=k*sx;ky=k*sy;cache=cacheStream=null;return projection}function projection(p){var x=p[0]*kx,y=p[1]*ky;if(alpha){var t=y*ca-x*sa;x=x*ca+y*sa;y=t}return[x+tx,y+ty]}projection.invert=function(p){var x=p[0]-tx,y=p[1]-ty;if(alpha){var t=y*ca+x*sa;x=x*ca-y*sa;y=t}return[x/kx,y/ky]};projection.stream=function(stream){return cache&&cacheStream===stream?cache:cache=transform(postclip(cacheStream=stream))};projection.postclip=function(_){return arguments.length?(postclip=_,x0=y0=x1=y1=null,reset()):postclip};projection.clipExtent=function(_){return arguments.length?(postclip=_==null?(x0=y0=x1=y1=null,identity):clipRectangle(x0=+_[0][0],y0=+_[0][1],x1=+_[1][0],y1=+_[1][1]),reset()):x0==null?null:[[x0,y0],[x1,y1]]};projection.scale=function(_){return arguments.length?(k=+_,reset()):k};projection.translate=function(_){return arguments.length?(tx=+_[0],ty=+_[1],reset()):[tx,ty]};projection.angle=function(_){return arguments.length?(alpha=_%360*radians,sa=sin$1(alpha),ca=cos$1(alpha),reset()):alpha*degrees};projection.reflectX=function(_){return arguments.length?(sx=_?-1:1,reset()):sx<0};projection.reflectY=function(_){return arguments.length?(sy=_?-1:1,reset()):sy<0};projection.fitExtent=function(extent,object){return fitExtent(projection,extent,object)};projection.fitSize=function(size,object){return fitSize(projection,size,object)};projection.fitWidth=function(width,object){return fitWidth(projection,width,object)};projection.fitHeight=function(height,object){return fitHeight(projection,height,object)};return projection}function naturalEarth1Raw(lambda,phi){var phi2=phi*phi,phi4=phi2*phi2;return[lambda*(.8707-.131979*phi2+phi4*(-.013791+phi4*(.003971*phi2-.001529*phi4))),phi*(1.007226+phi2*(.015085+phi4*(-.044475+.028874*phi2-.005916*phi4)))]}naturalEarth1Raw.invert=function(x,y){var phi=y,i=25,delta;do{var phi2=phi*phi,phi4=phi2*phi2;phi-=delta=(phi*(1.007226+phi2*(.015085+phi4*(-.044475+.028874*phi2-.005916*phi4)))-y)/(1.007226+phi2*(.015085*3+phi4*(-.044475*7+.028874*9*phi2-.005916*11*phi4)))}while(abs$1(delta)>epsilon$3&&--i>0);return[x/(.8707+(phi2=phi*phi)*(-.131979+phi2*(-.013791+phi2*phi2*phi2*(.003971-.001529*phi2)))),phi]};function geoNaturalEarth1(){return projection$1(naturalEarth1Raw).scale(175.295)}function orthographicRaw(x,y){return[cos$1(y)*sin$1(x),sin$1(y)]}orthographicRaw.invert=azimuthalInvert(asin$1);function geoOrthographic(){return projection$1(orthographicRaw).scale(249.5).clipAngle(90+epsilon$3)}function stereographicRaw(x,y){var cy=cos$1(y),k=1+cos$1(x)*cy;return[cy*sin$1(x)/k,sin$1(y)/k]}stereographicRaw.invert=azimuthalInvert((function(z){return 2*atan(z)}));function geoStereographic(){return projection$1(stereographicRaw).scale(250).clipAngle(142)}function transverseMercatorRaw(lambda,phi){return[log$1(tan((halfPi$1+phi)/2)),-lambda]}transverseMercatorRaw.invert=function(x,y){return[-y,2*atan(exp(x))-halfPi$1]};function geoTransverseMercator(){var m=mercatorProjection(transverseMercatorRaw),center=m.center,rotate=m.rotate;m.center=function(_){return arguments.length?center([-_[1],_[0]]):(_=center(),[_[1],-_[0]])};m.rotate=function(_){return arguments.length?rotate([_[0],_[1],_.length>2?_[2]+90:90]):(_=rotate(),[_[0],_[1],_[2]-90])};return rotate([0,0,90]).scale(159.155)}var abs=Math.abs;var cos=Math.cos;var sin=Math.sin;var epsilon$2=1e-6;var pi=Math.PI;var halfPi=pi/2;var sqrt2=sqrt(2);function asin(x){return x>1?halfPi:x<-1?-halfPi:Math.asin(x)}function sqrt(x){return x>0?Math.sqrt(x):0}function mollweideBromleyTheta(cp,phi){var cpsinPhi=cp*sin(phi),i=30,delta;do{phi-=delta=(phi+sin(phi)-cpsinPhi)/(1+cos(phi))}while(abs(delta)>epsilon$2&&--i>0);return phi/2}function mollweideBromleyRaw(cx,cy,cp){function forward(lambda,phi){return[cx*lambda*cos(phi=mollweideBromleyTheta(cp,phi)),cy*sin(phi)]}forward.invert=function(x,y){return y=asin(y/cy),[x/(cx*cos(y)),asin((2*y+sin(2*y))/cp)]};return forward}var mollweideRaw=mollweideBromleyRaw(sqrt2/halfPi,sqrt2,pi);function geoMollweide(){return projection$1(mollweideRaw).scale(169.529)}const defaultPath=geoPath();const projectionProperties=["clipAngle","clipExtent","scale","translate","center","rotate","parallels","precision","reflectX","reflectY","coefficient","distance","fraction","lobes","parallel","radius","ratio","spacing","tilt"];function create$1(type,constructor){return function projection(){const p=constructor();p.type=type;p.path=geoPath().projection(p);p.copy=p.copy||function(){const c=projection();projectionProperties.forEach((prop=>{if(p[prop])c[prop](p[prop]())}));c.path.pointRadius(p.path.pointRadius());return c};return registerScale(p)}}function projection(type,proj){if(!type||typeof type!=="string"){throw new Error("Projection type must be a name string.")}type=type.toLowerCase();if(arguments.length>1){projections[type]=create$1(type,proj);return this}else{return projections[type]||null}}function getProjectionPath(proj){return proj&&proj.path||defaultPath}const projections={albers:geoAlbers,albersusa:geoAlbersUsa,azimuthalequalarea:geoAzimuthalEqualArea,azimuthalequidistant:geoAzimuthalEquidistant,conicconformal:geoConicConformal,conicequalarea:geoConicEqualArea,conicequidistant:geoConicEquidistant,equalEarth:geoEqualEarth,equirectangular:geoEquirectangular,gnomonic:geoGnomonic,identity:geoIdentity,mercator:geoMercator,mollweide:geoMollweide,naturalEarth1:geoNaturalEarth1,orthographic:geoOrthographic,stereographic:geoStereographic,transversemercator:geoTransverseMercator};for(const key in projections){projection(key,projections[key])}function noop$1(){}const cases=[[],[[[1,1.5],[.5,1]]],[[[1.5,1],[1,1.5]]],[[[1.5,1],[.5,1]]],[[[1,.5],[1.5,1]]],[[[1,1.5],[.5,1]],[[1,.5],[1.5,1]]],[[[1,.5],[1,1.5]]],[[[1,.5],[.5,1]]],[[[.5,1],[1,.5]]],[[[1,1.5],[1,.5]]],[[[.5,1],[1,.5]],[[1.5,1],[1,1.5]]],[[[1.5,1],[1,.5]]],[[[.5,1],[1.5,1]]],[[[1,1.5],[1.5,1]]],[[[.5,1],[1,1.5]]],[]];function contours(){var dx=1,dy=1,smooth=smoothLinear;function contours(values,tz){return tz.map((value=>contour(values,value)))}function contour(values,value){var polygons=[],holes=[];isorings(values,value,(ring=>{smooth(ring,values,value);if(area$1(ring)>0)polygons.push([ring]);else holes.push(ring)}));holes.forEach((hole=>{for(var i=0,n=polygons.length,polygon;i<n;++i){if(contains$1((polygon=polygons[i])[0],hole)!==-1){polygon.push(hole);return}}}));return{type:"MultiPolygon",value:value,coordinates:polygons}}function isorings(values,value,callback){var fragmentByStart=[],fragmentByEnd=[],x,y,t0,t1,t2,t3;x=y=-1;t1=values[0]>=value;cases[t1<<1].forEach(stitch);while(++x<dx-1){t0=t1,t1=values[x+1]>=value;cases[t0|t1<<1].forEach(stitch)}cases[t1<<0].forEach(stitch);while(++y<dy-1){x=-1;t1=values[y*dx+dx]>=value;t2=values[y*dx]>=value;cases[t1<<1|t2<<2].forEach(stitch);while(++x<dx-1){t0=t1,t1=values[y*dx+dx+x+1]>=value;t3=t2,t2=values[y*dx+x+1]>=value;cases[t0|t1<<1|t2<<2|t3<<3].forEach(stitch)}cases[t1|t2<<3].forEach(stitch)}x=-1;t2=values[y*dx]>=value;cases[t2<<2].forEach(stitch);while(++x<dx-1){t3=t2,t2=values[y*dx+x+1]>=value;cases[t2<<2|t3<<3].forEach(stitch)}cases[t2<<3].forEach(stitch);function stitch(line){var start=[line[0][0]+x,line[0][1]+y],end=[line[1][0]+x,line[1][1]+y],startIndex=index(start),endIndex=index(end),f,g;if(f=fragmentByEnd[startIndex]){if(g=fragmentByStart[endIndex]){delete fragmentByEnd[f.end];delete fragmentByStart[g.start];if(f===g){f.ring.push(end);callback(f.ring)}else{fragmentByStart[f.start]=fragmentByEnd[g.end]={start:f.start,end:g.end,ring:f.ring.concat(g.ring)}}}else{delete fragmentByEnd[f.end];f.ring.push(end);fragmentByEnd[f.end=endIndex]=f}}else if(f=fragmentByStart[endIndex]){if(g=fragmentByEnd[startIndex]){delete fragmentByStart[f.start];delete fragmentByEnd[g.end];if(f===g){f.ring.push(end);callback(f.ring)}else{fragmentByStart[g.start]=fragmentByEnd[f.end]={start:g.start,end:f.end,ring:g.ring.concat(f.ring)}}}else{delete fragmentByStart[f.start];f.ring.unshift(start);fragmentByStart[f.start=startIndex]=f}}else{fragmentByStart[startIndex]=fragmentByEnd[endIndex]={start:startIndex,end:endIndex,ring:[start,end]}}}}function index(point){return point[0]*2+point[1]*(dx+1)*4}function smoothLinear(ring,values,value){ring.forEach((point=>{var x=point[0],y=point[1],xt=x|0,yt=y|0,v0,v1=values[yt*dx+xt];if(x>0&&x<dx&&xt===x){v0=values[yt*dx+xt-1];point[0]=x+(value-v0)/(v1-v0)-.5}if(y>0&&y<dy&&yt===y){v0=values[(yt-1)*dx+xt];point[1]=y+(value-v0)/(v1-v0)-.5}}))}contours.contour=contour;contours.size=function(_){if(!arguments.length)return[dx,dy];var _0=Math.floor(_[0]),_1=Math.floor(_[1]);if(!(_0>=0&&_1>=0))error("invalid size");return dx=_0,dy=_1,contours};contours.smooth=function(_){return arguments.length?(smooth=_?smoothLinear:noop$1,contours):smooth===smoothLinear};return contours}function area$1(ring){var i=0,n=ring.length,area=ring[n-1][1]*ring[0][0]-ring[n-1][0]*ring[0][1];while(++i<n)area+=ring[i-1][1]*ring[i][0]-ring[i-1][0]*ring[i][1];return area}function contains$1(ring,hole){var i=-1,n=hole.length,c;while(++i<n)if(c=ringContains(ring,hole[i]))return c;return 0}function ringContains(ring,point){var x=point[0],y=point[1],contains=-1;for(var i=0,n=ring.length,j=n-1;i<n;j=i++){var pi=ring[i],xi=pi[0],yi=pi[1],pj=ring[j],xj=pj[0],yj=pj[1];if(segmentContains(pi,pj,point))return 0;if(yi>y!==yj>y&&x<(xj-xi)*(y-yi)/(yj-yi)+xi)contains=-contains}return contains}function segmentContains(a,b,c){var i;return collinear$1(a,b,c)&&within(a[i=+(a[0]===b[0])],c[i],b[i])}function collinear$1(a,b,c){return(b[0]-a[0])*(c[1]-a[1])===(c[0]-a[0])*(b[1]-a[1])}function within(p,q,r){return p<=q&&q<=r||r<=q&&q<=p}function quantize(k,nice,zero){return function(values){var ex=extent(values),start=zero?Math.min(ex[0],0):ex[0],stop=ex[1],span=stop-start,step=nice?tickStep(start,stop,k):span/(k+1);return range$4(start+step,stop,step)}}function Isocontour(params){Transform.call(this,null,params)}Isocontour.Definition={type:"Isocontour",metadata:{generates:true},params:[{name:"field",type:"field"},{name:"thresholds",type:"number",array:true},{name:"levels",type:"number"},{name:"nice",type:"boolean",default:false},{name:"resolve",type:"enum",values:["shared","independent"],default:"independent"},{name:"zero",type:"boolean",default:true},{name:"smooth",type:"boolean",default:true},{name:"scale",type:"number",expr:true},{name:"translate",type:"number",array:true,expr:true},{name:"as",type:"string",null:true,default:"contour"}]};inherits(Isocontour,Transform,{transform(_,pulse){if(this.value&&!pulse.changed()&&!_.modified()){return pulse.StopPropagation}var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),source=pulse.materialize(pulse.SOURCE).source,field=_.field||identity$6,contour=contours().smooth(_.smooth!==false),tz=_.thresholds||levels(source,field,_),as=_.as===null?null:_.as||"contour",values=[];source.forEach((t=>{const grid=field(t);const paths=contour.size([grid.width,grid.height])(grid.values,isArray(tz)?tz:tz(grid.values));transformPaths(paths,grid,t,_);paths.forEach((p=>{values.push(rederive(t,ingest$1(as!=null?{[as]:p}:p)))}))}));if(this.value)out.rem=this.value;this.value=out.source=out.add=values;return out}});function levels(values,f,_){const q=quantize(_.levels||10,_.nice,_.zero!==false);return _.resolve!=="shared"?q:q(values.map((t=>max$2(f(t).values))))}function transformPaths(paths,grid,datum,_){let s=_.scale||grid.scale,t=_.translate||grid.translate;if(isFunction(s))s=s(datum,_);if(isFunction(t))t=t(datum,_);if((s===1||s==null)&&!t)return;const sx=(isNumber$1(s)?s:s[0])||1,sy=(isNumber$1(s)?s:s[1])||1,tx=t&&t[0]||0,ty=t&&t[1]||0;paths.forEach(transform$1(grid,sx,sy,tx,ty))}function transform$1(grid,sx,sy,tx,ty){const x1=grid.x1||0,y1=grid.y1||0,flip=sx*sy<0;function transformPolygon(coordinates){coordinates.forEach(transformRing)}function transformRing(coordinates){if(flip)coordinates.reverse();coordinates.forEach(transformPoint)}function transformPoint(coordinates){coordinates[0]=(coordinates[0]-x1)*sx+tx;coordinates[1]=(coordinates[1]-y1)*sy+ty}return function(geometry){geometry.coordinates.forEach(transformPolygon);return geometry}}function radius(bw,data,f){const v=bw>=0?bw:estimateBandwidth(data,f);return Math.round((Math.sqrt(4*v*v+1)-1)/2)}function number$2(_){return isFunction(_)?_:constant$5(+_)}function density2D(){var x=d=>d[0],y=d=>d[1],weight=one$2,bandwidth=[-1,-1],dx=960,dy=500,k=2;function density(data,counts){const rx=radius(bandwidth[0],data,x)>>k,ry=radius(bandwidth[1],data,y)>>k,ox=rx?rx+2:0,oy=ry?ry+2:0,n=2*ox+(dx>>k),m=2*oy+(dy>>k),values0=new Float32Array(n*m),values1=new Float32Array(n*m);let values=values0;data.forEach((d=>{const xi=ox+(+x(d)>>k),yi=oy+(+y(d)>>k);if(xi>=0&&xi<n&&yi>=0&&yi<m){values0[xi+yi*n]+=+weight(d)}}));if(rx>0&&ry>0){blurX(n,m,values0,values1,rx);blurY(n,m,values1,values0,ry);blurX(n,m,values0,values1,rx);blurY(n,m,values1,values0,ry);blurX(n,m,values0,values1,rx);blurY(n,m,values1,values0,ry)}else if(rx>0){blurX(n,m,values0,values1,rx);blurX(n,m,values1,values0,rx);blurX(n,m,values0,values1,rx);values=values1}else if(ry>0){blurY(n,m,values0,values1,ry);blurY(n,m,values1,values0,ry);blurY(n,m,values0,values1,ry);values=values1}const s=counts?Math.pow(2,-2*k):1/sum$1(values);for(let i=0,sz=n*m;i<sz;++i)values[i]*=s;return{values:values,scale:1<<k,width:n,height:m,x1:ox,y1:oy,x2:ox+(dx>>k),y2:oy+(dy>>k)}}density.x=function(_){return arguments.length?(x=number$2(_),density):x};density.y=function(_){return arguments.length?(y=number$2(_),density):y};density.weight=function(_){return arguments.length?(weight=number$2(_),density):weight};density.size=function(_){if(!arguments.length)return[dx,dy];var _0=+_[0],_1=+_[1];if(!(_0>=0&&_1>=0))error("invalid size");return dx=_0,dy=_1,density};density.cellSize=function(_){if(!arguments.length)return 1<<k;if(!((_=+_)>=1))error("invalid cell size");k=Math.floor(Math.log(_)/Math.LN2);return density};density.bandwidth=function(_){if(!arguments.length)return bandwidth;_=array$5(_);if(_.length===1)_=[+_[0],+_[0]];if(_.length!==2)error("invalid bandwidth");return bandwidth=_,density};return density}function blurX(n,m,source,target,r){const w=(r<<1)+1;for(let j=0;j<m;++j){for(let i=0,sr=0;i<n+r;++i){if(i<n){sr+=source[i+j*n]}if(i>=r){if(i>=w){sr-=source[i-w+j*n]}target[i-r+j*n]=sr/Math.min(i+1,n-1+w-i,w)}}}}function blurY(n,m,source,target,r){const w=(r<<1)+1;for(let i=0;i<n;++i){for(let j=0,sr=0;j<m+r;++j){if(j<m){sr+=source[i+j*n]}if(j>=r){if(j>=w){sr-=source[i+(j-w)*n]}target[i+(j-r)*n]=sr/Math.min(j+1,m-1+w-j,w)}}}}function KDE2D(params){Transform.call(this,null,params)}KDE2D.Definition={type:"KDE2D",metadata:{generates:true},params:[{name:"size",type:"number",array:true,length:2,required:true},{name:"x",type:"field",required:true},{name:"y",type:"field",required:true},{name:"weight",type:"field"},{name:"groupby",type:"field",array:true},{name:"cellSize",type:"number"},{name:"bandwidth",type:"number",array:true,length:2},{name:"counts",type:"boolean",default:false},{name:"as",type:"string",default:"grid"}]};const PARAMS=["x","y","weight","size","cellSize","bandwidth"];function params(obj,_){PARAMS.forEach((param=>_[param]!=null?obj[param](_[param]):0));return obj}inherits(KDE2D,Transform,{transform(_,pulse){if(this.value&&!pulse.changed()&&!_.modified())return pulse.StopPropagation;var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),source=pulse.materialize(pulse.SOURCE).source,groups=partition$2(source,_.groupby),names=(_.groupby||[]).map(accessorName),kde=params(density2D(),_),as=_.as||"grid",values=[];function set(t,vals){for(let i=0;i<names.length;++i)t[names[i]]=vals[i];return t}values=groups.map((g=>ingest$1(set({[as]:kde(g,_.counts)},g.dims))));if(this.value)out.rem=this.value;this.value=out.source=out.add=values;return out}});function partition$2(data,groupby){var groups=[],get=f=>f(t),map,i,n,t,k,g;if(groupby==null){groups.push(data)}else{for(map={},i=0,n=data.length;i<n;++i){t=data[i];k=groupby.map(get);g=map[k];if(!g){map[k]=g=[];g.dims=k;groups.push(g)}g.push(t)}}return groups}function Contour(params){Transform.call(this,null,params)}Contour.Definition={type:"Contour",metadata:{generates:true},params:[{name:"size",type:"number",array:true,length:2,required:true},{name:"values",type:"number",array:true},{name:"x",type:"field"},{name:"y",type:"field"},{name:"weight",type:"field"},{name:"cellSize",type:"number"},{name:"bandwidth",type:"number"},{name:"count",type:"number"},{name:"nice",type:"boolean",default:false},{name:"thresholds",type:"number",array:true},{name:"smooth",type:"boolean",default:true}]};inherits(Contour,Transform,{transform(_,pulse){if(this.value&&!pulse.changed()&&!_.modified()){return pulse.StopPropagation}var out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS),contour=contours().smooth(_.smooth!==false),values=_.values,thresh=_.thresholds||quantize(_.count||10,_.nice,!!values),size=_.size,grid,post;if(!values){values=pulse.materialize(pulse.SOURCE).source;grid=params(density2D(),_)(values,true);post=transform$1(grid,grid.scale||1,grid.scale||1,0,0);size=[grid.width,grid.height];values=grid.values}thresh=isArray(thresh)?thresh:thresh(values);values=contour.size(size)(values,thresh);if(post)values.forEach(post);if(this.value)out.rem=this.value;this.value=out.source=out.add=(values||[]).map(ingest$1);return out}});const Feature="Feature";const FeatureCollection="FeatureCollection";const MultiPoint="MultiPoint";function GeoJSON(params){Transform.call(this,null,params)}GeoJSON.Definition={type:"GeoJSON",metadata:{},params:[{name:"fields",type:"field",array:true,length:2},{name:"geojson",type:"field"}]};inherits(GeoJSON,Transform,{transform(_,pulse){var features=this._features,points=this._points,fields=_.fields,lon=fields&&fields[0],lat=fields&&fields[1],geojson=_.geojson||!fields&&identity$6,flag=pulse.ADD,mod;mod=_.modified()||pulse.changed(pulse.REM)||pulse.modified(accessorFields(geojson))||lon&&pulse.modified(accessorFields(lon))||lat&&pulse.modified(accessorFields(lat));if(!this.value||mod){flag=pulse.SOURCE;this._features=features=[];this._points=points=[]}if(geojson){pulse.visit(flag,(t=>features.push(geojson(t))))}if(lon&&lat){pulse.visit(flag,(t=>{var x=lon(t),y=lat(t);if(x!=null&&y!=null&&(x=+x)===x&&(y=+y)===y){points.push([x,y])}}));features=features.concat({type:Feature,geometry:{type:MultiPoint,coordinates:points}})}this.value={type:FeatureCollection,features:features}}});function GeoPath(params){Transform.call(this,null,params)}GeoPath.Definition={type:"GeoPath",metadata:{modifies:true},params:[{name:"projection",type:"projection"},{name:"field",type:"field"},{name:"pointRadius",type:"number",expr:true},{name:"as",type:"string",default:"path"}]};inherits(GeoPath,Transform,{transform(_,pulse){var out=pulse.fork(pulse.ALL),path=this.value,field=_.field||identity$6,as=_.as||"path",flag=out.SOURCE;if(!path||_.modified()){this.value=path=getProjectionPath(_.projection);out.materialize().reflow()}else{flag=field===identity$6||pulse.modified(field.fields)?out.ADD_MOD:out.ADD}const prev=initPath(path,_.pointRadius);out.visit(flag,(t=>t[as]=path(field(t))));path.pointRadius(prev);return out.modifies(as)}});function initPath(path,pointRadius){const prev=path.pointRadius();path.context(null);if(pointRadius!=null){path.pointRadius(pointRadius)}return prev}function GeoPoint(params){Transform.call(this,null,params)}GeoPoint.Definition={type:"GeoPoint",metadata:{modifies:true},params:[{name:"projection",type:"projection",required:true},{name:"fields",type:"field",array:true,required:true,length:2},{name:"as",type:"string",array:true,length:2,default:["x","y"]}]};inherits(GeoPoint,Transform,{transform(_,pulse){var proj=_.projection,lon=_.fields[0],lat=_.fields[1],as=_.as||["x","y"],x=as[0],y=as[1],mod;function set(t){const xy=proj([lon(t),lat(t)]);if(xy){t[x]=xy[0];t[y]=xy[1]}else{t[x]=undefined;t[y]=undefined}}if(_.modified()){pulse=pulse.materialize().reflow(true).visit(pulse.SOURCE,set)}else{mod=pulse.modified(lon.fields)||pulse.modified(lat.fields);pulse.visit(mod?pulse.ADD_MOD:pulse.ADD,set)}return pulse.modifies(as)}});function GeoShape(params){Transform.call(this,null,params)}GeoShape.Definition={type:"GeoShape",metadata:{modifies:true,nomod:true},params:[{name:"projection",type:"projection"},{name:"field",type:"field",default:"datum"},{name:"pointRadius",type:"number",expr:true},{name:"as",type:"string",default:"shape"}]};inherits(GeoShape,Transform,{transform(_,pulse){var out=pulse.fork(pulse.ALL),shape=this.value,as=_.as||"shape",flag=out.ADD;if(!shape||_.modified()){this.value=shape=shapeGenerator(getProjectionPath(_.projection),_.field||field$1("datum"),_.pointRadius);out.materialize().reflow();flag=out.SOURCE}out.visit(flag,(t=>t[as]=shape));return out.modifies(as)}});function shapeGenerator(path,field,pointRadius){const shape=pointRadius==null?_=>path(field(_)):_=>{var prev=path.pointRadius(),value=path.pointRadius(pointRadius)(field(_));path.pointRadius(prev);return value};shape.context=_=>{path.context(_);return shape};return shape}function Graticule(params){Transform.call(this,[],params);this.generator=graticule()}Graticule.Definition={type:"Graticule",metadata:{changes:true,generates:true},params:[{name:"extent",type:"array",array:true,length:2,content:{type:"number",array:true,length:2}},{name:"extentMajor",type:"array",array:true,length:2,content:{type:"number",array:true,length:2}},{name:"extentMinor",type:"array",array:true,length:2,content:{type:"number",array:true,length:2}},{name:"step",type:"number",array:true,length:2},{name:"stepMajor",type:"number",array:true,length:2,default:[90,360]},{name:"stepMinor",type:"number",array:true,length:2,default:[10,10]},{name:"precision",type:"number",default:2.5}]};inherits(Graticule,Transform,{transform(_,pulse){var src=this.value,gen=this.generator,t;if(!src.length||_.modified()){for(const prop in _){if(isFunction(gen[prop])){gen[prop](_[prop])}}}t=gen();if(src.length){pulse.mod.push(replace$1(src[0],t))}else{pulse.add.push(ingest$1(t))}src[0]=t;return pulse}});function Heatmap(params){Transform.call(this,null,params)}Heatmap.Definition={type:"heatmap",metadata:{modifies:true},params:[{name:"field",type:"field"},{name:"color",type:"string",expr:true},{name:"opacity",type:"number",expr:true},{name:"resolve",type:"enum",values:["shared","independent"],default:"independent"},{name:"as",type:"string",default:"image"}]};inherits(Heatmap,Transform,{transform(_,pulse){if(!pulse.changed()&&!_.modified()){return pulse.StopPropagation}var source=pulse.materialize(pulse.SOURCE).source,shared=_.resolve==="shared",field=_.field||identity$6,opacity=opacity_(_.opacity,_),color=color_(_.color,_),as=_.as||"image",obj={$x:0,$y:0,$value:0,$max:shared?max$2(source.map((t=>max$2(field(t).values)))):0};source.forEach((t=>{const v=field(t);const o=extend$1({},t,obj);if(!shared)o.$max=max$2(v.values||[]);t[as]=toCanvas(v,o,color.dep?color:constant$5(color(o)),opacity.dep?opacity:constant$5(opacity(o)))}));return pulse.reflow(true).modifies(as)}});function color_(color,_){let f;if(isFunction(color)){f=obj=>rgb$1(color(obj,_));f.dep=dependency(color)}else{f=constant$5(rgb$1(color||"#888"))}return f}function opacity_(opacity,_){let f;if(isFunction(opacity)){f=obj=>opacity(obj,_);f.dep=dependency(opacity)}else if(opacity){f=constant$5(opacity)}else{f=obj=>obj.$value/obj.$max||0;f.dep=true}return f}function dependency(f){if(!isFunction(f))return false;const set=toSet(accessorFields(f));return set.$x||set.$y||set.$value||set.$max}function toCanvas(grid,obj,color,opacity){const n=grid.width,m=grid.height,x1=grid.x1||0,y1=grid.y1||0,x2=grid.x2||n,y2=grid.y2||m,val=grid.values,value=val?i=>val[i]:zero$4,can=canvas(x2-x1,y2-y1),ctx=can.getContext("2d"),img=ctx.getImageData(0,0,x2-x1,y2-y1),pix=img.data;for(let j=y1,k=0;j<y2;++j){obj.$y=j-y1;for(let i=x1,r=j*n;i<x2;++i,k+=4){obj.$x=i-x1;obj.$value=value(i+r);const v=color(obj);pix[k+0]=v.r;pix[k+1]=v.g;pix[k+2]=v.b;pix[k+3]=~~(255*opacity(obj))}}ctx.putImageData(img,0,0);return can}function Projection$1(params){Transform.call(this,null,params);this.modified(true)}inherits(Projection$1,Transform,{transform(_,pulse){let proj=this.value;if(!proj||_.modified("type")){this.value=proj=create(_.type);projectionProperties.forEach((prop=>{if(_[prop]!=null)set$2(proj,prop,_[prop])}))}else{projectionProperties.forEach((prop=>{if(_.modified(prop))set$2(proj,prop,_[prop])}))}if(_.pointRadius!=null)proj.path.pointRadius(_.pointRadius);if(_.fit)fit(proj,_);return pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS)}});function fit(proj,_){const data=collectGeoJSON(_.fit);_.extent?proj.fitExtent(_.extent,data):_.size?proj.fitSize(_.size,data):0}function create(type){const constructor=projection((type||"mercator").toLowerCase());if(!constructor)error("Unrecognized projection type: "+type);return constructor()}function set$2(proj,key,value){if(isFunction(proj[key]))proj[key](value)}function collectGeoJSON(data){data=array$5(data);return data.length===1?data[0]:{type:FeatureCollection,features:data.reduce(((a,f)=>a.concat(featurize(f))),[])}}function featurize(f){return f.type===FeatureCollection?f.features:array$5(f).filter((d=>d!=null)).map((d=>d.type===Feature?d:{type:Feature,geometry:d}))}var geo=Object.freeze({__proto__:null,contour:Contour,geojson:GeoJSON,geopath:GeoPath,geopoint:GeoPoint,geoshape:GeoShape,graticule:Graticule,heatmap:Heatmap,isocontour:Isocontour,kde2d:KDE2D,projection:Projection$1});function forceCenter(x,y){var nodes,strength=1;if(x==null)x=0;if(y==null)y=0;function force(){var i,n=nodes.length,node,sx=0,sy=0;for(i=0;i<n;++i){node=nodes[i],sx+=node.x,sy+=node.y}for(sx=(sx/n-x)*strength,sy=(sy/n-y)*strength,i=0;i<n;++i){node=nodes[i],node.x-=sx,node.y-=sy}}force.initialize=function(_){nodes=_};force.x=function(_){return arguments.length?(x=+_,force):x};force.y=function(_){return arguments.length?(y=+_,force):y};force.strength=function(_){return arguments.length?(strength=+_,force):strength};return force}function tree_add(d){const x=+this._x.call(null,d),y=+this._y.call(null,d);return add$1(this.cover(x,y),x,y,d)}function add$1(tree,x,y,d){if(isNaN(x)||isNaN(y))return tree;var parent,node=tree._root,leaf={data:d},x0=tree._x0,y0=tree._y0,x1=tree._x1,y1=tree._y1,xm,ym,xp,yp,right,bottom,i,j;if(!node)return tree._root=leaf,tree;while(node.length){if(right=x>=(xm=(x0+x1)/2))x0=xm;else x1=xm;if(bottom=y>=(ym=(y0+y1)/2))y0=ym;else y1=ym;if(parent=node,!(node=node[i=bottom<<1|right]))return parent[i]=leaf,tree}xp=+tree._x.call(null,node.data);yp=+tree._y.call(null,node.data);if(x===xp&&y===yp)return leaf.next=node,parent?parent[i]=leaf:tree._root=leaf,tree;do{parent=parent?parent[i]=new Array(4):tree._root=new Array(4);if(right=x>=(xm=(x0+x1)/2))x0=xm;else x1=xm;if(bottom=y>=(ym=(y0+y1)/2))y0=ym;else y1=ym}while((i=bottom<<1|right)===(j=(yp>=ym)<<1|xp>=xm));return parent[j]=node,parent[i]=leaf,tree}function addAll(data){var d,i,n=data.length,x,y,xz=new Array(n),yz=new Array(n),x0=Infinity,y0=Infinity,x1=-Infinity,y1=-Infinity;for(i=0;i<n;++i){if(isNaN(x=+this._x.call(null,d=data[i]))||isNaN(y=+this._y.call(null,d)))continue;xz[i]=x;yz[i]=y;if(x<x0)x0=x;if(x>x1)x1=x;if(y<y0)y0=y;if(y>y1)y1=y}if(x0>x1||y0>y1)return this;this.cover(x0,y0).cover(x1,y1);for(i=0;i<n;++i){add$1(this,xz[i],yz[i],data[i])}return this}function tree_cover(x,y){if(isNaN(x=+x)||isNaN(y=+y))return this;var x0=this._x0,y0=this._y0,x1=this._x1,y1=this._y1;if(isNaN(x0)){x1=(x0=Math.floor(x))+1;y1=(y0=Math.floor(y))+1}else{var z=x1-x0||1,node=this._root,parent,i;while(x0>x||x>=x1||y0>y||y>=y1){i=(y<y0)<<1|x<x0;parent=new Array(4),parent[i]=node,node=parent,z*=2;switch(i){case 0:x1=x0+z,y1=y0+z;break;case 1:x0=x1-z,y1=y0+z;break;case 2:x1=x0+z,y0=y1-z;break;case 3:x0=x1-z,y0=y1-z;break}}if(this._root&&this._root.length)this._root=node}this._x0=x0;this._y0=y0;this._x1=x1;this._y1=y1;return this}function tree_data(){var data=[];this.visit((function(node){if(!node.length)do{data.push(node.data)}while(node=node.next)}));return data}function tree_extent(_){return arguments.length?this.cover(+_[0][0],+_[0][1]).cover(+_[1][0],+_[1][1]):isNaN(this._x0)?undefined:[[this._x0,this._y0],[this._x1,this._y1]]}function Quad(node,x0,y0,x1,y1){this.node=node;this.x0=x0;this.y0=y0;this.x1=x1;this.y1=y1}function tree_find(x,y,radius){var data,x0=this._x0,y0=this._y0,x1,y1,x2,y2,x3=this._x1,y3=this._y1,quads=[],node=this._root,q,i;if(node)quads.push(new Quad(node,x0,y0,x3,y3));if(radius==null)radius=Infinity;else{x0=x-radius,y0=y-radius;x3=x+radius,y3=y+radius;radius*=radius}while(q=quads.pop()){if(!(node=q.node)||(x1=q.x0)>x3||(y1=q.y0)>y3||(x2=q.x1)<x0||(y2=q.y1)<y0)continue;if(node.length){var xm=(x1+x2)/2,ym=(y1+y2)/2;quads.push(new Quad(node[3],xm,ym,x2,y2),new Quad(node[2],x1,ym,xm,y2),new Quad(node[1],xm,y1,x2,ym),new Quad(node[0],x1,y1,xm,ym));if(i=(y>=ym)<<1|x>=xm){q=quads[quads.length-1];quads[quads.length-1]=quads[quads.length-1-i];quads[quads.length-1-i]=q}}else{var dx=x-+this._x.call(null,node.data),dy=y-+this._y.call(null,node.data),d2=dx*dx+dy*dy;if(d2<radius){var d=Math.sqrt(radius=d2);x0=x-d,y0=y-d;x3=x+d,y3=y+d;data=node.data}}}return data}function tree_remove(d){if(isNaN(x=+this._x.call(null,d))||isNaN(y=+this._y.call(null,d)))return this;var parent,node=this._root,retainer,previous,next,x0=this._x0,y0=this._y0,x1=this._x1,y1=this._y1,x,y,xm,ym,right,bottom,i,j;if(!node)return this;if(node.length)while(true){if(right=x>=(xm=(x0+x1)/2))x0=xm;else x1=xm;if(bottom=y>=(ym=(y0+y1)/2))y0=ym;else y1=ym;if(!(parent=node,node=node[i=bottom<<1|right]))return this;if(!node.length)break;if(parent[i+1&3]||parent[i+2&3]||parent[i+3&3])retainer=parent,j=i}while(node.data!==d)if(!(previous=node,node=node.next))return this;if(next=node.next)delete node.next;if(previous)return next?previous.next=next:delete previous.next,this;if(!parent)return this._root=next,this;next?parent[i]=next:delete parent[i];if((node=parent[0]||parent[1]||parent[2]||parent[3])&&node===(parent[3]||parent[2]||parent[1]||parent[0])&&!node.length){if(retainer)retainer[j]=node;else this._root=node}return this}function removeAll(data){for(var i=0,n=data.length;i<n;++i)this.remove(data[i]);return this}function tree_root(){return this._root}function tree_size(){var size=0;this.visit((function(node){if(!node.length)do{++size}while(node=node.next)}));return size}function tree_visit(callback){var quads=[],q,node=this._root,child,x0,y0,x1,y1;if(node)quads.push(new Quad(node,this._x0,this._y0,this._x1,this._y1));while(q=quads.pop()){if(!callback(node=q.node,x0=q.x0,y0=q.y0,x1=q.x1,y1=q.y1)&&node.length){var xm=(x0+x1)/2,ym=(y0+y1)/2;if(child=node[3])quads.push(new Quad(child,xm,ym,x1,y1));if(child=node[2])quads.push(new Quad(child,x0,ym,xm,y1));if(child=node[1])quads.push(new Quad(child,xm,y0,x1,ym));if(child=node[0])quads.push(new Quad(child,x0,y0,xm,ym))}}return this}function tree_visitAfter(callback){var quads=[],next=[],q;if(this._root)quads.push(new Quad(this._root,this._x0,this._y0,this._x1,this._y1));while(q=quads.pop()){var node=q.node;if(node.length){var child,x0=q.x0,y0=q.y0,x1=q.x1,y1=q.y1,xm=(x0+x1)/2,ym=(y0+y1)/2;if(child=node[0])quads.push(new Quad(child,x0,y0,xm,ym));if(child=node[1])quads.push(new Quad(child,xm,y0,x1,ym));if(child=node[2])quads.push(new Quad(child,x0,ym,xm,y1));if(child=node[3])quads.push(new Quad(child,xm,ym,x1,y1))}next.push(q)}while(q=next.pop()){callback(q.node,q.x0,q.y0,q.x1,q.y1)}return this}function defaultX(d){return d[0]}function tree_x(_){return arguments.length?(this._x=_,this):this._x}function defaultY(d){return d[1]}function tree_y(_){return arguments.length?(this._y=_,this):this._y}function quadtree(nodes,x,y){var tree=new Quadtree(x==null?defaultX:x,y==null?defaultY:y,NaN,NaN,NaN,NaN);return nodes==null?tree:tree.addAll(nodes)}function Quadtree(x,y,x0,y0,x1,y1){this._x=x;this._y=y;this._x0=x0;this._y0=y0;this._x1=x1;this._y1=y1;this._root=undefined}function leaf_copy(leaf){var copy={data:leaf.data},next=copy;while(leaf=leaf.next)next=next.next={data:leaf.data};return copy}var treeProto=quadtree.prototype=Quadtree.prototype;treeProto.copy=function(){var copy=new Quadtree(this._x,this._y,this._x0,this._y0,this._x1,this._y1),node=this._root,nodes,child;if(!node)return copy;if(!node.length)return copy._root=leaf_copy(node),copy;nodes=[{source:node,target:copy._root=new Array(4)}];while(node=nodes.pop()){for(var i=0;i<4;++i){if(child=node.source[i]){if(child.length)nodes.push({source:child,target:node.target[i]=new Array(4)});else node.target[i]=leaf_copy(child)}}}return copy};treeProto.add=tree_add;treeProto.addAll=addAll;treeProto.cover=tree_cover;treeProto.data=tree_data;treeProto.extent=tree_extent;treeProto.find=tree_find;treeProto.remove=tree_remove;treeProto.removeAll=removeAll;treeProto.root=tree_root;treeProto.size=tree_size;treeProto.visit=tree_visit;treeProto.visitAfter=tree_visitAfter;treeProto.x=tree_x;treeProto.y=tree_y;function constant$1(x){return function(){return x}}function jiggle(random){return(random()-.5)*1e-6}function x$1(d){return d.x+d.vx}function y$1(d){return d.y+d.vy}function forceCollide(radius){var nodes,radii,random,strength=1,iterations=1;if(typeof radius!=="function")radius=constant$1(radius==null?1:+radius);function force(){var i,n=nodes.length,tree,node,xi,yi,ri,ri2;for(var k=0;k<iterations;++k){tree=quadtree(nodes,x$1,y$1).visitAfter(prepare);for(i=0;i<n;++i){node=nodes[i];ri=radii[node.index],ri2=ri*ri;xi=node.x+node.vx;yi=node.y+node.vy;tree.visit(apply)}}function apply(quad,x0,y0,x1,y1){var data=quad.data,rj=quad.r,r=ri+rj;if(data){if(data.index>node.index){var x=xi-data.x-data.vx,y=yi-data.y-data.vy,l=x*x+y*y;if(l<r*r){if(x===0)x=jiggle(random),l+=x*x;if(y===0)y=jiggle(random),l+=y*y;l=(r-(l=Math.sqrt(l)))/l*strength;node.vx+=(x*=l)*(r=(rj*=rj)/(ri2+rj));node.vy+=(y*=l)*r;data.vx-=x*(r=1-r);data.vy-=y*r}}return}return x0>xi+r||x1<xi-r||y0>yi+r||y1<yi-r}}function prepare(quad){if(quad.data)return quad.r=radii[quad.data.index];for(var i=quad.r=0;i<4;++i){if(quad[i]&&quad[i].r>quad.r){quad.r=quad[i].r}}}function initialize(){if(!nodes)return;var i,n=nodes.length,node;radii=new Array(n);for(i=0;i<n;++i)node=nodes[i],radii[node.index]=+radius(node,i,nodes)}force.initialize=function(_nodes,_random){nodes=_nodes;random=_random;initialize()};force.iterations=function(_){return arguments.length?(iterations=+_,force):iterations};force.strength=function(_){return arguments.length?(strength=+_,force):strength};force.radius=function(_){return arguments.length?(radius=typeof _==="function"?_:constant$1(+_),initialize(),force):radius};return force}function index$1(d){return d.index}function find$1(nodeById,nodeId){var node=nodeById.get(nodeId);if(!node)throw new Error("node not found: "+nodeId);return node}function forceLink(links){var id=index$1,strength=defaultStrength,strengths,distance=constant$1(30),distances,nodes,count,bias,random,iterations=1;if(links==null)links=[];function defaultStrength(link){return 1/Math.min(count[link.source.index],count[link.target.index])}function force(alpha){for(var k=0,n=links.length;k<iterations;++k){for(var i=0,link,source,target,x,y,l,b;i<n;++i){link=links[i],source=link.source,target=link.target;x=target.x+target.vx-source.x-source.vx||jiggle(random);y=target.y+target.vy-source.y-source.vy||jiggle(random);l=Math.sqrt(x*x+y*y);l=(l-distances[i])/l*alpha*strengths[i];x*=l,y*=l;target.vx-=x*(b=bias[i]);target.vy-=y*b;source.vx+=x*(b=1-b);source.vy+=y*b}}}function initialize(){if(!nodes)return;var i,n=nodes.length,m=links.length,nodeById=new Map(nodes.map(((d,i)=>[id(d,i,nodes),d]))),link;for(i=0,count=new Array(n);i<m;++i){link=links[i],link.index=i;if(typeof link.source!=="object")link.source=find$1(nodeById,link.source);if(typeof link.target!=="object")link.target=find$1(nodeById,link.target);count[link.source.index]=(count[link.source.index]||0)+1;count[link.target.index]=(count[link.target.index]||0)+1}for(i=0,bias=new Array(m);i<m;++i){link=links[i],bias[i]=count[link.source.index]/(count[link.source.index]+count[link.target.index])}strengths=new Array(m),initializeStrength();distances=new Array(m),initializeDistance()}function initializeStrength(){if(!nodes)return;for(var i=0,n=links.length;i<n;++i){strengths[i]=+strength(links[i],i,links)}}function initializeDistance(){if(!nodes)return;for(var i=0,n=links.length;i<n;++i){distances[i]=+distance(links[i],i,links)}}force.initialize=function(_nodes,_random){nodes=_nodes;random=_random;initialize()};force.links=function(_){return arguments.length?(links=_,initialize(),force):links};force.id=function(_){return arguments.length?(id=_,force):id};force.iterations=function(_){return arguments.length?(iterations=+_,force):iterations};force.strength=function(_){return arguments.length?(strength=typeof _==="function"?_:constant$1(+_),initializeStrength(),force):strength};force.distance=function(_){return arguments.length?(distance=typeof _==="function"?_:constant$1(+_),initializeDistance(),force):distance};return force}var noop={value:()=>{}};function dispatch(){for(var i=0,n=arguments.length,_={},t;i<n;++i){if(!(t=arguments[i]+"")||t in _||/[\s.]/.test(t))throw new Error("illegal type: "+t);_[t]=[]}return new Dispatch(_)}function Dispatch(_){this._=_}function parseTypenames(typenames,types){return typenames.trim().split(/^|\s+/).map((function(t){var name="",i=t.indexOf(".");if(i>=0)name=t.slice(i+1),t=t.slice(0,i);if(t&&!types.hasOwnProperty(t))throw new Error("unknown type: "+t);return{type:t,name:name}}))}Dispatch.prototype=dispatch.prototype={constructor:Dispatch,on:function(typename,callback){var _=this._,T=parseTypenames(typename+"",_),t,i=-1,n=T.length;if(arguments.length<2){while(++i<n)if((t=(typename=T[i]).type)&&(t=get(_[t],typename.name)))return t;return}if(callback!=null&&typeof callback!=="function")throw new Error("invalid callback: "+callback);while(++i<n){if(t=(typename=T[i]).type)_[t]=set$1(_[t],typename.name,callback);else if(callback==null)for(t in _)_[t]=set$1(_[t],typename.name,null)}return this},copy:function(){var copy={},_=this._;for(var t in _)copy[t]=_[t].slice();return new Dispatch(copy)},call:function(type,that){if((n=arguments.length-2)>0)for(var args=new Array(n),i=0,n,t;i<n;++i)args[i]=arguments[i+2];if(!this._.hasOwnProperty(type))throw new Error("unknown type: "+type);for(t=this._[type],i=0,n=t.length;i<n;++i)t[i].value.apply(that,args)},apply:function(type,that,args){if(!this._.hasOwnProperty(type))throw new Error("unknown type: "+type);for(var t=this._[type],i=0,n=t.length;i<n;++i)t[i].value.apply(that,args)}};function get(type,name){for(var i=0,n=type.length,c;i<n;++i){if((c=type[i]).name===name){return c.value}}}function set$1(type,name,callback){for(var i=0,n=type.length;i<n;++i){if(type[i].name===name){type[i]=noop,type=type.slice(0,i).concat(type.slice(i+1));break}}if(callback!=null)type.push({name:name,value:callback});return type}var frame=0,timeout=0,interval$2=0,pokeDelay=1e3,taskHead,taskTail,clockLast=0,clockNow=0,clockSkew=0,clock=typeof performance==="object"&&performance.now?performance:Date,setFrame=typeof window==="object"&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(f){setTimeout(f,17)};function now(){return clockNow||(setFrame(clearNow),clockNow=clock.now()+clockSkew)}function clearNow(){clockNow=0}function Timer$1(){this._call=this._time=this._next=null}Timer$1.prototype=timer$1.prototype={constructor:Timer$1,restart:function(callback,delay,time){if(typeof callback!=="function")throw new TypeError("callback is not a function");time=(time==null?now():+time)+(delay==null?0:+delay);if(!this._next&&taskTail!==this){if(taskTail)taskTail._next=this;else taskHead=this;taskTail=this}this._call=callback;this._time=time;sleep()},stop:function(){if(this._call){this._call=null;this._time=Infinity;sleep()}}};function timer$1(callback,delay,time){var t=new Timer$1;t.restart(callback,delay,time);return t}function timerFlush(){now();++frame;var t=taskHead,e;while(t){if((e=clockNow-t._time)>=0)t._call.call(undefined,e);t=t._next}--frame}function wake(){clockNow=(clockLast=clock.now())+clockSkew;frame=timeout=0;try{timerFlush()}finally{frame=0;nap();clockNow=0}}function poke(){var now=clock.now(),delay=now-clockLast;if(delay>pokeDelay)clockSkew-=delay,clockLast=now}function nap(){var t0,t1=taskHead,t2,time=Infinity;while(t1){if(t1._call){if(time>t1._time)time=t1._time;t0=t1,t1=t1._next}else{t2=t1._next,t1._next=null;t1=t0?t0._next=t2:taskHead=t2}}taskTail=t0;sleep(time)}function sleep(time){if(frame)return;if(timeout)timeout=clearTimeout(timeout);var delay=time-clockNow;if(delay>24){if(time<Infinity)timeout=setTimeout(wake,time-clock.now()-clockSkew);if(interval$2)interval$2=clearInterval(interval$2)}else{if(!interval$2)clockLast=clock.now(),interval$2=setInterval(poke,pokeDelay);frame=1,setFrame(wake)}}function interval$1(callback,delay,time){var t=new Timer$1,total=delay;if(delay==null)return t.restart(callback,delay,time),t;t._restart=t.restart;t.restart=function(callback,delay,time){delay=+delay,time=time==null?now():+time;t._restart((function tick(elapsed){elapsed+=total;t._restart(tick,total+=delay,time);callback(elapsed)}),delay,time)};t.restart(callback,delay,time);return t}const a$1=1664525;const c$1=1013904223;const m$1=4294967296;function lcg$1(){let s=1;return()=>(s=(a$1*s+c$1)%m$1)/m$1}function x(d){return d.x}function y(d){return d.y}var initialRadius=10,initialAngle=Math.PI*(3-Math.sqrt(5));function forceSimulation(nodes){var simulation,alpha=1,alphaMin=.001,alphaDecay=1-Math.pow(alphaMin,1/300),alphaTarget=0,velocityDecay=.6,forces=new Map,stepper=timer$1(step),event=dispatch("tick","end"),random=lcg$1();if(nodes==null)nodes=[];function step(){tick();event.call("tick",simulation);if(alpha<alphaMin){stepper.stop();event.call("end",simulation)}}function tick(iterations){var i,n=nodes.length,node;if(iterations===undefined)iterations=1;for(var k=0;k<iterations;++k){alpha+=(alphaTarget-alpha)*alphaDecay;forces.forEach((function(force){force(alpha)}));for(i=0;i<n;++i){node=nodes[i];if(node.fx==null)node.x+=node.vx*=velocityDecay;else node.x=node.fx,node.vx=0;if(node.fy==null)node.y+=node.vy*=velocityDecay;else node.y=node.fy,node.vy=0}}return simulation}function initializeNodes(){for(var i=0,n=nodes.length,node;i<n;++i){node=nodes[i],node.index=i;if(node.fx!=null)node.x=node.fx;if(node.fy!=null)node.y=node.fy;if(isNaN(node.x)||isNaN(node.y)){var radius=initialRadius*Math.sqrt(.5+i),angle=i*initialAngle;node.x=radius*Math.cos(angle);node.y=radius*Math.sin(angle)}if(isNaN(node.vx)||isNaN(node.vy)){node.vx=node.vy=0}}}function initializeForce(force){if(force.initialize)force.initialize(nodes,random);return force}initializeNodes();return simulation={tick:tick,restart:function(){return stepper.restart(step),simulation},stop:function(){return stepper.stop(),simulation},nodes:function(_){return arguments.length?(nodes=_,initializeNodes(),forces.forEach(initializeForce),simulation):nodes},alpha:function(_){return arguments.length?(alpha=+_,simulation):alpha},alphaMin:function(_){return arguments.length?(alphaMin=+_,simulation):alphaMin},alphaDecay:function(_){return arguments.length?(alphaDecay=+_,simulation):+alphaDecay},alphaTarget:function(_){return arguments.length?(alphaTarget=+_,simulation):alphaTarget},velocityDecay:function(_){return arguments.length?(velocityDecay=1-_,simulation):1-velocityDecay},randomSource:function(_){return arguments.length?(random=_,forces.forEach(initializeForce),simulation):random},force:function(name,_){return arguments.length>1?(_==null?forces.delete(name):forces.set(name,initializeForce(_)),simulation):forces.get(name)},find:function(x,y,radius){var i=0,n=nodes.length,dx,dy,d2,node,closest;if(radius==null)radius=Infinity;else radius*=radius;for(i=0;i<n;++i){node=nodes[i];dx=x-node.x;dy=y-node.y;d2=dx*dx+dy*dy;if(d2<radius)closest=node,radius=d2}return closest},on:function(name,_){return arguments.length>1?(event.on(name,_),simulation):event.on(name)}}}function forceManyBody(){var nodes,node,random,alpha,strength=constant$1(-30),strengths,distanceMin2=1,distanceMax2=Infinity,theta2=.81;function force(_){var i,n=nodes.length,tree=quadtree(nodes,x,y).visitAfter(accumulate);for(alpha=_,i=0;i<n;++i)node=nodes[i],tree.visit(apply)}function initialize(){if(!nodes)return;var i,n=nodes.length,node;strengths=new Array(n);for(i=0;i<n;++i)node=nodes[i],strengths[node.index]=+strength(node,i,nodes)}function accumulate(quad){var strength=0,q,c,weight=0,x,y,i;if(quad.length){for(x=y=i=0;i<4;++i){if((q=quad[i])&&(c=Math.abs(q.value))){strength+=q.value,weight+=c,x+=c*q.x,y+=c*q.y}}quad.x=x/weight;quad.y=y/weight}else{q=quad;q.x=q.data.x;q.y=q.data.y;do{strength+=strengths[q.data.index]}while(q=q.next)}quad.value=strength}function apply(quad,x1,_,x2){if(!quad.value)return true;var x=quad.x-node.x,y=quad.y-node.y,w=x2-x1,l=x*x+y*y;if(w*w/theta2<l){if(l<distanceMax2){if(x===0)x=jiggle(random),l+=x*x;if(y===0)y=jiggle(random),l+=y*y;if(l<distanceMin2)l=Math.sqrt(distanceMin2*l);node.vx+=x*quad.value*alpha/l;node.vy+=y*quad.value*alpha/l}return true}else if(quad.length||l>=distanceMax2)return;if(quad.data!==node||quad.next){if(x===0)x=jiggle(random),l+=x*x;if(y===0)y=jiggle(random),l+=y*y;if(l<distanceMin2)l=Math.sqrt(distanceMin2*l)}do{if(quad.data!==node){w=strengths[quad.data.index]*alpha/l;node.vx+=x*w;node.vy+=y*w}}while(quad=quad.next)}force.initialize=function(_nodes,_random){nodes=_nodes;random=_random;initialize()};force.strength=function(_){return arguments.length?(strength=typeof _==="function"?_:constant$1(+_),initialize(),force):strength};force.distanceMin=function(_){return arguments.length?(distanceMin2=_*_,force):Math.sqrt(distanceMin2)};force.distanceMax=function(_){return arguments.length?(distanceMax2=_*_,force):Math.sqrt(distanceMax2)};force.theta=function(_){return arguments.length?(theta2=_*_,force):Math.sqrt(theta2)};return force}function forceX(x){var strength=constant$1(.1),nodes,strengths,xz;if(typeof x!=="function")x=constant$1(x==null?0:+x);function force(alpha){for(var i=0,n=nodes.length,node;i<n;++i){node=nodes[i],node.vx+=(xz[i]-node.x)*strengths[i]*alpha}}function initialize(){if(!nodes)return;var i,n=nodes.length;strengths=new Array(n);xz=new Array(n);for(i=0;i<n;++i){strengths[i]=isNaN(xz[i]=+x(nodes[i],i,nodes))?0:+strength(nodes[i],i,nodes)}}force.initialize=function(_){nodes=_;initialize()};force.strength=function(_){return arguments.length?(strength=typeof _==="function"?_:constant$1(+_),initialize(),force):strength};force.x=function(_){return arguments.length?(x=typeof _==="function"?_:constant$1(+_),initialize(),force):x};return force}function forceY(y){var strength=constant$1(.1),nodes,strengths,yz;if(typeof y!=="function")y=constant$1(y==null?0:+y);function force(alpha){for(var i=0,n=nodes.length,node;i<n;++i){node=nodes[i],node.vy+=(yz[i]-node.y)*strengths[i]*alpha}}function initialize(){if(!nodes)return;var i,n=nodes.length;strengths=new Array(n);yz=new Array(n);for(i=0;i<n;++i){strengths[i]=isNaN(yz[i]=+y(nodes[i],i,nodes))?0:+strength(nodes[i],i,nodes)}}force.initialize=function(_){nodes=_;initialize()};force.strength=function(_){return arguments.length?(strength=typeof _==="function"?_:constant$1(+_),initialize(),force):strength};force.y=function(_){return arguments.length?(y=typeof _==="function"?_:constant$1(+_),initialize(),force):y};return force}const ForceMap={center:forceCenter,collide:forceCollide,nbody:forceManyBody,link:forceLink,x:forceX,y:forceY};const Forces="forces",ForceParams=["alpha","alphaMin","alphaTarget","velocityDecay","forces"],ForceConfig=["static","iterations"],ForceOutput=["x","y","vx","vy"];function Force(params){Transform.call(this,null,params)}Force.Definition={type:"Force",metadata:{modifies:true},params:[{name:"static",type:"boolean",default:false},{name:"restart",type:"boolean",default:false},{name:"iterations",type:"number",default:300},{name:"alpha",type:"number",default:1},{name:"alphaMin",type:"number",default:.001},{name:"alphaTarget",type:"number",default:0},{name:"velocityDecay",type:"number",default:.4},{name:"forces",type:"param",array:true,params:[{key:{force:"center"},params:[{name:"x",type:"number",default:0},{name:"y",type:"number",default:0}]},{key:{force:"collide"},params:[{name:"radius",type:"number",expr:true},{name:"strength",type:"number",default:.7},{name:"iterations",type:"number",default:1}]},{key:{force:"nbody"},params:[{name:"strength",type:"number",default:-30,expr:true},{name:"theta",type:"number",default:.9},{name:"distanceMin",type:"number",default:1},{name:"distanceMax",type:"number"}]},{key:{force:"link"},params:[{name:"links",type:"data"},{name:"id",type:"field"},{name:"distance",type:"number",default:30,expr:true},{name:"strength",type:"number",expr:true},{name:"iterations",type:"number",default:1}]},{key:{force:"x"},params:[{name:"strength",type:"number",default:.1},{name:"x",type:"field"}]},{key:{force:"y"},params:[{name:"strength",type:"number",default:.1},{name:"y",type:"field"}]}]},{name:"as",type:"string",array:true,modify:false,default:ForceOutput}]};inherits(Force,Transform,{transform(_,pulse){var sim=this.value,change=pulse.changed(pulse.ADD_REM),params=_.modified(ForceParams),iters=_.iterations||300;if(!sim){this.value=sim=simulation(pulse.source,_);sim.on("tick",rerun(pulse.dataflow,this));if(!_.static){change=true;sim.tick()}pulse.modifies("index")}else{if(change){pulse.modifies("index");sim.nodes(pulse.source)}if(params||pulse.changed(pulse.MOD)){setup(sim,_,0,pulse)}}if(params||change||_.modified(ForceConfig)||pulse.changed()&&_.restart){sim.alpha(Math.max(sim.alpha(),_.alpha||1)).alphaDecay(1-Math.pow(sim.alphaMin(),1/iters));if(_.static){for(sim.stop();--iters>=0;)sim.tick()}else{if(sim.stopped())sim.restart();if(!change)return pulse.StopPropagation}}return this.finish(_,pulse)},finish(_,pulse){const dataflow=pulse.dataflow;for(let args=this._argops,j=0,m=args.length,arg;j<m;++j){arg=args[j];if(arg.name!==Forces||arg.op._argval.force!=="link"){continue}for(var ops=arg.op._argops,i=0,n=ops.length,op;i<n;++i){if(ops[i].name==="links"&&(op=ops[i].op.source)){dataflow.pulse(op,dataflow.changeset().reflow());break}}}return pulse.reflow(_.modified()).modifies(ForceOutput)}});function rerun(df,op){return()=>df.touch(op).run()}function simulation(nodes,_){const sim=forceSimulation(nodes),stop=sim.stop,restart=sim.restart;let stopped=false;sim.stopped=()=>stopped;sim.restart=()=>(stopped=false,restart());sim.stop=()=>(stopped=true,stop());return setup(sim,_,true).on("end",(()=>stopped=true))}function setup(sim,_,init,pulse){var f=array$5(_.forces),i,n,p,name;for(i=0,n=ForceParams.length;i<n;++i){p=ForceParams[i];if(p!==Forces&&_.modified(p))sim[p](_[p])}for(i=0,n=f.length;i<n;++i){name=Forces+i;p=init||_.modified(Forces,i)?getForce(f[i]):pulse&&modified(f[i],pulse)?sim.force(name):null;if(p)sim.force(name,p)}for(n=sim.numForces||0;i<n;++i){sim.force(Forces+i,null)}sim.numForces=f.length;return sim}function modified(f,pulse){var k,v;for(k in f){if(isFunction(v=f[k])&&pulse.modified(accessorFields(v)))return 1}return 0}function getForce(_){var f,p;if(!has$1(ForceMap,_.force)){error("Unrecognized force: "+_.force)}f=ForceMap[_.force]();for(p in _){if(isFunction(f[p]))setForceParam(f[p],_[p],_)}return f}function setForceParam(f,v,_){f(isFunction(v)?d=>v(d,_):v)}var force=Object.freeze({__proto__:null,force:Force});function defaultSeparation$2(a,b){return a.parent===b.parent?1:2}function meanX(children){return children.reduce(meanXReduce,0)/children.length}function meanXReduce(x,c){return x+c.x}function maxY(children){return 1+children.reduce(maxYReduce,0)}function maxYReduce(y,c){return Math.max(y,c.y)}function leafLeft(node){var children;while(children=node.children)node=children[0];return node}function leafRight(node){var children;while(children=node.children)node=children[children.length-1];return node}function cluster(){var separation=defaultSeparation$2,dx=1,dy=1,nodeSize=false;function cluster(root){var previousNode,x=0;root.eachAfter((function(node){var children=node.children;if(children){node.x=meanX(children);node.y=maxY(children)}else{node.x=previousNode?x+=separation(node,previousNode):0;node.y=0;previousNode=node}}));var left=leafLeft(root),right=leafRight(root),x0=left.x-separation(left,right)/2,x1=right.x+separation(right,left)/2;return root.eachAfter(nodeSize?function(node){node.x=(node.x-root.x)*dx;node.y=(root.y-node.y)*dy}:function(node){node.x=(node.x-x0)/(x1-x0)*dx;node.y=(1-(root.y?node.y/root.y:1))*dy})}cluster.separation=function(x){return arguments.length?(separation=x,cluster):separation};cluster.size=function(x){return arguments.length?(nodeSize=false,dx=+x[0],dy=+x[1],cluster):nodeSize?null:[dx,dy]};cluster.nodeSize=function(x){return arguments.length?(nodeSize=true,dx=+x[0],dy=+x[1],cluster):nodeSize?[dx,dy]:null};return cluster}function count(node){var sum=0,children=node.children,i=children&&children.length;if(!i)sum=1;else while(--i>=0)sum+=children[i].value;node.value=sum}function node_count(){return this.eachAfter(count)}function node_each(callback,that){let index=-1;for(const node of this){callback.call(that,node,++index,this)}return this}function node_eachBefore(callback,that){var node=this,nodes=[node],children,i,index=-1;while(node=nodes.pop()){callback.call(that,node,++index,this);if(children=node.children){for(i=children.length-1;i>=0;--i){nodes.push(children[i])}}}return this}function node_eachAfter(callback,that){var node=this,nodes=[node],next=[],children,i,n,index=-1;while(node=nodes.pop()){next.push(node);if(children=node.children){for(i=0,n=children.length;i<n;++i){nodes.push(children[i])}}}while(node=next.pop()){callback.call(that,node,++index,this)}return this}function node_find(callback,that){let index=-1;for(const node of this){if(callback.call(that,node,++index,this)){return node}}}function node_sum(value){return this.eachAfter((function(node){var sum=+value(node.data)||0,children=node.children,i=children&&children.length;while(--i>=0)sum+=children[i].value;node.value=sum}))}function node_sort(compare){return this.eachBefore((function(node){if(node.children){node.children.sort(compare)}}))}function node_path(end){var start=this,ancestor=leastCommonAncestor(start,end),nodes=[start];while(start!==ancestor){start=start.parent;nodes.push(start)}var k=nodes.length;while(end!==ancestor){nodes.splice(k,0,end);end=end.parent}return nodes}function leastCommonAncestor(a,b){if(a===b)return a;var aNodes=a.ancestors(),bNodes=b.ancestors(),c=null;a=aNodes.pop();b=bNodes.pop();while(a===b){c=a;a=aNodes.pop();b=bNodes.pop()}return c}function node_ancestors(){var node=this,nodes=[node];while(node=node.parent){nodes.push(node)}return nodes}function node_descendants(){return Array.from(this)}function node_leaves(){var leaves=[];this.eachBefore((function(node){if(!node.children){leaves.push(node)}}));return leaves}function node_links(){var root=this,links=[];root.each((function(node){if(node!==root){links.push({source:node.parent,target:node})}}));return links}function*node_iterator(){var node=this,current,next=[node],children,i,n;do{current=next.reverse(),next=[];while(node=current.pop()){yield node;if(children=node.children){for(i=0,n=children.length;i<n;++i){next.push(children[i])}}}}while(next.length)}function hierarchy(data,children){if(data instanceof Map){data=[undefined,data];if(children===undefined)children=mapChildren}else if(children===undefined){children=objectChildren}var root=new Node$1(data),node,nodes=[root],child,childs,i,n;while(node=nodes.pop()){if((childs=children(node.data))&&(n=(childs=Array.from(childs)).length)){node.children=childs;for(i=n-1;i>=0;--i){nodes.push(child=childs[i]=new Node$1(childs[i]));child.parent=node;child.depth=node.depth+1}}}return root.eachBefore(computeHeight)}function node_copy(){return hierarchy(this).eachBefore(copyData)}function objectChildren(d){return d.children}function mapChildren(d){return Array.isArray(d)?d[1]:null}function copyData(node){if(node.data.value!==undefined)node.value=node.data.value;node.data=node.data.data}function computeHeight(node){var height=0;do{node.height=height}while((node=node.parent)&&node.height<++height)}function Node$1(data){this.data=data;this.depth=this.height=0;this.parent=null}Node$1.prototype=hierarchy.prototype={constructor:Node$1,count:node_count,each:node_each,eachAfter:node_eachAfter,eachBefore:node_eachBefore,find:node_find,sum:node_sum,sort:node_sort,path:node_path,ancestors:node_ancestors,descendants:node_descendants,leaves:node_leaves,links:node_links,copy:node_copy,[Symbol.iterator]:node_iterator};function optional(f){return f==null?null:required(f)}function required(f){if(typeof f!=="function")throw new Error;return f}function constantZero(){return 0}function constant(x){return function(){return x}}const a=1664525;const c=1013904223;const m=4294967296;function lcg(){let s=1;return()=>(s=(a*s+c)%m)/m}function array$2(x){return typeof x==="object"&&"length"in x?x:Array.from(x)}function shuffle(array,random){let m=array.length,t,i;while(m){i=random()*m--|0;t=array[m];array[m]=array[i];array[i]=t}return array}function packEncloseRandom(circles,random){var i=0,n=(circles=shuffle(Array.from(circles),random)).length,B=[],p,e;while(i<n){p=circles[i];if(e&&enclosesWeak(e,p))++i;else e=encloseBasis(B=extendBasis(B,p)),i=0}return e}function extendBasis(B,p){var i,j;if(enclosesWeakAll(p,B))return[p];for(i=0;i<B.length;++i){if(enclosesNot(p,B[i])&&enclosesWeakAll(encloseBasis2(B[i],p),B)){return[B[i],p]}}for(i=0;i<B.length-1;++i){for(j=i+1;j<B.length;++j){if(enclosesNot(encloseBasis2(B[i],B[j]),p)&&enclosesNot(encloseBasis2(B[i],p),B[j])&&enclosesNot(encloseBasis2(B[j],p),B[i])&&enclosesWeakAll(encloseBasis3(B[i],B[j],p),B)){return[B[i],B[j],p]}}}throw new Error}function enclosesNot(a,b){var dr=a.r-b.r,dx=b.x-a.x,dy=b.y-a.y;return dr<0||dr*dr<dx*dx+dy*dy}function enclosesWeak(a,b){var dr=a.r-b.r+Math.max(a.r,b.r,1)*1e-9,dx=b.x-a.x,dy=b.y-a.y;return dr>0&&dr*dr>dx*dx+dy*dy}function enclosesWeakAll(a,B){for(var i=0;i<B.length;++i){if(!enclosesWeak(a,B[i])){return false}}return true}function encloseBasis(B){switch(B.length){case 1:return encloseBasis1(B[0]);case 2:return encloseBasis2(B[0],B[1]);case 3:return encloseBasis3(B[0],B[1],B[2])}}function encloseBasis1(a){return{x:a.x,y:a.y,r:a.r}}function encloseBasis2(a,b){var x1=a.x,y1=a.y,r1=a.r,x2=b.x,y2=b.y,r2=b.r,x21=x2-x1,y21=y2-y1,r21=r2-r1,l=Math.sqrt(x21*x21+y21*y21);return{x:(x1+x2+x21/l*r21)/2,y:(y1+y2+y21/l*r21)/2,r:(l+r1+r2)/2}}function encloseBasis3(a,b,c){var x1=a.x,y1=a.y,r1=a.r,x2=b.x,y2=b.y,r2=b.r,x3=c.x,y3=c.y,r3=c.r,a2=x1-x2,a3=x1-x3,b2=y1-y2,b3=y1-y3,c2=r2-r1,c3=r3-r1,d1=x1*x1+y1*y1-r1*r1,d2=d1-x2*x2-y2*y2+r2*r2,d3=d1-x3*x3-y3*y3+r3*r3,ab=a3*b2-a2*b3,xa=(b2*d3-b3*d2)/(ab*2)-x1,xb=(b3*c2-b2*c3)/ab,ya=(a3*d2-a2*d3)/(ab*2)-y1,yb=(a2*c3-a3*c2)/ab,A=xb*xb+yb*yb-1,B=2*(r1+xa*xb+ya*yb),C=xa*xa+ya*ya-r1*r1,r=-(Math.abs(A)>1e-6?(B+Math.sqrt(B*B-4*A*C))/(2*A):C/B);return{x:x1+xa+xb*r,y:y1+ya+yb*r,r:r}}function place(b,a,c){var dx=b.x-a.x,x,a2,dy=b.y-a.y,y,b2,d2=dx*dx+dy*dy;if(d2){a2=a.r+c.r,a2*=a2;b2=b.r+c.r,b2*=b2;if(a2>b2){x=(d2+b2-a2)/(2*d2);y=Math.sqrt(Math.max(0,b2/d2-x*x));c.x=b.x-x*dx-y*dy;c.y=b.y-x*dy+y*dx}else{x=(d2+a2-b2)/(2*d2);y=Math.sqrt(Math.max(0,a2/d2-x*x));c.x=a.x+x*dx-y*dy;c.y=a.y+x*dy+y*dx}}else{c.x=a.x+c.r;c.y=a.y}}function intersects(a,b){var dr=a.r+b.r-1e-6,dx=b.x-a.x,dy=b.y-a.y;return dr>0&&dr*dr>dx*dx+dy*dy}function score(node){var a=node._,b=node.next._,ab=a.r+b.r,dx=(a.x*b.r+b.x*a.r)/ab,dy=(a.y*b.r+b.y*a.r)/ab;return dx*dx+dy*dy}function Node(circle){this._=circle;this.next=null;this.previous=null}function packSiblingsRandom(circles,random){if(!(n=(circles=array$2(circles)).length))return 0;var a,b,c,n,aa,ca,i,j,k,sj,sk;a=circles[0],a.x=0,a.y=0;if(!(n>1))return a.r;b=circles[1],a.x=-b.r,b.x=a.r,b.y=0;if(!(n>2))return a.r+b.r;place(b,a,c=circles[2]);a=new Node(a),b=new Node(b),c=new Node(c);a.next=c.previous=b;b.next=a.previous=c;c.next=b.previous=a;pack:for(i=3;i<n;++i){place(a._,b._,c=circles[i]),c=new Node(c);j=b.next,k=a.previous,sj=b._.r,sk=a._.r;do{if(sj<=sk){if(intersects(j._,c._)){b=j,a.next=b,b.previous=a,--i;continue pack}sj+=j._.r,j=j.next}else{if(intersects(k._,c._)){a=k,a.next=b,b.previous=a,--i;continue pack}sk+=k._.r,k=k.previous}}while(j!==k.next);c.previous=a,c.next=b,a.next=b.previous=b=c;aa=score(a);while((c=c.next)!==b){if((ca=score(c))<aa){a=c,aa=ca}}b=a.next}a=[b._],c=b;while((c=c.next)!==b)a.push(c._);c=packEncloseRandom(a,random);for(i=0;i<n;++i)a=circles[i],a.x-=c.x,a.y-=c.y;return c.r}function defaultRadius(d){return Math.sqrt(d.value)}function pack(){var radius=null,dx=1,dy=1,padding=constantZero;function pack(root){const random=lcg();root.x=dx/2,root.y=dy/2;if(radius){root.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding,.5,random)).eachBefore(translateChild(1))}else{root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero,1,random)).eachAfter(packChildrenRandom(padding,root.r/Math.min(dx,dy),random)).eachBefore(translateChild(Math.min(dx,dy)/(2*root.r)))}return root}pack.radius=function(x){return arguments.length?(radius=optional(x),pack):radius};pack.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],pack):[dx,dy]};pack.padding=function(x){return arguments.length?(padding=typeof x==="function"?x:constant(+x),pack):padding};return pack}function radiusLeaf(radius){return function(node){if(!node.children){node.r=Math.max(0,+radius(node)||0)}}}function packChildrenRandom(padding,k,random){return function(node){if(children=node.children){var children,i,n=children.length,r=padding(node)*k||0,e;if(r)for(i=0;i<n;++i)children[i].r+=r;e=packSiblingsRandom(children,random);if(r)for(i=0;i<n;++i)children[i].r-=r;node.r=e+r}}}function translateChild(k){return function(node){var parent=node.parent;node.r*=k;if(parent){node.x=parent.x+k*node.x;node.y=parent.y+k*node.y}}}function roundNode(node){node.x0=Math.round(node.x0);node.y0=Math.round(node.y0);node.x1=Math.round(node.x1);node.y1=Math.round(node.y1)}function treemapDice(parent,x0,y0,x1,y1){var nodes=parent.children,node,i=-1,n=nodes.length,k=parent.value&&(x1-x0)/parent.value;while(++i<n){node=nodes[i],node.y0=y0,node.y1=y1;node.x0=x0,node.x1=x0+=node.value*k}}function partition$1(){var dx=1,dy=1,padding=0,round=false;function partition(root){var n=root.height+1;root.x0=root.y0=padding;root.x1=dx;root.y1=dy/n;root.eachBefore(positionNode(dy,n));if(round)root.eachBefore(roundNode);return root}function positionNode(dy,n){return function(node){if(node.children){treemapDice(node,node.x0,dy*(node.depth+1)/n,node.x1,dy*(node.depth+2)/n)}var x0=node.x0,y0=node.y0,x1=node.x1-padding,y1=node.y1-padding;if(x1<x0)x0=x1=(x0+x1)/2;if(y1<y0)y0=y1=(y0+y1)/2;node.x0=x0;node.y0=y0;node.x1=x1;node.y1=y1}}partition.round=function(x){return arguments.length?(round=!!x,partition):round};partition.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],partition):[dx,dy]};partition.padding=function(x){return arguments.length?(padding=+x,partition):padding};return partition}var preroot={depth:-1},ambiguous={},imputed={};function defaultId(d){return d.id}function defaultParentId(d){return d.parentId}function stratify(){var id=defaultId,parentId=defaultParentId,path;function stratify(data){var nodes=Array.from(data),currentId=id,currentParentId=parentId,n,d,i,root,parent,node,nodeId,nodeKey,nodeByKey=new Map;if(path!=null){const I=nodes.map(((d,i)=>normalize$1(path(d,i,data))));const P=I.map(parentof);const S=new Set(I).add("");for(const i of P){if(!S.has(i)){S.add(i);I.push(i);P.push(parentof(i));nodes.push(imputed)}}currentId=(_,i)=>I[i];currentParentId=(_,i)=>P[i]}for(i=0,n=nodes.length;i<n;++i){d=nodes[i],node=nodes[i]=new Node$1(d);if((nodeId=currentId(d,i,data))!=null&&(nodeId+="")){nodeKey=node.id=nodeId;nodeByKey.set(nodeKey,nodeByKey.has(nodeKey)?ambiguous:node)}if((nodeId=currentParentId(d,i,data))!=null&&(nodeId+="")){node.parent=nodeId}}for(i=0;i<n;++i){node=nodes[i];if(nodeId=node.parent){parent=nodeByKey.get(nodeId);if(!parent)throw new Error("missing: "+nodeId);if(parent===ambiguous)throw new Error("ambiguous: "+nodeId);if(parent.children)parent.children.push(node);else parent.children=[node];node.parent=parent}else{if(root)throw new Error("multiple roots");root=node}}if(!root)throw new Error("no root");if(path!=null){while(root.data===imputed&&root.children.length===1){root=root.children[0],--n}for(let i=nodes.length-1;i>=0;--i){node=nodes[i];if(node.data!==imputed)break;node.data=null}}root.parent=preroot;root.eachBefore((function(node){node.depth=node.parent.depth+1;--n})).eachBefore(computeHeight);root.parent=null;if(n>0)throw new Error("cycle");return root}stratify.id=function(x){return arguments.length?(id=optional(x),stratify):id};stratify.parentId=function(x){return arguments.length?(parentId=optional(x),stratify):parentId};stratify.path=function(x){return arguments.length?(path=optional(x),stratify):path};return stratify}function normalize$1(path){path=`${path}`;let i=path.length;if(slash(path,i-1)&&!slash(path,i-2))path=path.slice(0,-1);return path[0]==="/"?path:`/${path}`}function parentof(path){let i=path.length;if(i<2)return"";while(--i>1)if(slash(path,i))break;return path.slice(0,i)}function slash(path,i){if(path[i]==="/"){let k=0;while(i>0&&path[--i]==="\\")++k;if((k&1)===0)return true}return false}function defaultSeparation$1(a,b){return a.parent===b.parent?1:2}function nextLeft(v){var children=v.children;return children?children[0]:v.t}function nextRight(v){var children=v.children;return children?children[children.length-1]:v.t}function moveSubtree(wm,wp,shift){var change=shift/(wp.i-wm.i);wp.c-=change;wp.s+=shift;wm.c+=change;wp.z+=shift;wp.m+=shift}function executeShifts(v){var shift=0,change=0,children=v.children,i=children.length,w;while(--i>=0){w=children[i];w.z+=shift;w.m+=shift;shift+=w.s+(change+=w.c)}}function nextAncestor(vim,v,ancestor){return vim.a.parent===v.parent?vim.a:ancestor}function TreeNode(node,i){this._=node;this.parent=null;this.children=null;this.A=null;this.a=this;this.z=0;this.m=0;this.c=0;this.s=0;this.t=null;this.i=i}TreeNode.prototype=Object.create(Node$1.prototype);function treeRoot(root){var tree=new TreeNode(root,0),node,nodes=[tree],child,children,i,n;while(node=nodes.pop()){if(children=node._.children){node.children=new Array(n=children.length);for(i=n-1;i>=0;--i){nodes.push(child=node.children[i]=new TreeNode(children[i],i));child.parent=node}}}(tree.parent=new TreeNode(null,0)).children=[tree];return tree}function tree$1(){var separation=defaultSeparation$1,dx=1,dy=1,nodeSize=null;function tree(root){var t=treeRoot(root);t.eachAfter(firstWalk),t.parent.m=-t.z;t.eachBefore(secondWalk);if(nodeSize)root.eachBefore(sizeNode);else{var left=root,right=root,bottom=root;root.eachBefore((function(node){if(node.x<left.x)left=node;if(node.x>right.x)right=node;if(node.depth>bottom.depth)bottom=node}));var s=left===right?1:separation(left,right)/2,tx=s-left.x,kx=dx/(right.x+s+tx),ky=dy/(bottom.depth||1);root.eachBefore((function(node){node.x=(node.x+tx)*kx;node.y=node.depth*ky}))}return root}function firstWalk(v){var children=v.children,siblings=v.parent.children,w=v.i?siblings[v.i-1]:null;if(children){executeShifts(v);var midpoint=(children[0].z+children[children.length-1].z)/2;if(w){v.z=w.z+separation(v._,w._);v.m=v.z-midpoint}else{v.z=midpoint}}else if(w){v.z=w.z+separation(v._,w._)}v.parent.A=apportion(v,w,v.parent.A||siblings[0])}function secondWalk(v){v._.x=v.z+v.parent.m;v.m+=v.parent.m}function apportion(v,w,ancestor){if(w){var vip=v,vop=v,vim=w,vom=vip.parent.children[0],sip=vip.m,sop=vop.m,sim=vim.m,som=vom.m,shift;while(vim=nextRight(vim),vip=nextLeft(vip),vim&&vip){vom=nextLeft(vom);vop=nextRight(vop);vop.a=v;shift=vim.z+sim-vip.z-sip+separation(vim._,vip._);if(shift>0){moveSubtree(nextAncestor(vim,v,ancestor),v,shift);sip+=shift;sop+=shift}sim+=vim.m;sip+=vip.m;som+=vom.m;sop+=vop.m}if(vim&&!nextRight(vop)){vop.t=vim;vop.m+=sim-sop}if(vip&&!nextLeft(vom)){vom.t=vip;vom.m+=sip-som;ancestor=v}}return ancestor}function sizeNode(node){node.x*=dx;node.y=node.depth*dy}tree.separation=function(x){return arguments.length?(separation=x,tree):separation};tree.size=function(x){return arguments.length?(nodeSize=false,dx=+x[0],dy=+x[1],tree):nodeSize?null:[dx,dy]};tree.nodeSize=function(x){return arguments.length?(nodeSize=true,dx=+x[0],dy=+x[1],tree):nodeSize?[dx,dy]:null};return tree}function treemapSlice(parent,x0,y0,x1,y1){var nodes=parent.children,node,i=-1,n=nodes.length,k=parent.value&&(y1-y0)/parent.value;while(++i<n){node=nodes[i],node.x0=x0,node.x1=x1;node.y0=y0,node.y1=y0+=node.value*k}}var phi=(1+Math.sqrt(5))/2;function squarifyRatio(ratio,parent,x0,y0,x1,y1){var rows=[],nodes=parent.children,row,nodeValue,i0=0,i1=0,n=nodes.length,dx,dy,value=parent.value,sumValue,minValue,maxValue,newRatio,minRatio,alpha,beta;while(i0<n){dx=x1-x0,dy=y1-y0;do{sumValue=nodes[i1++].value}while(!sumValue&&i1<n);minValue=maxValue=sumValue;alpha=Math.max(dy/dx,dx/dy)/(value*ratio);beta=sumValue*sumValue*alpha;minRatio=Math.max(maxValue/beta,beta/minValue);for(;i1<n;++i1){sumValue+=nodeValue=nodes[i1].value;if(nodeValue<minValue)minValue=nodeValue;if(nodeValue>maxValue)maxValue=nodeValue;beta=sumValue*sumValue*alpha;newRatio=Math.max(maxValue/beta,beta/minValue);if(newRatio>minRatio){sumValue-=nodeValue;break}minRatio=newRatio}rows.push(row={value:sumValue,dice:dx<dy,children:nodes.slice(i0,i1)});if(row.dice)treemapDice(row,x0,y0,x1,value?y0+=dy*sumValue/value:y1);else treemapSlice(row,x0,y0,value?x0+=dx*sumValue/value:x1,y1);value-=sumValue,i0=i1}return rows}var treemapSquarify=function custom(ratio){function squarify(parent,x0,y0,x1,y1){squarifyRatio(ratio,parent,x0,y0,x1,y1)}squarify.ratio=function(x){return custom((x=+x)>1?x:1)};return squarify}(phi);function treemap(){var tile=treemapSquarify,round=false,dx=1,dy=1,paddingStack=[0],paddingInner=constantZero,paddingTop=constantZero,paddingRight=constantZero,paddingBottom=constantZero,paddingLeft=constantZero;function treemap(root){root.x0=root.y0=0;root.x1=dx;root.y1=dy;root.eachBefore(positionNode);paddingStack=[0];if(round)root.eachBefore(roundNode);return root}function positionNode(node){var p=paddingStack[node.depth],x0=node.x0+p,y0=node.y0+p,x1=node.x1-p,y1=node.y1-p;if(x1<x0)x0=x1=(x0+x1)/2;if(y1<y0)y0=y1=(y0+y1)/2;node.x0=x0;node.y0=y0;node.x1=x1;node.y1=y1;if(node.children){p=paddingStack[node.depth+1]=paddingInner(node)/2;x0+=paddingLeft(node)-p;y0+=paddingTop(node)-p;x1-=paddingRight(node)-p;y1-=paddingBottom(node)-p;if(x1<x0)x0=x1=(x0+x1)/2;if(y1<y0)y0=y1=(y0+y1)/2;tile(node,x0,y0,x1,y1)}}treemap.round=function(x){return arguments.length?(round=!!x,treemap):round};treemap.size=function(x){return arguments.length?(dx=+x[0],dy=+x[1],treemap):[dx,dy]};treemap.tile=function(x){return arguments.length?(tile=required(x),treemap):tile};treemap.padding=function(x){return arguments.length?treemap.paddingInner(x).paddingOuter(x):treemap.paddingInner()};treemap.paddingInner=function(x){return arguments.length?(paddingInner=typeof x==="function"?x:constant(+x),treemap):paddingInner};treemap.paddingOuter=function(x){return arguments.length?treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x):treemap.paddingTop()};treemap.paddingTop=function(x){return arguments.length?(paddingTop=typeof x==="function"?x:constant(+x),treemap):paddingTop};treemap.paddingRight=function(x){return arguments.length?(paddingRight=typeof x==="function"?x:constant(+x),treemap):paddingRight};treemap.paddingBottom=function(x){return arguments.length?(paddingBottom=typeof x==="function"?x:constant(+x),treemap):paddingBottom};treemap.paddingLeft=function(x){return arguments.length?(paddingLeft=typeof x==="function"?x:constant(+x),treemap):paddingLeft};return treemap}function treemapBinary(parent,x0,y0,x1,y1){var nodes=parent.children,i,n=nodes.length,sum,sums=new Array(n+1);for(sums[0]=sum=i=0;i<n;++i){sums[i+1]=sum+=nodes[i].value}partition(0,n,parent.value,x0,y0,x1,y1);function partition(i,j,value,x0,y0,x1,y1){if(i>=j-1){var node=nodes[i];node.x0=x0,node.y0=y0;node.x1=x1,node.y1=y1;return}var valueOffset=sums[i],valueTarget=value/2+valueOffset,k=i+1,hi=j-1;while(k<hi){var mid=k+hi>>>1;if(sums[mid]<valueTarget)k=mid+1;else hi=mid}if(valueTarget-sums[k-1]<sums[k]-valueTarget&&i+1<k)--k;var valueLeft=sums[k]-valueOffset,valueRight=value-valueLeft;if(x1-x0>y1-y0){var xk=value?(x0*valueRight+x1*valueLeft)/value:x1;partition(i,k,valueLeft,x0,y0,xk,y1);partition(k,j,valueRight,xk,y0,x1,y1)}else{var yk=value?(y0*valueRight+y1*valueLeft)/value:y1;partition(i,k,valueLeft,x0,y0,x1,yk);partition(k,j,valueRight,x0,yk,x1,y1)}}}function treemapSliceDice(parent,x0,y0,x1,y1){(parent.depth&1?treemapSlice:treemapDice)(parent,x0,y0,x1,y1)}var treemapResquarify=function custom(ratio){function resquarify(parent,x0,y0,x1,y1){if((rows=parent._squarify)&&rows.ratio===ratio){var rows,row,nodes,i,j=-1,n,m=rows.length,value=parent.value;while(++j<m){row=rows[j],nodes=row.children;for(i=row.value=0,n=nodes.length;i<n;++i)row.value+=nodes[i].value;if(row.dice)treemapDice(row,x0,y0,x1,value?y0+=(y1-y0)*row.value/value:y1);else treemapSlice(row,x0,y0,value?x0+=(x1-x0)*row.value/value:x1,y1);value-=row.value}}else{parent._squarify=rows=squarifyRatio(ratio,parent,x0,y0,x1,y1);rows.ratio=ratio}}resquarify.ratio=function(x){return custom((x=+x)>1?x:1)};return resquarify}(phi);function lookup$2(tree,key,filter){const map={};tree.each((node=>{const t=node.data;if(filter(t))map[key(t)]=node}));tree.lookup=map;return tree}function Nest(params){Transform.call(this,null,params)}Nest.Definition={type:"Nest",metadata:{treesource:true,changes:true},params:[{name:"keys",type:"field",array:true},{name:"generate",type:"boolean"}]};const children$1=n=>n.values;inherits(Nest,Transform,{transform(_,pulse){if(!pulse.source){error("Nest transform requires an upstream data source.")}var gen=_.generate,mod=_.modified(),out=pulse.clone(),tree=this.value;if(!tree||mod||pulse.changed()){if(tree){tree.each((node=>{if(node.children&&isTuple(node.data)){out.rem.push(node.data)}}))}this.value=tree=hierarchy({values:array$5(_.keys).reduce(((n,k)=>{n.key(k);return n}),nest()).entries(out.source)},children$1);if(gen){tree.each((node=>{if(node.children){node=ingest$1(node.data);out.add.push(node);out.source.push(node)}}))}lookup$2(tree,tupleid,tupleid)}out.source.root=tree;return out}});function nest(){const keys=[],nest={entries:array=>entries(apply(array,0),0),key:d=>(keys.push(d),nest)};function apply(array,depth){if(depth>=keys.length){return array}const n=array.length,key=keys[depth++],valuesByKey={},result={};let i=-1,keyValue,value,values;while(++i<n){keyValue=key(value=array[i])+"";if(values=valuesByKey[keyValue]){values.push(value)}else{valuesByKey[keyValue]=[value]}}for(keyValue in valuesByKey){result[keyValue]=apply(valuesByKey[keyValue],depth)}return result}function entries(map,depth){if(++depth>keys.length)return map;const array=[];for(const key in map){array.push({key:key,values:entries(map[key],depth)})}return array}return nest}function HierarchyLayout(params){Transform.call(this,null,params)}const defaultSeparation=(a,b)=>a.parent===b.parent?1:2;inherits(HierarchyLayout,Transform,{transform(_,pulse){if(!pulse.source||!pulse.source.root){error(this.constructor.name+" transform requires a backing tree data source.")}const layout=this.layout(_.method),fields=this.fields,root=pulse.source.root,as=_.as||fields;if(_.field)root.sum(_.field);else root.count();if(_.sort)root.sort(stableCompare(_.sort,(d=>d.data)));setParams(layout,this.params,_);if(layout.separation){layout.separation(_.separation!==false?defaultSeparation:one$2)}try{this.value=layout(root)}catch(err){error(err)}root.each((node=>setFields(node,fields,as)));return pulse.reflow(_.modified()).modifies(as).modifies("leaf")}});function setParams(layout,params,_){for(let p,i=0,n=params.length;i<n;++i){p=params[i];if(p in _)layout[p](_[p])}}function setFields(node,fields,as){const t=node.data,n=fields.length-1;for(let i=0;i<n;++i){t[as[i]]=node[fields[i]]}t[as[n]]=node.children?node.children.length:0}const Output$3=["x","y","r","depth","children"];function Pack(params){HierarchyLayout.call(this,params)}Pack.Definition={type:"Pack",metadata:{tree:true,modifies:true},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number",default:0},{name:"radius",type:"field",default:null},{name:"size",type:"number",array:true,length:2},{name:"as",type:"string",array:true,length:Output$3.length,default:Output$3}]};inherits(Pack,HierarchyLayout,{layout:pack,params:["radius","size","padding"],fields:Output$3});const Output$2=["x0","y0","x1","y1","depth","children"];function Partition(params){HierarchyLayout.call(this,params)}Partition.Definition={type:"Partition",metadata:{tree:true,modifies:true},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"padding",type:"number",default:0},{name:"round",type:"boolean",default:false},{name:"size",type:"number",array:true,length:2},{name:"as",type:"string",array:true,length:Output$2.length,default:Output$2}]};inherits(Partition,HierarchyLayout,{layout:partition$1,params:["size","round","padding"],fields:Output$2});function Stratify(params){Transform.call(this,null,params)}Stratify.Definition={type:"Stratify",metadata:{treesource:true},params:[{name:"key",type:"field",required:true},{name:"parentKey",type:"field",required:true}]};inherits(Stratify,Transform,{transform(_,pulse){if(!pulse.source){error("Stratify transform requires an upstream data source.")}let tree=this.value;const mod=_.modified(),out=pulse.fork(pulse.ALL).materialize(pulse.SOURCE),run=!tree||mod||pulse.changed(pulse.ADD_REM)||pulse.modified(_.key.fields)||pulse.modified(_.parentKey.fields);out.source=out.source.slice();if(run){tree=out.source.length?lookup$2(stratify().id(_.key).parentId(_.parentKey)(out.source),_.key,truthy):lookup$2(stratify()([{}]),_.key,_.key)}out.source.root=this.value=tree;return out}});const Layouts={tidy:tree$1,cluster:cluster};const Output$1$1=["x","y","depth","children"];function Tree(params){HierarchyLayout.call(this,params)}Tree.Definition={type:"Tree",metadata:{tree:true,modifies:true},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum",default:"tidy",values:["tidy","cluster"]},{name:"size",type:"number",array:true,length:2},{name:"nodeSize",type:"number",array:true,length:2},{name:"separation",type:"boolean",default:true},{name:"as",type:"string",array:true,length:Output$1$1.length,default:Output$1$1}]};inherits(Tree,HierarchyLayout,{layout(method){const m=method||"tidy";if(has$1(Layouts,m))return Layouts[m]();else error("Unrecognized Tree layout method: "+m)},params:["size","nodeSize"],fields:Output$1$1});function TreeLinks(params){Transform.call(this,[],params)}TreeLinks.Definition={type:"TreeLinks",metadata:{tree:true,generates:true,changes:true},params:[]};inherits(TreeLinks,Transform,{transform(_,pulse){const links=this.value,tree=pulse.source&&pulse.source.root,out=pulse.fork(pulse.NO_SOURCE),lut={};if(!tree)error("TreeLinks transform requires a tree data source.");if(pulse.changed(pulse.ADD_REM)){out.rem=links;pulse.visit(pulse.SOURCE,(t=>lut[tupleid(t)]=1));tree.each((node=>{const t=node.data,p=node.parent&&node.parent.data;if(p&&lut[tupleid(t)]&&lut[tupleid(p)]){out.add.push(ingest$1({source:p,target:t}))}}));this.value=out.add}else if(pulse.changed(pulse.MOD)){pulse.visit(pulse.MOD,(t=>lut[tupleid(t)]=1));links.forEach((link=>{if(lut[tupleid(link.source)]||lut[tupleid(link.target)]){out.mod.push(link)}}))}return out}});const Tiles={binary:treemapBinary,dice:treemapDice,slice:treemapSlice,slicedice:treemapSliceDice,squarify:treemapSquarify,resquarify:treemapResquarify};const Output$4=["x0","y0","x1","y1","depth","children"];function Treemap(params){HierarchyLayout.call(this,params)}Treemap.Definition={type:"Treemap",metadata:{tree:true,modifies:true},params:[{name:"field",type:"field"},{name:"sort",type:"compare"},{name:"method",type:"enum",default:"squarify",values:["squarify","resquarify","binary","dice","slice","slicedice"]},{name:"padding",type:"number",default:0},{name:"paddingInner",type:"number",default:0},{name:"paddingOuter",type:"number",default:0},{name:"paddingTop",type:"number",default:0},{name:"paddingRight",type:"number",default:0},{name:"paddingBottom",type:"number",default:0},{name:"paddingLeft",type:"number",default:0},{name:"ratio",type:"number",default:1.618033988749895},{name:"round",type:"boolean",default:false},{name:"size",type:"number",array:true,length:2},{name:"as",type:"string",array:true,length:Output$4.length,default:Output$4}]};inherits(Treemap,HierarchyLayout,{layout(){const x=treemap();x.ratio=_=>{const t=x.tile();if(t.ratio)x.tile(t.ratio(_))};x.method=_=>{if(has$1(Tiles,_))x.tile(Tiles[_]);else error("Unrecognized Treemap layout method: "+_)};return x},params:["method","ratio","size","round","padding","paddingInner","paddingOuter","paddingTop","paddingRight","paddingBottom","paddingLeft"],fields:Output$4});var tree=Object.freeze({__proto__:null,nest:Nest,pack:Pack,partition:Partition,stratify:Stratify,tree:Tree,treelinks:TreeLinks,treemap:Treemap});const ALPHA_MASK=4278190080;function baseBitmaps($,data){const bitmap=$.bitmap();(data||[]).forEach((d=>bitmap.set($(d.boundary[0]),$(d.boundary[3]))));return[bitmap,undefined]}function markBitmaps($,baseMark,avoidMarks,labelInside,isGroupArea){const width=$.width,height=$.height,border=labelInside||isGroupArea,context=canvas(width,height).getContext("2d"),baseMarkContext=canvas(width,height).getContext("2d"),strokeContext=border&&canvas(width,height).getContext("2d");avoidMarks.forEach((items=>draw(context,items,false)));draw(baseMarkContext,baseMark,false);if(border){draw(strokeContext,baseMark,true)}const buffer=getBuffer(context,width,height),baseMarkBuffer=getBuffer(baseMarkContext,width,height),strokeBuffer=border&&getBuffer(strokeContext,width,height),layer1=$.bitmap(),layer2=border&&$.bitmap();let x,y,u,v,index,alpha,strokeAlpha,baseMarkAlpha;for(y=0;y<height;++y){for(x=0;x<width;++x){index=y*width+x;alpha=buffer[index]&ALPHA_MASK;baseMarkAlpha=baseMarkBuffer[index]&ALPHA_MASK;strokeAlpha=border&&strokeBuffer[index]&ALPHA_MASK;if(alpha||strokeAlpha||baseMarkAlpha){u=$(x);v=$(y);if(!isGroupArea&&(alpha||baseMarkAlpha))layer1.set(u,v);if(border&&(alpha||strokeAlpha))layer2.set(u,v)}}}return[layer1,layer2]}function getBuffer(context,width,height){return new Uint32Array(context.getImageData(0,0,width,height).data.buffer)}function draw(context,items,interior){if(!items.length)return;const type=items[0].mark.marktype;if(type==="group"){items.forEach((group=>{group.items.forEach((mark=>draw(context,mark.items,interior)))}))}else{Marks[type].draw(context,{items:interior?items.map(prepare):items})}}function prepare(source){const item=rederive(source,{});if(item.stroke&&item.strokeOpacity!==0||item.fill&&item.fillOpacity!==0){return{...item,strokeOpacity:1,stroke:"#000",fillOpacity:0}}return item}const DIV=5,MOD=31,SIZE$1=32,RIGHT0=new Uint32Array(SIZE$1+1),RIGHT1=new Uint32Array(SIZE$1+1);RIGHT1[0]=0;RIGHT0[0]=~RIGHT1[0];for(let i=1;i<=SIZE$1;++i){RIGHT1[i]=RIGHT1[i-1]<<1|1;RIGHT0[i]=~RIGHT1[i]}function Bitmap(w,h){const array=new Uint32Array(~~((w*h+SIZE$1)/SIZE$1));function _set(index,mask){array[index]|=mask}function _clear(index,mask){array[index]&=mask}return{array:array,get:(x,y)=>{const index=y*w+x;return array[index>>>DIV]&1<<(index&MOD)},set:(x,y)=>{const index=y*w+x;_set(index>>>DIV,1<<(index&MOD))},clear:(x,y)=>{const index=y*w+x;_clear(index>>>DIV,~(1<<(index&MOD)))},getRange:(x,y,x2,y2)=>{let r=y2,start,end,indexStart,indexEnd;for(;r>=y;--r){start=r*w+x;end=r*w+x2;indexStart=start>>>DIV;indexEnd=end>>>DIV;if(indexStart===indexEnd){if(array[indexStart]&RIGHT0[start&MOD]&RIGHT1[(end&MOD)+1]){return true}}else{if(array[indexStart]&RIGHT0[start&MOD])return true;if(array[indexEnd]&RIGHT1[(end&MOD)+1])return true;for(let i=indexStart+1;i<indexEnd;++i){if(array[i])return true}}}return false},setRange:(x,y,x2,y2)=>{let start,end,indexStart,indexEnd,i;for(;y<=y2;++y){start=y*w+x;end=y*w+x2;indexStart=start>>>DIV;indexEnd=end>>>DIV;if(indexStart===indexEnd){_set(indexStart,RIGHT0[start&MOD]&RIGHT1[(end&MOD)+1])}else{_set(indexStart,RIGHT0[start&MOD]);_set(indexEnd,RIGHT1[(end&MOD)+1]);for(i=indexStart+1;i<indexEnd;++i)_set(i,4294967295)}}},clearRange:(x,y,x2,y2)=>{let start,end,indexStart,indexEnd,i;for(;y<=y2;++y){start=y*w+x;end=y*w+x2;indexStart=start>>>DIV;indexEnd=end>>>DIV;if(indexStart===indexEnd){_clear(indexStart,RIGHT1[start&MOD]|RIGHT0[(end&MOD)+1])}else{_clear(indexStart,RIGHT1[start&MOD]);_clear(indexEnd,RIGHT0[(end&MOD)+1]);for(i=indexStart+1;i<indexEnd;++i)_clear(i,0)}}},outOfBounds:(x,y,x2,y2)=>x<0||y<0||y2>=h||x2>=w}}function scaler(width,height,padding){const ratio=Math.max(1,Math.sqrt(width*height/1e6)),w=~~((width+2*padding+ratio)/ratio),h=~~((height+2*padding+ratio)/ratio),scale=_=>~~((_+padding)/ratio);scale.invert=_=>_*ratio-padding;scale.bitmap=()=>Bitmap(w,h);scale.ratio=ratio;scale.padding=padding;scale.width=width;scale.height=height;return scale}function placeAreaLabelNaive($,bitmaps,avoidBaseMark,markIndex){const width=$.width,height=$.height;return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,textHeight=d.datum.fontSize,textWidth=textMetrics.width(d.datum,d.datum.text);let maxAreaWidth=0,x1,x2,y1,y2,x,y,areaWidth;for(let i=0;i<n;++i){x1=items[i].x;y1=items[i].y;x2=items[i].x2===undefined?x1:items[i].x2;y2=items[i].y2===undefined?y1:items[i].y2;x=(x1+x2)/2;y=(y1+y2)/2;areaWidth=Math.abs(x2-x1+y2-y1);if(areaWidth>=maxAreaWidth){maxAreaWidth=areaWidth;d.x=x;d.y=y}}x=textWidth/2;y=textHeight/2;x1=d.x-x;x2=d.x+x;y1=d.y-y;y2=d.y+y;d.align="center";if(x1<0&&x2<=width){d.align="left"}else if(0<=x1&&width<x2){d.align="right"}d.baseline="middle";if(y1<0&&y2<=height){d.baseline="top"}else if(0<=y1&&height<y2){d.baseline="bottom"}return true}}function outOfBounds(x,y,textWidth,textHeight,width,height){let r=textWidth/2;return x-r<0||x+r>width||y-(r=textHeight/2)<0||y+r>height}function collision($,x,y,textHeight,textWidth,h,bm0,bm1){const w=textWidth*h/(textHeight*2),x1=$(x-w),x2=$(x+w),y1=$(y-(h=h/2)),y2=$(y+h);return bm0.outOfBounds(x1,y1,x2,y2)||bm0.getRange(x1,y1,x2,y2)||bm1&&bm1.getRange(x1,y1,x2,y2)}function placeAreaLabelReducedSearch($,bitmaps,avoidBaseMark,markIndex){const width=$.width,height=$.height,bm0=bitmaps[0],bm1=bitmaps[1];function tryLabel(_x,_y,maxSize,textWidth,textHeight){const x=$.invert(_x),y=$.invert(_y);let lo=maxSize,hi=height,mid;if(!outOfBounds(x,y,textWidth,textHeight,width,height)&&!collision($,x,y,textHeight,textWidth,lo,bm0,bm1)&&!collision($,x,y,textHeight,textWidth,textHeight,bm0,null)){while(hi-lo>=1){mid=(lo+hi)/2;if(collision($,x,y,textHeight,textWidth,mid,bm0,bm1)){hi=mid}else{lo=mid}}if(lo>maxSize){return[x,y,lo,true]}}}return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,textHeight=d.datum.fontSize,textWidth=textMetrics.width(d.datum,d.datum.text);let maxSize=avoidBaseMark?textHeight:0,labelPlaced=false,labelPlaced2=false,maxAreaWidth=0,x1,x2,y1,y2,x,y,_x,_y,_x1,_xMid,_x2,_y1,_yMid,_y2,areaWidth,result,swapTmp;for(let i=0;i<n;++i){x1=items[i].x;y1=items[i].y;x2=items[i].x2===undefined?x1:items[i].x2;y2=items[i].y2===undefined?y1:items[i].y2;if(x1>x2){swapTmp=x1;x1=x2;x2=swapTmp}if(y1>y2){swapTmp=y1;y1=y2;y2=swapTmp}_x1=$(x1);_x2=$(x2);_xMid=~~((_x1+_x2)/2);_y1=$(y1);_y2=$(y2);_yMid=~~((_y1+_y2)/2);for(_x=_xMid;_x>=_x1;--_x){for(_y=_yMid;_y>=_y1;--_y){result=tryLabel(_x,_y,maxSize,textWidth,textHeight);if(result){[d.x,d.y,maxSize,labelPlaced]=result}}}for(_x=_xMid;_x<=_x2;++_x){for(_y=_yMid;_y<=_y2;++_y){result=tryLabel(_x,_y,maxSize,textWidth,textHeight);if(result){[d.x,d.y,maxSize,labelPlaced]=result}}}if(!labelPlaced&&!avoidBaseMark){areaWidth=Math.abs(x2-x1+y2-y1);x=(x1+x2)/2;y=(y1+y2)/2;if(areaWidth>=maxAreaWidth&&!outOfBounds(x,y,textWidth,textHeight,width,height)&&!collision($,x,y,textHeight,textWidth,textHeight,bm0,null)){maxAreaWidth=areaWidth;d.x=x;d.y=y;labelPlaced2=true}}}if(labelPlaced||labelPlaced2){x=textWidth/2;y=textHeight/2;bm0.setRange($(d.x-x),$(d.y-y),$(d.x+x),$(d.y+y));d.align="center";d.baseline="middle";return true}else{return false}}}const X_DIR=[-1,-1,1,1];const Y_DIR=[-1,1,-1,1];function placeAreaLabelFloodFill($,bitmaps,avoidBaseMark,markIndex){const width=$.width,height=$.height,bm0=bitmaps[0],bm1=bitmaps[1],bm2=$.bitmap();return function(d){const items=d.datum.datum.items[markIndex].items,n=items.length,textHeight=d.datum.fontSize,textWidth=textMetrics.width(d.datum,d.datum.text),stack=[];let maxSize=avoidBaseMark?textHeight:0,labelPlaced=false,labelPlaced2=false,maxAreaWidth=0,x1,x2,y1,y2,x,y,_x,_y,lo,hi,mid,areaWidth;for(let i=0;i<n;++i){x1=items[i].x;y1=items[i].y;x2=items[i].x2===undefined?x1:items[i].x2;y2=items[i].y2===undefined?y1:items[i].y2;stack.push([$((x1+x2)/2),$((y1+y2)/2)]);while(stack.length){[_x,_y]=stack.pop();if(bm0.get(_x,_y)||bm1.get(_x,_y)||bm2.get(_x,_y))continue;bm2.set(_x,_y);for(let j=0;j<4;++j){x=_x+X_DIR[j];y=_y+Y_DIR[j];if(!bm2.outOfBounds(x,y,x,y))stack.push([x,y])}x=$.invert(_x);y=$.invert(_y);lo=maxSize;hi=height;if(!outOfBounds(x,y,textWidth,textHeight,width,height)&&!collision($,x,y,textHeight,textWidth,lo,bm0,bm1)&&!collision($,x,y,textHeight,textWidth,textHeight,bm0,null)){while(hi-lo>=1){mid=(lo+hi)/2;if(collision($,x,y,textHeight,textWidth,mid,bm0,bm1)){hi=mid}else{lo=mid}}if(lo>maxSize){d.x=x;d.y=y;maxSize=lo;labelPlaced=true}}}if(!labelPlaced&&!avoidBaseMark){areaWidth=Math.abs(x2-x1+y2-y1);x=(x1+x2)/2;y=(y1+y2)/2;if(areaWidth>=maxAreaWidth&&!outOfBounds(x,y,textWidth,textHeight,width,height)&&!collision($,x,y,textHeight,textWidth,textHeight,bm0,null)){maxAreaWidth=areaWidth;d.x=x;d.y=y;labelPlaced2=true}}}if(labelPlaced||labelPlaced2){x=textWidth/2;y=textHeight/2;bm0.setRange($(d.x-x),$(d.y-y),$(d.x+x),$(d.y+y));d.align="center";d.baseline="middle";return true}else{return false}}}const Aligns=["right","center","left"],Baselines=["bottom","middle","top"];function placeMarkLabel($,bitmaps,anchors,offsets){const width=$.width,height=$.height,bm0=bitmaps[0],bm1=bitmaps[1],n=offsets.length;return function(d){const boundary=d.boundary,textHeight=d.datum.fontSize;if(boundary[2]<0||boundary[5]<0||boundary[0]>width||boundary[3]>height){return false}let textWidth=d.textWidth??0,dx,dy,isInside,sizeFactor,insideFactor,x1,x2,y1,y2,xc,yc,_x1,_x2,_y1,_y2;for(let i=0;i<n;++i){dx=(anchors[i]&3)-1;dy=(anchors[i]>>>2&3)-1;isInside=dx===0&&dy===0||offsets[i]<0;sizeFactor=dx&&dy?Math.SQRT1_2:1;insideFactor=offsets[i]<0?-1:1;x1=boundary[1+dx]+offsets[i]*dx*sizeFactor;yc=boundary[4+dy]+insideFactor*textHeight*dy/2+offsets[i]*dy*sizeFactor;y1=yc-textHeight/2;y2=yc+textHeight/2;_x1=$(x1);_y1=$(y1);_y2=$(y2);if(!textWidth){if(!test(_x1,_x1,_y1,_y2,bm0,bm1,x1,x1,y1,y2,boundary,isInside)){continue}else{textWidth=textMetrics.width(d.datum,d.datum.text)}}xc=x1+insideFactor*textWidth*dx/2;x1=xc-textWidth/2;x2=xc+textWidth/2;_x1=$(x1);_x2=$(x2);if(test(_x1,_x2,_y1,_y2,bm0,bm1,x1,x2,y1,y2,boundary,isInside)){d.x=!dx?xc:dx*insideFactor<0?x2:x1;d.y=!dy?yc:dy*insideFactor<0?y2:y1;d.align=Aligns[dx*insideFactor+1];d.baseline=Baselines[dy*insideFactor+1];bm0.setRange(_x1,_y1,_x2,_y2);return true}}return false}}function test(_x1,_x2,_y1,_y2,bm0,bm1,x1,x2,y1,y2,boundary,isInside){return!(bm0.outOfBounds(_x1,_y1,_x2,_y2)||(isInside&&bm1||bm0).getRange(_x1,_y1,_x2,_y2))}const TOP=0,MIDDLE=4,BOTTOM=8,LEFT=0,CENTER$1=1,RIGHT=2;const anchorCode={"top-left":TOP+LEFT,top:TOP+CENTER$1,"top-right":TOP+RIGHT,left:MIDDLE+LEFT,middle:MIDDLE+CENTER$1,right:MIDDLE+RIGHT,"bottom-left":BOTTOM+LEFT,bottom:BOTTOM+CENTER$1,"bottom-right":BOTTOM+RIGHT};const placeAreaLabel={naive:placeAreaLabelNaive,"reduced-search":placeAreaLabelReducedSearch,floodfill:placeAreaLabelFloodFill};function labelLayout(texts,size,compare,offset,anchor,avoidMarks,avoidBaseMark,lineAnchor,markIndex,padding,method){if(!texts.length)return texts;const positions=Math.max(offset.length,anchor.length),offsets=getOffsets(offset,positions),anchors=getAnchors(anchor,positions),marktype=markType(texts[0].datum),grouptype=marktype==="group"&&texts[0].datum.items[markIndex].marktype,isGroupArea=grouptype==="area",boundary=markBoundary(marktype,grouptype,lineAnchor,markIndex),infPadding=padding===null||padding===Infinity,isNaiveGroupArea=isGroupArea&&method==="naive";let maxTextWidth=-1,maxTextHeight=-1;const data=texts.map((d=>{const textWidth=infPadding?textMetrics.width(d,d.text):undefined;maxTextWidth=Math.max(maxTextWidth,textWidth);maxTextHeight=Math.max(maxTextHeight,d.fontSize);return{datum:d,opacity:0,x:undefined,y:undefined,align:undefined,baseline:undefined,boundary:boundary(d),textWidth:textWidth}}));padding=padding===null||padding===Infinity?Math.max(maxTextWidth,maxTextHeight)+Math.max(...offset):padding;const $=scaler(size[0],size[1],padding);let bitmaps;if(!isNaiveGroupArea){if(compare){data.sort(((a,b)=>compare(a.datum,b.datum)))}let labelInside=false;for(let i=0;i<anchors.length&&!labelInside;++i){labelInside=anchors[i]===5||offsets[i]<0}const baseMark=(marktype&&avoidBaseMark||isGroupArea)&&texts.map((d=>d.datum));bitmaps=avoidMarks.length||baseMark?markBitmaps($,baseMark||[],avoidMarks,labelInside,isGroupArea):baseBitmaps($,avoidBaseMark&&data)}const place=isGroupArea?placeAreaLabel[method]($,bitmaps,avoidBaseMark,markIndex):placeMarkLabel($,bitmaps,anchors,offsets);data.forEach((d=>d.opacity=+place(d)));return data}function getOffsets(_,count){const offsets=new Float64Array(count),n=_.length;for(let i=0;i<n;++i)offsets[i]=_[i]||0;for(let i=n;i<count;++i)offsets[i]=offsets[n-1];return offsets}function getAnchors(_,count){const anchors=new Int8Array(count),n=_.length;for(let i=0;i<n;++i)anchors[i]|=anchorCode[_[i]];for(let i=n;i<count;++i)anchors[i]=anchors[n-1];return anchors}function markType(item){return item&&item.mark&&item.mark.marktype}function markBoundary(marktype,grouptype,lineAnchor,markIndex){const xy=d=>[d.x,d.x,d.x,d.y,d.y,d.y];if(!marktype){return xy}else if(marktype==="line"||marktype==="area"){return d=>xy(d.datum)}else if(grouptype==="line"){return d=>{const items=d.datum.items[markIndex].items;return xy(items.length?items[lineAnchor==="start"?0:items.length-1]:{x:NaN,y:NaN})}}else{return d=>{const b=d.datum.bounds;return[b.x1,(b.x1+b.x2)/2,b.x2,b.y1,(b.y1+b.y2)/2,b.y2]}}}const Output$1=["x","y","opacity","align","baseline"];const Anchors=["top-left","left","bottom-left","top","bottom","top-right","right","bottom-right"];function Label$1(params){Transform.call(this,null,params)}Label$1.Definition={type:"Label",metadata:{modifies:true},params:[{name:"size",type:"number",array:true,length:2,required:true},{name:"sort",type:"compare"},{name:"anchor",type:"string",array:true,default:Anchors},{name:"offset",type:"number",array:true,default:[1]},{name:"padding",type:"number",default:0,null:true},{name:"lineAnchor",type:"string",values:["start","end"],default:"end"},{name:"markIndex",type:"number",default:0},{name:"avoidBaseMark",type:"boolean",default:true},{name:"avoidMarks",type:"data",array:true},{name:"method",type:"string",default:"naive"},{name:"as",type:"string",array:true,length:Output$1.length,default:Output$1}]};inherits(Label$1,Transform,{transform(_,pulse){function modp(param){const p=_[param];return isFunction(p)&&pulse.modified(p.fields)}const mod=_.modified();if(!(mod||pulse.changed(pulse.ADD_REM)||modp("sort")))return;if(!_.size||_.size.length!==2){error("Size parameter should be specified as a [width, height] array.")}const as=_.as||Output$1;labelLayout(pulse.materialize(pulse.SOURCE).source||[],_.size,_.sort,array$5(_.offset==null?1:_.offset),array$5(_.anchor||Anchors),_.avoidMarks||[],_.avoidBaseMark!==false,_.lineAnchor||"end",_.markIndex||0,_.padding===undefined?0:_.padding,_.method||"naive").forEach((l=>{const t=l.datum;t[as[0]]=l.x;t[as[1]]=l.y;t[as[2]]=l.opacity;t[as[3]]=l.align;t[as[4]]=l.baseline}));return pulse.reflow(mod).modifies(as)}});var label=Object.freeze({__proto__:null,label:Label$1});function partition(data,groupby){var groups=[],get=function(f){return f(t)},map,i,n,t,k,g;if(groupby==null){groups.push(data)}else{for(map={},i=0,n=data.length;i<n;++i){t=data[i];k=groupby.map(get);g=map[k];if(!g){map[k]=g=[];g.dims=k;groups.push(g)}g.push(t)}}return groups}function Loess(params){Transform.call(this,null,params)}Loess.Definition={type:"Loess",metadata:{generates:true},params:[{name:"x",type:"field",required:true},{name:"y",type:"field",required:true},{name:"groupby",type:"field",array:true},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:true}]};inherits(Loess,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){const source=pulse.materialize(pulse.SOURCE).source,groups=partition(source,_.groupby),names=(_.groupby||[]).map(accessorName),m=names.length,as=_.as||[accessorName(_.x),accessorName(_.y)],values=[];groups.forEach((g=>{loess(g,_.x,_.y,_.bandwidth||.3).forEach((p=>{const t={};for(let i=0;i<m;++i){t[names[i]]=g.dims[i]}t[as[0]]=p[0];t[as[1]]=p[1];values.push(ingest$1(t))}))}));if(this.value)out.rem=this.value;this.value=out.add=out.source=values}return out}});const Methods={constant:constant$4,linear:linear$2,log:log$3,exp:exp$1,pow:pow$3,quad:quad,poly:poly};const degreesOfFreedom=(method,order)=>method==="poly"?order:method==="quad"?2:1;function Regression(params){Transform.call(this,null,params)}Regression.Definition={type:"Regression",metadata:{generates:true},params:[{name:"x",type:"field",required:true},{name:"y",type:"field",required:true},{name:"groupby",type:"field",array:true},{name:"method",type:"string",default:"linear",values:Object.keys(Methods)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:true,length:2},{name:"params",type:"boolean",default:false},{name:"as",type:"string",array:true}]};inherits(Regression,Transform,{transform(_,pulse){const out=pulse.fork(pulse.NO_SOURCE|pulse.NO_FIELDS);if(!this.value||pulse.changed()||_.modified()){const source=pulse.materialize(pulse.SOURCE).source,groups=partition(source,_.groupby),names=(_.groupby||[]).map(accessorName),method=_.method||"linear",order=_.order==null?3:_.order,dof=degreesOfFreedom(method,order),as=_.as||[accessorName(_.x),accessorName(_.y)],fit=Methods[method],values=[];let domain=_.extent;if(!has$1(Methods,method)){error("Invalid regression method: "+method)}if(domain!=null){if(method==="log"&&domain[0]<=0){pulse.dataflow.warn("Ignoring extent with values <= 0 for log regression.");domain=null}}groups.forEach((g=>{const n=g.length;if(n<=dof){pulse.dataflow.warn("Skipping regression with more parameters than data points.");return}const model=fit(g,_.x,_.y,order);if(_.params){values.push(ingest$1({keys:g.dims,coef:model.coef,rSquared:model.rSquared}));return}const dom=domain||extent(g,_.x),add=p=>{const t={};for(let i=0;i<names.length;++i){t[names[i]]=g.dims[i]}t[as[0]]=p[0];t[as[1]]=p[1];values.push(ingest$1(t))};if(method==="linear"||method==="constant"){dom.forEach((x=>add([x,model.predict(x)])))}else{sampleCurve(model.predict,dom,25,200).forEach(add)}}));if(this.value)out.rem=this.value;this.value=out.add=out.source=values}return out}});var reg=Object.freeze({__proto__:null,loess:Loess,regression:Regression});const epsilon$1=11102230246251565e-32;const splitter=134217729;const resulterrbound=(3+8*epsilon$1)*epsilon$1;function sum(elen,e,flen,f,h){let Q,Qnew,hh,bvirt;let enow=e[0];let fnow=f[0];let eindex=0;let findex=0;if(fnow>enow===fnow>-enow){Q=enow;enow=e[++eindex]}else{Q=fnow;fnow=f[++findex]}let hindex=0;if(eindex<elen&&findex<flen){if(fnow>enow===fnow>-enow){Qnew=enow+Q;hh=Q-(Qnew-enow);enow=e[++eindex]}else{Qnew=fnow+Q;hh=Q-(Qnew-fnow);fnow=f[++findex]}Q=Qnew;if(hh!==0){h[hindex++]=hh}while(eindex<elen&&findex<flen){if(fnow>enow===fnow>-enow){Qnew=Q+enow;bvirt=Qnew-Q;hh=Q-(Qnew-bvirt)+(enow-bvirt);enow=e[++eindex]}else{Qnew=Q+fnow;bvirt=Qnew-Q;hh=Q-(Qnew-bvirt)+(fnow-bvirt);fnow=f[++findex]}Q=Qnew;if(hh!==0){h[hindex++]=hh}}}while(eindex<elen){Qnew=Q+enow;bvirt=Qnew-Q;hh=Q-(Qnew-bvirt)+(enow-bvirt);enow=e[++eindex];Q=Qnew;if(hh!==0){h[hindex++]=hh}}while(findex<flen){Qnew=Q+fnow;bvirt=Qnew-Q;hh=Q-(Qnew-bvirt)+(fnow-bvirt);fnow=f[++findex];Q=Qnew;if(hh!==0){h[hindex++]=hh}}if(Q!==0||hindex===0){h[hindex++]=Q}return hindex}function estimate(elen,e){let Q=e[0];for(let i=1;i<elen;i++)Q+=e[i];return Q}function vec(n){return new Float64Array(n)}const ccwerrboundA=(3+16*epsilon$1)*epsilon$1;const ccwerrboundB=(2+12*epsilon$1)*epsilon$1;const ccwerrboundC=(9+64*epsilon$1)*epsilon$1*epsilon$1;const B=vec(4);const C1=vec(8);const C2=vec(12);const D=vec(16);const u=vec(4);function orient2dadapt(ax,ay,bx,by,cx,cy,detsum){let acxtail,acytail,bcxtail,bcytail;let bvirt,c,ahi,alo,bhi,blo,_i,_j,_0,s1,s0,t1,t0,u3;const acx=ax-cx;const bcx=bx-cx;const acy=ay-cy;const bcy=by-cy;s1=acx*bcy;c=splitter*acx;ahi=c-(c-acx);alo=acx-ahi;c=splitter*bcy;bhi=c-(c-bcy);blo=bcy-bhi;s0=alo*blo-(s1-ahi*bhi-alo*bhi-ahi*blo);t1=acy*bcx;c=splitter*acy;ahi=c-(c-acy);alo=acy-ahi;c=splitter*bcx;bhi=c-(c-bcx);blo=bcx-bhi;t0=alo*blo-(t1-ahi*bhi-alo*bhi-ahi*blo);_i=s0-t0;bvirt=s0-_i;B[0]=s0-(_i+bvirt)+(bvirt-t0);_j=s1+_i;bvirt=_j-s1;_0=s1-(_j-bvirt)+(_i-bvirt);_i=_0-t1;bvirt=_0-_i;B[1]=_0-(_i+bvirt)+(bvirt-t1);u3=_j+_i;bvirt=u3-_j;B[2]=_j-(u3-bvirt)+(_i-bvirt);B[3]=u3;let det=estimate(4,B);let errbound=ccwerrboundB*detsum;if(det>=errbound||-det>=errbound){return det}bvirt=ax-acx;acxtail=ax-(acx+bvirt)+(bvirt-cx);bvirt=bx-bcx;bcxtail=bx-(bcx+bvirt)+(bvirt-cx);bvirt=ay-acy;acytail=ay-(acy+bvirt)+(bvirt-cy);bvirt=by-bcy;bcytail=by-(bcy+bvirt)+(bvirt-cy);if(acxtail===0&&acytail===0&&bcxtail===0&&bcytail===0){return det}errbound=ccwerrboundC*detsum+resulterrbound*Math.abs(det);det+=acx*bcytail+bcy*acxtail-(acy*bcxtail+bcx*acytail);if(det>=errbound||-det>=errbound)return det;s1=acxtail*bcy;c=splitter*acxtail;ahi=c-(c-acxtail);alo=acxtail-ahi;c=splitter*bcy;bhi=c-(c-bcy);blo=bcy-bhi;s0=alo*blo-(s1-ahi*bhi-alo*bhi-ahi*blo);t1=acytail*bcx;c=splitter*acytail;ahi=c-(c-acytail);alo=acytail-ahi;c=splitter*bcx;bhi=c-(c-bcx);blo=bcx-bhi;t0=alo*blo-(t1-ahi*bhi-alo*bhi-ahi*blo);_i=s0-t0;bvirt=s0-_i;u[0]=s0-(_i+bvirt)+(bvirt-t0);_j=s1+_i;bvirt=_j-s1;_0=s1-(_j-bvirt)+(_i-bvirt);_i=_0-t1;bvirt=_0-_i;u[1]=_0-(_i+bvirt)+(bvirt-t1);u3=_j+_i;bvirt=u3-_j;u[2]=_j-(u3-bvirt)+(_i-bvirt);u[3]=u3;const C1len=sum(4,B,4,u,C1);s1=acx*bcytail;c=splitter*acx;ahi=c-(c-acx);alo=acx-ahi;c=splitter*bcytail;bhi=c-(c-bcytail);blo=bcytail-bhi;s0=alo*blo-(s1-ahi*bhi-alo*bhi-ahi*blo);t1=acy*bcxtail;c=splitter*acy;ahi=c-(c-acy);alo=acy-ahi;c=splitter*bcxtail;bhi=c-(c-bcxtail);blo=bcxtail-bhi;t0=alo*blo-(t1-ahi*bhi-alo*bhi-ahi*blo);_i=s0-t0;bvirt=s0-_i;u[0]=s0-(_i+bvirt)+(bvirt-t0);_j=s1+_i;bvirt=_j-s1;_0=s1-(_j-bvirt)+(_i-bvirt);_i=_0-t1;bvirt=_0-_i;u[1]=_0-(_i+bvirt)+(bvirt-t1);u3=_j+_i;bvirt=u3-_j;u[2]=_j-(u3-bvirt)+(_i-bvirt);u[3]=u3;const C2len=sum(C1len,C1,4,u,C2);s1=acxtail*bcytail;c=splitter*acxtail;ahi=c-(c-acxtail);alo=acxtail-ahi;c=splitter*bcytail;bhi=c-(c-bcytail);blo=bcytail-bhi;s0=alo*blo-(s1-ahi*bhi-alo*bhi-ahi*blo);t1=acytail*bcxtail;c=splitter*acytail;ahi=c-(c-acytail);alo=acytail-ahi;c=splitter*bcxtail;bhi=c-(c-bcxtail);blo=bcxtail-bhi;t0=alo*blo-(t1-ahi*bhi-alo*bhi-ahi*blo);_i=s0-t0;bvirt=s0-_i;u[0]=s0-(_i+bvirt)+(bvirt-t0);_j=s1+_i;bvirt=_j-s1;_0=s1-(_j-bvirt)+(_i-bvirt);_i=_0-t1;bvirt=_0-_i;u[1]=_0-(_i+bvirt)+(bvirt-t1);u3=_j+_i;bvirt=u3-_j;u[2]=_j-(u3-bvirt)+(_i-bvirt);u[3]=u3;const Dlen=sum(C2len,C2,4,u,D);return D[Dlen-1]}function orient2d(ax,ay,bx,by,cx,cy){const detleft=(ay-cy)*(bx-cx);const detright=(ax-cx)*(by-cy);const det=detleft-detright;const detsum=Math.abs(detleft+detright);if(Math.abs(det)>=ccwerrboundA*detsum)return det;return-orient2dadapt(ax,ay,bx,by,cx,cy,detsum)}const EPSILON=Math.pow(2,-52);const EDGE_STACK=new Uint32Array(512);class Delaunator{static from(points,getX=defaultGetX,getY=defaultGetY){const n=points.length;const coords=new Float64Array(n*2);for(let i=0;i<n;i++){const p=points[i];coords[2*i]=getX(p);coords[2*i+1]=getY(p)}return new Delaunator(coords)}constructor(coords){const n=coords.length>>1;if(n>0&&typeof coords[0]!=="number")throw new Error("Expected coords to contain numbers.");this.coords=coords;const maxTriangles=Math.max(2*n-5,0);this._triangles=new Uint32Array(maxTriangles*3);this._halfedges=new Int32Array(maxTriangles*3);this._hashSize=Math.ceil(Math.sqrt(n));this._hullPrev=new Uint32Array(n);this._hullNext=new Uint32Array(n);this._hullTri=new Uint32Array(n);this._hullHash=new Int32Array(this._hashSize);this._ids=new Uint32Array(n);this._dists=new Float64Array(n);this.update()}update(){const{coords:coords,_hullPrev:hullPrev,_hullNext:hullNext,_hullTri:hullTri,_hullHash:hullHash}=this;const n=coords.length>>1;let minX=Infinity;let minY=Infinity;let maxX=-Infinity;let maxY=-Infinity;for(let i=0;i<n;i++){const x=coords[2*i];const y=coords[2*i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;this._ids[i]=i}const cx=(minX+maxX)/2;const cy=(minY+maxY)/2;let i0,i1,i2;for(let i=0,minDist=Infinity;i<n;i++){const d=dist(cx,cy,coords[2*i],coords[2*i+1]);if(d<minDist){i0=i;minDist=d}}const i0x=coords[2*i0];const i0y=coords[2*i0+1];for(let i=0,minDist=Infinity;i<n;i++){if(i===i0)continue;const d=dist(i0x,i0y,coords[2*i],coords[2*i+1]);if(d<minDist&&d>0){i1=i;minDist=d}}let i1x=coords[2*i1];let i1y=coords[2*i1+1];let minRadius=Infinity;for(let i=0;i<n;i++){if(i===i0||i===i1)continue;const r=circumradius(i0x,i0y,i1x,i1y,coords[2*i],coords[2*i+1]);if(r<minRadius){i2=i;minRadius=r}}let i2x=coords[2*i2];let i2y=coords[2*i2+1];if(minRadius===Infinity){for(let i=0;i<n;i++){this._dists[i]=coords[2*i]-coords[0]||coords[2*i+1]-coords[1]}quicksort(this._ids,this._dists,0,n-1);const hull=new Uint32Array(n);let j=0;for(let i=0,d0=-Infinity;i<n;i++){const id=this._ids[i];const d=this._dists[id];if(d>d0){hull[j++]=id;d0=d}}this.hull=hull.subarray(0,j);this.triangles=new Uint32Array(0);this.halfedges=new Uint32Array(0);return}if(orient2d(i0x,i0y,i1x,i1y,i2x,i2y)<0){const i=i1;const x=i1x;const y=i1y;i1=i2;i1x=i2x;i1y=i2y;i2=i;i2x=x;i2y=y}const center=circumcenter(i0x,i0y,i1x,i1y,i2x,i2y);this._cx=center.x;this._cy=center.y;for(let i=0;i<n;i++){this._dists[i]=dist(coords[2*i],coords[2*i+1],center.x,center.y)}quicksort(this._ids,this._dists,0,n-1);this._hullStart=i0;let hullSize=3;hullNext[i0]=hullPrev[i2]=i1;hullNext[i1]=hullPrev[i0]=i2;hullNext[i2]=hullPrev[i1]=i0;hullTri[i0]=0;hullTri[i1]=1;hullTri[i2]=2;hullHash.fill(-1);hullHash[this._hashKey(i0x,i0y)]=i0;hullHash[this._hashKey(i1x,i1y)]=i1;hullHash[this._hashKey(i2x,i2y)]=i2;this.trianglesLen=0;this._addTriangle(i0,i1,i2,-1,-1,-1);for(let k=0,xp,yp;k<this._ids.length;k++){const i=this._ids[k];const x=coords[2*i];const y=coords[2*i+1];if(k>0&&Math.abs(x-xp)<=EPSILON&&Math.abs(y-yp)<=EPSILON)continue;xp=x;yp=y;if(i===i0||i===i1||i===i2)continue;let start=0;for(let j=0,key=this._hashKey(x,y);j<this._hashSize;j++){start=hullHash[(key+j)%this._hashSize];if(start!==-1&&start!==hullNext[start])break}start=hullPrev[start];let e=start,q;while(q=hullNext[e],orient2d(x,y,coords[2*e],coords[2*e+1],coords[2*q],coords[2*q+1])>=0){e=q;if(e===start){e=-1;break}}if(e===-1)continue;let t=this._addTriangle(e,i,hullNext[e],-1,-1,hullTri[e]);hullTri[i]=this._legalize(t+2);hullTri[e]=t;hullSize++;let n=hullNext[e];while(q=hullNext[n],orient2d(x,y,coords[2*n],coords[2*n+1],coords[2*q],coords[2*q+1])<0){t=this._addTriangle(n,i,q,hullTri[i],-1,hullTri[n]);hullTri[i]=this._legalize(t+2);hullNext[n]=n;hullSize--;n=q}if(e===start){while(q=hullPrev[e],orient2d(x,y,coords[2*q],coords[2*q+1],coords[2*e],coords[2*e+1])<0){t=this._addTriangle(q,i,e,-1,hullTri[e],hullTri[q]);this._legalize(t+2);hullTri[q]=t;hullNext[e]=e;hullSize--;e=q}}this._hullStart=hullPrev[i]=e;hullNext[e]=hullPrev[n]=i;hullNext[i]=n;hullHash[this._hashKey(x,y)]=i;hullHash[this._hashKey(coords[2*e],coords[2*e+1])]=e}this.hull=new Uint32Array(hullSize);for(let i=0,e=this._hullStart;i<hullSize;i++){this.hull[i]=e;e=hullNext[e]}this.triangles=this._triangles.subarray(0,this.trianglesLen);this.halfedges=this._halfedges.subarray(0,this.trianglesLen)}_hashKey(x,y){return Math.floor(pseudoAngle(x-this._cx,y-this._cy)*this._hashSize)%this._hashSize}_legalize(a){const{_triangles:triangles,_halfedges:halfedges,coords:coords}=this;let i=0;let ar=0;while(true){const b=halfedges[a];const a0=a-a%3;ar=a0+(a+2)%3;if(b===-1){if(i===0)break;a=EDGE_STACK[--i];continue}const b0=b-b%3;const al=a0+(a+1)%3;const bl=b0+(b+2)%3;const p0=triangles[ar];const pr=triangles[a];const pl=triangles[al];const p1=triangles[bl];const illegal=inCircle(coords[2*p0],coords[2*p0+1],coords[2*pr],coords[2*pr+1],coords[2*pl],coords[2*pl+1],coords[2*p1],coords[2*p1+1]);if(illegal){triangles[a]=p1;triangles[b]=p0;const hbl=halfedges[bl];if(hbl===-1){let e=this._hullStart;do{if(this._hullTri[e]===bl){this._hullTri[e]=a;break}e=this._hullPrev[e]}while(e!==this._hullStart)}this._link(a,hbl);this._link(b,halfedges[ar]);this._link(ar,bl);const br=b0+(b+1)%3;if(i<EDGE_STACK.length){EDGE_STACK[i++]=br}}else{if(i===0)break;a=EDGE_STACK[--i]}}return ar}_link(a,b){this._halfedges[a]=b;if(b!==-1)this._halfedges[b]=a}_addTriangle(i0,i1,i2,a,b,c){const t=this.trianglesLen;this._triangles[t]=i0;this._triangles[t+1]=i1;this._triangles[t+2]=i2;this._link(t,a);this._link(t+1,b);this._link(t+2,c);this.trianglesLen+=3;return t}}function pseudoAngle(dx,dy){const p=dx/(Math.abs(dx)+Math.abs(dy));return(dy>0?3-p:1+p)/4}function dist(ax,ay,bx,by){const dx=ax-bx;const dy=ay-by;return dx*dx+dy*dy}function inCircle(ax,ay,bx,by,cx,cy,px,py){const dx=ax-px;const dy=ay-py;const ex=bx-px;const ey=by-py;const fx=cx-px;const fy=cy-py;const ap=dx*dx+dy*dy;const bp=ex*ex+ey*ey;const cp=fx*fx+fy*fy;return dx*(ey*cp-bp*fy)-dy*(ex*cp-bp*fx)+ap*(ex*fy-ey*fx)<0}function circumradius(ax,ay,bx,by,cx,cy){const dx=bx-ax;const dy=by-ay;const ex=cx-ax;const ey=cy-ay;const bl=dx*dx+dy*dy;const cl=ex*ex+ey*ey;const d=.5/(dx*ey-dy*ex);const x=(ey*bl-dy*cl)*d;const y=(dx*cl-ex*bl)*d;return x*x+y*y}function circumcenter(ax,ay,bx,by,cx,cy){const dx=bx-ax;const dy=by-ay;const ex=cx-ax;const ey=cy-ay;const bl=dx*dx+dy*dy;const cl=ex*ex+ey*ey;const d=.5/(dx*ey-dy*ex);const x=ax+(ey*bl-dy*cl)*d;const y=ay+(dx*cl-ex*bl)*d;return{x:x,y:y}}function quicksort(ids,dists,left,right){if(right-left<=20){for(let i=left+1;i<=right;i++){const temp=ids[i];const tempDist=dists[temp];let j=i-1;while(j>=left&&dists[ids[j]]>tempDist)ids[j+1]=ids[j--];ids[j+1]=temp}}else{const median=left+right>>1;let i=left+1;let j=right;swap(ids,median,i);if(dists[ids[left]]>dists[ids[right]])swap(ids,left,right);if(dists[ids[i]]>dists[ids[right]])swap(ids,i,right);if(dists[ids[left]]>dists[ids[i]])swap(ids,left,i);const temp=ids[i];const tempDist=dists[temp];while(true){do{i++}while(dists[ids[i]]<tempDist);do{j--}while(dists[ids[j]]>tempDist);if(j<i)break;swap(ids,i,j)}ids[left+1]=ids[j];ids[j]=temp;if(right-i+1>=j-left){quicksort(ids,dists,i,right);quicksort(ids,dists,left,j-1)}else{quicksort(ids,dists,left,j-1);quicksort(ids,dists,i,right)}}}function swap(arr,i,j){const tmp=arr[i];arr[i]=arr[j];arr[j]=tmp}function defaultGetX(p){return p[0]}function defaultGetY(p){return p[1]}const epsilon=1e-6;class Path{constructor(){this._x0=this._y0=this._x1=this._y1=null;this._=""}moveTo(x,y){this._+=`M${this._x0=this._x1=+x},${this._y0=this._y1=+y}`}closePath(){if(this._x1!==null){this._x1=this._x0,this._y1=this._y0;this._+="Z"}}lineTo(x,y){this._+=`L${this._x1=+x},${this._y1=+y}`}arc(x,y,r){x=+x,y=+y,r=+r;const x0=x+r;const y0=y;if(r<0)throw new Error("negative radius");if(this._x1===null)this._+=`M${x0},${y0}`;else if(Math.abs(this._x1-x0)>epsilon||Math.abs(this._y1-y0)>epsilon)this._+="L"+x0+","+y0;if(!r)return;this._+=`A${r},${r},0,1,1,${x-r},${y}A${r},${r},0,1,1,${this._x1=x0},${this._y1=y0}`}rect(x,y,w,h){this._+=`M${this._x0=this._x1=+x},${this._y0=this._y1=+y}h${+w}v${+h}h${-w}Z`}value(){return this._||null}}class Polygon{constructor(){this._=[]}moveTo(x,y){this._.push([x,y])}closePath(){this._.push(this._[0].slice())}lineTo(x,y){this._.push([x,y])}value(){return this._.length?this._:null}}let Voronoi$1=class Voronoi{constructor(delaunay,[xmin,ymin,xmax,ymax]=[0,0,960,500]){if(!((xmax=+xmax)>=(xmin=+xmin))||!((ymax=+ymax)>=(ymin=+ymin)))throw new Error("invalid bounds");this.delaunay=delaunay;this._circumcenters=new Float64Array(delaunay.points.length*2);this.vectors=new Float64Array(delaunay.points.length*2);this.xmax=xmax,this.xmin=xmin;this.ymax=ymax,this.ymin=ymin;this._init()}update(){this.delaunay.update();this._init();return this}_init(){const{delaunay:{points:points,hull:hull,triangles:triangles},vectors:vectors}=this;let bx,by;const circumcenters=this.circumcenters=this._circumcenters.subarray(0,triangles.length/3*2);for(let i=0,j=0,n=triangles.length,x,y;i<n;i+=3,j+=2){const t1=triangles[i]*2;const t2=triangles[i+1]*2;const t3=triangles[i+2]*2;const x1=points[t1];const y1=points[t1+1];const x2=points[t2];const y2=points[t2+1];const x3=points[t3];const y3=points[t3+1];const dx=x2-x1;const dy=y2-y1;const ex=x3-x1;const ey=y3-y1;const ab=(dx*ey-dy*ex)*2;if(Math.abs(ab)<1e-9){if(bx===undefined){bx=by=0;for(const i of hull)bx+=points[i*2],by+=points[i*2+1];bx/=hull.length,by/=hull.length}const a=1e9*Math.sign((bx-x1)*ey-(by-y1)*ex);x=(x1+x3)/2-a*ey;y=(y1+y3)/2+a*ex}else{const d=1/ab;const bl=dx*dx+dy*dy;const cl=ex*ex+ey*ey;x=x1+(ey*bl-dy*cl)*d;y=y1+(dx*cl-ex*bl)*d}circumcenters[j]=x;circumcenters[j+1]=y}let h=hull[hull.length-1];let p0,p1=h*4;let x0,x1=points[2*h];let y0,y1=points[2*h+1];vectors.fill(0);for(let i=0;i<hull.length;++i){h=hull[i];p0=p1,x0=x1,y0=y1;p1=h*4,x1=points[2*h],y1=points[2*h+1];vectors[p0+2]=vectors[p1]=y0-y1;vectors[p0+3]=vectors[p1+1]=x1-x0}}render(context){const buffer=context==null?context=new Path:undefined;const{delaunay:{halfedges:halfedges,inedges:inedges,hull:hull},circumcenters:circumcenters,vectors:vectors}=this;if(hull.length<=1)return null;for(let i=0,n=halfedges.length;i<n;++i){const j=halfedges[i];if(j<i)continue;const ti=Math.floor(i/3)*2;const tj=Math.floor(j/3)*2;const xi=circumcenters[ti];const yi=circumcenters[ti+1];const xj=circumcenters[tj];const yj=circumcenters[tj+1];this._renderSegment(xi,yi,xj,yj,context)}let h0,h1=hull[hull.length-1];for(let i=0;i<hull.length;++i){h0=h1,h1=hull[i];const t=Math.floor(inedges[h1]/3)*2;const x=circumcenters[t];const y=circumcenters[t+1];const v=h0*4;const p=this._project(x,y,vectors[v+2],vectors[v+3]);if(p)this._renderSegment(x,y,p[0],p[1],context)}return buffer&&buffer.value()}renderBounds(context){const buffer=context==null?context=new Path:undefined;context.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin);return buffer&&buffer.value()}renderCell(i,context){const buffer=context==null?context=new Path:undefined;const points=this._clip(i);if(points===null||!points.length)return;context.moveTo(points[0],points[1]);let n=points.length;while(points[0]===points[n-2]&&points[1]===points[n-1]&&n>1)n-=2;for(let i=2;i<n;i+=2){if(points[i]!==points[i-2]||points[i+1]!==points[i-1])context.lineTo(points[i],points[i+1])}context.closePath();return buffer&&buffer.value()}*cellPolygons(){const{delaunay:{points:points}}=this;for(let i=0,n=points.length/2;i<n;++i){const cell=this.cellPolygon(i);if(cell)cell.index=i,yield cell}}cellPolygon(i){const polygon=new Polygon;this.renderCell(i,polygon);return polygon.value()}_renderSegment(x0,y0,x1,y1,context){let S;const c0=this._regioncode(x0,y0);const c1=this._regioncode(x1,y1);if(c0===0&&c1===0){context.moveTo(x0,y0);context.lineTo(x1,y1)}else if(S=this._clipSegment(x0,y0,x1,y1,c0,c1)){context.moveTo(S[0],S[1]);context.lineTo(S[2],S[3])}}contains(i,x,y){if((x=+x,x!==x)||(y=+y,y!==y))return false;return this.delaunay._step(i,x,y)===i}*neighbors(i){const ci=this._clip(i);if(ci)for(const j of this.delaunay.neighbors(i)){const cj=this._clip(j);if(cj)loop:for(let ai=0,li=ci.length;ai<li;ai+=2){for(let aj=0,lj=cj.length;aj<lj;aj+=2){if(ci[ai]===cj[aj]&&ci[ai+1]===cj[aj+1]&&ci[(ai+2)%li]===cj[(aj+lj-2)%lj]&&ci[(ai+3)%li]===cj[(aj+lj-1)%lj]){yield j;break loop}}}}}_cell(i){const{circumcenters:circumcenters,delaunay:{inedges:inedges,halfedges:halfedges,triangles:triangles}}=this;const e0=inedges[i];if(e0===-1)return null;const points=[];let e=e0;do{const t=Math.floor(e/3);points.push(circumcenters[t*2],circumcenters[t*2+1]);e=e%3===2?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e]}while(e!==e0&&e!==-1);return points}_clip(i){if(i===0&&this.delaunay.hull.length===1){return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin]}const points=this._cell(i);if(points===null)return null;const{vectors:V}=this;const v=i*4;return this._simplify(V[v]||V[v+1]?this._clipInfinite(i,points,V[v],V[v+1],V[v+2],V[v+3]):this._clipFinite(i,points))}_clipFinite(i,points){const n=points.length;let P=null;let x0,y0,x1=points[n-2],y1=points[n-1];let c0,c1=this._regioncode(x1,y1);let e0,e1=0;for(let j=0;j<n;j+=2){x0=x1,y0=y1,x1=points[j],y1=points[j+1];c0=c1,c1=this._regioncode(x1,y1);if(c0===0&&c1===0){e0=e1,e1=0;if(P)P.push(x1,y1);else P=[x1,y1]}else{let S,sx0,sy0,sx1,sy1;if(c0===0){if((S=this._clipSegment(x0,y0,x1,y1,c0,c1))===null)continue;[sx0,sy0,sx1,sy1]=S}else{if((S=this._clipSegment(x1,y1,x0,y0,c1,c0))===null)continue;[sx1,sy1,sx0,sy0]=S;e0=e1,e1=this._edgecode(sx0,sy0);if(e0&&e1)this._edge(i,e0,e1,P,P.length);if(P)P.push(sx0,sy0);else P=[sx0,sy0]}e0=e1,e1=this._edgecode(sx1,sy1);if(e0&&e1)this._edge(i,e0,e1,P,P.length);if(P)P.push(sx1,sy1);else P=[sx1,sy1]}}if(P){e0=e1,e1=this._edgecode(P[0],P[1]);if(e0&&e1)this._edge(i,e0,e1,P,P.length)}else if(this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)){return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin]}return P}_clipSegment(x0,y0,x1,y1,c0,c1){const flip=c0<c1;if(flip)[x0,y0,x1,y1,c0,c1]=[x1,y1,x0,y0,c1,c0];while(true){if(c0===0&&c1===0)return flip?[x1,y1,x0,y0]:[x0,y0,x1,y1];if(c0&c1)return null;let x,y,c=c0||c1;if(c&8)x=x0+(x1-x0)*(this.ymax-y0)/(y1-y0),y=this.ymax;else if(c&4)x=x0+(x1-x0)*(this.ymin-y0)/(y1-y0),y=this.ymin;else if(c&2)y=y0+(y1-y0)*(this.xmax-x0)/(x1-x0),x=this.xmax;else y=y0+(y1-y0)*(this.xmin-x0)/(x1-x0),x=this.xmin;if(c0)x0=x,y0=y,c0=this._regioncode(x0,y0);else x1=x,y1=y,c1=this._regioncode(x1,y1)}}_clipInfinite(i,points,vx0,vy0,vxn,vyn){let P=Array.from(points),p;if(p=this._project(P[0],P[1],vx0,vy0))P.unshift(p[0],p[1]);if(p=this._project(P[P.length-2],P[P.length-1],vxn,vyn))P.push(p[0],p[1]);if(P=this._clipFinite(i,P)){for(let j=0,n=P.length,c0,c1=this._edgecode(P[n-2],P[n-1]);j<n;j+=2){c0=c1,c1=this._edgecode(P[j],P[j+1]);if(c0&&c1)j=this._edge(i,c0,c1,P,j),n=P.length}}else if(this.contains(i,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)){P=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]}return P}_edge(i,e0,e1,P,j){while(e0!==e1){let x,y;switch(e0){case 5:e0=4;continue;case 4:e0=6,x=this.xmax,y=this.ymin;break;case 6:e0=2;continue;case 2:e0=10,x=this.xmax,y=this.ymax;break;case 10:e0=8;continue;case 8:e0=9,x=this.xmin,y=this.ymax;break;case 9:e0=1;continue;case 1:e0=5,x=this.xmin,y=this.ymin;break}if((P[j]!==x||P[j+1]!==y)&&this.contains(i,x,y)){P.splice(j,0,x,y),j+=2}}return j}_project(x0,y0,vx,vy){let t=Infinity,c,x,y;if(vy<0){if(y0<=this.ymin)return null;if((c=(this.ymin-y0)/vy)<t)y=this.ymin,x=x0+(t=c)*vx}else if(vy>0){if(y0>=this.ymax)return null;if((c=(this.ymax-y0)/vy)<t)y=this.ymax,x=x0+(t=c)*vx}if(vx>0){if(x0>=this.xmax)return null;if((c=(this.xmax-x0)/vx)<t)x=this.xmax,y=y0+(t=c)*vy}else if(vx<0){if(x0<=this.xmin)return null;if((c=(this.xmin-x0)/vx)<t)x=this.xmin,y=y0+(t=c)*vy}return[x,y]}_edgecode(x,y){return(x===this.xmin?1:x===this.xmax?2:0)|(y===this.ymin?4:y===this.ymax?8:0)}_regioncode(x,y){return(x<this.xmin?1:x>this.xmax?2:0)|(y<this.ymin?4:y>this.ymax?8:0)}_simplify(P){if(P&&P.length>4){for(let i=0;i<P.length;i+=2){const j=(i+2)%P.length,k=(i+4)%P.length;if(P[i]===P[j]&&P[j]===P[k]||P[i+1]===P[j+1]&&P[j+1]===P[k+1]){P.splice(j,2),i-=2}}if(!P.length)P=null}return P}};const tau=2*Math.PI,pow=Math.pow;function pointX(p){return p[0]}function pointY(p){return p[1]}function collinear(d){const{triangles:triangles,coords:coords}=d;for(let i=0;i<triangles.length;i+=3){const a=2*triangles[i],b=2*triangles[i+1],c=2*triangles[i+2],cross=(coords[c]-coords[a])*(coords[b+1]-coords[a+1])-(coords[b]-coords[a])*(coords[c+1]-coords[a+1]);if(cross>1e-10)return false}return true}function jitter(x,y,r){return[x+Math.sin(x+y)*r,y+Math.cos(x-y)*r]}class Delaunay{static from(points,fx=pointX,fy=pointY,that){return new Delaunay("length"in points?flatArray(points,fx,fy,that):Float64Array.from(flatIterable(points,fx,fy,that)))}constructor(points){this._delaunator=new Delaunator(points);this.inedges=new Int32Array(points.length/2);this._hullIndex=new Int32Array(points.length/2);this.points=this._delaunator.coords;this._init()}update(){this._delaunator.update();this._init();return this}_init(){const d=this._delaunator,points=this.points;if(d.hull&&d.hull.length>2&&collinear(d)){this.collinear=Int32Array.from({length:points.length/2},((_,i)=>i)).sort(((i,j)=>points[2*i]-points[2*j]||points[2*i+1]-points[2*j+1]));const e=this.collinear[0],f=this.collinear[this.collinear.length-1],bounds=[points[2*e],points[2*e+1],points[2*f],points[2*f+1]],r=1e-8*Math.hypot(bounds[3]-bounds[1],bounds[2]-bounds[0]);for(let i=0,n=points.length/2;i<n;++i){const p=jitter(points[2*i],points[2*i+1],r);points[2*i]=p[0];points[2*i+1]=p[1]}this._delaunator=new Delaunator(points)}else{delete this.collinear}const halfedges=this.halfedges=this._delaunator.halfedges;const hull=this.hull=this._delaunator.hull;const triangles=this.triangles=this._delaunator.triangles;const inedges=this.inedges.fill(-1);const hullIndex=this._hullIndex.fill(-1);for(let e=0,n=halfedges.length;e<n;++e){const p=triangles[e%3===2?e-2:e+1];if(halfedges[e]===-1||inedges[p]===-1)inedges[p]=e}for(let i=0,n=hull.length;i<n;++i){hullIndex[hull[i]]=i}if(hull.length<=2&&hull.length>0){this.triangles=new Int32Array(3).fill(-1);this.halfedges=new Int32Array(3).fill(-1);this.triangles[0]=hull[0];inedges[hull[0]]=1;if(hull.length===2){inedges[hull[1]]=0;this.triangles[1]=hull[1];this.triangles[2]=hull[1]}}}voronoi(bounds){return new Voronoi$1(this,bounds)}*neighbors(i){const{inedges:inedges,hull:hull,_hullIndex:_hullIndex,halfedges:halfedges,triangles:triangles,collinear:collinear}=this;if(collinear){const l=collinear.indexOf(i);if(l>0)yield collinear[l-1];if(l<collinear.length-1)yield collinear[l+1];return}const e0=inedges[i];if(e0===-1)return;let e=e0,p0=-1;do{yield p0=triangles[e];e=e%3===2?e-2:e+1;if(triangles[e]!==i)return;e=halfedges[e];if(e===-1){const p=hull[(_hullIndex[i]+1)%hull.length];if(p!==p0)yield p;return}}while(e!==e0)}find(x,y,i=0){if((x=+x,x!==x)||(y=+y,y!==y))return-1;const i0=i;let c;while((c=this._step(i,x,y))>=0&&c!==i&&c!==i0)i=c;return c}_step(i,x,y){const{inedges:inedges,hull:hull,_hullIndex:_hullIndex,halfedges:halfedges,triangles:triangles,points:points}=this;if(inedges[i]===-1||!points.length)return(i+1)%(points.length>>1);let c=i;let dc=pow(x-points[i*2],2)+pow(y-points[i*2+1],2);const e0=inedges[i];let e=e0;do{let t=triangles[e];const dt=pow(x-points[t*2],2)+pow(y-points[t*2+1],2);if(dt<dc)dc=dt,c=t;e=e%3===2?e-2:e+1;if(triangles[e]!==i)break;e=halfedges[e];if(e===-1){e=hull[(_hullIndex[i]+1)%hull.length];if(e!==t){if(pow(x-points[e*2],2)+pow(y-points[e*2+1],2)<dc)return e}break}}while(e!==e0);return c}render(context){const buffer=context==null?context=new Path:undefined;const{points:points,halfedges:halfedges,triangles:triangles}=this;for(let i=0,n=halfedges.length;i<n;++i){const j=halfedges[i];if(j<i)continue;const ti=triangles[i]*2;const tj=triangles[j]*2;context.moveTo(points[ti],points[ti+1]);context.lineTo(points[tj],points[tj+1])}this.renderHull(context);return buffer&&buffer.value()}renderPoints(context,r){if(r===undefined&&(!context||typeof context.moveTo!=="function"))r=context,context=null;r=r==undefined?2:+r;const buffer=context==null?context=new Path:undefined;const{points:points}=this;for(let i=0,n=points.length;i<n;i+=2){const x=points[i],y=points[i+1];context.moveTo(x+r,y);context.arc(x,y,r,0,tau)}return buffer&&buffer.value()}renderHull(context){const buffer=context==null?context=new Path:undefined;const{hull:hull,points:points}=this;const h=hull[0]*2,n=hull.length;context.moveTo(points[h],points[h+1]);for(let i=1;i<n;++i){const h=2*hull[i];context.lineTo(points[h],points[h+1])}context.closePath();return buffer&&buffer.value()}hullPolygon(){const polygon=new Polygon;this.renderHull(polygon);return polygon.value()}renderTriangle(i,context){const buffer=context==null?context=new Path:undefined;const{points:points,triangles:triangles}=this;const t0=triangles[i*=3]*2;const t1=triangles[i+1]*2;const t2=triangles[i+2]*2;context.moveTo(points[t0],points[t0+1]);context.lineTo(points[t1],points[t1+1]);context.lineTo(points[t2],points[t2+1]);context.closePath();return buffer&&buffer.value()}*trianglePolygons(){const{triangles:triangles}=this;for(let i=0,n=triangles.length/3;i<n;++i){yield this.trianglePolygon(i)}}trianglePolygon(i){const polygon=new Polygon;this.renderTriangle(i,polygon);return polygon.value()}}function flatArray(points,fx,fy,that){const n=points.length;const array=new Float64Array(n*2);for(let i=0;i<n;++i){const p=points[i];array[i*2]=fx.call(that,p,i,points);array[i*2+1]=fy.call(that,p,i,points)}return array}function*flatIterable(points,fx,fy,that){let i=0;for(const p of points){yield fx.call(that,p,i,points);yield fy.call(that,p,i,points);++i}}function Voronoi(params){Transform.call(this,null,params)}Voronoi.Definition={type:"Voronoi",metadata:{modifies:true},params:[{name:"x",type:"field",required:true},{name:"y",type:"field",required:true},{name:"size",type:"number",array:true,length:2},{name:"extent",type:"array",array:true,length:2,default:[[-1e5,-1e5],[1e5,1e5]],content:{type:"number",array:true,length:2}},{name:"as",type:"string",default:"path"}]};const defaultExtent=[-1e5,-1e5,1e5,1e5];inherits(Voronoi,Transform,{transform(_,pulse){const as=_.as||"path",data=pulse.source;if(!data||!data.length)return pulse;let s=_.size;s=s?[0,0,s[0],s[1]]:(s=_.extent)?[s[0][0],s[0][1],s[1][0],s[1][1]]:defaultExtent;const voronoi=this.value=Delaunay.from(data,_.x,_.y).voronoi(s);for(let i=0,n=data.length;i<n;++i){const polygon=voronoi.cellPolygon(i);data[i][as]=polygon&&!isPoint(polygon)?toPathString(polygon):null}return pulse.reflow(_.modified()).modifies(as)}});function toPathString(p){const x=p[0][0],y=p[0][1];let n=p.length-1;for(;p[n][0]===x&&p[n][1]===y;--n);return"M"+p.slice(0,n+1).join("L")+"Z"}function isPoint(p){return p.length===2&&p[0][0]===p[1][0]&&p[0][1]===p[1][1]}var voronoi=Object.freeze({__proto__:null,voronoi:Voronoi});var cloudRadians=Math.PI/180,cw=1<<11>>5,ch=1<<11;function cloud(){var size=[256,256],text,font,fontSize,fontStyle,fontWeight,rotate,padding,spiral=archimedeanSpiral,words=[],random=Math.random,cloud={};cloud.layout=function(){var contextAndRatio=getContext(canvas()),board=zeroArray((size[0]>>5)*size[1]),bounds=null,n=words.length,i=-1,tags=[],data=words.map((d=>({text:text(d),font:font(d),style:fontStyle(d),weight:fontWeight(d),rotate:rotate(d),size:~~(fontSize(d)+1e-14),padding:padding(d),xoff:0,yoff:0,x1:0,y1:0,x0:0,y0:0,hasText:false,sprite:null,datum:d}))).sort(((a,b)=>b.size-a.size));while(++i<n){var d=data[i];d.x=size[0]*(random()+.5)>>1;d.y=size[1]*(random()+.5)>>1;cloudSprite(contextAndRatio,d,data,i);if(d.hasText&&place(board,d,bounds)){tags.push(d);if(bounds)cloudBounds(bounds,d);else bounds=[{x:d.x+d.x0,y:d.y+d.y0},{x:d.x+d.x1,y:d.y+d.y1}];d.x-=size[0]>>1;d.y-=size[1]>>1}}return tags};function getContext(canvas){canvas.width=canvas.height=1;var ratio=Math.sqrt(canvas.getContext("2d").getImageData(0,0,1,1).data.length>>2);canvas.width=(cw<<5)/ratio;canvas.height=ch/ratio;var context=canvas.getContext("2d");context.fillStyle=context.strokeStyle="red";context.textAlign="center";return{context:context,ratio:ratio}}function place(board,tag,bounds){var startX=tag.x,startY=tag.y,maxDelta=Math.hypot(size[0],size[1]),s=spiral(size),dt=random()<.5?1:-1,t=-dt,dxdy,dx,dy;while(dxdy=s(t+=dt)){dx=~~dxdy[0];dy=~~dxdy[1];if(Math.min(Math.abs(dx),Math.abs(dy))>=maxDelta)break;tag.x=startX+dx;tag.y=startY+dy;if(tag.x+tag.x0<0||tag.y+tag.y0<0||tag.x+tag.x1>size[0]||tag.y+tag.y1>size[1])continue;if(!bounds||!cloudCollide(tag,board,size[0])){if(!bounds||collideRects(tag,bounds)){var sprite=tag.sprite,w=tag.width>>5,sw=size[0]>>5,lx=tag.x-(w<<4),sx=lx&127,msx=32-sx,h=tag.y1-tag.y0,x=(tag.y+tag.y0)*sw+(lx>>5),last;for(var j=0;j<h;j++){last=0;for(var i=0;i<=w;i++){board[x+i]|=last<<msx|(i<w?(last=sprite[j*w+i])>>>sx:0)}x+=sw}tag.sprite=null;return true}}}return false}cloud.words=function(_){if(arguments.length){words=_;return cloud}else{return words}};cloud.size=function(_){if(arguments.length){size=[+_[0],+_[1]];return cloud}else{return size}};cloud.font=function(_){if(arguments.length){font=functor(_);return cloud}else{return font}};cloud.fontStyle=function(_){if(arguments.length){fontStyle=functor(_);return cloud}else{return fontStyle}};cloud.fontWeight=function(_){if(arguments.length){fontWeight=functor(_);return cloud}else{return fontWeight}};cloud.rotate=function(_){if(arguments.length){rotate=functor(_);return cloud}else{return rotate}};cloud.text=function(_){if(arguments.length){text=functor(_);return cloud}else{return text}};cloud.spiral=function(_){if(arguments.length){spiral=spirals[_]||_;return cloud}else{return spiral}};cloud.fontSize=function(_){if(arguments.length){fontSize=functor(_);return cloud}else{return fontSize}};cloud.padding=function(_){if(arguments.length){padding=functor(_);return cloud}else{return padding}};cloud.random=function(_){if(arguments.length){random=_;return cloud}else{return random}};return cloud}function cloudSprite(contextAndRatio,d,data,di){if(d.sprite)return;var c=contextAndRatio.context,ratio=contextAndRatio.ratio;c.clearRect(0,0,(cw<<5)/ratio,ch/ratio);var x=0,y=0,maxh=0,n=data.length,w,w32,h,i,j;--di;while(++di<n){d=data[di];c.save();c.font=d.style+" "+d.weight+" "+~~((d.size+1)/ratio)+"px "+d.font;w=c.measureText(d.text+"m").width*ratio;h=d.size<<1;if(d.rotate){var sr=Math.sin(d.rotate*cloudRadians),cr=Math.cos(d.rotate*cloudRadians),wcr=w*cr,wsr=w*sr,hcr=h*cr,hsr=h*sr;w=Math.max(Math.abs(wcr+hsr),Math.abs(wcr-hsr))+31>>5<<5;h=~~Math.max(Math.abs(wsr+hcr),Math.abs(wsr-hcr))}else{w=w+31>>5<<5}if(h>maxh)maxh=h;if(x+w>=cw<<5){x=0;y+=maxh;maxh=0}if(y+h>=ch)break;c.translate((x+(w>>1))/ratio,(y+(h>>1))/ratio);if(d.rotate)c.rotate(d.rotate*cloudRadians);c.fillText(d.text,0,0);if(d.padding){c.lineWidth=2*d.padding;c.strokeText(d.text,0,0)}c.restore();d.width=w;d.height=h;d.xoff=x;d.yoff=y;d.x1=w>>1;d.y1=h>>1;d.x0=-d.x1;d.y0=-d.y1;d.hasText=true;x+=w}var pixels=c.getImageData(0,0,(cw<<5)/ratio,ch/ratio).data,sprite=[];while(--di>=0){d=data[di];if(!d.hasText)continue;w=d.width;w32=w>>5;h=d.y1-d.y0;for(i=0;i<h*w32;i++)sprite[i]=0;x=d.xoff;if(x==null)return;y=d.yoff;var seen=0,seenRow=-1;for(j=0;j<h;j++){for(i=0;i<w;i++){var k=w32*j+(i>>5),m=pixels[(y+j)*(cw<<5)+(x+i)<<2]?1<<31-i%32:0;sprite[k]|=m;seen|=m}if(seen)seenRow=j;else{d.y0++;h--;j--;y++}}d.y1=d.y0+seenRow;d.sprite=sprite.slice(0,(d.y1-d.y0)*w32)}}function cloudCollide(tag,board,sw){sw>>=5;var sprite=tag.sprite,w=tag.width>>5,lx=tag.x-(w<<4),sx=lx&127,msx=32-sx,h=tag.y1-tag.y0,x=(tag.y+tag.y0)*sw+(lx>>5),last;for(var j=0;j<h;j++){last=0;for(var i=0;i<=w;i++){if((last<<msx|(i<w?(last=sprite[j*w+i])>>>sx:0))&board[x+i])return true}x+=sw}return false}function cloudBounds(bounds,d){var b0=bounds[0],b1=bounds[1];if(d.x+d.x0<b0.x)b0.x=d.x+d.x0;if(d.y+d.y0<b0.y)b0.y=d.y+d.y0;if(d.x+d.x1>b1.x)b1.x=d.x+d.x1;if(d.y+d.y1>b1.y)b1.y=d.y+d.y1}function collideRects(a,b){return a.x+a.x1>b[0].x&&a.x+a.x0<b[1].x&&a.y+a.y1>b[0].y&&a.y+a.y0<b[1].y}function archimedeanSpiral(size){var e=size[0]/size[1];return function(t){return[e*(t*=.1)*Math.cos(t),t*Math.sin(t)]}}function rectangularSpiral(size){var dy=4,dx=dy*size[0]/size[1],x=0,y=0;return function(t){var sign=t<0?-1:1;switch(Math.sqrt(1+4*sign*t)-sign&3){case 0:x+=dx;break;case 1:y+=dy;break;case 2:x-=dx;break;default:y-=dy;break}return[x,y]}}function zeroArray(n){var a=[],i=-1;while(++i<n)a[i]=0;return a}function functor(d){return typeof d==="function"?d:function(){return d}}var spirals={archimedean:archimedeanSpiral,rectangular:rectangularSpiral};const Output=["x","y","font","fontSize","fontStyle","fontWeight","angle"];const Params$1=["text","font","rotate","fontSize","fontStyle","fontWeight"];function Wordcloud(params){Transform.call(this,cloud(),params)}Wordcloud.Definition={type:"Wordcloud",metadata:{modifies:true},params:[{name:"size",type:"number",array:true,length:2},{name:"font",type:"string",expr:true,default:"sans-serif"},{name:"fontStyle",type:"string",expr:true,default:"normal"},{name:"fontWeight",type:"string",expr:true,default:"normal"},{name:"fontSize",type:"number",expr:true,default:14},{name:"fontSizeRange",type:"number",array:"nullable",default:[10,50]},{name:"rotate",type:"number",expr:true,default:0},{name:"text",type:"field"},{name:"spiral",type:"string",values:["archimedean","rectangular"]},{name:"padding",type:"number",expr:true},{name:"as",type:"string",array:true,length:7,default:Output}]};inherits(Wordcloud,Transform,{transform(_,pulse){if(_.size&&!(_.size[0]&&_.size[1])){error("Wordcloud size dimensions must be non-zero.")}function modp(param){const p=_[param];return isFunction(p)&&pulse.modified(p.fields)}const mod=_.modified();if(!(mod||pulse.changed(pulse.ADD_REM)||Params$1.some(modp)))return;const data=pulse.materialize(pulse.SOURCE).source,layout=this.value,as=_.as||Output;let fontSize=_.fontSize||14,range;isFunction(fontSize)?range=_.fontSizeRange:fontSize=constant$5(fontSize);if(range){const fsize=fontSize,sizeScale=scale$4("sqrt")().domain(extent(data,fsize)).range(range);fontSize=x=>sizeScale(fsize(x))}data.forEach((t=>{t[as[0]]=NaN;t[as[1]]=NaN;t[as[3]]=0}));const words=layout.words(data).text(_.text).size(_.size||[500,500]).padding(_.padding||1).spiral(_.spiral||"archimedean").rotate(_.rotate||0).font(_.font||"sans-serif").fontStyle(_.fontStyle||"normal").fontWeight(_.fontWeight||"normal").fontSize(fontSize).random(random).layout();const size=layout.size(),dx=size[0]>>1,dy=size[1]>>1,n=words.length;for(let i=0,w,t;i<n;++i){w=words[i];t=w.datum;t[as[0]]=w.x+dx;t[as[1]]=w.y+dy;t[as[2]]=w.font;t[as[3]]=w.size;t[as[4]]=w.style;t[as[5]]=w.weight;t[as[6]]=w.rotate}return pulse.reflow(mod).modifies(as)}});var wordcloud=Object.freeze({__proto__:null,wordcloud:Wordcloud});const array8=n=>new Uint8Array(n);const array16=n=>new Uint16Array(n);const array32=n=>new Uint32Array(n);function Bitmaps(){let width=8,data=[],seen=array32(0),curr=array$1(0,width),prev=array$1(0,width);return{data:()=>data,seen:()=>seen=lengthen(seen,data.length),add(array){for(let i=0,j=data.length,n=array.length,t;i<n;++i){t=array[i];t._index=j++;data.push(t)}},remove(num,map){const n=data.length,copy=Array(n-num),reindex=data;let t,i,j;for(i=0;!map[i]&&i<n;++i){copy[i]=data[i];reindex[i]=i}for(j=i;i<n;++i){t=data[i];if(!map[i]){reindex[i]=j;curr[j]=curr[i];prev[j]=prev[i];copy[j]=t;t._index=j++}else{reindex[i]=-1}curr[i]=0}data=copy;return reindex},size:()=>data.length,curr:()=>curr,prev:()=>prev,reset:k=>prev[k]=curr[k],all:()=>width<257?255:width<65537?65535:4294967295,set(k,one){curr[k]|=one},clear(k,one){curr[k]&=~one},resize(n,m){const k=curr.length;if(n>k||m>width){width=Math.max(m,width);curr=array$1(n,width,curr);prev=array$1(n,width)}}}}function lengthen(array,length,copy){if(array.length>=length)return array;copy=copy||new array.constructor(length);copy.set(array);return copy}function array$1(n,m,array){const copy=(m<257?array8:m<65537?array16:array32)(n);if(array)copy.set(array);return copy}function Dimension(index,i,query){const bit=1<<i;return{one:bit,zero:~bit,range:query.slice(),bisect:index.bisect,index:index.index,size:index.size,onAdd(added,curr){const dim=this,range=dim.bisect(dim.range,added.value),idx=added.index,lo=range[0],hi=range[1],n1=idx.length;let i;for(i=0;i<lo;++i)curr[idx[i]]|=bit;for(i=hi;i<n1;++i)curr[idx[i]]|=bit;return dim}}}function SortedIndex(){let index=array32(0),value=[],size=0;function insert(key,data,base){if(!data.length)return[];const n0=size,n1=data.length,addi=array32(n1);let addv=Array(n1),oldv,oldi,i;for(i=0;i<n1;++i){addv[i]=key(data[i]);addi[i]=i}addv=sort(addv,addi);if(n0){oldv=value;oldi=index;value=Array(n0+n1);index=array32(n0+n1);merge$1(base,oldv,oldi,n0,addv,addi,n1,value,index)}else{if(base>0)for(i=0;i<n1;++i){addi[i]+=base}value=addv;index=addi}size=n0+n1;return{index:addi,value:addv}}function remove(num,map){const n=size;let idx,i,j;for(i=0;!map[index[i]]&&i<n;++i);for(j=i;i<n;++i){if(!map[idx=index[i]]){index[j]=idx;value[j]=value[i];++j}}size=n-num}function reindex(map){for(let i=0,n=size;i<n;++i){index[i]=map[index[i]]}}function bisect(range,array){let n;if(array){n=array.length}else{array=value;n=size}return[bisectLeft$1(array,range[0],0,n),bisectRight$1(array,range[1],0,n)]}return{insert:insert,remove:remove,bisect:bisect,reindex:reindex,index:()=>index,size:()=>size}}function sort(values,index){values.sort.call(index,((a,b)=>{const x=values[a],y=values[b];return x<y?-1:x>y?1:0}));return permute(values,index)}function merge$1(base,value0,index0,n0,value1,index1,n1,value,index){let i0=0,i1=0,i;for(i=0;i0<n0&&i1<n1;++i){if(value0[i0]<value1[i1]){value[i]=value0[i0];index[i]=index0[i0++]}else{value[i]=value1[i1];index[i]=index1[i1++]+base}}for(;i0<n0;++i0,++i){value[i]=value0[i0];index[i]=index0[i0]}for(;i1<n1;++i1,++i){value[i]=value1[i1];index[i]=index1[i1]+base}}function CrossFilter(params){Transform.call(this,Bitmaps(),params);this._indices=null;this._dims=null}CrossFilter.Definition={type:"CrossFilter",metadata:{},params:[{name:"fields",type:"field",array:true,required:true},{name:"query",type:"array",array:true,required:true,content:{type:"number",array:true,length:2}}]};inherits(CrossFilter,Transform,{transform(_,pulse){if(!this._dims){return this.init(_,pulse)}else{var init=_.modified("fields")||_.fields.some((f=>pulse.modified(f.fields)));return init?this.reinit(_,pulse):this.eval(_,pulse)}},init(_,pulse){const fields=_.fields,query=_.query,indices=this._indices={},dims=this._dims=[],m=query.length;let i=0,key,index;for(;i<m;++i){key=fields[i].fname;index=indices[key]||(indices[key]=SortedIndex());dims.push(Dimension(index,i,query[i]))}return this.eval(_,pulse)},reinit(_,pulse){const output=pulse.materialize().fork(),fields=_.fields,query=_.query,indices=this._indices,dims=this._dims,bits=this.value,curr=bits.curr(),prev=bits.prev(),all=bits.all(),out=output.rem=output.add,mod=output.mod,m=query.length,adds={};let add,index,key,mods,remMap,modMap,i,n,f;prev.set(curr);if(pulse.rem.length){remMap=this.remove(_,pulse,output)}if(pulse.add.length){bits.add(pulse.add)}if(pulse.mod.length){modMap={};for(mods=pulse.mod,i=0,n=mods.length;i<n;++i){modMap[mods[i]._index]=1}}for(i=0;i<m;++i){f=fields[i];if(!dims[i]||_.modified("fields",i)||pulse.modified(f.fields)){key=f.fname;if(!(add=adds[key])){indices[key]=index=SortedIndex();adds[key]=add=index.insert(f,pulse.source,0)}dims[i]=Dimension(index,i,query[i]).onAdd(add,curr)}}for(i=0,n=bits.data().length;i<n;++i){if(remMap[i]){continue}else if(prev[i]!==curr[i]){out.push(i)}else if(modMap[i]&&curr[i]!==all){mod.push(i)}}bits.mask=(1<<m)-1;return output},eval(_,pulse){const output=pulse.materialize().fork(),m=this._dims.length;let mask=0;if(pulse.rem.length){this.remove(_,pulse,output);mask|=(1<<m)-1}if(_.modified("query")&&!_.modified("fields")){mask|=this.update(_,pulse,output)}if(pulse.add.length){this.insert(_,pulse,output);mask|=(1<<m)-1}if(pulse.mod.length){this.modify(pulse,output);mask|=(1<<m)-1}this.value.mask=mask;return output},insert(_,pulse,output){const tuples=pulse.add,bits=this.value,dims=this._dims,indices=this._indices,fields=_.fields,adds={},out=output.add,n=bits.size()+tuples.length,m=dims.length;let k=bits.size(),j,key,add;bits.resize(n,m);bits.add(tuples);const curr=bits.curr(),prev=bits.prev(),all=bits.all();for(j=0;j<m;++j){key=fields[j].fname;add=adds[key]||(adds[key]=indices[key].insert(fields[j],tuples,k));dims[j].onAdd(add,curr)}for(;k<n;++k){prev[k]=all;if(curr[k]!==all)out.push(k)}},modify(pulse,output){const out=output.mod,bits=this.value,curr=bits.curr(),all=bits.all(),tuples=pulse.mod;let i,n,k;for(i=0,n=tuples.length;i<n;++i){k=tuples[i]._index;if(curr[k]!==all)out.push(k)}},remove(_,pulse,output){const indices=this._indices,bits=this.value,curr=bits.curr(),prev=bits.prev(),all=bits.all(),map={},out=output.rem,tuples=pulse.rem;let i,n,k,f;for(i=0,n=tuples.length;i<n;++i){k=tuples[i]._index;map[k]=1;prev[k]=f=curr[k];curr[k]=all;if(f!==all)out.push(k)}for(k in indices){indices[k].remove(n,map)}this.reindex(pulse,n,map);return map},reindex(pulse,num,map){const indices=this._indices,bits=this.value;pulse.runAfter((()=>{const indexMap=bits.remove(num,map);for(const key in indices)indices[key].reindex(indexMap)}))},update(_,pulse,output){const dims=this._dims,query=_.query,stamp=pulse.stamp,m=dims.length;let mask=0,i,q;output.filters=0;for(q=0;q<m;++q){if(_.modified("query",q)){i=q;++mask}}if(mask===1){mask=dims[i].one;this.incrementOne(dims[i],query[i],output.add,output.rem)}else{for(q=0,mask=0;q<m;++q){if(!_.modified("query",q))continue;mask|=dims[q].one;this.incrementAll(dims[q],query[q],stamp,output.add);output.rem=output.add}}return mask},incrementAll(dim,query,stamp,out){const bits=this.value,seen=bits.seen(),curr=bits.curr(),prev=bits.prev(),index=dim.index(),old=dim.bisect(dim.range),range=dim.bisect(query),lo1=range[0],hi1=range[1],lo0=old[0],hi0=old[1],one=dim.one;let i,j,k;if(lo1<lo0){for(i=lo1,j=Math.min(lo0,hi1);i<j;++i){k=index[i];if(seen[k]!==stamp){prev[k]=curr[k];seen[k]=stamp;out.push(k)}curr[k]^=one}}else if(lo1>lo0){for(i=lo0,j=Math.min(lo1,hi0);i<j;++i){k=index[i];if(seen[k]!==stamp){prev[k]=curr[k];seen[k]=stamp;out.push(k)}curr[k]^=one}}if(hi1>hi0){for(i=Math.max(lo1,hi0),j=hi1;i<j;++i){k=index[i];if(seen[k]!==stamp){prev[k]=curr[k];seen[k]=stamp;out.push(k)}curr[k]^=one}}else if(hi1<hi0){for(i=Math.max(lo0,hi1),j=hi0;i<j;++i){k=index[i];if(seen[k]!==stamp){prev[k]=curr[k];seen[k]=stamp;out.push(k)}curr[k]^=one}}dim.range=query.slice()},incrementOne(dim,query,add,rem){const bits=this.value,curr=bits.curr(),index=dim.index(),old=dim.bisect(dim.range),range=dim.bisect(query),lo1=range[0],hi1=range[1],lo0=old[0],hi0=old[1],one=dim.one;let i,j,k;if(lo1<lo0){for(i=lo1,j=Math.min(lo0,hi1);i<j;++i){k=index[i];curr[k]^=one;add.push(k)}}else if(lo1>lo0){for(i=lo0,j=Math.min(lo1,hi0);i<j;++i){k=index[i];curr[k]^=one;rem.push(k)}}if(hi1>hi0){for(i=Math.max(lo1,hi0),j=hi1;i<j;++i){k=index[i];curr[k]^=one;add.push(k)}}else if(hi1<hi0){for(i=Math.max(lo0,hi1),j=hi0;i<j;++i){k=index[i];curr[k]^=one;rem.push(k)}}dim.range=query.slice()}});function ResolveFilter(params){Transform.call(this,null,params)}ResolveFilter.Definition={type:"ResolveFilter",metadata:{},params:[{name:"ignore",type:"number",required:true,description:"A bit mask indicating which filters to ignore."},{name:"filter",type:"object",required:true,description:"Per-tuple filter bitmaps from a CrossFilter transform."}]};inherits(ResolveFilter,Transform,{transform(_,pulse){const ignore=~(_.ignore||0),bitmap=_.filter,mask=bitmap.mask;if((mask&ignore)===0)return pulse.StopPropagation;const output=pulse.fork(pulse.ALL),data=bitmap.data(),curr=bitmap.curr(),prev=bitmap.prev(),pass=k=>!(curr[k]&ignore)?data[k]:null;output.filter(output.MOD,pass);if(!(mask&mask-1)){output.filter(output.ADD,pass);output.filter(output.REM,(k=>(curr[k]&ignore)===mask?data[k]:null))}else{output.filter(output.ADD,(k=>{const c=curr[k]&ignore,f=!c&&c^prev[k]&ignore;return f?data[k]:null}));output.filter(output.REM,(k=>{const c=curr[k]&ignore,f=c&&!(c^(c^prev[k]&ignore));return f?data[k]:null}))}return output.filter(output.SOURCE,(t=>pass(t._index)))}});var xf=Object.freeze({__proto__:null,crossfilter:CrossFilter,resolvefilter:ResolveFilter});const RawCode="RawCode";const Literal="Literal";const Property="Property";const Identifier="Identifier";const ArrayExpression="ArrayExpression";const BinaryExpression="BinaryExpression";const CallExpression="CallExpression";const ConditionalExpression="ConditionalExpression";const LogicalExpression="LogicalExpression";const MemberExpression="MemberExpression";const ObjectExpression="ObjectExpression";const UnaryExpression="UnaryExpression";function ASTNode(type){this.type=type}ASTNode.prototype.visit=function(visitor){let c,i,n;if(visitor(this))return 1;for(c=children(this),i=0,n=c.length;i<n;++i){if(c[i].visit(visitor))return 1}};function children(node){switch(node.type){case ArrayExpression:return node.elements;case BinaryExpression:case LogicalExpression:return[node.left,node.right];case CallExpression:return[node.callee].concat(node.arguments);case ConditionalExpression:return[node.test,node.consequent,node.alternate];case MemberExpression:return[node.object,node.property];case ObjectExpression:return node.properties;case Property:return[node.key,node.value];case UnaryExpression:return[node.argument];case Identifier:case Literal:case RawCode:default:return[]}}var TokenName,source,index,length,lookahead;var TokenBooleanLiteral=1,TokenEOF=2,TokenIdentifier=3,TokenKeyword=4,TokenNullLiteral=5,TokenNumericLiteral=6,TokenPunctuator=7,TokenStringLiteral=8,TokenRegularExpression=9;TokenName={};TokenName[TokenBooleanLiteral]="Boolean";TokenName[TokenEOF]="<end>";TokenName[TokenIdentifier]="Identifier";TokenName[TokenKeyword]="Keyword";TokenName[TokenNullLiteral]="Null";TokenName[TokenNumericLiteral]="Numeric";TokenName[TokenPunctuator]="Punctuator";TokenName[TokenStringLiteral]="String";TokenName[TokenRegularExpression]="RegularExpression";var SyntaxArrayExpression="ArrayExpression",SyntaxBinaryExpression="BinaryExpression",SyntaxCallExpression="CallExpression",SyntaxConditionalExpression="ConditionalExpression",SyntaxIdentifier="Identifier",SyntaxLiteral="Literal",SyntaxLogicalExpression="LogicalExpression",SyntaxMemberExpression="MemberExpression",SyntaxObjectExpression="ObjectExpression",SyntaxProperty="Property",SyntaxUnaryExpression="UnaryExpression";var MessageUnexpectedToken="Unexpected token %0",MessageUnexpectedNumber="Unexpected number",MessageUnexpectedString="Unexpected string",MessageUnexpectedIdentifier="Unexpected identifier",MessageUnexpectedReserved="Unexpected reserved word",MessageUnexpectedEOS="Unexpected end of input",MessageInvalidRegExp="Invalid regular expression",MessageUnterminatedRegExp="Invalid regular expression: missing /",MessageStrictOctalLiteral="Octal literals are not allowed in strict mode.",MessageStrictDuplicateProperty="Duplicate data property in object literal not allowed in strict mode";var ILLEGAL$1="ILLEGAL",DISABLED="Disabled.";var RegexNonAsciiIdentifierStart=new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"),RegexNonAsciiIdentifierPart=new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");function assert(condition,message){if(!condition){throw new Error("ASSERT: "+message)}}function isDecimalDigit(ch){return ch>=48&&ch<=57}function isHexDigit(ch){return"0123456789abcdefABCDEF".includes(ch)}function isOctalDigit(ch){return"01234567".includes(ch)}function isWhiteSpace(ch){return ch===32||ch===9||ch===11||ch===12||ch===160||ch>=5760&&[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279].includes(ch)}function isLineTerminator(ch){return ch===10||ch===13||ch===8232||ch===8233}function isIdentifierStart(ch){return ch===36||ch===95||ch>=65&&ch<=90||ch>=97&&ch<=122||ch===92||ch>=128&&RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch))}function isIdentifierPart(ch){return ch===36||ch===95||ch>=65&&ch<=90||ch>=97&&ch<=122||ch>=48&&ch<=57||ch===92||ch>=128&&RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch))}const keywords={if:1,in:1,do:1,var:1,for:1,new:1,try:1,let:1,this:1,else:1,case:1,void:1,with:1,enum:1,while:1,break:1,catch:1,throw:1,const:1,yield:1,class:1,super:1,return:1,typeof:1,delete:1,switch:1,export:1,import:1,public:1,static:1,default:1,finally:1,extends:1,package:1,private:1,function:1,continue:1,debugger:1,interface:1,protected:1,instanceof:1,implements:1};function skipComment(){while(index<length){const ch=source.charCodeAt(index);if(isWhiteSpace(ch)||isLineTerminator(ch)){++index}else{break}}}function scanHexEscape(prefix){var i,len,ch,code=0;len=prefix==="u"?4:2;for(i=0;i<len;++i){if(index<length&&isHexDigit(source[index])){ch=source[index++];code=code*16+"0123456789abcdef".indexOf(ch.toLowerCase())}else{throwError({},MessageUnexpectedToken,ILLEGAL$1)}}return String.fromCharCode(code)}function scanUnicodeCodePointEscape(){var ch,code,cu1,cu2;ch=source[index];code=0;if(ch==="}"){throwError({},MessageUnexpectedToken,ILLEGAL$1)}while(index<length){ch=source[index++];if(!isHexDigit(ch)){break}code=code*16+"0123456789abcdef".indexOf(ch.toLowerCase())}if(code>1114111||ch!=="}"){throwError({},MessageUnexpectedToken,ILLEGAL$1)}if(code<=65535){return String.fromCharCode(code)}cu1=(code-65536>>10)+55296;cu2=(code-65536&1023)+56320;return String.fromCharCode(cu1,cu2)}function getEscapedIdentifier(){var ch,id;ch=source.charCodeAt(index++);id=String.fromCharCode(ch);if(ch===92){if(source.charCodeAt(index)!==117){throwError({},MessageUnexpectedToken,ILLEGAL$1)}++index;ch=scanHexEscape("u");if(!ch||ch==="\\"||!isIdentifierStart(ch.charCodeAt(0))){throwError({},MessageUnexpectedToken,ILLEGAL$1)}id=ch}while(index<length){ch=source.charCodeAt(index);if(!isIdentifierPart(ch)){break}++index;id+=String.fromCharCode(ch);if(ch===92){id=id.substr(0,id.length-1);if(source.charCodeAt(index)!==117){throwError({},MessageUnexpectedToken,ILLEGAL$1)}++index;ch=scanHexEscape("u");if(!ch||ch==="\\"||!isIdentifierPart(ch.charCodeAt(0))){throwError({},MessageUnexpectedToken,ILLEGAL$1)}id+=ch}}return id}function getIdentifier(){var start,ch;start=index++;while(index<length){ch=source.charCodeAt(index);if(ch===92){index=start;return getEscapedIdentifier()}if(isIdentifierPart(ch)){++index}else{break}}return source.slice(start,index)}function scanIdentifier(){var start,id,type;start=index;id=source.charCodeAt(index)===92?getEscapedIdentifier():getIdentifier();if(id.length===1){type=TokenIdentifier}else if(keywords.hasOwnProperty(id)){type=TokenKeyword}else if(id==="null"){type=TokenNullLiteral}else if(id==="true"||id==="false"){type=TokenBooleanLiteral}else{type=TokenIdentifier}return{type:type,value:id,start:start,end:index}}function scanPunctuator(){var start=index,code=source.charCodeAt(index),code2,ch1=source[index],ch2,ch3,ch4;switch(code){case 46:case 40:case 41:case 59:case 44:case 123:case 125:case 91:case 93:case 58:case 63:case 126:++index;return{type:TokenPunctuator,value:String.fromCharCode(code),start:start,end:index};default:code2=source.charCodeAt(index+1);if(code2===61){switch(code){case 43:case 45:case 47:case 60:case 62:case 94:case 124:case 37:case 38:case 42:index+=2;return{type:TokenPunctuator,value:String.fromCharCode(code)+String.fromCharCode(code2),start:start,end:index};case 33:case 61:index+=2;if(source.charCodeAt(index)===61){++index}return{type:TokenPunctuator,value:source.slice(start,index),start:start,end:index}}}}ch4=source.substr(index,4);if(ch4===">>>="){index+=4;return{type:TokenPunctuator,value:ch4,start:start,end:index}}ch3=ch4.substr(0,3);if(ch3===">>>"||ch3==="<<="||ch3===">>="){index+=3;return{type:TokenPunctuator,value:ch3,start:start,end:index}}ch2=ch3.substr(0,2);if(ch1===ch2[1]&&"+-<>&|".includes(ch1)||ch2==="=>"){index+=2;return{type:TokenPunctuator,value:ch2,start:start,end:index}}if(ch2==="//"){throwError({},MessageUnexpectedToken,ILLEGAL$1)}if("<>=!+-*%&|^/".includes(ch1)){++index;return{type:TokenPunctuator,value:ch1,start:start,end:index}}throwError({},MessageUnexpectedToken,ILLEGAL$1)}function scanHexLiteral(start){let number="";while(index<length){if(!isHexDigit(source[index])){break}number+=source[index++]}if(number.length===0){throwError({},MessageUnexpectedToken,ILLEGAL$1)}if(isIdentifierStart(source.charCodeAt(index))){throwError({},MessageUnexpectedToken,ILLEGAL$1)}return{type:TokenNumericLiteral,value:parseInt("0x"+number,16),start:start,end:index}}function scanOctalLiteral(start){let number="0"+source[index++];while(index<length){if(!isOctalDigit(source[index])){break}number+=source[index++]}if(isIdentifierStart(source.charCodeAt(index))||isDecimalDigit(source.charCodeAt(index))){throwError({},MessageUnexpectedToken,ILLEGAL$1)}return{type:TokenNumericLiteral,value:parseInt(number,8),octal:true,start:start,end:index}}function scanNumericLiteral(){var number,start,ch;ch=source[index];assert(isDecimalDigit(ch.charCodeAt(0))||ch===".","Numeric literal must start with a decimal digit or a decimal point");start=index;number="";if(ch!=="."){number=source[index++];ch=source[index];if(number==="0"){if(ch==="x"||ch==="X"){++index;return scanHexLiteral(start)}if(isOctalDigit(ch)){return scanOctalLiteral(start)}if(ch&&isDecimalDigit(ch.charCodeAt(0))){throwError({},MessageUnexpectedToken,ILLEGAL$1)}}while(isDecimalDigit(source.charCodeAt(index))){number+=source[index++]}ch=source[index]}if(ch==="."){number+=source[index++];while(isDecimalDigit(source.charCodeAt(index))){number+=source[index++]}ch=source[index]}if(ch==="e"||ch==="E"){number+=source[index++];ch=source[index];if(ch==="+"||ch==="-"){number+=source[index++]}if(isDecimalDigit(source.charCodeAt(index))){while(isDecimalDigit(source.charCodeAt(index))){number+=source[index++]}}else{throwError({},MessageUnexpectedToken,ILLEGAL$1)}}if(isIdentifierStart(source.charCodeAt(index))){throwError({},MessageUnexpectedToken,ILLEGAL$1)}return{type:TokenNumericLiteral,value:parseFloat(number),start:start,end:index}}function scanStringLiteral(){var str="",quote,start,ch,code,octal=false;quote=source[index];assert(quote==="'"||quote==='"',"String literal must starts with a quote");start=index;++index;while(index<length){ch=source[index++];if(ch===quote){quote="";break}else if(ch==="\\"){ch=source[index++];if(!ch||!isLineTerminator(ch.charCodeAt(0))){switch(ch){case"u":case"x":if(source[index]==="{"){++index;str+=scanUnicodeCodePointEscape()}else{str+=scanHexEscape(ch)}break;case"n":str+="\n";break;case"r":str+="\r";break;case"t":str+="\t";break;case"b":str+="\b";break;case"f":str+="\f";break;case"v":str+="\v";break;default:if(isOctalDigit(ch)){code="01234567".indexOf(ch);if(code!==0){octal=true}if(index<length&&isOctalDigit(source[index])){octal=true;code=code*8+"01234567".indexOf(source[index++]);if("0123".includes(ch)&&index<length&&isOctalDigit(source[index])){code=code*8+"01234567".indexOf(source[index++])}}str+=String.fromCharCode(code)}else{str+=ch}break}}else{if(ch==="\r"&&source[index]==="\n"){++index}}}else if(isLineTerminator(ch.charCodeAt(0))){break}else{str+=ch}}if(quote!==""){throwError({},MessageUnexpectedToken,ILLEGAL$1)}return{type:TokenStringLiteral,value:str,octal:octal,start:start,end:index}}function testRegExp(pattern,flags){let tmp=pattern;if(flags.includes("u")){tmp=tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g,(($0,$1)=>{if(parseInt($1,16)<=1114111){return"x"}throwError({},MessageInvalidRegExp)})).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,"x")}try{new RegExp(tmp)}catch(e){throwError({},MessageInvalidRegExp)}try{return new RegExp(pattern,flags)}catch(exception){return null}}function scanRegExpBody(){var ch,str,classMarker,terminated,body;ch=source[index];assert(ch==="/","Regular expression literal must start with a slash");str=source[index++];classMarker=false;terminated=false;while(index<length){ch=source[index++];str+=ch;if(ch==="\\"){ch=source[index++];if(isLineTerminator(ch.charCodeAt(0))){throwError({},MessageUnterminatedRegExp)}str+=ch}else if(isLineTerminator(ch.charCodeAt(0))){throwError({},MessageUnterminatedRegExp)}else if(classMarker){if(ch==="]"){classMarker=false}}else{if(ch==="/"){terminated=true;break}else if(ch==="["){classMarker=true}}}if(!terminated){throwError({},MessageUnterminatedRegExp)}body=str.substr(1,str.length-2);return{value:body,literal:str}}function scanRegExpFlags(){var ch,str,flags;str="";flags="";while(index<length){ch=source[index];if(!isIdentifierPart(ch.charCodeAt(0))){break}++index;if(ch==="\\"&&index<length){throwError({},MessageUnexpectedToken,ILLEGAL$1)}else{flags+=ch;str+=ch}}if(flags.search(/[^gimuy]/g)>=0){throwError({},MessageInvalidRegExp,flags)}return{value:flags,literal:str}}function scanRegExp(){var start,body,flags,value;lookahead=null;skipComment();start=index;body=scanRegExpBody();flags=scanRegExpFlags();value=testRegExp(body.value,flags.value);return{literal:body.literal+flags.literal,value:value,regex:{pattern:body.value,flags:flags.value},start:start,end:index}}function isIdentifierName(token){return token.type===TokenIdentifier||token.type===TokenKeyword||token.type===TokenBooleanLiteral||token.type===TokenNullLiteral}function advance(){skipComment();if(index>=length){return{type:TokenEOF,start:index,end:index}}const ch=source.charCodeAt(index);if(isIdentifierStart(ch)){return scanIdentifier()}if(ch===40||ch===41||ch===59){return scanPunctuator()}if(ch===39||ch===34){return scanStringLiteral()}if(ch===46){if(isDecimalDigit(source.charCodeAt(index+1))){return scanNumericLiteral()}return scanPunctuator()}if(isDecimalDigit(ch)){return scanNumericLiteral()}return scanPunctuator()}function lex(){const token=lookahead;index=token.end;lookahead=advance();index=token.end;return token}function peek(){const pos=index;lookahead=advance();index=pos}function finishArrayExpression(elements){const node=new ASTNode(SyntaxArrayExpression);node.elements=elements;return node}function finishBinaryExpression(operator,left,right){const node=new ASTNode(operator==="||"||operator==="&&"?SyntaxLogicalExpression:SyntaxBinaryExpression);node.operator=operator;node.left=left;node.right=right;return node}function finishCallExpression(callee,args){const node=new ASTNode(SyntaxCallExpression);node.callee=callee;node.arguments=args;return node}function finishConditionalExpression(test,consequent,alternate){const node=new ASTNode(SyntaxConditionalExpression);node.test=test;node.consequent=consequent;node.alternate=alternate;return node}function finishIdentifier(name){const node=new ASTNode(SyntaxIdentifier);node.name=name;return node}function finishLiteral(token){const node=new ASTNode(SyntaxLiteral);node.value=token.value;node.raw=source.slice(token.start,token.end);if(token.regex){if(node.raw==="//"){node.raw="/(?:)/"}node.regex=token.regex}return node}function finishMemberExpression(accessor,object,property){const node=new ASTNode(SyntaxMemberExpression);node.computed=accessor==="[";node.object=object;node.property=property;if(!node.computed)property.member=true;return node}function finishObjectExpression(properties){const node=new ASTNode(SyntaxObjectExpression);node.properties=properties;return node}function finishProperty(kind,key,value){const node=new ASTNode(SyntaxProperty);node.key=key;node.value=value;node.kind=kind;return node}function finishUnaryExpression(operator,argument){const node=new ASTNode(SyntaxUnaryExpression);node.operator=operator;node.argument=argument;node.prefix=true;return node}function throwError(token,messageFormat){var error,args=Array.prototype.slice.call(arguments,2),msg=messageFormat.replace(/%(\d)/g,((whole,index)=>{assert(index<args.length,"Message reference must be in range");return args[index]}));error=new Error(msg);error.index=index;error.description=msg;throw error}function throwUnexpected(token){if(token.type===TokenEOF){throwError(token,MessageUnexpectedEOS)}if(token.type===TokenNumericLiteral){throwError(token,MessageUnexpectedNumber)}if(token.type===TokenStringLiteral){throwError(token,MessageUnexpectedString)}if(token.type===TokenIdentifier){throwError(token,MessageUnexpectedIdentifier)}if(token.type===TokenKeyword){throwError(token,MessageUnexpectedReserved)}throwError(token,MessageUnexpectedToken,token.value)}function expect(value){const token=lex();if(token.type!==TokenPunctuator||token.value!==value){throwUnexpected(token)}}function match(value){return lookahead.type===TokenPunctuator&&lookahead.value===value}function matchKeyword(keyword){return lookahead.type===TokenKeyword&&lookahead.value===keyword}function parseArrayInitialiser(){const elements=[];index=lookahead.start;expect("[");while(!match("]")){if(match(",")){lex();elements.push(null)}else{elements.push(parseConditionalExpression());if(!match("]")){expect(",")}}}lex();return finishArrayExpression(elements)}function parseObjectPropertyKey(){index=lookahead.start;const token=lex();if(token.type===TokenStringLiteral||token.type===TokenNumericLiteral){if(token.octal){throwError(token,MessageStrictOctalLiteral)}return finishLiteral(token)}return finishIdentifier(token.value)}function parseObjectProperty(){var token,key,id,value;index=lookahead.start;token=lookahead;if(token.type===TokenIdentifier){id=parseObjectPropertyKey();expect(":");value=parseConditionalExpression();return finishProperty("init",id,value)}if(token.type===TokenEOF||token.type===TokenPunctuator){throwUnexpected(token)}else{key=parseObjectPropertyKey();expect(":");value=parseConditionalExpression();return finishProperty("init",key,value)}}function parseObjectInitialiser(){var properties=[],property,name,key,map={},toString=String;index=lookahead.start;expect("{");while(!match("}")){property=parseObjectProperty();if(property.key.type===SyntaxIdentifier){name=property.key.name}else{name=toString(property.key.value)}key="$"+name;if(Object.prototype.hasOwnProperty.call(map,key)){throwError({},MessageStrictDuplicateProperty)}else{map[key]=true}properties.push(property);if(!match("}")){expect(",")}}expect("}");return finishObjectExpression(properties)}function parseGroupExpression(){expect("(");const expr=parseExpression$1();expect(")");return expr}const legalKeywords={if:1};function parsePrimaryExpression(){var type,token,expr;if(match("(")){return parseGroupExpression()}if(match("[")){return parseArrayInitialiser()}if(match("{")){return parseObjectInitialiser()}type=lookahead.type;index=lookahead.start;if(type===TokenIdentifier||legalKeywords[lookahead.value]){expr=finishIdentifier(lex().value)}else if(type===TokenStringLiteral||type===TokenNumericLiteral){if(lookahead.octal){throwError(lookahead,MessageStrictOctalLiteral)}expr=finishLiteral(lex())}else if(type===TokenKeyword){throw new Error(DISABLED)}else if(type===TokenBooleanLiteral){token=lex();token.value=token.value==="true";expr=finishLiteral(token)}else if(type===TokenNullLiteral){token=lex();token.value=null;expr=finishLiteral(token)}else if(match("/")||match("/=")){expr=finishLiteral(scanRegExp());peek()}else{throwUnexpected(lex())}return expr}function parseArguments(){const args=[];expect("(");if(!match(")")){while(index<length){args.push(parseConditionalExpression());if(match(")")){break}expect(",")}}expect(")");return args}function parseNonComputedProperty(){index=lookahead.start;const token=lex();if(!isIdentifierName(token)){throwUnexpected(token)}return finishIdentifier(token.value)}function parseNonComputedMember(){expect(".");return parseNonComputedProperty()}function parseComputedMember(){expect("[");const expr=parseExpression$1();expect("]");return expr}function parseLeftHandSideExpressionAllowCall(){var expr,args,property;expr=parsePrimaryExpression();for(;;){if(match(".")){property=parseNonComputedMember();expr=finishMemberExpression(".",expr,property)}else if(match("(")){args=parseArguments();expr=finishCallExpression(expr,args)}else if(match("[")){property=parseComputedMember();expr=finishMemberExpression("[",expr,property)}else{break}}return expr}function parsePostfixExpression(){const expr=parseLeftHandSideExpressionAllowCall();if(lookahead.type===TokenPunctuator){if(match("++")||match("--")){throw new Error(DISABLED)}}return expr}function parseUnaryExpression(){var token,expr;if(lookahead.type!==TokenPunctuator&&lookahead.type!==TokenKeyword){expr=parsePostfixExpression()}else if(match("++")||match("--")){throw new Error(DISABLED)}else if(match("+")||match("-")||match("~")||match("!")){token=lex();expr=parseUnaryExpression();expr=finishUnaryExpression(token.value,expr)}else if(matchKeyword("delete")||matchKeyword("void")||matchKeyword("typeof")){throw new Error(DISABLED)}else{expr=parsePostfixExpression()}return expr}function binaryPrecedence(token){let prec=0;if(token.type!==TokenPunctuator&&token.type!==TokenKeyword){return 0}switch(token.value){case"||":prec=1;break;case"&&":prec=2;break;case"|":prec=3;break;case"^":prec=4;break;case"&":prec=5;break;case"==":case"!=":case"===":case"!==":prec=6;break;case"<":case">":case"<=":case">=":case"instanceof":case"in":prec=7;break;case"<<":case">>":case">>>":prec=8;break;case"+":case"-":prec=9;break;case"*":case"/":case"%":prec=11;break}return prec}function parseBinaryExpression(){var marker,markers,expr,token,prec,stack,right,operator,left,i;marker=lookahead;left=parseUnaryExpression();token=lookahead;prec=binaryPrecedence(token);if(prec===0){return left}token.prec=prec;lex();markers=[marker,lookahead];right=parseUnaryExpression();stack=[left,token,right];while((prec=binaryPrecedence(lookahead))>0){while(stack.length>2&&prec<=stack[stack.length-2].prec){right=stack.pop();operator=stack.pop().value;left=stack.pop();markers.pop();expr=finishBinaryExpression(operator,left,right);stack.push(expr)}token=lex();token.prec=prec;stack.push(token);markers.push(lookahead);expr=parseUnaryExpression();stack.push(expr)}i=stack.length-1;expr=stack[i];markers.pop();while(i>1){markers.pop();expr=finishBinaryExpression(stack[i-1].value,stack[i-2],expr);i-=2}return expr}function parseConditionalExpression(){var expr,consequent,alternate;expr=parseBinaryExpression();if(match("?")){lex();consequent=parseConditionalExpression();expect(":");alternate=parseConditionalExpression();expr=finishConditionalExpression(expr,consequent,alternate)}return expr}function parseExpression$1(){const expr=parseConditionalExpression();if(match(",")){throw new Error(DISABLED)}return expr}function parser$1(code){source=code;index=0;length=source.length;lookahead=null;peek();const expr=parseExpression$1();if(lookahead.type!==TokenEOF){throw new Error("Unexpect token after expression.")}return expr}var Constants={NaN:"NaN",E:"Math.E",LN2:"Math.LN2",LN10:"Math.LN10",LOG2E:"Math.LOG2E",LOG10E:"Math.LOG10E",PI:"Math.PI",SQRT1_2:"Math.SQRT1_2",SQRT2:"Math.SQRT2",MIN_VALUE:"Number.MIN_VALUE",MAX_VALUE:"Number.MAX_VALUE"};function Functions(codegen){function fncall(name,args,cast,type){let obj=codegen(args[0]);if(cast){obj=cast+"("+obj+")";if(cast.lastIndexOf("new ",0)===0)obj="("+obj+")"}return obj+"."+name+(type<0?"":type===0?"()":"("+args.slice(1).map(codegen).join(",")+")")}function fn(name,cast,type){return args=>fncall(name,args,cast,type)}const DATE="new Date",STRING="String",REGEXP="RegExp";return{isNaN:"Number.isNaN",isFinite:"Number.isFinite",abs:"Math.abs",acos:"Math.acos",asin:"Math.asin",atan:"Math.atan",atan2:"Math.atan2",ceil:"Math.ceil",cos:"Math.cos",exp:"Math.exp",floor:"Math.floor",hypot:"Math.hypot",log:"Math.log",max:"Math.max",min:"Math.min",pow:"Math.pow",random:"Math.random",round:"Math.round",sin:"Math.sin",sqrt:"Math.sqrt",tan:"Math.tan",clamp:function(args){if(args.length<3)error("Missing arguments to clamp function.");if(args.length>3)error("Too many arguments to clamp function.");const a=args.map(codegen);return"Math.max("+a[1]+", Math.min("+a[2]+","+a[0]+"))"},now:"Date.now",utc:"Date.UTC",datetime:DATE,date:fn("getDate",DATE,0),day:fn("getDay",DATE,0),year:fn("getFullYear",DATE,0),month:fn("getMonth",DATE,0),hours:fn("getHours",DATE,0),minutes:fn("getMinutes",DATE,0),seconds:fn("getSeconds",DATE,0),milliseconds:fn("getMilliseconds",DATE,0),time:fn("getTime",DATE,0),timezoneoffset:fn("getTimezoneOffset",DATE,0),utcdate:fn("getUTCDate",DATE,0),utcday:fn("getUTCDay",DATE,0),utcyear:fn("getUTCFullYear",DATE,0),utcmonth:fn("getUTCMonth",DATE,0),utchours:fn("getUTCHours",DATE,0),utcminutes:fn("getUTCMinutes",DATE,0),utcseconds:fn("getUTCSeconds",DATE,0),utcmilliseconds:fn("getUTCMilliseconds",DATE,0),length:fn("length",null,-1),parseFloat:"parseFloat",parseInt:"parseInt",upper:fn("toUpperCase",STRING,0),lower:fn("toLowerCase",STRING,0),substring:fn("substring",STRING),split:fn("split",STRING),trim:fn("trim",STRING,0),regexp:REGEXP,test:fn("test",REGEXP),if:function(args){if(args.length<3)error("Missing arguments to if function.");if(args.length>3)error("Too many arguments to if function.");const a=args.map(codegen);return"("+a[0]+"?"+a[1]+":"+a[2]+")"}}}function stripQuotes(s){const n=s&&s.length-1;return n&&(s[0]==='"'&&s[n]==='"'||s[0]==="'"&&s[n]==="'")?s.slice(1,-1):s}function codegen(opt){opt=opt||{};const allowed=opt.allowed?toSet(opt.allowed):{},forbidden=opt.forbidden?toSet(opt.forbidden):{},constants=opt.constants||Constants,functions=(opt.functions||Functions)(visit),globalvar=opt.globalvar,fieldvar=opt.fieldvar,outputGlobal=isFunction(globalvar)?globalvar:id=>`${globalvar}["${id}"]`;let globals={},fields={},memberDepth=0;function visit(ast){if(isString(ast))return ast;const generator=Generators[ast.type];if(generator==null)error("Unsupported type: "+ast.type);return generator(ast)}const Generators={Literal:n=>n.raw,Identifier:n=>{const id=n.name;if(memberDepth>0){return id}else if(has$1(forbidden,id)){return error("Illegal identifier: "+id)}else if(has$1(constants,id)){return constants[id]}else if(has$1(allowed,id)){return id}else{globals[id]=1;return outputGlobal(id)}},MemberExpression:n=>{const d=!n.computed,o=visit(n.object);if(d)memberDepth+=1;const p=visit(n.property);if(o===fieldvar){fields[stripQuotes(p)]=1}if(d)memberDepth-=1;return o+(d?"."+p:"["+p+"]")},CallExpression:n=>{if(n.callee.type!=="Identifier"){error("Illegal callee type: "+n.callee.type)}const callee=n.callee.name,args=n.arguments,fn=has$1(functions,callee)&&functions[callee];if(!fn)error("Unrecognized function: "+callee);return isFunction(fn)?fn(args):fn+"("+args.map(visit).join(",")+")"},ArrayExpression:n=>"["+n.elements.map(visit).join(",")+"]",BinaryExpression:n=>"("+visit(n.left)+" "+n.operator+" "+visit(n.right)+")",UnaryExpression:n=>"("+n.operator+visit(n.argument)+")",ConditionalExpression:n=>"("+visit(n.test)+"?"+visit(n.consequent)+":"+visit(n.alternate)+")",LogicalExpression:n=>"("+visit(n.left)+n.operator+visit(n.right)+")",ObjectExpression:n=>"{"+n.properties.map(visit).join(",")+"}",Property:n=>{memberDepth+=1;const k=visit(n.key);memberDepth-=1;return k+":"+visit(n.value)}};function codegen(ast){const result={code:visit(ast),globals:Object.keys(globals),fields:Object.keys(fields)};globals={};fields={};return result}codegen.functions=functions;codegen.constants=constants;return codegen}const SELECTION_GETTER=Symbol("vega_selection_getter");function getter(f){if(!f.getter||!f.getter[SELECTION_GETTER]){f.getter=field$1(f.field);f.getter[SELECTION_GETTER]=true}return f.getter}const Intersect="intersect";const Union="union";const VlMulti="vlMulti";const VlPoint="vlPoint";const Or="or";const And="and";const SelectionId="_vgsid_";const $selectionId=field$1(SelectionId);const TYPE_ENUM="E",TYPE_RANGE_INC="R",TYPE_RANGE_EXC="R-E",TYPE_RANGE_LE="R-LE",TYPE_RANGE_RE="R-RE",UNIT_INDEX="index:unit";function testPoint(datum,entry){var fields=entry.fields,values=entry.values,n=fields.length,i=0,dval,f;for(;i<n;++i){f=fields[i];dval=getter(f)(datum);if(isDate$1(dval))dval=toNumber(dval);if(isDate$1(values[i]))values[i]=toNumber(values[i]);if(isArray(values[i])&&isDate$1(values[i][0]))values[i]=values[i].map(toNumber);if(f.type===TYPE_ENUM){if(isArray(values[i])?values[i].indexOf(dval)<0:dval!==values[i]){return false}}else{if(f.type===TYPE_RANGE_INC){if(!inrange(dval,values[i]))return false}else if(f.type===TYPE_RANGE_RE){if(!inrange(dval,values[i],true,false))return false}else if(f.type===TYPE_RANGE_EXC){if(!inrange(dval,values[i],false,false))return false}else if(f.type===TYPE_RANGE_LE){if(!inrange(dval,values[i],false,true))return false}}}return true}function selectionTest(name,datum,op){var data=this.context.data[name],entries=data?data.values.value:[],unitIdx=data?data[UNIT_INDEX]&&data[UNIT_INDEX].value:undefined,intersect=op===Intersect,n=entries.length,i=0,entry,miss,count,unit,b;for(;i<n;++i){entry=entries[i];if(unitIdx&&intersect){miss=miss||{};count=miss[unit=entry.unit]||0;if(count===-1)continue;b=testPoint(datum,entry);miss[unit]=b?-1:++count;if(b&&unitIdx.size===1)return true;if(!b&&count===unitIdx.get(unit).count)return false}else{b=testPoint(datum,entry);if(intersect^b)return b}}return n&&intersect}const bisect=bisector($selectionId),bisectLeft=bisect.left,bisectRight=bisect.right;function selectionIdTest(name,datum,op){const data=this.context.data[name],entries=data?data.values.value:[],unitIdx=data?data[UNIT_INDEX]&&data[UNIT_INDEX].value:undefined,intersect=op===Intersect,value=$selectionId(datum),index=bisectLeft(entries,value);if(index===entries.length)return false;if($selectionId(entries[index])!==value)return false;if(unitIdx&&intersect){if(unitIdx.size===1)return true;if(bisectRight(entries,value)-index<unitIdx.size)return false}return true}function selectionTuples(array,base){return array.map((x=>extend$1(base.fields?{values:base.fields.map((f=>getter(f)(x.datum)))}:{[SelectionId]:$selectionId(x.datum)},base)))}function selectionResolve(name,op,isMulti,vl5){var data=this.context.data[name],entries=data?data.values.value:[],resolved={},multiRes={},types={},entry,fields,values,unit,field,value,res,resUnit,type,union,n=entries.length,i=0,j,m;for(;i<n;++i){entry=entries[i];unit=entry.unit;fields=entry.fields;values=entry.values;if(fields&&values){for(j=0,m=fields.length;j<m;++j){field=fields[j];res=resolved[field.field]||(resolved[field.field]={});resUnit=res[unit]||(res[unit]=[]);types[field.field]=type=field.type.charAt(0);union=ops[`${type}_union`];res[unit]=union(resUnit,array$5(values[j]))}if(isMulti){resUnit=multiRes[unit]||(multiRes[unit]=[]);resUnit.push(array$5(values).reduce(((obj,curr,j)=>(obj[fields[j].field]=curr,obj)),{}))}}else{field=SelectionId;value=$selectionId(entry);res=resolved[field]||(resolved[field]={});resUnit=res[unit]||(res[unit]=[]);resUnit.push(value);if(isMulti){resUnit=multiRes[unit]||(multiRes[unit]=[]);resUnit.push({[SelectionId]:value})}}}op=op||Union;if(resolved[SelectionId]){resolved[SelectionId]=ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]))}else{Object.keys(resolved).forEach((field=>{resolved[field]=Object.keys(resolved[field]).map((unit=>resolved[field][unit])).reduce(((acc,curr)=>acc===undefined?curr:ops[`${types[field]}_${op}`](acc,curr)))}))}entries=Object.keys(multiRes);if(isMulti&&entries.length){const key=vl5?VlPoint:VlMulti;resolved[key]=op===Union?{[Or]:entries.reduce(((acc,k)=>(acc.push(...multiRes[k]),acc)),[])}:{[And]:entries.map((k=>({[Or]:multiRes[k]})))}}return resolved}var ops={[`${SelectionId}_union`]:union,[`${SelectionId}_intersect`]:intersection,E_union:function(base,value){if(!base.length)return value;var i=0,n=value.length;for(;i<n;++i)if(base.indexOf(value[i])<0)base.push(value[i]);return base},E_intersect:function(base,value){return!base.length?value:base.filter((v=>value.indexOf(v)>=0))},R_union:function(base,value){var lo=toNumber(value[0]),hi=toNumber(value[1]);if(lo>hi){lo=value[1];hi=value[0]}if(!base.length)return[lo,hi];if(base[0]>lo)base[0]=lo;if(base[1]<hi)base[1]=hi;return base},R_intersect:function(base,value){var lo=toNumber(value[0]),hi=toNumber(value[1]);if(lo>hi){lo=value[1];hi=value[0]}if(!base.length)return[lo,hi];if(hi<base[0]||base[1]<lo){return[]}else{if(base[0]<lo)base[0]=lo;if(base[1]>hi)base[1]=hi}return base}};const DataPrefix$1=":",IndexPrefix$1="@";function selectionVisitor(name,args,scope,params){if(args[0].type!==Literal)error("First argument to selection functions must be a string literal.");const data=args[0].value,op=args.length>=2&&peek$1(args).value,field="unit",indexName=IndexPrefix$1+field,dataName=DataPrefix$1+data;if(op===Intersect&&!has$1(params,indexName)){params[indexName]=scope.getData(data).indataRef(scope,field)}if(!has$1(params,dataName)){params[dataName]=scope.getData(data).tuplesRef()}}function data$1(name){const data=this.context.data[name];return data?data.values.value:[]}function indata(name,field,value){const index=this.context.data[name]["index:"+field],entry=index?index.value.get(value):undefined;return entry?entry.count:entry}function setdata(name,tuples){const df=this.context.dataflow,data=this.context.data[name],input=data.input;df.pulse(input,df.changeset().remove(truthy).insert(tuples));return 1}function encode(item,name,retval){if(item){const df=this.context.dataflow,target=item.mark.source;df.pulse(target,df.changeset().encode(item,name))}return retval!==undefined?retval:item}const wrap=method=>function(value,spec){const locale=this.context.dataflow.locale();return value===null?"null":locale[method](spec)(value)};const format=wrap("format");const timeFormat$1=wrap("timeFormat");const utcFormat=wrap("utcFormat");const timeParse=wrap("timeParse");const utcParse=wrap("utcParse");const dateObj=new Date(2e3,0,1);function time(month,day,specifier){if(!Number.isInteger(month)||!Number.isInteger(day))return"";dateObj.setYear(2e3);dateObj.setMonth(month);dateObj.setDate(day);return timeFormat$1.call(this,dateObj,specifier)}function monthFormat(month){return time.call(this,month,1,"%B")}function monthAbbrevFormat(month){return time.call(this,month,1,"%b")}function dayFormat(day){return time.call(this,0,2+day,"%A")}function dayAbbrevFormat(day){return time.call(this,0,2+day,"%a")}const DataPrefix=":";const IndexPrefix="@";const ScalePrefix="%";const SignalPrefix="$";function dataVisitor(name,args,scope,params){if(args[0].type!==Literal){error("First argument to data functions must be a string literal.")}const data=args[0].value,dataName=DataPrefix+data;if(!has$1(dataName,params)){try{params[dataName]=scope.getData(data).tuplesRef()}catch(err){}}}function indataVisitor(name,args,scope,params){if(args[0].type!==Literal)error("First argument to indata must be a string literal.");if(args[1].type!==Literal)error("Second argument to indata must be a string literal.");const data=args[0].value,field=args[1].value,indexName=IndexPrefix+field;if(!has$1(indexName,params)){params[indexName]=scope.getData(data).indataRef(scope,field)}}function scaleVisitor(name,args,scope,params){if(args[0].type===Literal){addScaleDependency(scope,params,args[0].value)}else{for(name in scope.scales){addScaleDependency(scope,params,name)}}}function addScaleDependency(scope,params,name){const scaleName=ScalePrefix+name;if(!has$1(params,scaleName)){try{params[scaleName]=scope.scaleRef(name)}catch(err){}}}function getScale(nameOrFunction,ctx){if(isFunction(nameOrFunction)){return nameOrFunction}if(isString(nameOrFunction)){const maybeScale=ctx.scales[nameOrFunction];return maybeScale&&isRegisteredScale(maybeScale.value)?maybeScale.value:undefined}return undefined}function internalScaleFunctions(codegen,fnctx,visitors){fnctx.__bandwidth=s=>s&&s.bandwidth?s.bandwidth():0;visitors._bandwidth=scaleVisitor;visitors._range=scaleVisitor;visitors._scale=scaleVisitor;const ref=arg=>"_["+(arg.type===Literal?$(ScalePrefix+arg.value):$(ScalePrefix)+"+"+codegen(arg))+"]";return{_bandwidth:args=>`this.__bandwidth(${ref(args[0])})`,_range:args=>`${ref(args[0])}.range()`,_scale:args=>`${ref(args[0])}(${codegen(args[1])})`}}function geoMethod(methodName,globalMethod){return function(projection,geojson,group){if(projection){const p=getScale(projection,(group||this).context);return p&&p.path[methodName](geojson)}else{return globalMethod(geojson)}}}const geoArea=geoMethod("area",geoArea$1);const geoBounds=geoMethod("bounds",geoBounds$1);const geoCentroid=geoMethod("centroid",geoCentroid$1);function geoScale(projection,group){const p=getScale(projection,(group||this).context);return p&&p.scale()}function inScope(item){const group=this.context.group;let value=false;if(group)while(item){if(item===group){value=true;break}item=item.mark.group}return value}function log(df,method,args){try{df[method].apply(df,["EXPRESSION"].concat([].slice.call(args)))}catch(err){df.warn(err)}return args[args.length-1]}function warn$1(){return log(this.context.dataflow,"warn",arguments)}function info(){return log(this.context.dataflow,"info",arguments)}function debug$1(){return log(this.context.dataflow,"debug",arguments)}function channel_luminance_value(channelValue){const val=channelValue/255;if(val<=.03928){return val/12.92}return Math.pow((val+.055)/1.055,2.4)}function luminance(color){const c=rgb$1(color),r=channel_luminance_value(c.r),g=channel_luminance_value(c.g),b=channel_luminance_value(c.b);return.2126*r+.7152*g+.0722*b}function contrast(color1,color2){const lum1=luminance(color1),lum2=luminance(color2),lumL=Math.max(lum1,lum2),lumD=Math.min(lum1,lum2);return(lumL+.05)/(lumD+.05)}function merge(){const args=[].slice.call(arguments);args.unshift({});return extend$1(...args)}function equal(a,b){return a===b||a!==a&&b!==b?true:isArray(a)?isArray(b)&&a.length===b.length?equalArray(a,b):false:isObject(a)&&isObject(b)?equalObject(a,b):false}function equalArray(a,b){for(let i=0,n=a.length;i<n;++i){if(!equal(a[i],b[i]))return false}return true}function equalObject(a,b){for(const key in a){if(!equal(a[key],b[key]))return false}return true}function removePredicate(props){return _=>equalObject(props,_)}function modify(name,insert,remove,toggle,modify,values){const df=this.context.dataflow,data=this.context.data[name],input=data.input,stamp=df.stamp();let changes=data.changes,predicate,key;if(df._trigger===false||!(input.value.length||insert||toggle)){return 0}if(!changes||changes.stamp<stamp){data.changes=changes=df.changeset();changes.stamp=stamp;df.runAfter((()=>{data.modified=true;df.pulse(input,changes).run()}),true,1)}if(remove){predicate=remove===true?truthy:isArray(remove)||isTuple(remove)?remove:removePredicate(remove);changes.remove(predicate)}if(insert){changes.insert(insert)}if(toggle){predicate=removePredicate(toggle);if(input.value.some(predicate)){changes.remove(predicate)}else{changes.insert(toggle)}}if(modify){for(key in values){changes.modify(modify,key,values[key])}}return 1}function pinchDistance(event){const t=event.touches,dx=t[0].clientX-t[1].clientX,dy=t[0].clientY-t[1].clientY;return Math.hypot(dx,dy)}function pinchAngle(event){const t=event.touches;return Math.atan2(t[0].clientY-t[1].clientY,t[0].clientX-t[1].clientX)}const accessors={};function pluck(data,name){const accessor=accessors[name]||(accessors[name]=field$1(name));return isArray(data)?data.map(accessor):accessor(data)}function array(seq){return isArray(seq)||ArrayBuffer.isView(seq)?seq:null}function sequence(seq){return array(seq)||(isString(seq)?seq:null)}function join(seq){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key]}return array(seq).join(...args)}function indexof(seq){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2]}return sequence(seq).indexOf(...args)}function lastindexof(seq){for(var _len3=arguments.length,args=new Array(_len3>1?_len3-1:0),_key3=1;_key3<_len3;_key3++){args[_key3-1]=arguments[_key3]}return sequence(seq).lastIndexOf(...args)}function slice(seq){for(var _len4=arguments.length,args=new Array(_len4>1?_len4-1:0),_key4=1;_key4<_len4;_key4++){args[_key4-1]=arguments[_key4]}return sequence(seq).slice(...args)}function replace(str,pattern,repl){if(isFunction(repl))error("Function argument passed to replace.");return String(str).replace(pattern,repl)}function reverse$1(seq){return array(seq).slice().reverse()}function bandspace(count,paddingInner,paddingOuter){return bandSpace(count||0,paddingInner||0,paddingOuter||0)}function bandwidth(name,group){const s=getScale(name,(group||this).context);return s&&s.bandwidth?s.bandwidth():0}function copy(name,group){const s=getScale(name,(group||this).context);return s?s.copy():undefined}function domain$2(name,group){const s=getScale(name,(group||this).context);return s?s.domain():[]}function invert(name,range,group){const s=getScale(name,(group||this).context);return!s?undefined:isArray(range)?(s.invertRange||s.invert)(range):(s.invert||s.invertExtent)(range)}function range$2(name,group){const s=getScale(name,(group||this).context);return s&&s.range?s.range():[]}function scale$2(name,value,group){const s=getScale(name,(group||this).context);return s?s(value):undefined}function scaleGradient(scale,p0,p1,count,group){scale=getScale(scale,(group||this).context);const gradient=Gradient$1(p0,p1);let stops=scale.domain(),min=stops[0],max=peek$1(stops),fraction=identity$6;if(!(max-min)){scale=(scale.interpolator?scale$4("sequential")().interpolator(scale.interpolator()):scale$4("linear")().interpolate(scale.interpolate()).range(scale.range())).domain([min=0,max=1])}else{fraction=scaleFraction(scale,min,max)}if(scale.ticks){stops=scale.ticks(+count||15);if(min!==stops[0])stops.unshift(min);if(max!==peek$1(stops))stops.push(max)}stops.forEach((_=>gradient.stop(fraction(_),scale(_))));return gradient}function geoShape(projection,geojson,group){const p=getScale(projection,(group||this).context);return function(context){return p?p.path.context(context)(geojson):""}}function pathShape(path){let p=null;return function(context){return context?pathRender(context,p=p||parse$3(path)):path}}const datum=d=>d.data;function treeNodes(name,context){const tree=data$1.call(context,name);return tree.root&&tree.root.lookup||{}}function treePath(name,source,target){const nodes=treeNodes(name,this),s=nodes[source],t=nodes[target];return s&&t?s.path(t).map(datum):undefined}function treeAncestors(name,node){const n=treeNodes(name,this)[node];return n?n.ancestors().map(datum):undefined}const _window=()=>typeof window!=="undefined"&&window||null;function screen(){const w=_window();return w?w.screen:{}}function windowSize(){const w=_window();return w?[w.innerWidth,w.innerHeight]:[undefined,undefined]}function containerSize(){const view=this.context.dataflow,el=view.container&&view.container();return el?[el.clientWidth,el.clientHeight]:[undefined,undefined]}function intersect(b,opt,group){if(!b)return[];const[u,v]=b,box=(new Bounds).set(u[0],u[1],v[0],v[1]),scene=group||this.context.dataflow.scenegraph().root;return intersect$2(scene,box,filter(opt))}function filter(opt){let p=null;if(opt){const types=array$5(opt.marktype),names=array$5(opt.markname);p=_=>(!types.length||types.some((t=>_.marktype===t)))&&(!names.length||names.some((s=>_.name===s)))}return p}function lassoAppend(lasso,x,y){let minDist=arguments.length>3&&arguments[3]!==undefined?arguments[3]:5;lasso=array$5(lasso);const last=lasso[lasso.length-1];return last===undefined||Math.hypot(last[0]-x,last[1]-y)>minDist?[...lasso,[x,y]]:lasso}function lassoPath(lasso){return array$5(lasso).reduce(((svg,_ref,i)=>{let[x,y]=_ref;return svg+=i==0?`M ${x},${y} `:i===lasso.length-1?" Z":`L ${x},${y} `}),"")}function intersectLasso(markname,pixelLasso,unit){const{x:x,y:y,mark:mark}=unit;const bb=(new Bounds).set(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);for(const[px,py]of pixelLasso){if(px<bb.x1)bb.x1=px;if(px>bb.x2)bb.x2=px;if(py<bb.y1)bb.y1=py;if(py>bb.y2)bb.y2=py}bb.translate(x,y);const intersection=intersect([[bb.x1,bb.y1],[bb.x2,bb.y2]],markname,mark);return intersection.filter((tuple=>pointInPolygon(tuple.x,tuple.y,pixelLasso)))}function pointInPolygon(testx,testy,polygon){let intersections=0;for(let i=0,j=polygon.length-1;i<polygon.length;j=i++){const[prevX,prevY]=polygon[j];const[x,y]=polygon[i];if(y>testy!=prevY>testy&&testx<(prevX-x)*(testy-y)/(prevY-y)+x){intersections++}}return intersections&1}const functionContext={random(){return random()},cumulativeNormal:cumulativeNormal,cumulativeLogNormal:cumulativeLogNormal,cumulativeUniform:cumulativeUniform,densityNormal:densityNormal,densityLogNormal:densityLogNormal,densityUniform:densityUniform,quantileNormal:quantileNormal,quantileLogNormal:quantileLogNormal,quantileUniform:quantileUniform,sampleNormal:sampleNormal,sampleLogNormal:sampleLogNormal,sampleUniform:sampleUniform,isArray:isArray,isBoolean:isBoolean$2,isDate:isDate$1,isDefined(_){return _!==undefined},isNumber:isNumber$1,isObject:isObject,isRegExp:isRegExp,isString:isString,isTuple:isTuple,isValid(_){return _!=null&&_===_},toBoolean:toBoolean,toDate(_){return toDate(_)},toNumber:toNumber,toString:toString$1,indexof:indexof,join:join,lastindexof:lastindexof,replace:replace,reverse:reverse$1,slice:slice,flush:flush,lerp:lerp,merge:merge,pad:pad$2,peek:peek$1,pluck:pluck,span:span,inrange:inrange,truncate:truncate$1,rgb:rgb$1,lab:lab$1,hcl:hcl$2,hsl:hsl$2,luminance:luminance,contrast:contrast,sequence:range$4,format:format,utcFormat:utcFormat,utcParse:utcParse,utcOffset:utcOffset,utcSequence:utcSequence,timeFormat:timeFormat$1,timeParse:timeParse,timeOffset:timeOffset,timeSequence:timeSequence,timeUnitSpecifier:timeUnitSpecifier,monthFormat:monthFormat,monthAbbrevFormat:monthAbbrevFormat,dayFormat:dayFormat,dayAbbrevFormat:dayAbbrevFormat,quarter:quarter,utcquarter:utcquarter,week:week,utcweek:utcweek,dayofyear:dayofyear,utcdayofyear:utcdayofyear,warn:warn$1,info:info,debug:debug$1,extent(_){return extent(_)},inScope:inScope,intersect:intersect,clampRange:clampRange,pinchDistance:pinchDistance,pinchAngle:pinchAngle,screen:screen,containerSize:containerSize,windowSize:windowSize,bandspace:bandspace,setdata:setdata,pathShape:pathShape,panLinear:panLinear,panLog:panLog,panPow:panPow,panSymlog:panSymlog,zoomLinear:zoomLinear,zoomLog:zoomLog,zoomPow:zoomPow,zoomSymlog:zoomSymlog,encode:encode,modify:modify,lassoAppend:lassoAppend,lassoPath:lassoPath,intersectLasso:intersectLasso};const eventFunctions=["view","item","group","xy","x","y"],eventPrefix="event.vega.",thisPrefix="this.",astVisitors={};const codegenParams={forbidden:["_"],allowed:["datum","event","item"],fieldvar:"datum",globalvar:id=>`_[${$(SignalPrefix+id)}]`,functions:buildFunctions,constants:Constants,visitors:astVisitors};const codeGenerator=codegen(codegenParams);function buildFunctions(codegen){const fn=Functions(codegen);eventFunctions.forEach((name=>fn[name]=eventPrefix+name));for(const name in functionContext){fn[name]=thisPrefix+name}extend$1(fn,internalScaleFunctions(codegen,functionContext,astVisitors));return fn}function expressionFunction(name,fn,visitor){if(arguments.length===1){return functionContext[name]}functionContext[name]=fn;if(visitor)astVisitors[name]=visitor;if(codeGenerator)codeGenerator.functions[name]=thisPrefix+name;return this}expressionFunction("bandwidth",bandwidth,scaleVisitor);expressionFunction("copy",copy,scaleVisitor);expressionFunction("domain",domain$2,scaleVisitor);expressionFunction("range",range$2,scaleVisitor);expressionFunction("invert",invert,scaleVisitor);expressionFunction("scale",scale$2,scaleVisitor);expressionFunction("gradient",scaleGradient,scaleVisitor);expressionFunction("geoArea",geoArea,scaleVisitor);expressionFunction("geoBounds",geoBounds,scaleVisitor);expressionFunction("geoCentroid",geoCentroid,scaleVisitor);expressionFunction("geoShape",geoShape,scaleVisitor);expressionFunction("geoScale",geoScale,scaleVisitor);expressionFunction("indata",indata,indataVisitor);expressionFunction("data",data$1,dataVisitor);expressionFunction("treePath",treePath,dataVisitor);expressionFunction("treeAncestors",treeAncestors,dataVisitor);expressionFunction("vlSelectionTest",selectionTest,selectionVisitor);expressionFunction("vlSelectionIdTest",selectionIdTest,selectionVisitor);expressionFunction("vlSelectionResolve",selectionResolve,selectionVisitor);expressionFunction("vlSelectionTuples",selectionTuples);function parser(expr,scope){const params={};let ast;try{expr=isString(expr)?expr:$(expr)+"";ast=parser$1(expr)}catch(err){error("Expression parse error: "+expr)}ast.visit((node=>{if(node.type!==CallExpression)return;const name=node.callee.name,visit=codegenParams.visitors[name];if(visit)visit(name,node.arguments,scope,params)}));const gen=codeGenerator(ast);gen.globals.forEach((name=>{const signalName=SignalPrefix+name;if(!has$1(params,signalName)&&scope.getSignal(name)){params[signalName]=scope.signalRef(name)}}));return{$expr:extend$1({code:gen.code},scope.options.ast?{ast:ast}:null),$fields:gen.fields,$params:params}}function parse$2(spec){const ctx=this,operators=spec.operators||[];if(spec.background){ctx.background=spec.background}if(spec.eventConfig){ctx.eventConfig=spec.eventConfig}if(spec.locale){ctx.locale=spec.locale}operators.forEach((entry=>ctx.parseOperator(entry)));operators.forEach((entry=>ctx.parseOperatorParameters(entry)));(spec.streams||[]).forEach((entry=>ctx.parseStream(entry)));(spec.updates||[]).forEach((entry=>ctx.parseUpdate(entry)));return ctx.resolve()}const Skip$2=toSet(["rule"]),Swap=toSet(["group","image","rect"]);function adjustSpatial(encode,marktype){let code="";if(Skip$2[marktype])return code;if(encode.x2){if(encode.x){if(Swap[marktype]){code+="if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"}code+="o.width=o.x2-o.x;"}else{code+="o.x=o.x2-(o.width||0);"}}if(encode.xc){code+="o.x=o.xc-(o.width||0)/2;"}if(encode.y2){if(encode.y){if(Swap[marktype]){code+="if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"}code+="o.height=o.y2-o.y;"}else{code+="o.y=o.y2-(o.height||0);"}}if(encode.yc){code+="o.y=o.yc-(o.height||0)/2;"}return code}function canonicalType(type){return(type+"").toLowerCase()}function isOperator(type){return canonicalType(type)==="operator"}function isCollect(type){return canonicalType(type)==="collect"}function expression$1(ctx,args,code){if(!code.endsWith(";")){code="return("+code+");"}const fn=Function(...args.concat(code));return ctx&&ctx.functions?fn.bind(ctx.functions):fn}function _compare(u,v,lt,gt){return`((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\n  : (u > v || v == null) && u != null ? ${gt}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\n  : v !== v && u === u ? ${gt} : `}var expressionCodegen={operator:(ctx,expr)=>expression$1(ctx,["_"],expr.code),parameter:(ctx,expr)=>expression$1(ctx,["datum","_"],expr.code),event:(ctx,expr)=>expression$1(ctx,["event"],expr.code),handler:(ctx,expr)=>{const code=`var datum=event.item&&event.item.datum;return ${expr.code};`;return expression$1(ctx,["_","event"],code)},encode:(ctx,encode)=>{const{marktype:marktype,channels:channels}=encode;let code="var o=item,datum=o.datum,m=0,$;";for(const name in channels){const o="o["+$(name)+"]";code+=`$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`}code+=adjustSpatial(channels,marktype);code+="return m;";return expression$1(ctx,["item","_"],code)},codegen:{get(path){const ref=`[${path.map($).join("][")}]`;const get=Function("_",`return _${ref};`);get.path=ref;return get},comparator(fields,orders){let t;const map=(f,i)=>{const o=orders[i];let u,v;if(f.path){u=`a${f.path}`;v=`b${f.path}`}else{(t=t||{})["f"+i]=f;u=`this.f${i}(a)`;v=`this.f${i}(b)`}return _compare(u,v,-o,o)};const fn=Function("a","b","var u, v; return "+fields.map(map).join("")+"0;");return t?fn.bind(t):fn}}};function parseOperator(spec){const ctx=this;if(isOperator(spec.type)||!spec.type){ctx.operator(spec,spec.update?ctx.operatorExpression(spec.update):null)}else{ctx.transform(spec,spec.type)}}function parseOperatorParameters(spec){const ctx=this;if(spec.params){const op=ctx.get(spec.id);if(!op)error("Invalid operator id: "+spec.id);ctx.dataflow.connect(op,op.parameters(ctx.parseParameters(spec.params),spec.react,spec.initonly))}}function parseParameters$1(spec,params){params=params||{};const ctx=this;for(const key in spec){const value=spec[key];params[key]=isArray(value)?value.map((v=>parseParameter$2(v,ctx,params))):parseParameter$2(value,ctx,params)}return params}function parseParameter$2(spec,ctx,params){if(!spec||!isObject(spec))return spec;for(let i=0,n=PARSERS.length,p;i<n;++i){p=PARSERS[i];if(has$1(spec,p.key)){return p.parse(spec,ctx,params)}}return spec}var PARSERS=[{key:"$ref",parse:getOperator},{key:"$key",parse:getKey},{key:"$expr",parse:getExpression},{key:"$field",parse:getField},{key:"$encode",parse:getEncode},{key:"$compare",parse:getCompare},{key:"$context",parse:getContext},{key:"$subflow",parse:getSubflow},{key:"$tupleid",parse:getTupleId}];function getOperator(_,ctx){return ctx.get(_.$ref)||error("Operator not defined: "+_.$ref)}function getExpression(_,ctx,params){if(_.$params){ctx.parseParameters(_.$params,params)}const k="e:"+_.$expr.code;return ctx.fn[k]||(ctx.fn[k]=accessor(ctx.parameterExpression(_.$expr),_.$fields))}function getKey(_,ctx){const k="k:"+_.$key+"_"+!!_.$flat;return ctx.fn[k]||(ctx.fn[k]=key(_.$key,_.$flat,ctx.expr.codegen))}function getField(_,ctx){if(!_.$field)return null;const k="f:"+_.$field+"_"+_.$name;return ctx.fn[k]||(ctx.fn[k]=field$1(_.$field,_.$name,ctx.expr.codegen))}function getCompare(_,ctx){const k="c:"+_.$compare+"_"+_.$order,c=array$5(_.$compare).map((_=>_&&_.$tupleid?tupleid:_));return ctx.fn[k]||(ctx.fn[k]=compare$1(c,_.$order,ctx.expr.codegen))}function getEncode(_,ctx){const spec=_.$encode,encode={};for(const name in spec){const enc=spec[name];encode[name]=accessor(ctx.encodeExpression(enc.$expr),enc.$fields);encode[name].output=enc.$output}return encode}function getContext(_,ctx){return ctx}function getSubflow(_,ctx){const spec=_.$subflow;return function(dataflow,key,parent){const subctx=ctx.fork().parse(spec),op=subctx.get(spec.operators[0].id),p=subctx.signals.parent;if(p)p.set(parent);op.detachSubflow=()=>ctx.detach(subctx);return op}}function getTupleId(){return tupleid}function parseStream$2(spec){var ctx=this,filter=spec.filter!=null?ctx.eventExpression(spec.filter):undefined,stream=spec.stream!=null?ctx.get(spec.stream):undefined,args;if(spec.source){stream=ctx.events(spec.source,spec.type,filter)}else if(spec.merge){args=spec.merge.map((_=>ctx.get(_)));stream=args[0].merge.apply(args[0],args.slice(1))}if(spec.between){args=spec.between.map((_=>ctx.get(_)));stream=stream.between(args[0],args[1])}if(spec.filter){stream=stream.filter(filter)}if(spec.throttle!=null){stream=stream.throttle(+spec.throttle)}if(spec.debounce!=null){stream=stream.debounce(+spec.debounce)}if(stream==null){error("Invalid stream definition: "+JSON.stringify(spec))}if(spec.consume)stream.consume(true);ctx.stream(spec,stream)}function parseUpdate$1(spec){var ctx=this,srcid=isObject(srcid=spec.source)?srcid.$ref:srcid,source=ctx.get(srcid),target=null,update=spec.update,params=undefined;if(!source)error("Source not defined: "+spec.source);target=spec.target&&spec.target.$expr?ctx.eventExpression(spec.target.$expr):ctx.get(spec.target);if(update&&update.$expr){if(update.$params){params=ctx.parseParameters(update.$params)}update=ctx.handlerExpression(update.$expr)}ctx.update(spec,source,target,update,params)}const SKIP={skip:true};function getState$1(options){var ctx=this,state={};if(options.signals){var signals=state.signals={};Object.keys(ctx.signals).forEach((key=>{const op=ctx.signals[key];if(options.signals(key,op)){signals[key]=op.value}}))}if(options.data){var data=state.data={};Object.keys(ctx.data).forEach((key=>{const dataset=ctx.data[key];if(options.data(key,dataset)){data[key]=dataset.input.value}}))}if(ctx.subcontext&&options.recurse!==false){state.subcontext=ctx.subcontext.map((ctx=>ctx.getState(options)))}return state}function setState$1(state){var ctx=this,df=ctx.dataflow,data=state.data,signals=state.signals;Object.keys(signals||{}).forEach((key=>{df.update(ctx.signals[key],signals[key],SKIP)}));Object.keys(data||{}).forEach((key=>{df.pulse(ctx.data[key].input,df.changeset().remove(truthy).insert(data[key]))}));(state.subcontext||[]).forEach(((substate,i)=>{const subctx=ctx.subcontext[i];if(subctx)subctx.setState(substate)}))}function context(df,transforms,functions,expr){return new Context(df,transforms,functions,expr)}function Context(df,transforms,functions,expr){this.dataflow=df;this.transforms=transforms;this.events=df.events.bind(df);this.expr=expr||expressionCodegen,this.signals={};this.scales={};this.nodes={};this.data={};this.fn={};if(functions){this.functions=Object.create(functions);this.functions.context=this}}function Subcontext(ctx){this.dataflow=ctx.dataflow;this.transforms=ctx.transforms;this.events=ctx.events;this.expr=ctx.expr;this.signals=Object.create(ctx.signals);this.scales=Object.create(ctx.scales);this.nodes=Object.create(ctx.nodes);this.data=Object.create(ctx.data);this.fn=Object.create(ctx.fn);if(ctx.functions){this.functions=Object.create(ctx.functions);this.functions.context=this}}Context.prototype=Subcontext.prototype={fork(){const ctx=new Subcontext(this);(this.subcontext||(this.subcontext=[])).push(ctx);return ctx},detach(ctx){this.subcontext=this.subcontext.filter((c=>c!==ctx));const keys=Object.keys(ctx.nodes);for(const key of keys)ctx.nodes[key]._targets=null;for(const key of keys)ctx.nodes[key].detach();ctx.nodes=null},get(id){return this.nodes[id]},set(id,node){return this.nodes[id]=node},add(spec,op){const ctx=this,df=ctx.dataflow,data=spec.value;ctx.set(spec.id,op);if(isCollect(spec.type)&&data){if(data.$ingest){df.ingest(op,data.$ingest,data.$format)}else if(data.$request){df.preload(op,data.$request,data.$format)}else{df.pulse(op,df.changeset().insert(data))}}if(spec.root){ctx.root=op}if(spec.parent){let p=ctx.get(spec.parent.$ref);if(p){df.connect(p,[op]);op.targets().add(p)}else{(ctx.unresolved=ctx.unresolved||[]).push((()=>{p=ctx.get(spec.parent.$ref);df.connect(p,[op]);op.targets().add(p)}))}}if(spec.signal){ctx.signals[spec.signal]=op}if(spec.scale){ctx.scales[spec.scale]=op}if(spec.data){for(const name in spec.data){const data=ctx.data[name]||(ctx.data[name]={});spec.data[name].forEach((role=>data[role]=op))}}},resolve(){(this.unresolved||[]).forEach((fn=>fn()));delete this.unresolved;return this},operator(spec,update){this.add(spec,this.dataflow.add(spec.value,update))},transform(spec,type){this.add(spec,this.dataflow.add(this.transforms[canonicalType(type)]))},stream(spec,stream){this.set(spec.id,stream)},update(spec,stream,target,update,params){this.dataflow.on(stream,target,update,params,spec.options)},operatorExpression(expr){return this.expr.operator(this,expr)},parameterExpression(expr){return this.expr.parameter(this,expr)},eventExpression(expr){return this.expr.event(this,expr)},handlerExpression(expr){return this.expr.handler(this,expr)},encodeExpression(encode){return this.expr.encode(this,encode)},parse:parse$2,parseOperator:parseOperator,parseOperatorParameters:parseOperatorParameters,parseParameters:parseParameters$1,parseStream:parseStream$2,parseUpdate:parseUpdate$1,getState:getState$1,setState:setState$1};function initializeAria(view){const el=view.container();if(el){el.setAttribute("role","graphics-document");el.setAttribute("aria-roleDescription","visualization");ariaLabel(el,view.description())}}function ariaLabel(el,desc){if(el)desc==null?el.removeAttribute("aria-label"):el.setAttribute("aria-label",desc)}function background(view){view.add(null,(_=>{view._background=_.bg;view._resize=1;return _.bg}),{bg:view._signals.background})}const Default="default";function cursor$1(view){const cursor=view._signals.cursor||(view._signals.cursor=view.add({user:Default,item:null}));view.on(view.events("view","pointermove"),cursor,((_,event)=>{const value=cursor.value,user=value?isString(value)?value:value.user:Default,item=event.item&&event.item.cursor||null;return value&&user===value.user&&item==value.item?value:{user:user,item:item}}));view.add(null,(function(_){let user=_.cursor,item=this.value;if(!isString(user)){item=user.item;user=user.user}setCursor(view,user&&user!==Default?user:item||user);return item}),{cursor:cursor})}function setCursor(view,cursor){const el=view.globalCursor()?typeof document!=="undefined"&&document.body:view.container();if(el){return cursor==null?el.style.removeProperty("cursor"):el.style.cursor=cursor}}function dataref(view,name){var data=view._runtime.data;if(!has$1(data,name)){error("Unrecognized data set: "+name)}return data[name]}function data(name,values){return arguments.length<2?dataref(this,name).values.value:change.call(this,name,changeset().remove(truthy).insert(values))}function change(name,changes){if(!isChangeSet(changes)){error("Second argument to changes must be a changeset.")}const dataset=dataref(this,name);dataset.modified=true;return this.pulse(dataset.input,changes)}function insert(name,_){return change.call(this,name,changeset().insert(_))}function remove(name,_){return change.call(this,name,changeset().remove(_))}function width(view){var padding=view.padding();return Math.max(0,view._viewWidth+padding.left+padding.right)}function height(view){var padding=view.padding();return Math.max(0,view._viewHeight+padding.top+padding.bottom)}function offset(view){var padding=view.padding(),origin=view._origin;return[padding.left+origin[0],padding.top+origin[1]]}function resizeRenderer(view){var origin=offset(view),w=width(view),h=height(view);view._renderer.background(view.background());view._renderer.resize(w,h,origin);view._handler.origin(origin);view._resizeListeners.forEach((handler=>{try{handler(w,h)}catch(error){view.error(error)}}))}function eventExtend(view,event,item){var r=view._renderer,el=r&&r.canvas(),p,e,translate;if(el){translate=offset(view);e=event.changedTouches?event.changedTouches[0]:event;p=point$2(e,el);p[0]-=translate[0];p[1]-=translate[1]}event.dataflow=view;event.item=item;event.vega=extension(view,item,p);return event}function extension(view,item,point){const itemGroup=item?item.mark.marktype==="group"?item:item.mark.group:null;function group(name){var g=itemGroup,i;if(name)for(i=item;i;i=i.mark.group){if(i.mark.name===name){g=i;break}}return g&&g.mark&&g.mark.interactive?g:{}}function xy(item){if(!item)return point;if(isString(item))item=group(item);const p=point.slice();while(item){p[0]-=item.x||0;p[1]-=item.y||0;item=item.mark&&item.mark.group}return p}return{view:constant$5(view),item:constant$5(item||{}),group:group,xy:xy,x:item=>xy(item)[0],y:item=>xy(item)[1]}}const VIEW$1="view",TIMER="timer",WINDOW="window",NO_TRAP={trap:false};function initializeEventConfig(config){const events=extend$1({defaults:{}},config);const unpack=(obj,keys)=>{keys.forEach((k=>{if(isArray(obj[k]))obj[k]=toSet(obj[k])}))};unpack(events.defaults,["prevent","allow"]);unpack(events,["view","window","selector"]);return events}function trackEventListener(view,sources,type,handler){view._eventListeners.push({type:type,sources:array$5(sources),handler:handler})}function prevent(view,type){var def=view._eventConfig.defaults,prevent=def.prevent,allow=def.allow;return prevent===false||allow===true?false:prevent===true||allow===false?true:prevent?prevent[type]:allow?!allow[type]:view.preventDefault()}function permit(view,key,type){const rule=view._eventConfig&&view._eventConfig[key];if(rule===false||isObject(rule)&&!rule[type]){view.warn(`Blocked ${key} ${type} event listener.`);return false}return true}function events(source,type,filter){var view=this,s=new EventStream(filter),send=function(e,item){view.runAsync(null,(()=>{if(source===VIEW$1&&prevent(view,type)){e.preventDefault()}s.receive(eventExtend(view,e,item))}))},sources;if(source===TIMER){if(permit(view,"timer",type)){view.timer(send,type)}}else if(source===VIEW$1){if(permit(view,"view",type)){view.addEventListener(type,send,NO_TRAP)}}else{if(source===WINDOW){if(permit(view,"window",type)&&typeof window!=="undefined"){sources=[window]}}else if(typeof document!=="undefined"){if(permit(view,"selector",type)){sources=Array.from(document.querySelectorAll(source))}}if(!sources){view.warn("Can not resolve event source: "+source)}else{for(var i=0,n=sources.length;i<n;++i){sources[i].addEventListener(type,send)}trackEventListener(view,sources,type,send)}}return s}function itemFilter(event){return event.item}function markTarget(event){return event.item.mark.source}function invoke(name){return function(_,event){return event.vega.view().changeset().encode(event.item,name)}}function hover(hoverSet,leaveSet){hoverSet=[hoverSet||"hover"];leaveSet=[leaveSet||"update",hoverSet[0]];this.on(this.events("view","pointerover",itemFilter),markTarget,invoke(hoverSet));this.on(this.events("view","pointerout",itemFilter),markTarget,invoke(leaveSet));return this}function finalize(){var tooltip=this._tooltip,timers=this._timers,handlers=this._handler.handlers(),listeners=this._eventListeners,n,m,e,h,t;n=timers.length;while(--n>=0){timers[n].stop()}n=listeners.length;while(--n>=0){e=listeners[n];m=e.sources.length;while(--m>=0){e.sources[m].removeEventListener(e.type,e.handler)}}if(tooltip){tooltip.call(this,this._handler,null,null,null)}n=handlers.length;while(--n>=0){t=handlers[n].type;h=handlers[n].handler;this._handler.off(t,h)}return this}function element(tag,attr,text){const el=document.createElement(tag);for(const key in attr)el.setAttribute(key,attr[key]);if(text!=null)el.textContent=text;return el}const BindClass="vega-bind",NameClass="vega-bind-name",RadioClass="vega-bind-radio";function bind(view,el,binding){if(!el)return;const param=binding.param;let bind=binding.state;if(!bind){bind=binding.state={elements:null,active:false,set:null,update:value=>{if(value!=view.signal(param.signal)){view.runAsync(null,(()=>{bind.source=true;view.signal(param.signal,value)}))}}};if(param.debounce){bind.update=debounce(param.debounce,bind.update)}}const create=param.input==null&&param.element?target:generate;create(bind,el,param,view);if(!bind.active){view.on(view._signals[param.signal],null,(()=>{bind.source?bind.source=false:bind.set(view.signal(param.signal))}));bind.active=true}return bind}function target(bind,node,param,view){const type=param.event||"input";const handler=()=>bind.update(node.value);view.signal(param.signal,node.value);node.addEventListener(type,handler);trackEventListener(view,node,type,handler);bind.set=value=>{node.value=value;node.dispatchEvent(event(type))}}function event(type){return typeof Event!=="undefined"?new Event(type):{type:type}}function generate(bind,el,param,view){const value=view.signal(param.signal);const div=element("div",{class:BindClass});const wrapper=param.input==="radio"?div:div.appendChild(element("label"));wrapper.appendChild(element("span",{class:NameClass},param.name||param.signal));el.appendChild(div);let input=form;switch(param.input){case"checkbox":input=checkbox;break;case"select":input=select;break;case"radio":input=radio;break;case"range":input=range$1;break}input(bind,wrapper,param,value)}function form(bind,el,param,value){const node=element("input");for(const key in param){if(key!=="signal"&&key!=="element"){node.setAttribute(key==="input"?"type":key,param[key])}}node.setAttribute("name",param.signal);node.value=value;el.appendChild(node);node.addEventListener("input",(()=>bind.update(node.value)));bind.elements=[node];bind.set=value=>node.value=value}function checkbox(bind,el,param,value){const attr={type:"checkbox",name:param.signal};if(value)attr.checked=true;const node=element("input",attr);el.appendChild(node);node.addEventListener("change",(()=>bind.update(node.checked)));bind.elements=[node];bind.set=value=>node.checked=!!value||null}function select(bind,el,param,value){const node=element("select",{name:param.signal}),labels=param.labels||[];param.options.forEach(((option,i)=>{const attr={value:option};if(valuesEqual(option,value))attr.selected=true;node.appendChild(element("option",attr,(labels[i]||option)+""))}));el.appendChild(node);node.addEventListener("change",(()=>{bind.update(param.options[node.selectedIndex])}));bind.elements=[node];bind.set=value=>{for(let i=0,n=param.options.length;i<n;++i){if(valuesEqual(param.options[i],value)){node.selectedIndex=i;return}}}}function radio(bind,el,param,value){const group=element("span",{class:RadioClass}),labels=param.labels||[];el.appendChild(group);bind.elements=param.options.map(((option,i)=>{const attr={type:"radio",name:param.signal,value:option};if(valuesEqual(option,value))attr.checked=true;const input=element("input",attr);input.addEventListener("change",(()=>bind.update(option)));const label=element("label",{},(labels[i]||option)+"");label.prepend(input);group.appendChild(label);return input}));bind.set=value=>{const nodes=bind.elements,n=nodes.length;for(let i=0;i<n;++i){if(valuesEqual(nodes[i].value,value))nodes[i].checked=true}}}function range$1(bind,el,param,value){value=value!==undefined?value:(+param.max+ +param.min)/2;const max=param.max!=null?param.max:Math.max(100,+value)||100,min=param.min||Math.min(0,max,+value)||0,step=param.step||tickStep(min,max,100);const node=element("input",{type:"range",name:param.signal,min:min,max:max,step:step});node.value=value;const span=element("span",{},+value);el.appendChild(node);el.appendChild(span);const update=()=>{span.textContent=node.value;bind.update(+node.value)};node.addEventListener("input",update);node.addEventListener("change",update);bind.elements=[node];bind.set=value=>{node.value=value;span.textContent=value}}function valuesEqual(a,b){return a===b||a+""===b+""}function initializeRenderer(view,r,el,constructor,scaleFactor,opt){r=r||new constructor(view.loader());return r.initialize(el,width(view),height(view),offset(view),scaleFactor,opt).background(view.background())}function trap(view,fn){return!fn?null:function(){try{fn.apply(this,arguments)}catch(error){view.error(error)}}}function initializeHandler(view,prevHandler,el,constructor){const handler=new constructor(view.loader(),trap(view,view.tooltip())).scene(view.scenegraph().root).initialize(el,offset(view),view);if(prevHandler){prevHandler.handlers().forEach((h=>{handler.on(h.type,h.handler)}))}return handler}function initialize(el,elBind){const view=this,type=view._renderType,config=view._eventConfig.bind,module=renderModule(type);el=view._el=el?lookup$1(view,el,true):null;initializeAria(view);if(!module)view.error("Unrecognized renderer type: "+type);const Handler=module.handler||CanvasHandler,Renderer=el?module.renderer:module.headless;view._renderer=!Renderer?null:initializeRenderer(view,view._renderer,el,Renderer);view._handler=initializeHandler(view,view._handler,el,Handler);view._redraw=true;if(el&&config!=="none"){elBind=elBind?view._elBind=lookup$1(view,elBind,true):el.appendChild(element("form",{class:"vega-bindings"}));view._bind.forEach((_=>{if(_.param.element&&config!=="container"){_.element=lookup$1(view,_.param.element,!!_.param.input)}}));view._bind.forEach((_=>{bind(view,_.element||elBind,_)}))}return view}function lookup$1(view,el,clear){if(typeof el==="string"){if(typeof document!=="undefined"){el=document.querySelector(el);if(!el){view.error("Signal bind element not found: "+el);return null}}else{view.error("DOM document instance not found.");return null}}if(el&&clear){try{el.textContent=""}catch(e){el=null;view.error(e)}}return el}const number$1=_=>+_||0;const paddingObject$1=_=>({top:_,bottom:_,left:_,right:_});function padding$1(_){return isObject(_)?{top:number$1(_.top),bottom:number$1(_.bottom),left:number$1(_.left),right:number$1(_.right)}:paddingObject$1(number$1(_))}async function renderHeadless(view,type,scaleFactor,opt){const module=renderModule(type),ctr=module&&module.headless;if(!ctr)error("Unrecognized renderer type: "+type);await view.runAsync();return initializeRenderer(view,null,null,ctr,scaleFactor,opt).renderAsync(view._scenegraph.root)}async function renderToImageURL(type,scaleFactor){if(type!==RenderType.Canvas&&type!==RenderType.SVG&&type!==RenderType.PNG){error("Unrecognized image type: "+type)}const r=await renderHeadless(this,type,scaleFactor);return type===RenderType.SVG?toBlobURL(r.svg(),"image/svg+xml"):r.canvas().toDataURL("image/png")}function toBlobURL(data,mime){const blob=new Blob([data],{type:mime});return window.URL.createObjectURL(blob)}async function renderToCanvas(scaleFactor,opt){const r=await renderHeadless(this,RenderType.Canvas,scaleFactor,opt);return r.canvas()}async function renderToSVG(scaleFactor){const r=await renderHeadless(this,RenderType.SVG,scaleFactor);return r.svg()}function runtime(view,spec,expr){return context(view,transforms,functionContext,expr).parse(spec)}function scale$1(name){var scales=this._runtime.scales;if(!has$1(scales,name)){error("Unrecognized scale or projection: "+name)}return scales[name].value}var Width="width",Height="height",Padding="padding",Skip$1={skip:true};function viewWidth(view,width){var a=view.autosize(),p=view.padding();return width-(a&&a.contains===Padding?p.left+p.right:0)}function viewHeight(view,height){var a=view.autosize(),p=view.padding();return height-(a&&a.contains===Padding?p.top+p.bottom:0)}function initializeResize(view){var s=view._signals,w=s[Width],h=s[Height],p=s[Padding];function resetSize(){view._autosize=view._resize=1}view._resizeWidth=view.add(null,(_=>{view._width=_.size;view._viewWidth=viewWidth(view,_.size);resetSize()}),{size:w});view._resizeHeight=view.add(null,(_=>{view._height=_.size;view._viewHeight=viewHeight(view,_.size);resetSize()}),{size:h});const resizePadding=view.add(null,resetSize,{pad:p});view._resizeWidth.rank=w.rank+1;view._resizeHeight.rank=h.rank+1;resizePadding.rank=p.rank+1}function resizeView(viewWidth,viewHeight,width,height,origin,auto){this.runAfter((view=>{let rerun=0;view._autosize=0;if(view.width()!==width){rerun=1;view.signal(Width,width,Skip$1);view._resizeWidth.skip(true)}if(view.height()!==height){rerun=1;view.signal(Height,height,Skip$1);view._resizeHeight.skip(true)}if(view._viewWidth!==viewWidth){view._resize=1;view._viewWidth=viewWidth}if(view._viewHeight!==viewHeight){view._resize=1;view._viewHeight=viewHeight}if(view._origin[0]!==origin[0]||view._origin[1]!==origin[1]){view._resize=1;view._origin=origin}if(rerun)view.run("enter");if(auto)view.runAfter((v=>v.resize()))}),false,1)}function getState(options){return this._runtime.getState(options||{data:dataTest,signals:signalTest,recurse:true})}function dataTest(name,data){return data.modified&&isArray(data.input.value)&&!name.startsWith("_:vega:_")}function signalTest(name,op){return!(name==="parent"||op instanceof transforms.proxy)}function setState(state){this.runAsync(null,(v=>{v._trigger=false;v._runtime.setState(state)}),(v=>{v._trigger=true}));return this}function timer(callback,delay){function tick(elapsed){callback({timestamp:Date.now(),elapsed:elapsed})}this._timers.push(interval$1(tick,delay))}function defaultTooltip(handler,event,item,value){const el=handler.element();if(el)el.setAttribute("title",formatTooltip(value))}function formatTooltip(value){return value==null?"":isArray(value)?formatArray(value):isObject(value)&&!isDate$1(value)?formatObject(value):value+""}function formatObject(obj){return Object.keys(obj).map((key=>{const v=obj[key];return key+": "+(isArray(v)?formatArray(v):formatValue(v))})).join("\n")}function formatArray(value){return"["+value.map(formatValue).join(", ")+"]"}function formatValue(value){return isArray(value)?"[…]":isObject(value)&&!isDate$1(value)?"{…}":value}function watchPixelRatio(){if(this.renderer()==="canvas"&&this._renderer._canvas){let remove=null;const updatePixelRatio=()=>{if(remove!=null){remove()}const media=matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);media.addEventListener("change",updatePixelRatio);remove=()=>{media.removeEventListener("change",updatePixelRatio)};this._renderer._canvas.getContext("2d").pixelRatio=window.devicePixelRatio||1;this._redraw=true;this._resize=1;this.resize().runAsync()};updatePixelRatio()}}function View$1(spec,options){const view=this;options=options||{};Dataflow.call(view);if(options.loader)view.loader(options.loader);if(options.logger)view.logger(options.logger);if(options.logLevel!=null)view.logLevel(options.logLevel);if(options.locale||spec.locale){const loc=extend$1({},spec.locale,options.locale);view.locale(locale(loc.number,loc.time))}view._el=null;view._elBind=null;view._renderType=options.renderer||RenderType.Canvas;view._scenegraph=new Scenegraph;const root=view._scenegraph.root;view._renderer=null;view._tooltip=options.tooltip||defaultTooltip,view._redraw=true;view._handler=(new CanvasHandler).scene(root);view._globalCursor=false;view._preventDefault=false;view._timers=[];view._eventListeners=[];view._resizeListeners=[];view._eventConfig=initializeEventConfig(spec.eventConfig);view.globalCursor(view._eventConfig.globalCursor);const ctx=runtime(view,spec,options.expr);view._runtime=ctx;view._signals=ctx.signals;view._bind=(spec.bindings||[]).map((_=>({state:null,param:extend$1({},_)})));if(ctx.root)ctx.root.set(root);root.source=ctx.data.root.input;view.pulse(ctx.data.root.input,view.changeset().insert(root.items));view._width=view.width();view._height=view.height();view._viewWidth=viewWidth(view,view._width);view._viewHeight=viewHeight(view,view._height);view._origin=[0,0];view._resize=0;view._autosize=1;initializeResize(view);background(view);cursor$1(view);view.description(spec.description);if(options.hover)view.hover();if(options.container)view.initialize(options.container,options.bind);if(options.watchPixelRatio)view._watchPixelRatio()}function lookupSignal(view,name){return has$1(view._signals,name)?view._signals[name]:error("Unrecognized signal name: "+$(name))}function findOperatorHandler(op,handler){const h=(op._targets||[]).filter((op=>op._update&&op._update.handler===handler));return h.length?h[0]:null}function addOperatorListener(view,name,op,handler){let h=findOperatorHandler(op,handler);if(!h){h=trap(view,(()=>handler(name,op.value)));h.handler=handler;view.on(op,null,h)}return view}function removeOperatorListener(view,op,handler){const h=findOperatorHandler(op,handler);if(h)op._targets.remove(h);return view}inherits(View$1,Dataflow,{async evaluate(encode,prerun,postrun){await Dataflow.prototype.evaluate.call(this,encode,prerun);if(this._redraw||this._resize){try{if(this._renderer){if(this._resize){this._resize=0;resizeRenderer(this)}await this._renderer.renderAsync(this._scenegraph.root)}this._redraw=false}catch(e){this.error(e)}}if(postrun)asyncCallback(this,postrun);return this},dirty(item){this._redraw=true;this._renderer&&this._renderer.dirty(item)},description(text){if(arguments.length){const desc=text!=null?text+"":null;if(desc!==this._desc)ariaLabel(this._el,this._desc=desc);return this}return this._desc},container(){return this._el},scenegraph(){return this._scenegraph},origin(){return this._origin.slice()},signal(name,value,options){const op=lookupSignal(this,name);return arguments.length===1?op.value:this.update(op,value,options)},width(_){return arguments.length?this.signal("width",_):this.signal("width")},height(_){return arguments.length?this.signal("height",_):this.signal("height")},padding(_){return arguments.length?this.signal("padding",padding$1(_)):padding$1(this.signal("padding"))},autosize(_){return arguments.length?this.signal("autosize",_):this.signal("autosize")},background(_){return arguments.length?this.signal("background",_):this.signal("background")},renderer(type){if(!arguments.length)return this._renderType;if(!renderModule(type))error("Unrecognized renderer type: "+type);if(type!==this._renderType){this._renderType=type;this._resetRenderer()}return this},tooltip(handler){if(!arguments.length)return this._tooltip;if(handler!==this._tooltip){this._tooltip=handler;this._resetRenderer()}return this},loader(loader){if(!arguments.length)return this._loader;if(loader!==this._loader){Dataflow.prototype.loader.call(this,loader);this._resetRenderer()}return this},resize(){this._autosize=1;return this.touch(lookupSignal(this,"autosize"))},_resetRenderer(){if(this._renderer){this._renderer=null;this.initialize(this._el,this._elBind)}},_resizeView:resizeView,addEventListener(type,handler,options){let callback=handler;if(!(options&&options.trap===false)){callback=trap(this,handler);callback.raw=handler}this._handler.on(type,callback);return this},removeEventListener(type,handler){var handlers=this._handler.handlers(type),i=handlers.length,h,t;while(--i>=0){t=handlers[i].type;h=handlers[i].handler;if(type===t&&(handler===h||handler===h.raw)){this._handler.off(t,h);break}}return this},addResizeListener(handler){const l=this._resizeListeners;if(!l.includes(handler)){l.push(handler)}return this},removeResizeListener(handler){var l=this._resizeListeners,i=l.indexOf(handler);if(i>=0){l.splice(i,1)}return this},addSignalListener(name,handler){return addOperatorListener(this,name,lookupSignal(this,name),handler)},removeSignalListener(name,handler){return removeOperatorListener(this,lookupSignal(this,name),handler)},addDataListener(name,handler){return addOperatorListener(this,name,dataref(this,name).values,handler)},removeDataListener(name,handler){return removeOperatorListener(this,dataref(this,name).values,handler)},globalCursor(_){if(arguments.length){if(this._globalCursor!==!!_){const prev=setCursor(this,null);this._globalCursor=!!_;if(prev)setCursor(this,prev)}return this}else{return this._globalCursor}},preventDefault(_){if(arguments.length){this._preventDefault=_;return this}else{return this._preventDefault}},timer:timer,events:events,finalize:finalize,hover:hover,data:data,change:change,insert:insert,remove:remove,scale:scale$1,initialize:initialize,toImageURL:renderToImageURL,toCanvas:renderToCanvas,toSVG:renderToSVG,getState:getState,setState:setState,_watchPixelRatio:watchPixelRatio});const VIEW="view",LBRACK="[",RBRACK="]",LBRACE="{",RBRACE="}",COLON=":",COMMA=",",NAME="@",GT=">",ILLEGAL=/[[\]{}]/,DEFAULT_MARKS={"*":1,arc:1,area:1,group:1,image:1,line:1,path:1,rect:1,rule:1,shape:1,symbol:1,text:1,trail:1};let DEFAULT_SOURCE,MARKS;function eventSelector(selector,source,marks){DEFAULT_SOURCE=source||VIEW;MARKS=DEFAULT_MARKS;return parseMerge(selector.trim()).map(parseSelector)}function isMarkType(type){return MARKS[type]}function find(s,i,endChar,pushChar,popChar){const n=s.length;let count=0,c;for(;i<n;++i){c=s[i];if(!count&&c===endChar)return i;else if(popChar&&popChar.indexOf(c)>=0)--count;else if(pushChar&&pushChar.indexOf(c)>=0)++count}return i}function parseMerge(s){const output=[],n=s.length;let start=0,i=0;while(i<n){i=find(s,i,COMMA,LBRACK+LBRACE,RBRACK+RBRACE);output.push(s.substring(start,i).trim());start=++i}if(output.length===0){throw"Empty event selector: "+s}return output}function parseSelector(s){return s[0]==="["?parseBetween(s):parseStream$1(s)}function parseBetween(s){const n=s.length;let i=1,b;i=find(s,i,RBRACK,LBRACK,RBRACK);if(i===n){throw"Empty between selector: "+s}b=parseMerge(s.substring(1,i));if(b.length!==2){throw"Between selector must have two elements: "+s}s=s.slice(i+1).trim();if(s[0]!==GT){throw"Expected '>' after between selector: "+s}b=b.map(parseSelector);const stream=parseSelector(s.slice(1).trim());if(stream.between){return{between:b,stream:stream}}else{stream.between=b}return stream}function parseStream$1(s){const stream={source:DEFAULT_SOURCE},source=[];let throttle=[0,0],markname=0,start=0,n=s.length,i=0,j,filter;if(s[n-1]===RBRACE){i=s.lastIndexOf(LBRACE);if(i>=0){try{throttle=parseThrottle(s.substring(i+1,n-1))}catch(e){throw"Invalid throttle specification: "+s}s=s.slice(0,i).trim();n=s.length}else throw"Unmatched right brace: "+s;i=0}if(!n)throw s;if(s[0]===NAME)markname=++i;j=find(s,i,COLON);if(j<n){source.push(s.substring(start,j).trim());start=i=++j}i=find(s,i,LBRACK);if(i===n){source.push(s.substring(start,n).trim())}else{source.push(s.substring(start,i).trim());filter=[];start=++i;if(start===n)throw"Unmatched left bracket: "+s}while(i<n){i=find(s,i,RBRACK);if(i===n)throw"Unmatched left bracket: "+s;filter.push(s.substring(start,i).trim());if(i<n-1&&s[++i]!==LBRACK)throw"Expected left bracket: "+s;start=++i}if(!(n=source.length)||ILLEGAL.test(source[n-1])){throw"Invalid event selector: "+s}if(n>1){stream.type=source[1];if(markname){stream.markname=source[0].slice(1)}else if(isMarkType(source[0])){stream.marktype=source[0]}else{stream.source=source[0]}}else{stream.type=source[0]}if(stream.type.slice(-1)==="!"){stream.consume=true;stream.type=stream.type.slice(0,-1)}if(filter!=null)stream.filter=filter;if(throttle[0])stream.throttle=throttle[0];if(throttle[1])stream.debounce=throttle[1];return stream}function parseThrottle(s){const a=s.split(COMMA);if(!s.length||a.length>2)throw s;return a.map((_=>{const x=+_;if(x!==x)throw s;return x}))}function parseAutosize(spec){return isObject(spec)?spec:{type:spec||"pad"}}const number=_=>+_||0;const paddingObject=_=>({top:_,bottom:_,left:_,right:_});function parsePadding(spec){return!isObject(spec)?paddingObject(number(spec)):spec.signal?spec:{top:number(spec.top),bottom:number(spec.bottom),left:number(spec.left),right:number(spec.right)}}const encoder=_=>isObject(_)&&!isArray(_)?extend$1({},_):{value:_};function addEncode(object,name,value,set){if(value!=null){const isEncoder=isObject(value)&&!isArray(value)||isArray(value)&&value.length&&isObject(value[0]);if(isEncoder){object.update[name]=value}else{object[set||"enter"][name]={value:value}}return 1}else{return 0}}function addEncoders(object,enter,update){for(const name in enter){addEncode(object,name,enter[name])}for(const name in update){addEncode(object,name,update[name],"update")}}function extendEncode(encode,extra,skip){for(const name in extra){if(skip&&has$1(skip,name))continue;encode[name]=extend$1(encode[name]||{},extra[name])}return encode}function has(key,encode){return encode&&(encode.enter&&encode.enter[key]||encode.update&&encode.update[key])}const MarkRole="mark";const FrameRole="frame";const ScopeRole="scope";const AxisRole="axis";const AxisDomainRole="axis-domain";const AxisGridRole="axis-grid";const AxisLabelRole="axis-label";const AxisTickRole="axis-tick";const AxisTitleRole="axis-title";const LegendRole="legend";const LegendBandRole="legend-band";const LegendEntryRole="legend-entry";const LegendGradientRole="legend-gradient";const LegendLabelRole="legend-label";const LegendSymbolRole="legend-symbol";const LegendTitleRole="legend-title";const TitleRole="title";const TitleTextRole="title-text";const TitleSubtitleRole="title-subtitle";function applyDefaults(encode,type,role,style,config){const defaults={},enter={};let update,key,skip,props;key="lineBreak";if(type==="text"&&config[key]!=null&&!has(key,encode)){applyDefault(defaults,key,config[key])}if(role=="legend"||String(role).startsWith("axis")){role=null}props=role===FrameRole?config.group:role===MarkRole?extend$1({},config.mark,config[type]):null;for(key in props){skip=has(key,encode)||(key==="fill"||key==="stroke")&&(has("fill",encode)||has("stroke",encode));if(!skip)applyDefault(defaults,key,props[key])}array$5(style).forEach((name=>{const props=config.style&&config.style[name];for(const key in props){if(!has(key,encode)){applyDefault(defaults,key,props[key])}}}));encode=extend$1({},encode);for(key in defaults){props=defaults[key];if(props.signal){(update=update||{})[key]=props}else{enter[key]=props}}encode.enter=extend$1(enter,encode.enter);if(update)encode.update=extend$1(update,encode.update);return encode}function applyDefault(defaults,key,value){defaults[key]=value&&value.signal?{signal:value.signal}:{value:value}}const scaleRef=scale=>isString(scale)?$(scale):scale.signal?`(${scale.signal})`:field(scale);function entry$1(enc){if(enc.gradient!=null){return gradient$1(enc)}let value=enc.signal?`(${enc.signal})`:enc.color?color$1(enc.color):enc.field!=null?field(enc.field):enc.value!==undefined?$(enc.value):undefined;if(enc.scale!=null){value=scale(enc,value)}if(value===undefined){value=null}if(enc.exponent!=null){value=`pow(${value},${property(enc.exponent)})`}if(enc.mult!=null){value+=`*${property(enc.mult)}`}if(enc.offset!=null){value+=`+${property(enc.offset)}`}if(enc.round){value=`round(${value})`}return value}const _color=(type,x,y,z)=>`(${type}(${[x,y,z].map(entry$1).join(",")})+'')`;function color$1(enc){return enc.c?_color("hcl",enc.h,enc.c,enc.l):enc.h||enc.s?_color("hsl",enc.h,enc.s,enc.l):enc.l||enc.a?_color("lab",enc.l,enc.a,enc.b):enc.r||enc.g||enc.b?_color("rgb",enc.r,enc.g,enc.b):null}function gradient$1(enc){const args=[enc.start,enc.stop,enc.count].map((_=>_==null?null:$(_)));while(args.length&&peek$1(args)==null)args.pop();args.unshift(scaleRef(enc.gradient));return`gradient(${args.join(",")})`}function property(property){return isObject(property)?"("+entry$1(property)+")":property}function field(ref){return resolveField(isObject(ref)?ref:{datum:ref})}function resolveField(ref){let object,level,field;if(ref.signal){object="datum";field=ref.signal}else if(ref.group||ref.parent){level=Math.max(1,ref.level||1);object="item";while(level-- >0){object+=".mark.group"}if(ref.parent){field=ref.parent;object+=".datum"}else{field=ref.group}}else if(ref.datum){object="datum";field=ref.datum}else{error("Invalid field reference: "+$(ref))}if(!ref.signal){field=isString(field)?splitAccessPath(field).map($).join("]["):resolveField(field)}return object+"["+field+"]"}function scale(enc,value){const scale=scaleRef(enc.scale);if(enc.range!=null){value=`lerp(_range(${scale}), ${+enc.range})`}else{if(value!==undefined)value=`_scale(${scale}, ${value})`;if(enc.band){value=(value?value+"+":"")+`_bandwidth(${scale})`+(+enc.band===1?"":"*"+property(enc.band));if(enc.extra){value=`(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`}}if(value==null)value="0"}return value}function rule$1(enc){let code="";enc.forEach((rule=>{const value=entry$1(rule);code+=rule.test?`(${rule.test})?${value}:`:value}));if(peek$1(code)===":"){code+="null"}return code}function parseEncode(encode,type,role,style,scope,params){const enc={};params=params||{};params.encoders={$encode:enc};encode=applyDefaults(encode,type,role,style,scope.config);for(const key in encode){enc[key]=parseBlock(encode[key],type,params,scope)}return params}function parseBlock(block,marktype,params,scope){const channels={},fields={};for(const name in block){if(block[name]!=null){channels[name]=parse$1(expr(block[name]),scope,params,fields)}}return{$expr:{marktype:marktype,channels:channels},$fields:Object.keys(fields),$output:Object.keys(block)}}function expr(enc){return isArray(enc)?rule$1(enc):entry$1(enc)}function parse$1(code,scope,params,fields){const expr=parser(code,scope);expr.$fields.forEach((name=>fields[name]=1));extend$1(params,expr.$params);return expr.$expr}const OUTER="outer",OUTER_INVALID=["value","update","init","react","bind"];function outerError(prefix,name){error(prefix+' for "outer" push: '+$(name))}function parseSignal(signal,scope){const name=signal.name;if(signal.push===OUTER){if(!scope.signals[name])outerError("No prior signal definition",name);OUTER_INVALID.forEach((prop=>{if(signal[prop]!==undefined)outerError("Invalid property ",prop)}))}else{const op=scope.addSignal(name,signal.value);if(signal.react===false)op.react=false;if(signal.bind)scope.addBinding(name,signal.bind)}}function Entry(type,value,params,parent){this.id=-1;this.type=type;this.value=value;this.params=params;if(parent)this.parent=parent}function entry(type,value,params,parent){return new Entry(type,value,params,parent)}function operator(value,params){return entry("operator",value,params)}function ref(op){const ref={$ref:op.id};if(op.id<0)(op.refs=op.refs||[]).push(ref);return ref}function fieldRef$1(field,name){return name?{$field:field,$name:name}:{$field:field}}const keyFieldRef=fieldRef$1("key");function compareRef(fields,orders){return{$compare:fields,$order:orders}}function keyRef(fields,flat){const ref={$key:fields};if(flat)ref.$flat=true;return ref}const Ascending="ascending";const Descending="descending";function sortKey(sort){return!isObject(sort)?"":(sort.order===Descending?"-":"+")+aggrField(sort.op,sort.field)}function aggrField(op,field){return(op&&op.signal?"$"+op.signal:op||"")+(op&&field?"_":"")+(field&&field.signal?"$"+field.signal:field||"")}const Scope$1="scope";const View="view";function isSignal(_){return _&&_.signal}function isExpr$1(_){return _&&_.expr}function hasSignal(_){if(isSignal(_))return true;if(isObject(_))for(const key in _){if(hasSignal(_[key]))return true}return false}function value(specValue,defaultValue){return specValue!=null?specValue:defaultValue}function deref(v){return v&&v.signal||v}const Timer="timer";function parseStream(stream,scope){const method=stream.merge?mergeStream:stream.stream?nestedStream:stream.type?eventStream:error("Invalid stream specification: "+$(stream));return method(stream,scope)}function eventSource(source){return source===Scope$1?View:source||View}function mergeStream(stream,scope){const list=stream.merge.map((s=>parseStream(s,scope))),entry=streamParameters({merge:list},stream,scope);return scope.addStream(entry).id}function nestedStream(stream,scope){const id=parseStream(stream.stream,scope),entry=streamParameters({stream:id},stream,scope);return scope.addStream(entry).id}function eventStream(stream,scope){let id;if(stream.type===Timer){id=scope.event(Timer,stream.throttle);stream={between:stream.between,filter:stream.filter}}else{id=scope.event(eventSource(stream.source),stream.type)}const entry=streamParameters({stream:id},stream,scope);return Object.keys(entry).length===1?id:scope.addStream(entry).id}function streamParameters(entry,stream,scope){let param=stream.between;if(param){if(param.length!==2){error('Stream "between" parameter must have 2 entries: '+$(stream))}entry.between=[parseStream(param[0],scope),parseStream(param[1],scope)]}param=stream.filter?[].concat(stream.filter):[];if(stream.marktype||stream.markname||stream.markrole){param.push(filterMark(stream.marktype,stream.markname,stream.markrole))}if(stream.source===Scope$1){param.push("inScope(event.item)")}if(param.length){entry.filter=parser("("+param.join(")&&(")+")",scope).$expr}if((param=stream.throttle)!=null){entry.throttle=+param}if((param=stream.debounce)!=null){entry.debounce=+param}if(stream.consume){entry.consume=true}return entry}function filterMark(type,name,role){const item="event.item";return item+(type&&type!=="*"?"&&"+item+".mark.marktype==='"+type+"'":"")+(role?"&&"+item+".mark.role==='"+role+"'":"")+(name?"&&"+item+".mark.name==='"+name+"'":"")}const OP_VALUE_EXPR={code:"_.$value",ast:{type:"Identifier",value:"value"}};function parseUpdate(spec,scope,target){const encode=spec.encode,entry={target:target};let events=spec.events,update=spec.update,sources=[];if(!events){error("Signal update missing events specification.")}if(isString(events)){events=eventSelector(events,scope.isSubscope()?Scope$1:View)}events=array$5(events).filter((s=>s.signal||s.scale?(sources.push(s),0):1));if(sources.length>1){sources=[mergeSources(sources)]}if(events.length){sources.push(events.length>1?{merge:events}:events[0])}if(encode!=null){if(update)error("Signal encode and update are mutually exclusive.");update="encode(item(),"+$(encode)+")"}entry.update=isString(update)?parser(update,scope):update.expr!=null?parser(update.expr,scope):update.value!=null?update.value:update.signal!=null?{$expr:OP_VALUE_EXPR,$params:{$value:scope.signalRef(update.signal)}}:error("Invalid signal update specification.");if(spec.force){entry.options={force:true}}sources.forEach((source=>scope.addUpdate(extend$1(streamSource(source,scope),entry))))}function streamSource(stream,scope){return{source:stream.signal?scope.signalRef(stream.signal):stream.scale?scope.scaleRef(stream.scale):parseStream(stream,scope)}}function mergeSources(sources){return{signal:"["+sources.map((s=>s.scale?'scale("'+s.scale+'")':s.signal))+"]"}}function parseSignalUpdates(signal,scope){const op=scope.getSignal(signal.name);let expr=signal.update;if(signal.init){if(expr){error("Signals can not include both init and update expressions.")}else{expr=signal.init;op.initonly=true}}if(expr){expr=parser(expr,scope);op.update=expr.$expr;op.params=expr.$params}if(signal.on){signal.on.forEach((_=>parseUpdate(_,scope,op.id)))}}const transform=name=>(params,value,parent)=>entry(name,value,params||undefined,parent);const Aggregate=transform("aggregate");const AxisTicks=transform("axisticks");const Bound=transform("bound");const Collect=transform("collect");const Compare=transform("compare");const DataJoin=transform("datajoin");const Encode=transform("encode");const Expression=transform("expression");const Facet=transform("facet");const Field=transform("field");const Key=transform("key");const LegendEntries=transform("legendentries");const Load=transform("load");const Mark$1=transform("mark");const MultiExtent=transform("multiextent");const MultiValues=transform("multivalues");const Overlap=transform("overlap");const Params=transform("params");const PreFacet=transform("prefacet");const Projection=transform("projection");const Proxy=transform("proxy");const Relay=transform("relay");const Render=transform("render");const Scale=transform("scale");const Sieve=transform("sieve");const SortItems=transform("sortitems");const ViewLayout=transform("viewlayout");const Values=transform("values");let FIELD_REF_ID=0;const MULTIDOMAIN_SORT_OPS={min:"min",max:"max",count:"sum"};function initScale(spec,scope){const type=spec.type||"linear";if(!isValidScaleType(type)){error("Unrecognized scale type: "+$(type))}scope.addScale(spec.name,{type:type,domain:undefined})}function parseScale(spec,scope){const params=scope.getScale(spec.name).params;let key;params.domain=parseScaleDomain$1(spec.domain,spec,scope);if(spec.range!=null){params.range=parseScaleRange$1(spec,scope,params)}if(spec.interpolate!=null){parseScaleInterpolate(spec.interpolate,params)}if(spec.nice!=null){params.nice=parseScaleNice(spec.nice,scope)}if(spec.bins!=null){params.bins=parseScaleBins(spec.bins,scope)}for(key in spec){if(has$1(params,key)||key==="name")continue;params[key]=parseLiteral(spec[key],scope)}}function parseLiteral(v,scope){return!isObject(v)?v:v.signal?scope.signalRef(v.signal):error("Unsupported object: "+$(v))}function parseArray(v,scope){return v.signal?scope.signalRef(v.signal):v.map((v=>parseLiteral(v,scope)))}function dataLookupError(name){error("Can not find data set: "+$(name))}function parseScaleDomain$1(domain,spec,scope){if(!domain){if(spec.domainMin!=null||spec.domainMax!=null){error("No scale domain defined for domainMin/domainMax to override.")}return}return domain.signal?scope.signalRef(domain.signal):(isArray(domain)?explicitDomain:domain.fields?multipleDomain:singularDomain)(domain,spec,scope)}function explicitDomain(domain,spec,scope){return domain.map((v=>parseLiteral(v,scope)))}function singularDomain(domain,spec,scope){const data=scope.getData(domain.data);if(!data)dataLookupError(domain.data);return isDiscrete$2(spec.type)?data.valuesRef(scope,domain.field,parseSort(domain.sort,false)):isQuantile$1(spec.type)?data.domainRef(scope,domain.field):data.extentRef(scope,domain.field)}function multipleDomain(domain,spec,scope){const data=domain.data,fields=domain.fields.reduce(((dom,d)=>{d=isString(d)?{data:data,field:d}:isArray(d)||d.signal?fieldRef(d,scope):d;dom.push(d);return dom}),[]);return(isDiscrete$2(spec.type)?ordinalMultipleDomain:isQuantile$1(spec.type)?quantileMultipleDomain:numericMultipleDomain)(domain,scope,fields)}function fieldRef(data,scope){const name="_:vega:_"+FIELD_REF_ID++,coll=Collect({});if(isArray(data)){coll.value={$ingest:data}}else if(data.signal){const code="setdata("+$(name)+","+data.signal+")";coll.params.input=scope.signalRef(code)}scope.addDataPipeline(name,[coll,Sieve({})]);return{data:name,field:"data"}}function ordinalMultipleDomain(domain,scope,fields){const sort=parseSort(domain.sort,true);let a,v;const counts=fields.map((f=>{const data=scope.getData(f.data);if(!data)dataLookupError(f.data);return data.countsRef(scope,f.field,sort)}));const p={groupby:keyFieldRef,pulse:counts};if(sort){a=sort.op||"count";v=sort.field?aggrField(a,sort.field):"count";p.ops=[MULTIDOMAIN_SORT_OPS[a]];p.fields=[scope.fieldRef(v)];p.as=[v]}a=scope.add(Aggregate(p));const c=scope.add(Collect({pulse:ref(a)}));v=scope.add(Values({field:keyFieldRef,sort:scope.sortRef(sort),pulse:ref(c)}));return ref(v)}function parseSort(sort,multidomain){if(sort){if(!sort.field&&!sort.op){if(isObject(sort))sort.field="key";else sort={field:"key"}}else if(!sort.field&&sort.op!=="count"){error("No field provided for sort aggregate op: "+sort.op)}else if(multidomain&&sort.field){if(sort.op&&!MULTIDOMAIN_SORT_OPS[sort.op]){error("Multiple domain scales can not be sorted using "+sort.op)}}}return sort}function quantileMultipleDomain(domain,scope,fields){const values=fields.map((f=>{const data=scope.getData(f.data);if(!data)dataLookupError(f.data);return data.domainRef(scope,f.field)}));return ref(scope.add(MultiValues({values:values})))}function numericMultipleDomain(domain,scope,fields){const extents=fields.map((f=>{const data=scope.getData(f.data);if(!data)dataLookupError(f.data);return data.extentRef(scope,f.field)}));return ref(scope.add(MultiExtent({extents:extents})))}function parseScaleBins(v,scope){return v.signal||isArray(v)?parseArray(v,scope):scope.objectProperty(v)}function parseScaleNice(nice,scope){return nice.signal?scope.signalRef(nice.signal):isObject(nice)?{interval:parseLiteral(nice.interval),step:parseLiteral(nice.step)}:parseLiteral(nice)}function parseScaleInterpolate(interpolate,params){params.interpolate=parseLiteral(interpolate.type||interpolate);if(interpolate.gamma!=null){params.interpolateGamma=parseLiteral(interpolate.gamma)}}function parseScaleRange$1(spec,scope,params){const config=scope.config.range;let range=spec.range;if(range.signal){return scope.signalRef(range.signal)}else if(isString(range)){if(config&&has$1(config,range)){spec=extend$1({},spec,{range:config[range]});return parseScaleRange$1(spec,scope,params)}else if(range==="width"){range=[0,{signal:"width"}]}else if(range==="height"){range=isDiscrete$2(spec.type)?[0,{signal:"height"}]:[{signal:"height"},0]}else{error("Unrecognized scale range value: "+$(range))}}else if(range.scheme){params.scheme=isArray(range.scheme)?parseArray(range.scheme,scope):parseLiteral(range.scheme,scope);if(range.extent)params.schemeExtent=parseArray(range.extent,scope);if(range.count)params.schemeCount=parseLiteral(range.count,scope);return}else if(range.step){params.rangeStep=parseLiteral(range.step,scope);return}else if(isDiscrete$2(spec.type)&&!isArray(range)){return parseScaleDomain$1(range,spec,scope)}else if(!isArray(range)){error("Unsupported range type: "+$(range))}return range.map((v=>(isArray(v)?parseArray:parseLiteral)(v,scope)))}function parseProjection$1(proj,scope){const config=scope.config.projection||{},params={};for(const name in proj){if(name==="name")continue;params[name]=parseParameter$1(proj[name],name,scope)}for(const name in config){if(params[name]==null){params[name]=parseParameter$1(config[name],name,scope)}}scope.addProjection(proj.name,params)}function parseParameter$1(_,name,scope){return isArray(_)?_.map((_=>parseParameter$1(_,name,scope))):!isObject(_)?_:_.signal?scope.signalRef(_.signal):name==="fit"?_:error("Unsupported parameter object: "+$(_))}const Top="top";const Left="left";const Right="right";const Bottom="bottom";const Center="center";const Vertical="vertical";const Start="start";const Middle="middle";const End="end";const Index="index";const Label="label";const Offset="offset";const Perc="perc";const Perc2="perc2";const Value="value";const GuideLabelStyle="guide-label";const GuideTitleStyle="guide-title";const GroupTitleStyle="group-title";const GroupSubtitleStyle="group-subtitle";const Symbols="symbol";const Gradient="gradient";const Discrete="discrete";const Size="size";const Shape="shape";const Fill="fill";const Stroke="stroke";const StrokeWidth="strokeWidth";const StrokeDash="strokeDash";const Opacity="opacity";const LegendScales=[Size,Shape,Fill,Stroke,StrokeWidth,StrokeDash,Opacity];const Skip={name:1,style:1,interactive:1};const zero$1={value:0};const one={value:1};const GroupMark="group";const RectMark="rect";const RuleMark="rule";const SymbolMark="symbol";const TextMark="text";function guideGroup(mark){mark.type=GroupMark;mark.interactive=mark.interactive||false;return mark}function lookup(spec,config){const _=(name,dflt)=>value(spec[name],value(config[name],dflt));_.isVertical=s=>Vertical===value(spec.direction,config.direction||(s?config.symbolDirection:config.gradientDirection));_.gradientLength=()=>value(spec.gradientLength,config.gradientLength||config.gradientWidth);_.gradientThickness=()=>value(spec.gradientThickness,config.gradientThickness||config.gradientHeight);_.entryColumns=()=>value(spec.columns,value(config.columns,+_.isVertical(true)));return _}function getEncoding(name,encode){const v=encode&&(encode.update&&encode.update[name]||encode.enter&&encode.enter[name]);return v&&v.signal?v:v?v.value:null}function getStyle(name,scope,style){const s=scope.config.style[style];return s&&s[name]}function anchorExpr(s,e,m){return`item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`}const alignExpr$1=anchorExpr($(Left),$(Right),$(Center));function tickBand(_){const v=_("tickBand");let offset=_("tickOffset"),band,extra;if(!v){band=_("bandPosition");extra=_("tickExtra")}else if(v.signal){band={signal:`(${v.signal}) === 'extent' ? 1 : 0.5`};extra={signal:`(${v.signal}) === 'extent'`};if(!isObject(offset)){offset={signal:`(${v.signal}) === 'extent' ? 0 : ${offset}`}}}else if(v==="extent"){band=1;extra=true;offset=0}else{band=.5;extra=false}return{extra:extra,band:band,offset:offset}}function extendOffset(value,offset){return!offset?value:!value?offset:!isObject(value)?{value:value,offset:offset}:Object.assign({},value,{offset:extendOffset(value.offset,offset)})}function guideMark(mark,extras){if(extras){mark.name=extras.name;mark.style=extras.style||mark.style;mark.interactive=!!extras.interactive;mark.encode=extendEncode(mark.encode,extras,Skip)}else{mark.interactive=false}return mark}function legendGradient(spec,scale,config,userEncode){const _=lookup(spec,config),vertical=_.isVertical(),thickness=_.gradientThickness(),length=_.gradientLength();let enter,start,stop,width,height;if(vertical){start=[0,1];stop=[0,0];width=thickness;height=length}else{start=[0,0];stop=[1,0];width=length;height=thickness}const encode={enter:enter={opacity:zero$1,x:zero$1,y:zero$1,width:encoder(width),height:encoder(height)},update:extend$1({},enter,{opacity:one,fill:{gradient:scale,start:start,stop:stop}}),exit:{opacity:zero$1}};addEncoders(encode,{stroke:_("gradientStrokeColor"),strokeWidth:_("gradientStrokeWidth")},{opacity:_("gradientOpacity")});return guideMark({type:RectMark,role:LegendGradientRole,encode:encode},userEncode)}function legendGradientDiscrete(spec,scale,config,userEncode,dataRef){const _=lookup(spec,config),vertical=_.isVertical(),thickness=_.gradientThickness(),length=_.gradientLength();let u,v,uu,vv,adjust="";vertical?(u="y",uu="y2",v="x",vv="width",adjust="1-"):(u="x",uu="x2",v="y",vv="height");const enter={opacity:zero$1,fill:{scale:scale,field:Value}};enter[u]={signal:adjust+"datum."+Perc,mult:length};enter[v]=zero$1;enter[uu]={signal:adjust+"datum."+Perc2,mult:length};enter[vv]=encoder(thickness);const encode={enter:enter,update:extend$1({},enter,{opacity:one}),exit:{opacity:zero$1}};addEncoders(encode,{stroke:_("gradientStrokeColor"),strokeWidth:_("gradientStrokeWidth")},{opacity:_("gradientOpacity")});return guideMark({type:RectMark,role:LegendBandRole,key:Value,from:dataRef,encode:encode},userEncode)}const alignExpr=`datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`,baselineExpr=`datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;function legendGradientLabels(spec,config,userEncode,dataRef){const _=lookup(spec,config),vertical=_.isVertical(),thickness=encoder(_.gradientThickness()),length=_.gradientLength();let overlap=_("labelOverlap"),enter,update,u,v,adjust="";const encode={enter:enter={opacity:zero$1},update:update={opacity:one,text:{field:Label}},exit:{opacity:zero$1}};addEncoders(encode,{fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontStyle:_("labelFontStyle"),fontWeight:_("labelFontWeight"),limit:value(spec.labelLimit,config.gradientLabelLimit)});if(vertical){enter.align={value:"left"};enter.baseline=update.baseline={signal:baselineExpr};u="y";v="x";adjust="1-"}else{enter.align=update.align={signal:alignExpr};enter.baseline={value:"top"};u="x";v="y"}enter[u]=update[u]={signal:adjust+"datum."+Perc,mult:length};enter[v]=update[v]=thickness;thickness.offset=value(spec.labelOffset,config.gradientLabelOffset)||0;overlap=overlap?{separation:_("labelSeparation"),method:overlap,order:"datum."+Index}:undefined;return guideMark({type:TextMark,role:LegendLabelRole,style:GuideLabelStyle,key:Value,from:dataRef,encode:encode,overlap:overlap},userEncode)}function legendSymbolGroups(spec,config,userEncode,dataRef,columns){const _=lookup(spec,config),entries=userEncode.entries,interactive=!!(entries&&entries.interactive),name=entries?entries.name:undefined,height=_("clipHeight"),symbolOffset=_("symbolOffset"),valueRef={data:"value"},xSignal=`(${columns}) ? datum.${Offset} : datum.${Size}`,yEncode=height?encoder(height):{field:Size},index=`datum.${Index}`,ncols=`max(1, ${columns})`;let encode,enter,update,nrows,sort;yEncode.mult=.5;encode={enter:enter={opacity:zero$1,x:{signal:xSignal,mult:.5,offset:symbolOffset},y:yEncode},update:update={opacity:one,x:enter.x,y:enter.y},exit:{opacity:zero$1}};let baseFill=null,baseStroke=null;if(!spec.fill){baseFill=config.symbolBaseFillColor;baseStroke=config.symbolBaseStrokeColor}addEncoders(encode,{fill:_("symbolFillColor",baseFill),shape:_("symbolType"),size:_("symbolSize"),stroke:_("symbolStrokeColor",baseStroke),strokeDash:_("symbolDash"),strokeDashOffset:_("symbolDashOffset"),strokeWidth:_("symbolStrokeWidth")},{opacity:_("symbolOpacity")});LegendScales.forEach((scale=>{if(spec[scale]){update[scale]=enter[scale]={scale:spec[scale],field:Value}}}));const symbols=guideMark({type:SymbolMark,role:LegendSymbolRole,key:Value,from:valueRef,clip:height?true:undefined,encode:encode},userEncode.symbols);const labelOffset=encoder(symbolOffset);labelOffset.offset=_("labelOffset");encode={enter:enter={opacity:zero$1,x:{signal:xSignal,offset:labelOffset},y:yEncode},update:update={opacity:one,text:{field:Label},x:enter.x,y:enter.y},exit:{opacity:zero$1}};addEncoders(encode,{align:_("labelAlign"),baseline:_("labelBaseline"),fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontStyle:_("labelFontStyle"),fontWeight:_("labelFontWeight"),limit:_("labelLimit")});const labels=guideMark({type:TextMark,role:LegendLabelRole,style:GuideLabelStyle,key:Value,from:valueRef,encode:encode},userEncode.labels);encode={enter:{noBound:{value:!height},width:zero$1,height:height?encoder(height):zero$1,opacity:zero$1},exit:{opacity:zero$1},update:update={opacity:one,row:{signal:null},column:{signal:null}}};if(_.isVertical(true)){nrows=`ceil(item.mark.items.length / ${ncols})`;update.row.signal=`${index}%${nrows}`;update.column.signal=`floor(${index} / ${nrows})`;sort={field:["row",index]}}else{update.row.signal=`floor(${index} / ${ncols})`;update.column.signal=`${index} % ${ncols}`;sort={field:index}}update.column.signal=`(${columns})?${update.column.signal}:${index}`;dataRef={facet:{data:dataRef,name:"value",groupby:Index}};return guideGroup({role:ScopeRole,from:dataRef,encode:extendEncode(encode,entries,Skip),marks:[symbols,labels],name:name,interactive:interactive,sort:sort})}function legendSymbolLayout(spec,config){const _=lookup(spec,config);return{align:_("gridAlign"),columns:_.entryColumns(),center:{row:true,column:false},padding:{row:_("rowPadding"),column:_("columnPadding")}}}const isL='item.orient === "left"',isR='item.orient === "right"',isLR=`(${isL} || ${isR})`,isVG=`datum.vgrad && ${isLR}`,baseline$1=anchorExpr('"top"','"bottom"','"middle"'),alignFlip=anchorExpr('"right"','"left"','"center"'),exprAlign=`datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`,exprAnchor=`item._anchor || (${isLR} ? "middle" : "start")`,exprAngle=`${isVG} ? (${isL} ? -90 : 90) : 0`,exprBaseline=`${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline$1}) : "top"`;function legendTitle(spec,config,userEncode,dataRef){const _=lookup(spec,config);const encode={enter:{opacity:zero$1},update:{opacity:one,x:{field:{group:"padding"}},y:{field:{group:"padding"}}},exit:{opacity:zero$1}};addEncoders(encode,{orient:_("titleOrient"),_anchor:_("titleAnchor"),anchor:{signal:exprAnchor},angle:{signal:exprAngle},align:{signal:exprAlign},baseline:{signal:exprBaseline},text:spec.title,fill:_("titleColor"),fillOpacity:_("titleOpacity"),font:_("titleFont"),fontSize:_("titleFontSize"),fontStyle:_("titleFontStyle"),fontWeight:_("titleFontWeight"),limit:_("titleLimit"),lineHeight:_("titleLineHeight")},{align:_("titleAlign"),baseline:_("titleBaseline")});return guideMark({type:TextMark,role:LegendTitleRole,style:GuideTitleStyle,from:dataRef,encode:encode},userEncode)}function clip(clip,scope){let expr;if(isObject(clip)){if(clip.signal){expr=clip.signal}else if(clip.path){expr="pathShape("+param(clip.path)+")"}else if(clip.sphere){expr="geoShape("+param(clip.sphere)+', {type: "Sphere"})'}}return expr?scope.signalRef(expr):!!clip}function param(value){return isObject(value)&&value.signal?value.signal:$(value)}function getRole(spec){const role=spec.role||"";return role.startsWith("axis")||role.startsWith("legend")||role.startsWith("title")?role:spec.type===GroupMark?ScopeRole:role||MarkRole}function definition(spec){return{marktype:spec.type,name:spec.name||undefined,role:spec.role||getRole(spec),zindex:+spec.zindex||undefined,aria:spec.aria,description:spec.description}}function interactive(spec,scope){return spec&&spec.signal?scope.signalRef(spec.signal):spec===false?false:true}function parseTransform(spec,scope){const def=definition$1(spec.type);if(!def)error("Unrecognized transform type: "+$(spec.type));const t=entry(def.type.toLowerCase(),null,parseParameters(def,spec,scope));if(spec.signal)scope.addSignal(spec.signal,scope.proxy(t));t.metadata=def.metadata||{};return t}function parseParameters(def,spec,scope){const params={},n=def.params.length;for(let i=0;i<n;++i){const pdef=def.params[i];params[pdef.name]=parseParameter(pdef,spec,scope)}return params}function parseParameter(def,spec,scope){const type=def.type,value=spec[def.name];if(type==="index"){return parseIndexParameter(def,spec,scope)}else if(value===undefined){if(def.required){error("Missing required "+$(spec.type)+" parameter: "+$(def.name))}return}else if(type==="param"){return parseSubParameters(def,spec,scope)}else if(type==="projection"){return scope.projectionRef(spec[def.name])}return def.array&&!isSignal(value)?value.map((v=>parameterValue(def,v,scope))):parameterValue(def,value,scope)}function parameterValue(def,value,scope){const type=def.type;if(isSignal(value)){return isExpr(type)?error("Expression references can not be signals."):isField(type)?scope.fieldRef(value):isCompare(type)?scope.compareRef(value):scope.signalRef(value.signal)}else{const expr=def.expr||isField(type);return expr&&outerExpr(value)?scope.exprRef(value.expr,value.as):expr&&outerField(value)?fieldRef$1(value.field,value.as):isExpr(type)?parser(value,scope):isData(type)?ref(scope.getData(value).values):isField(type)?fieldRef$1(value):isCompare(type)?scope.compareRef(value):value}}function parseIndexParameter(def,spec,scope){if(!isString(spec.from)){error('Lookup "from" parameter must be a string literal.')}return scope.getData(spec.from).lookupRef(scope,spec.key)}function parseSubParameters(def,spec,scope){const value=spec[def.name];if(def.array){if(!isArray(value)){error("Expected an array of sub-parameters. Instead: "+$(value))}return value.map((v=>parseSubParameter(def,v,scope)))}else{return parseSubParameter(def,value,scope)}}function parseSubParameter(def,value,scope){const n=def.params.length;let pdef;for(let i=0;i<n;++i){pdef=def.params[i];for(const k in pdef.key){if(pdef.key[k]!==value[k]){pdef=null;break}}if(pdef)break}if(!pdef)error("Unsupported parameter: "+$(value));const params=extend$1(parseParameters(pdef,value,scope),pdef.key);return ref(scope.add(Params(params)))}const outerExpr=_=>_&&_.expr;const outerField=_=>_&&_.field;const isData=_=>_==="data";const isExpr=_=>_==="expr";const isField=_=>_==="field";const isCompare=_=>_==="compare";function parseData$1(from,group,scope){let facet,key,op,dataRef,parent;if(!from){dataRef=ref(scope.add(Collect(null,[{}])))}else if(facet=from.facet){if(!group)error("Only group marks can be faceted.");if(facet.field!=null){dataRef=parent=getDataRef(facet,scope)}else{if(!from.data){op=parseTransform(extend$1({type:"aggregate",groupby:array$5(facet.groupby)},facet.aggregate),scope);op.params.key=scope.keyRef(facet.groupby);op.params.pulse=getDataRef(facet,scope);dataRef=parent=ref(scope.add(op))}else{parent=ref(scope.getData(from.data).aggregate)}key=scope.keyRef(facet.groupby,true)}}if(!dataRef){dataRef=getDataRef(from,scope)}return{key:key,pulse:dataRef,parent:parent}}function getDataRef(from,scope){return from.$ref?from:from.data&&from.data.$ref?from.data:ref(scope.getData(from.data).output)}function DataScope(scope,input,output,values,aggr){this.scope=scope;this.input=input;this.output=output;this.values=values;this.aggregate=aggr;this.index={}}DataScope.fromEntries=function(scope,entries){const n=entries.length,values=entries[n-1],output=entries[n-2];let input=entries[0],aggr=null,i=1;if(input&&input.type==="load"){input=entries[1]}scope.add(entries[0]);for(;i<n;++i){entries[i].params.pulse=ref(entries[i-1]);scope.add(entries[i]);if(entries[i].type==="aggregate")aggr=entries[i]}return new DataScope(scope,input,output,values,aggr)};function fieldKey(field){return isString(field)?field:null}function addSortField(scope,p,sort){const as=aggrField(sort.op,sort.field);let s;if(p.ops){for(let i=0,n=p.as.length;i<n;++i){if(p.as[i]===as)return}}else{p.ops=["count"];p.fields=[null];p.as=["count"]}if(sort.op){p.ops.push((s=sort.op.signal)?scope.signalRef(s):sort.op);p.fields.push(scope.fieldRef(sort.field));p.as.push(as)}}function cache(scope,ds,name,optype,field,counts,index){const cache=ds[name]||(ds[name]={}),sort=sortKey(counts);let k=fieldKey(field),v,op;if(k!=null){scope=ds.scope;k=k+(sort?"|"+sort:"");v=cache[k]}if(!v){const params=counts?{field:keyFieldRef,pulse:ds.countsRef(scope,field,counts)}:{field:scope.fieldRef(field),pulse:ref(ds.output)};if(sort)params.sort=scope.sortRef(counts);op=scope.add(entry(optype,undefined,params));if(index)ds.index[field]=op;v=ref(op);if(k!=null)cache[k]=v}return v}DataScope.prototype={countsRef(scope,field,sort){const ds=this,cache=ds.counts||(ds.counts={}),k=fieldKey(field);let v,a,p;if(k!=null){scope=ds.scope;v=cache[k]}if(!v){p={groupby:scope.fieldRef(field,"key"),pulse:ref(ds.output)};if(sort&&sort.field)addSortField(scope,p,sort);a=scope.add(Aggregate(p));v=scope.add(Collect({pulse:ref(a)}));v={agg:a,ref:ref(v)};if(k!=null)cache[k]=v}else if(sort&&sort.field){addSortField(scope,v.agg.params,sort)}return v.ref},tuplesRef(){return ref(this.values)},extentRef(scope,field){return cache(scope,this,"extent","extent",field,false)},domainRef(scope,field){return cache(scope,this,"domain","values",field,false)},valuesRef(scope,field,sort){return cache(scope,this,"vals","values",field,sort||true)},lookupRef(scope,field){return cache(scope,this,"lookup","tupleindex",field,false)},indataRef(scope,field){return cache(scope,this,"indata","tupleindex",field,true,true)}};function parseFacet(spec,scope,group){const facet=spec.from.facet,name=facet.name,data=getDataRef(facet,scope);let op;if(!facet.name){error("Facet must have a name: "+$(facet))}if(!facet.data){error("Facet must reference a data set: "+$(facet))}if(facet.field){op=scope.add(PreFacet({field:scope.fieldRef(facet.field),pulse:data}))}else if(facet.groupby){op=scope.add(Facet({key:scope.keyRef(facet.groupby),group:ref(scope.proxy(group.parent)),pulse:data}))}else{error("Facet must specify groupby or field: "+$(facet))}const subscope=scope.fork(),source=subscope.add(Collect()),values=subscope.add(Sieve({pulse:ref(source)}));subscope.addData(name,new DataScope(subscope,source,source,values));subscope.addSignal("parent",null);op.params.subflow={$subflow:subscope.parse(spec).toRuntime()}}function parseSubflow(spec,scope,input){const op=scope.add(PreFacet({pulse:input.pulse})),subscope=scope.fork();subscope.add(Sieve());subscope.addSignal("parent",null);op.params.subflow={$subflow:subscope.parse(spec).toRuntime()}}function parseTrigger(spec,scope,name){const remove=spec.remove,insert=spec.insert,toggle=spec.toggle,modify=spec.modify,values=spec.values,op=scope.add(operator());const update="if("+spec.trigger+',modify("'+name+'",'+[insert,remove,toggle,modify,values].map((_=>_==null?"null":_)).join(",")+"),0)";const expr=parser(update,scope);op.update=expr.$expr;op.params=expr.$params}function parseMark(spec,scope){const role=getRole(spec),group=spec.type===GroupMark,facet=spec.from&&spec.from.facet,overlap=spec.overlap;let layout=spec.layout||role===ScopeRole||role===FrameRole,ops,op,store,enc,name,layoutRef,boundRef;const nested=role===MarkRole||layout||facet;const input=parseData$1(spec.from,group,scope);op=scope.add(DataJoin({key:input.key||(spec.key?fieldRef$1(spec.key):undefined),pulse:input.pulse,clean:!group}));const joinRef=ref(op);op=store=scope.add(Collect({pulse:joinRef}));op=scope.add(Mark$1({markdef:definition(spec),interactive:interactive(spec.interactive,scope),clip:clip(spec.clip,scope),context:{$context:true},groups:scope.lookup(),parent:scope.signals.parent?scope.signalRef("parent"):null,index:scope.markpath(),pulse:ref(op)}));const markRef=ref(op);op=enc=scope.add(Encode(parseEncode(spec.encode,spec.type,role,spec.style,scope,{mod:false,pulse:markRef})));op.params.parent=scope.encode();if(spec.transform){spec.transform.forEach((_=>{const tx=parseTransform(_,scope),md=tx.metadata;if(md.generates||md.changes){error("Mark transforms should not generate new data.")}if(!md.nomod)enc.params.mod=true;tx.params.pulse=ref(op);scope.add(op=tx)}))}if(spec.sort){op=scope.add(SortItems({sort:scope.compareRef(spec.sort),pulse:ref(op)}))}const encodeRef=ref(op);if(facet||layout){layout=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,mark:markRef,pulse:encodeRef}));layoutRef=ref(layout)}const bound=scope.add(Bound({mark:markRef,pulse:layoutRef||encodeRef}));boundRef=ref(bound);if(group){if(nested){ops=scope.operators;ops.pop();if(layout)ops.pop()}scope.pushState(encodeRef,layoutRef||boundRef,joinRef);facet?parseFacet(spec,scope,input):nested?parseSubflow(spec,scope,input):scope.parse(spec);scope.popState();if(nested){if(layout)ops.push(layout);ops.push(bound)}}if(overlap){boundRef=parseOverlap(overlap,boundRef,scope)}const render=scope.add(Render({pulse:boundRef})),sieve=scope.add(Sieve({pulse:ref(render)},undefined,scope.parent()));if(spec.name!=null){name=spec.name;scope.addData(name,new DataScope(scope,store,render,sieve));if(spec.on)spec.on.forEach((on=>{if(on.insert||on.remove||on.toggle){error("Marks only support modify triggers.")}parseTrigger(on,scope,name)}))}}function parseOverlap(overlap,source,scope){const method=overlap.method,bound=overlap.bound,sep=overlap.separation;const params={separation:isSignal(sep)?scope.signalRef(sep.signal):sep,method:isSignal(method)?scope.signalRef(method.signal):method,pulse:source};if(overlap.order){params.sort=scope.compareRef({field:overlap.order})}if(bound){const tol=bound.tolerance;params.boundTolerance=isSignal(tol)?scope.signalRef(tol.signal):+tol;params.boundScale=scope.scaleRef(bound.scale);params.boundOrient=bound.orient}return ref(scope.add(Overlap(params)))}function parseLegend$1(spec,scope){const config=scope.config.legend,encode=spec.encode||{},_=lookup(spec,config),legendEncode=encode.legend||{},name=legendEncode.name||undefined,interactive=legendEncode.interactive,style=legendEncode.style,scales={};let scale=0,entryLayout,params,children;LegendScales.forEach((s=>spec[s]?(scales[s]=spec[s],scale=scale||spec[s]):0));if(!scale)error("Missing valid scale for legend.");const type=legendType(spec,scope.scaleType(scale));const datum={title:spec.title!=null,scales:scales,type:type,vgrad:type!=="symbol"&&_.isVertical()};const dataRef=ref(scope.add(Collect(null,[datum])));const entryEncode={enter:{x:{value:0},y:{value:0}}};const entryRef=ref(scope.add(LegendEntries(params={type:type,scale:scope.scaleRef(scale),count:scope.objectProperty(_("tickCount")),limit:scope.property(_("symbolLimit")),values:scope.objectProperty(spec.values),minstep:scope.property(spec.tickMinStep),formatType:scope.property(spec.formatType),formatSpecifier:scope.property(spec.format)})));if(type===Gradient){children=[legendGradient(spec,scale,config,encode.gradient),legendGradientLabels(spec,config,encode.labels,entryRef)];params.count=params.count||scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`)}else if(type===Discrete){children=[legendGradientDiscrete(spec,scale,config,encode.gradient,entryRef),legendGradientLabels(spec,config,encode.labels,entryRef)]}else{entryLayout=legendSymbolLayout(spec,config);children=[legendSymbolGroups(spec,config,encode,entryRef,deref(entryLayout.columns))];params.size=sizeExpression(spec,scope,children[0].marks)}children=[guideGroup({role:LegendEntryRole,from:dataRef,encode:entryEncode,marks:children,layout:entryLayout,interactive:interactive})];if(datum.title){children.push(legendTitle(spec,config,encode.title,dataRef))}return parseMark(guideGroup({role:LegendRole,from:dataRef,encode:extendEncode(buildLegendEncode(_,spec,config),legendEncode,Skip),marks:children,aria:_("aria"),description:_("description"),zindex:_("zindex"),name:name,interactive:interactive,style:style}),scope)}function legendType(spec,scaleType){let type=spec.type||Symbols;if(!spec.type&&scaleCount(spec)===1&&(spec.fill||spec.stroke)){type=isContinuous$1(scaleType)?Gradient:isDiscretizing$1(scaleType)?Discrete:Symbols}return type!==Gradient?type:isDiscretizing$1(scaleType)?Discrete:Gradient}function scaleCount(spec){return LegendScales.reduce(((count,type)=>count+(spec[type]?1:0)),0)}function buildLegendEncode(_,spec,config){const encode={enter:{},update:{}};addEncoders(encode,{orient:_("orient"),offset:_("offset"),padding:_("padding"),titlePadding:_("titlePadding"),cornerRadius:_("cornerRadius"),fill:_("fillColor"),stroke:_("strokeColor"),strokeWidth:config.strokeWidth,strokeDash:config.strokeDash,x:_("legendX"),y:_("legendY"),format:spec.format,formatType:spec.formatType});return encode}function sizeExpression(spec,scope,marks){const size=deref(getChannel("size",spec,marks)),strokeWidth=deref(getChannel("strokeWidth",spec,marks)),fontSize=deref(getFontSize(marks[1].encode,scope,GuideLabelStyle));return parser(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,scope)}function getChannel(name,spec,marks){return spec[name]?`scale("${spec[name]}",datum)`:getEncoding(name,marks[0].encode)}function getFontSize(encode,scope,style){return getEncoding("fontSize",encode)||getStyle("fontSize",scope,style)}const angleExpr=`item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;function parseTitle(spec,scope){spec=isString(spec)?{text:spec}:spec;const _=lookup(spec,scope.config.title),encode=spec.encode||{},userEncode=encode.group||{},name=userEncode.name||undefined,interactive=userEncode.interactive,style=userEncode.style,children=[];const datum={},dataRef=ref(scope.add(Collect(null,[datum])));children.push(buildTitle(spec,_,titleEncode(spec),dataRef));if(spec.subtitle){children.push(buildSubTitle(spec,_,encode.subtitle,dataRef))}return parseMark(guideGroup({role:TitleRole,from:dataRef,encode:groupEncode(_,userEncode),marks:children,aria:_("aria"),description:_("description"),zindex:_("zindex"),name:name,interactive:interactive,style:style}),scope)}function titleEncode(spec){const encode=spec.encode;return encode&&encode.title||extend$1({name:spec.name,interactive:spec.interactive,style:spec.style},encode)}function groupEncode(_,userEncode){const encode={enter:{},update:{}};addEncoders(encode,{orient:_("orient"),anchor:_("anchor"),align:{signal:alignExpr$1},angle:{signal:angleExpr},limit:_("limit"),frame:_("frame"),offset:_("offset")||0,padding:_("subtitlePadding")});return extendEncode(encode,userEncode,Skip)}function buildTitle(spec,_,userEncode,dataRef){const zero={value:0},text=spec.text,encode={enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};addEncoders(encode,{text:text,align:{signal:"item.mark.group.align"},angle:{signal:"item.mark.group.angle"},limit:{signal:"item.mark.group.limit"},baseline:"top",dx:_("dx"),dy:_("dy"),fill:_("color"),font:_("font"),fontSize:_("fontSize"),fontStyle:_("fontStyle"),fontWeight:_("fontWeight"),lineHeight:_("lineHeight")},{align:_("align"),angle:_("angle"),baseline:_("baseline")});return guideMark({type:TextMark,role:TitleTextRole,style:GroupTitleStyle,from:dataRef,encode:encode},userEncode)}function buildSubTitle(spec,_,userEncode,dataRef){const zero={value:0},text=spec.subtitle,encode={enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};addEncoders(encode,{text:text,align:{signal:"item.mark.group.align"},angle:{signal:"item.mark.group.angle"},limit:{signal:"item.mark.group.limit"},baseline:"top",dx:_("dx"),dy:_("dy"),fill:_("subtitleColor"),font:_("subtitleFont"),fontSize:_("subtitleFontSize"),fontStyle:_("subtitleFontStyle"),fontWeight:_("subtitleFontWeight"),lineHeight:_("subtitleLineHeight")},{align:_("align"),angle:_("angle"),baseline:_("baseline")});return guideMark({type:TextMark,role:TitleSubtitleRole,style:GroupSubtitleStyle,from:dataRef,encode:encode},userEncode)}function parseData$2(data,scope){const transforms=[];if(data.transform){data.transform.forEach((tx=>{transforms.push(parseTransform(tx,scope))}))}if(data.on){data.on.forEach((on=>{parseTrigger(on,scope,data.name)}))}scope.addDataPipeline(data.name,analyze(data,scope,transforms))}function analyze(data,scope,ops){const output=[];let source=null,modify=false,generate=false,upstream,i,n,t,m;if(data.values){if(isSignal(data.values)||hasSignal(data.format)){output.push(load(scope,data));output.push(source=collect())}else{output.push(source=collect({$ingest:data.values,$format:data.format}))}}else if(data.url){if(hasSignal(data.url)||hasSignal(data.format)){output.push(load(scope,data));output.push(source=collect())}else{output.push(source=collect({$request:data.url,$format:data.format}))}}else if(data.source){source=upstream=array$5(data.source).map((d=>ref(scope.getData(d).output)));output.push(null)}for(i=0,n=ops.length;i<n;++i){t=ops[i];m=t.metadata;if(!source&&!m.source){output.push(source=collect())}output.push(t);if(m.generates)generate=true;if(m.modifies&&!generate)modify=true;if(m.source)source=t;else if(m.changes)source=null}if(upstream){n=upstream.length-1;output[0]=Relay({derive:modify,pulse:n?upstream:upstream[0]});if(modify||n){output.splice(1,0,collect())}}if(!source)output.push(collect());output.push(Sieve({}));return output}function collect(values){const s=Collect({},values);s.metadata={source:true};return s}function load(scope,data){return Load({url:data.url?scope.property(data.url):undefined,async:data.async?scope.property(data.async):undefined,values:data.values?scope.property(data.values):undefined,format:scope.objectProperty(data.format)})}const isX=orient=>orient===Bottom||orient===Top;const getSign=(orient,a,b)=>isSignal(orient)?ifLeftTopExpr(orient.signal,a,b):orient===Left||orient===Top?a:b;const ifX=(orient,a,b)=>isSignal(orient)?ifXEnc(orient.signal,a,b):isX(orient)?a:b;const ifY=(orient,a,b)=>isSignal(orient)?ifYEnc(orient.signal,a,b):isX(orient)?b:a;const ifTop=(orient,a,b)=>isSignal(orient)?ifTopExpr(orient.signal,a,b):orient===Top?{value:a}:{value:b};const ifRight=(orient,a,b)=>isSignal(orient)?ifRightExpr(orient.signal,a,b):orient===Right?{value:a}:{value:b};const ifXEnc=($orient,a,b)=>ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`,a,b);const ifYEnc=($orient,a,b)=>ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`,a,b);const ifLeftTopExpr=($orient,a,b)=>ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`,a,b);const ifTopExpr=($orient,a,b)=>ifExpr(`${$orient} === '${Top}'`,a,b);const ifRightExpr=($orient,a,b)=>ifExpr(`${$orient} === '${Right}'`,a,b);const ifEnc=(test,a,b)=>{a=a!=null?encoder(a):a;b=b!=null?encoder(b):b;if(isSimple(a)&&isSimple(b)){a=a?a.signal||$(a.value):null;b=b?b.signal||$(b.value):null;return{signal:`${test} ? (${a}) : (${b})`}}else{return[extend$1({test:test},a)].concat(b||[])}};const isSimple=enc=>enc==null||Object.keys(enc).length===1;const ifExpr=(test,a,b)=>({signal:`${test} ? (${toExpr(a)}) : (${toExpr(b)})`});const ifOrient=($orient,t,b,l,r)=>({signal:(l!=null?`${$orient} === '${Left}' ? (${toExpr(l)}) : `:"")+(b!=null?`${$orient} === '${Bottom}' ? (${toExpr(b)}) : `:"")+(r!=null?`${$orient} === '${Right}' ? (${toExpr(r)}) : `:"")+(t!=null?`${$orient} === '${Top}' ? (${toExpr(t)}) : `:"")+"(null)"});const toExpr=v=>isSignal(v)?v.signal:v==null?null:$(v);const mult=(sign,value)=>value===0?0:isSignal(sign)?{signal:`(${sign.signal}) * ${value}`}:{value:sign*value};const patch=(value,base)=>{const s=value.signal;return s&&s.endsWith("(null)")?{signal:s.slice(0,-6)+base.signal}:value};function fallback(prop,config,axisConfig,style){let styleProp;if(config&&has$1(config,prop)){return config[prop]}else if(has$1(axisConfig,prop)){return axisConfig[prop]}else if(prop.startsWith("title")){switch(prop){case"titleColor":styleProp="fill";break;case"titleFont":case"titleFontSize":case"titleFontWeight":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style[GuideTitleStyle][styleProp]}else if(prop.startsWith("label")){switch(prop){case"labelColor":styleProp="fill";break;case"labelFont":case"labelFontSize":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style[GuideLabelStyle][styleProp]}return null}function keys$2(objects){const map={};for(const obj of objects){if(!obj)continue;for(const key in obj)map[key]=1}return Object.keys(map)}function axisConfig(spec,scope){var config=scope.config,style=config.style,axis=config.axis,band=scope.scaleType(spec.scale)==="band"&&config.axisBand,orient=spec.orient,xy,or,key;if(isSignal(orient)){const xyKeys=keys$2([config.axisX,config.axisY]),orientKeys=keys$2([config.axisTop,config.axisBottom,config.axisLeft,config.axisRight]);xy={};for(key of xyKeys){xy[key]=ifX(orient,fallback(key,config.axisX,axis,style),fallback(key,config.axisY,axis,style))}or={};for(key of orientKeys){or[key]=ifOrient(orient.signal,fallback(key,config.axisTop,axis,style),fallback(key,config.axisBottom,axis,style),fallback(key,config.axisLeft,axis,style),fallback(key,config.axisRight,axis,style))}}else{xy=orient===Top||orient===Bottom?config.axisX:config.axisY;or=config["axis"+orient[0].toUpperCase()+orient.slice(1)]}const result=xy||or||band?extend$1({},axis,xy,or,band):axis;return result}function axisDomain(spec,config,userEncode,dataRef){const _=lookup(spec,config),orient=spec.orient;let enter,update;const encode={enter:enter={opacity:zero$1},update:update={opacity:one},exit:{opacity:zero$1}};addEncoders(encode,{stroke:_("domainColor"),strokeCap:_("domainCap"),strokeDash:_("domainDash"),strokeDashOffset:_("domainDashOffset"),strokeWidth:_("domainWidth"),strokeOpacity:_("domainOpacity")});const pos0=position(spec,0);const pos1=position(spec,1);enter.x=update.x=ifX(orient,pos0,zero$1);enter.x2=update.x2=ifX(orient,pos1);enter.y=update.y=ifY(orient,pos0,zero$1);enter.y2=update.y2=ifY(orient,pos1);return guideMark({type:RuleMark,role:AxisDomainRole,from:dataRef,encode:encode},userEncode)}function position(spec,pos){return{scale:spec.scale,range:pos}}function axisGrid(spec,config,userEncode,dataRef,band){const _=lookup(spec,config),orient=spec.orient,vscale=spec.gridScale,sign=getSign(orient,1,-1),offset=offsetValue(spec.offset,sign);let enter,exit,update;const encode={enter:enter={opacity:zero$1},update:update={opacity:one},exit:exit={opacity:zero$1}};addEncoders(encode,{stroke:_("gridColor"),strokeCap:_("gridCap"),strokeDash:_("gridDash"),strokeDashOffset:_("gridDashOffset"),strokeOpacity:_("gridOpacity"),strokeWidth:_("gridWidth")});const tickPos={scale:spec.scale,field:Value,band:band.band,extra:band.extra,offset:band.offset,round:_("tickRound")};const sz=ifX(orient,{signal:"height"},{signal:"width"});const gridStart=vscale?{scale:vscale,range:0,mult:sign,offset:offset}:{value:0,offset:offset};const gridEnd=vscale?{scale:vscale,range:1,mult:sign,offset:offset}:extend$1(sz,{mult:sign,offset:offset});enter.x=update.x=ifX(orient,tickPos,gridStart);enter.y=update.y=ifY(orient,tickPos,gridStart);enter.x2=update.x2=ifY(orient,gridEnd);enter.y2=update.y2=ifX(orient,gridEnd);exit.x=ifX(orient,tickPos);exit.y=ifY(orient,tickPos);return guideMark({type:RuleMark,role:AxisGridRole,key:Value,from:dataRef,encode:encode},userEncode)}function offsetValue(offset,sign){if(sign===1);else if(!isObject(offset)){offset=isSignal(sign)?{signal:`(${sign.signal}) * (${offset||0})`}:sign*(offset||0)}else{let entry=offset=extend$1({},offset);while(entry.mult!=null){if(!isObject(entry.mult)){entry.mult=isSignal(sign)?{signal:`(${entry.mult}) * (${sign.signal})`}:entry.mult*sign;return offset}else{entry=entry.mult=extend$1({},entry.mult)}}entry.mult=sign}return offset}function axisTicks(spec,config,userEncode,dataRef,size,band){const _=lookup(spec,config),orient=spec.orient,sign=getSign(orient,-1,1);let enter,exit,update;const encode={enter:enter={opacity:zero$1},update:update={opacity:one},exit:exit={opacity:zero$1}};addEncoders(encode,{stroke:_("tickColor"),strokeCap:_("tickCap"),strokeDash:_("tickDash"),strokeDashOffset:_("tickDashOffset"),strokeOpacity:_("tickOpacity"),strokeWidth:_("tickWidth")});const tickSize=encoder(size);tickSize.mult=sign;const tickPos={scale:spec.scale,field:Value,band:band.band,extra:band.extra,offset:band.offset,round:_("tickRound")};update.y=enter.y=ifX(orient,zero$1,tickPos);update.y2=enter.y2=ifX(orient,tickSize);exit.x=ifX(orient,tickPos);update.x=enter.x=ifY(orient,zero$1,tickPos);update.x2=enter.x2=ifY(orient,tickSize);exit.y=ifY(orient,tickPos);return guideMark({type:RuleMark,role:AxisTickRole,key:Value,from:dataRef,encode:encode},userEncode)}function flushExpr(scale,threshold,a,b,c){return{signal:'flush(range("'+scale+'"), '+'scale("'+scale+'", datum.value), '+threshold+","+a+","+b+","+c+")"}}function axisLabels(spec,config,userEncode,dataRef,size,band){const _=lookup(spec,config),orient=spec.orient,scale=spec.scale,sign=getSign(orient,-1,1),flush=deref(_("labelFlush")),flushOffset=deref(_("labelFlushOffset")),labelAlign=_("labelAlign"),labelBaseline=_("labelBaseline");let flushOn=flush===0||!!flush,update;const tickSize=encoder(size);tickSize.mult=sign;tickSize.offset=encoder(_("labelPadding")||0);tickSize.offset.mult=sign;const tickPos={scale:scale,field:Value,band:.5,offset:extendOffset(band.offset,_("labelOffset"))};const align=ifX(orient,flushOn?flushExpr(scale,flush,'"left"','"right"','"center"'):{value:"center"},ifRight(orient,"left","right"));const baseline=ifX(orient,ifTop(orient,"bottom","top"),flushOn?flushExpr(scale,flush,'"top"','"bottom"','"middle"'):{value:"middle"});const offsetExpr=flushExpr(scale,flush,`-(${flushOffset})`,flushOffset,0);flushOn=flushOn&&flushOffset;const enter={opacity:zero$1,x:ifX(orient,tickPos,tickSize),y:ifY(orient,tickPos,tickSize)};const encode={enter:enter,update:update={opacity:one,text:{field:Label},x:enter.x,y:enter.y,align:align,baseline:baseline},exit:{opacity:zero$1,x:enter.x,y:enter.y}};addEncoders(encode,{dx:!labelAlign&&flushOn?ifX(orient,offsetExpr):null,dy:!labelBaseline&&flushOn?ifY(orient,offsetExpr):null});addEncoders(encode,{angle:_("labelAngle"),fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontWeight:_("labelFontWeight"),fontStyle:_("labelFontStyle"),limit:_("labelLimit"),lineHeight:_("labelLineHeight")},{align:labelAlign,baseline:labelBaseline});const bound=_("labelBound");let overlap=_("labelOverlap");overlap=overlap||bound?{separation:_("labelSeparation"),method:overlap,order:"datum.index",bound:bound?{scale:scale,orient:orient,tolerance:bound}:null}:undefined;if(update.align!==align){update.align=patch(update.align,align)}if(update.baseline!==baseline){update.baseline=patch(update.baseline,baseline)}return guideMark({type:TextMark,role:AxisLabelRole,style:GuideLabelStyle,key:Value,from:dataRef,encode:encode,overlap:overlap},userEncode)}function axisTitle(spec,config,userEncode,dataRef){const _=lookup(spec,config),orient=spec.orient,sign=getSign(orient,-1,1);let enter,update;const encode={enter:enter={opacity:zero$1,anchor:encoder(_("titleAnchor",null)),align:{signal:alignExpr$1}},update:update=extend$1({},enter,{opacity:one,text:encoder(spec.title)}),exit:{opacity:zero$1}};const titlePos={signal:`lerp(range("${spec.scale}"), ${anchorExpr(0,1,.5)})`};update.x=ifX(orient,titlePos);update.y=ifY(orient,titlePos);enter.angle=ifX(orient,zero$1,mult(sign,90));enter.baseline=ifX(orient,ifTop(orient,Bottom,Top),{value:Bottom});update.angle=enter.angle;update.baseline=enter.baseline;addEncoders(encode,{fill:_("titleColor"),fillOpacity:_("titleOpacity"),font:_("titleFont"),fontSize:_("titleFontSize"),fontStyle:_("titleFontStyle"),fontWeight:_("titleFontWeight"),limit:_("titleLimit"),lineHeight:_("titleLineHeight")},{align:_("titleAlign"),angle:_("titleAngle"),baseline:_("titleBaseline")});autoLayout(_,orient,encode,userEncode);encode.update.align=patch(encode.update.align,enter.align);encode.update.angle=patch(encode.update.angle,enter.angle);encode.update.baseline=patch(encode.update.baseline,enter.baseline);return guideMark({type:TextMark,role:AxisTitleRole,style:GuideTitleStyle,from:dataRef,encode:encode},userEncode)}function autoLayout(_,orient,encode,userEncode){const auto=(value,dim)=>value!=null?(encode.update[dim]=patch(encoder(value),encode.update[dim]),false):!has(dim,userEncode)?true:false;const autoY=auto(_("titleX"),"x"),autoX=auto(_("titleY"),"y");encode.enter.auto=autoX===autoY?encoder(autoX):ifX(orient,encoder(autoX),encoder(autoY))}function parseAxis$1(spec,scope){const config=axisConfig(spec,scope),encode=spec.encode||{},axisEncode=encode.axis||{},name=axisEncode.name||undefined,interactive=axisEncode.interactive,style=axisEncode.style,_=lookup(spec,config),band=tickBand(_);const datum={scale:spec.scale,ticks:!!_("ticks"),labels:!!_("labels"),grid:!!_("grid"),domain:!!_("domain"),title:spec.title!=null};const dataRef=ref(scope.add(Collect({},[datum])));const ticksRef=ref(scope.add(AxisTicks({scale:scope.scaleRef(spec.scale),extra:scope.property(band.extra),count:scope.objectProperty(spec.tickCount),values:scope.objectProperty(spec.values),minstep:scope.property(spec.tickMinStep),formatType:scope.property(spec.formatType),formatSpecifier:scope.property(spec.format)})));const children=[];let size;if(datum.grid){children.push(axisGrid(spec,config,encode.grid,ticksRef,band))}if(datum.ticks){size=_("tickSize");children.push(axisTicks(spec,config,encode.ticks,ticksRef,size,band))}if(datum.labels){size=datum.ticks?size:0;children.push(axisLabels(spec,config,encode.labels,ticksRef,size,band))}if(datum.domain){children.push(axisDomain(spec,config,encode.domain,dataRef))}if(datum.title){children.push(axisTitle(spec,config,encode.title,dataRef))}return parseMark(guideGroup({role:AxisRole,from:dataRef,encode:extendEncode(buildAxisEncode(_,spec),axisEncode,Skip),marks:children,aria:_("aria"),description:_("description"),zindex:_("zindex"),name:name,interactive:interactive,style:style}),scope)}function buildAxisEncode(_,spec){const encode={enter:{},update:{}};addEncoders(encode,{orient:_("orient"),offset:_("offset")||0,position:value(spec.position,0),titlePadding:_("titlePadding"),minExtent:_("minExtent"),maxExtent:_("maxExtent"),range:{signal:`abs(span(range("${spec.scale}")))`},translate:_("translate"),format:spec.format,formatType:spec.formatType});return encode}function parseScope(spec,scope,preprocessed){const signals=array$5(spec.signals),scales=array$5(spec.scales);if(!preprocessed)signals.forEach((_=>parseSignal(_,scope)));array$5(spec.projections).forEach((_=>parseProjection$1(_,scope)));scales.forEach((_=>initScale(_,scope)));array$5(spec.data).forEach((_=>parseData$2(_,scope)));scales.forEach((_=>parseScale(_,scope)));(preprocessed||signals).forEach((_=>parseSignalUpdates(_,scope)));array$5(spec.axes).forEach((_=>parseAxis$1(_,scope)));array$5(spec.marks).forEach((_=>parseMark(_,scope)));array$5(spec.legends).forEach((_=>parseLegend$1(_,scope)));if(spec.title)parseTitle(spec.title,scope);scope.parseLambdas();return scope}const rootEncode=spec=>extendEncode({enter:{x:{value:0},y:{value:0}},update:{width:{signal:"width"},height:{signal:"height"}}},spec);function parseView(spec,scope){const config=scope.config;const root=ref(scope.root=scope.add(operator()));const signals=collectSignals(spec,config);signals.forEach((_=>parseSignal(_,scope)));scope.description=spec.description||config.description;scope.eventConfig=config.events;scope.legends=scope.objectProperty(config.legend&&config.legend.layout);scope.locale=config.locale;const input=scope.add(Collect());const encode=scope.add(Encode(parseEncode(rootEncode(spec.encode),GroupMark,FrameRole,spec.style,scope,{pulse:ref(input)})));const parent=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,autosize:scope.signalRef("autosize"),mark:root,pulse:ref(encode)}));scope.operators.pop();scope.pushState(ref(encode),ref(parent),null);parseScope(spec,scope,signals);scope.operators.push(parent);let op=scope.add(Bound({mark:root,pulse:ref(parent)}));op=scope.add(Render({pulse:ref(op)}));op=scope.add(Sieve({pulse:ref(op)}));scope.addData("root",new DataScope(scope,input,input,op));return scope}function signalObject(name,value){return value&&value.signal?{name:name,update:value.signal}:{name:name,value:value}}function collectSignals(spec,config){const _=name=>value(spec[name],config[name]),signals=[signalObject("background",_("background")),signalObject("autosize",parseAutosize(_("autosize"))),signalObject("padding",parsePadding(_("padding"))),signalObject("width",_("width")||0),signalObject("height",_("height")||0)],pre=signals.reduce(((p,s)=>(p[s.name]=s,p)),{}),map={};array$5(spec.signals).forEach((s=>{if(has$1(pre,s.name)){s=extend$1(pre[s.name],s)}else{signals.push(s)}map[s.name]=s}));array$5(config.signals).forEach((s=>{if(!has$1(map,s.name)&&!has$1(pre,s.name)){signals.push(s)}}));return signals}function Scope(config,options){this.config=config||{};this.options=options||{};this.bindings=[];this.field={};this.signals={};this.lambdas={};this.scales={};this.events={};this.data={};this.streams=[];this.updates=[];this.operators=[];this.eventConfig=null;this.locale=null;this._id=0;this._subid=0;this._nextsub=[0];this._parent=[];this._encode=[];this._lookup=[];this._markpath=[]}function Subscope(scope){this.config=scope.config;this.options=scope.options;this.legends=scope.legends;this.field=Object.create(scope.field);this.signals=Object.create(scope.signals);this.lambdas=Object.create(scope.lambdas);this.scales=Object.create(scope.scales);this.events=Object.create(scope.events);this.data=Object.create(scope.data);this.streams=[];this.updates=[];this.operators=[];this._id=0;this._subid=++scope._nextsub[0];this._nextsub=scope._nextsub;this._parent=scope._parent.slice();this._encode=scope._encode.slice();this._lookup=scope._lookup.slice();this._markpath=scope._markpath}Scope.prototype=Subscope.prototype={parse(spec){return parseScope(spec,this)},fork(){return new Subscope(this)},isSubscope(){return this._subid>0},toRuntime(){this.finish();return{description:this.description,operators:this.operators,streams:this.streams,updates:this.updates,bindings:this.bindings,eventConfig:this.eventConfig,locale:this.locale}},id(){return(this._subid?this._subid+":":0)+this._id++},add(op){this.operators.push(op);op.id=this.id();if(op.refs){op.refs.forEach((ref=>{ref.$ref=op.id}));op.refs=null}return op},proxy(op){const vref=op instanceof Entry?ref(op):op;return this.add(Proxy({value:vref}))},addStream(stream){this.streams.push(stream);stream.id=this.id();return stream},addUpdate(update){this.updates.push(update);return update},finish(){let name,ds;if(this.root)this.root.root=true;for(name in this.signals){this.signals[name].signal=name}for(name in this.scales){this.scales[name].scale=name}function annotate(op,name,type){let data,list;if(op){data=op.data||(op.data={});list=data[name]||(data[name]=[]);list.push(type)}}for(name in this.data){ds=this.data[name];annotate(ds.input,name,"input");annotate(ds.output,name,"output");annotate(ds.values,name,"values");for(const field in ds.index){annotate(ds.index[field],name,"index:"+field)}}return this},pushState(encode,parent,lookup){this._encode.push(ref(this.add(Sieve({pulse:encode}))));this._parent.push(parent);this._lookup.push(lookup?ref(this.proxy(lookup)):null);this._markpath.push(-1)},popState(){this._encode.pop();this._parent.pop();this._lookup.pop();this._markpath.pop()},parent(){return peek$1(this._parent)},encode(){return peek$1(this._encode)},lookup(){return peek$1(this._lookup)},markpath(){const p=this._markpath;return++p[p.length-1]},fieldRef(field,name){if(isString(field))return fieldRef$1(field,name);if(!field.signal){error("Unsupported field reference: "+$(field))}const s=field.signal;let f=this.field[s];if(!f){const params={name:this.signalRef(s)};if(name)params.as=name;this.field[s]=f=ref(this.add(Field(params)))}return f},compareRef(cmp){let signal=false;const check=_=>isSignal(_)?(signal=true,this.signalRef(_.signal)):isExpr$1(_)?(signal=true,this.exprRef(_.expr)):_;const fields=array$5(cmp.field).map(check),orders=array$5(cmp.order).map(check);return signal?ref(this.add(Compare({fields:fields,orders:orders}))):compareRef(fields,orders)},keyRef(fields,flat){let signal=false;const check=_=>isSignal(_)?(signal=true,ref(sig[_.signal])):_;const sig=this.signals;fields=array$5(fields).map(check);return signal?ref(this.add(Key({fields:fields,flat:flat}))):keyRef(fields,flat)},sortRef(sort){if(!sort)return sort;const a=aggrField(sort.op,sort.field),o=sort.order||Ascending;return o.signal?ref(this.add(Compare({fields:a,orders:this.signalRef(o.signal)}))):compareRef(a,o)},event(source,type){const key=source+":"+type;if(!this.events[key]){const id=this.id();this.streams.push({id:id,source:source,type:type});this.events[key]=id}return this.events[key]},hasOwnSignal(name){return has$1(this.signals,name)},addSignal(name,value){if(this.hasOwnSignal(name)){error("Duplicate signal name: "+$(name))}const op=value instanceof Entry?value:this.add(operator(value));return this.signals[name]=op},getSignal(name){if(!this.signals[name]){error("Unrecognized signal name: "+$(name))}return this.signals[name]},signalRef(s){if(this.signals[s]){return ref(this.signals[s])}else if(!has$1(this.lambdas,s)){this.lambdas[s]=this.add(operator(null))}return ref(this.lambdas[s])},parseLambdas(){const code=Object.keys(this.lambdas);for(let i=0,n=code.length;i<n;++i){const s=code[i],e=parser(s,this),op=this.lambdas[s];op.params=e.$params;op.update=e.$expr}},property(spec){return spec&&spec.signal?this.signalRef(spec.signal):spec},objectProperty(spec){return!spec||!isObject(spec)?spec:this.signalRef(spec.signal||propertyLambda(spec))},exprRef(code,name){const params={expr:parser(code,this)};if(name)params.expr.$name=name;return ref(this.add(Expression(params)))},addBinding(name,bind){if(!this.bindings){error("Nested signals do not support binding: "+$(name))}this.bindings.push(extend$1({signal:name},bind))},addScaleProj(name,transform){if(has$1(this.scales,name)){error("Duplicate scale or projection name: "+$(name))}this.scales[name]=this.add(transform)},addScale(name,params){this.addScaleProj(name,Scale(params))},addProjection(name,params){this.addScaleProj(name,Projection(params))},getScale(name){if(!this.scales[name]){error("Unrecognized scale name: "+$(name))}return this.scales[name]},scaleRef(name){return ref(this.getScale(name))},scaleType(name){return this.getScale(name).params.type},projectionRef(name){return this.scaleRef(name)},projectionType(name){return this.scaleType(name)},addData(name,dataScope){if(has$1(this.data,name)){error("Duplicate data set name: "+$(name))}return this.data[name]=dataScope},getData(name){if(!this.data[name]){error("Undefined data set name: "+$(name))}return this.data[name]},addDataPipeline(name,entries){if(has$1(this.data,name)){error("Duplicate data set name: "+$(name))}return this.addData(name,DataScope.fromEntries(this,entries))}};function propertyLambda(spec){return(isArray(spec)?arrayLambda:objectLambda)(spec)}function arrayLambda(array){const n=array.length;let code="[";for(let i=0;i<n;++i){const value=array[i];code+=(i>0?",":"")+(isObject(value)?value.signal||propertyLambda(value):$(value))}return code+"]"}function objectLambda(obj){let code="{",i=0,key,value;for(key in obj){value=obj[key];code+=(++i>1?",":"")+$(key)+":"+(isObject(value)?value.signal||propertyLambda(value):$(value))}return code+"}"}function defaults(){const defaultFont="sans-serif",defaultSymbolSize=30,defaultStrokeWidth=2,defaultColor="#4c78a8",black="#000",gray="#888",lightGray="#ddd";return{description:"Vega visualization",padding:0,autosize:"pad",background:null,events:{defaults:{allow:["wheel"]}},group:null,mark:null,arc:{fill:defaultColor},area:{fill:defaultColor},image:null,line:{stroke:defaultColor,strokeWidth:defaultStrokeWidth},path:{stroke:defaultColor},rect:{fill:defaultColor},rule:{stroke:black},shape:{stroke:defaultColor},symbol:{fill:defaultColor,size:64},text:{fill:black,font:defaultFont,fontSize:11},trail:{fill:defaultColor,size:defaultStrokeWidth},style:{"guide-label":{fill:black,font:defaultFont,fontSize:10},"guide-title":{fill:black,font:defaultFont,fontSize:11,fontWeight:"bold"},"group-title":{fill:black,font:defaultFont,fontSize:13,fontWeight:"bold"},"group-subtitle":{fill:black,font:defaultFont,fontSize:12},point:{size:defaultSymbolSize,strokeWidth:defaultStrokeWidth,shape:"circle"},circle:{size:defaultSymbolSize,strokeWidth:defaultStrokeWidth},square:{size:defaultSymbolSize,strokeWidth:defaultStrokeWidth,shape:"square"},cell:{fill:"transparent",stroke:lightGray},view:{fill:"transparent"}},title:{orient:"top",anchor:"middle",offset:4,subtitlePadding:3},axis:{minExtent:0,maxExtent:200,bandPosition:.5,domain:true,domainWidth:1,domainColor:gray,grid:false,gridWidth:1,gridColor:lightGray,labels:true,labelAngle:0,labelLimit:180,labelOffset:0,labelPadding:2,ticks:true,tickColor:gray,tickOffset:0,tickRound:true,tickSize:5,tickWidth:1,titlePadding:4},axisBand:{tickOffset:-.5},projection:{type:"mercator"},legend:{orient:"right",padding:0,gridAlign:"each",columnPadding:10,rowPadding:2,symbolDirection:"vertical",gradientDirection:"vertical",gradientLength:200,gradientThickness:16,gradientStrokeColor:lightGray,gradientStrokeWidth:0,gradientLabelOffset:2,labelAlign:"left",labelBaseline:"middle",labelLimit:160,labelOffset:4,labelOverlap:true,symbolLimit:30,symbolType:"circle",symbolSize:100,symbolOffset:0,symbolStrokeWidth:1.5,symbolBaseFillColor:"transparent",symbolBaseStrokeColor:gray,titleLimit:180,titleOrient:"top",titlePadding:5,layout:{offset:18,direction:"horizontal",left:{direction:"vertical"},right:{direction:"vertical"}}},range:{category:{scheme:"tableau10"},ordinal:{scheme:"blues"},heatmap:{scheme:"yellowgreenblue"},ramp:{scheme:"blues"},diverging:{scheme:"blueorange",extent:[1,0]},symbol:["circle","square","triangle-up","cross","diamond","triangle-right","triangle-down","triangle-left"]}}}function parse(spec,config,options){if(!isObject(spec)){error("Input Vega specification must be an object.")}config=mergeConfig(defaults(),config,spec.config);return parseView(spec,new Scope(config,options)).toRuntime()}extend$1(transforms,tx,vtx,encode$1,geo,force,label,tree,reg,voronoi,wordcloud,xf);const VOID=-1;const PRIMITIVE=0;const ARRAY=1;const OBJECT=2;const DATE=3;const REGEXP=4;const MAP=5;const SET=6;const ERROR=7;const BIGINT=8;const env=typeof self==="object"?self:globalThis;const deserializer=($,_)=>{const as=(out,index)=>{$.set(index,out);return out};const unpair=index=>{if($.has(index))return $.get(index);const[type,value]=_[index];switch(type){case PRIMITIVE:case VOID:return as(value,index);case ARRAY:{const arr=as([],index);for(const index of value)arr.push(unpair(index));return arr}case OBJECT:{const object=as({},index);for(const[key,index]of value)object[unpair(key)]=unpair(index);return object}case DATE:return as(new Date(value),index);case REGEXP:{const{source:source,flags:flags}=value;return as(new RegExp(source,flags),index)}case MAP:{const map=as(new Map,index);for(const[key,index]of value)map.set(unpair(key),unpair(index));return map}case SET:{const set=as(new Set,index);for(const index of value)set.add(unpair(index));return set}case ERROR:{const{name:name,message:message}=value;return as(new env[name](message),index)}case BIGINT:return as(BigInt(value),index);case"BigInt":return as(Object(BigInt(value)),index)}return as(new env[type](value),index)};return unpair};const deserialize=serialized=>deserializer(new Map,serialized)(0);const EMPTY="";const{toString:toString}={};const{keys:keys$1}=Object;const typeOf=value=>{const type=typeof value;if(type!=="object"||!value)return[PRIMITIVE,type];const asString=toString.call(value).slice(8,-1);switch(asString){case"Array":return[ARRAY,EMPTY];case"Object":return[OBJECT,EMPTY];case"Date":return[DATE,EMPTY];case"RegExp":return[REGEXP,EMPTY];case"Map":return[MAP,EMPTY];case"Set":return[SET,EMPTY]}if(asString.includes("Array"))return[ARRAY,asString];if(asString.includes("Error"))return[ERROR,asString];return[OBJECT,asString]};const shouldSkip=([TYPE,type])=>TYPE===PRIMITIVE&&(type==="function"||type==="symbol");const serializer=(strict,json,$,_)=>{const as=(out,value)=>{const index=_.push(out)-1;$.set(value,index);return index};const pair=value=>{if($.has(value))return $.get(value);let[TYPE,type]=typeOf(value);switch(TYPE){case PRIMITIVE:{let entry=value;switch(type){case"bigint":TYPE=BIGINT;entry=value.toString();break;case"function":case"symbol":if(strict)throw new TypeError("unable to serialize "+type);entry=null;break;case"undefined":return as([VOID],value)}return as([TYPE,entry],value)}case ARRAY:{if(type)return as([type,[...value]],value);const arr=[];const index=as([TYPE,arr],value);for(const entry of value)arr.push(pair(entry));return index}case OBJECT:{if(type){switch(type){case"BigInt":return as([type,value.toString()],value);case"Boolean":case"Number":case"String":return as([type,value.valueOf()],value)}}if(json&&"toJSON"in value)return pair(value.toJSON());const entries=[];const index=as([TYPE,entries],value);for(const key of keys$1(value)){if(strict||!shouldSkip(typeOf(value[key])))entries.push([pair(key),pair(value[key])])}return index}case DATE:return as([TYPE,value.toISOString()],value);case REGEXP:{const{source:source,flags:flags}=value;return as([TYPE,{source:source,flags:flags}],value)}case MAP:{const entries=[];const index=as([TYPE,entries],value);for(const[key,entry]of value){if(strict||!(shouldSkip(typeOf(key))||shouldSkip(typeOf(entry))))entries.push([pair(key),pair(entry)])}return index}case SET:{const entries=[];const index=as([TYPE,entries],value);for(const entry of value){if(strict||!shouldSkip(typeOf(entry)))entries.push(pair(entry))}return index}}const{message:message}=value;return as([TYPE,{name:type,message:message}],value)};return pair};const serialize=(value,{json:json,lossy:lossy}={})=>{const _=[];return serializer(!(json||lossy),!!json,new Map,_)(value),_};var structuredClone=typeof structuredClone==="function"?(any,options)=>options&&("json"in options||"lossy"in options)?deserialize(serialize(any,options)):structuredClone(any):(any,options)=>deserialize(serialize(any,options));function isLogicalOr(op){return hasProperty(op,"or")}function isLogicalAnd(op){return hasProperty(op,"and")}function isLogicalNot(op){return hasProperty(op,"not")}function forEachLeaf(op,fn){if(isLogicalNot(op)){forEachLeaf(op.not,fn)}else if(isLogicalAnd(op)){for(const subop of op.and){forEachLeaf(subop,fn)}}else if(isLogicalOr(op)){for(const subop of op.or){forEachLeaf(subop,fn)}}else{fn(op)}}function normalizeLogicalComposition(op,normalizer){if(isLogicalNot(op)){return{not:normalizeLogicalComposition(op.not,normalizer)}}else if(isLogicalAnd(op)){return{and:op.and.map((o=>normalizeLogicalComposition(o,normalizer)))}}else if(isLogicalOr(op)){return{or:op.or.map((o=>normalizeLogicalComposition(o,normalizer)))}}else{return normalizer(op)}}const duplicate=structuredClone;function never(message){throw new Error(message)}function pick(obj,props){const copy={};for(const prop of props){if(has$1(obj,prop)){copy[prop]=obj[prop]}}return copy}function omit(obj,props){const copy={...obj};for(const prop of props){delete copy[prop]}return copy}Set.prototype["toJSON"]=function(){return`Set(${[...this].map((x=>stringify(x))).join(",")})`};function hash(a){if(isNumber$1(a)){return a}const str=isString(a)?a:stringify(a);if(str.length<250){return str}let h=0;for(let i=0;i<str.length;i++){const char=str.charCodeAt(i);h=(h<<5)-h+char;h=h&h}return h}function isNullOrFalse(x){return x===false||x===null}function contains(array,item){return array.includes(item)}function some(arr,f){let i=0;for(const[k,a]of arr.entries()){if(f(a,k,i++)){return true}}return false}function every(arr,f){let i=0;for(const[k,a]of arr.entries()){if(!f(a,k,i++)){return false}}return true}function mergeDeep(dest,...src){for(const s of src){deepMerge_(dest,s??{})}return dest}function deepMerge_(dest,src){for(const property of keys(src)){writeConfig(dest,property,src[property],true)}}function unique(values,f){const results=[];const u={};let v;for(const val of values){v=f(val);if(v in u){continue}u[v]=1;results.push(val)}return results}function setEqual(a,b){if(a.size!==b.size){return false}for(const e of a){if(!b.has(e)){return false}}return true}function hasIntersection(a,b){for(const key of a){if(b.has(key)){return true}}return false}function prefixGenerator(a){const prefixes=new Set;for(const x of a){const splitField=splitAccessPath(x);const wrappedWithAccessors=splitField.map(((y,i)=>i===0?y:`[${y}]`));const computedPrefixes=wrappedWithAccessors.map(((_,i)=>wrappedWithAccessors.slice(0,i+1).join("")));for(const y of computedPrefixes){prefixes.add(y)}}return prefixes}function fieldIntersection(a,b){if(a===undefined||b===undefined){return true}return hasIntersection(prefixGenerator(a),prefixGenerator(b))}function isEmpty(obj){return keys(obj).length===0}const keys=Object.keys;const vals=Object.values;const entries$1=Object.entries;function isBoolean(b){return b===true||b===false}function varName(s){const alphanumericS=s.replace(/\W/g,"_");return(s.match(/^\d+/)?"_":"")+alphanumericS}function logicalExpr(op,cb){if(isLogicalNot(op)){return`!(${logicalExpr(op.not,cb)})`}else if(isLogicalAnd(op)){return`(${op.and.map((and=>logicalExpr(and,cb))).join(") && (")})`}else if(isLogicalOr(op)){return`(${op.or.map((or=>logicalExpr(or,cb))).join(") || (")})`}else{return cb(op)}}function deleteNestedProperty(obj,orderedProps){if(orderedProps.length===0){return true}const prop=orderedProps.shift();if(prop in obj&&deleteNestedProperty(obj[prop],orderedProps)){delete obj[prop]}return isEmpty(obj)}function titleCase(s){return s.charAt(0).toUpperCase()+s.substr(1)}function accessPathWithDatum(path,datum="datum"){const pieces=splitAccessPath(path);const prefixes=[];for(let i=1;i<=pieces.length;i++){const prefix=`[${pieces.slice(0,i).map($).join("][")}]`;prefixes.push(`${datum}${prefix}`)}return prefixes.join(" && ")}function flatAccessWithDatum(path,datum="datum"){return`${datum}[${$(splitAccessPath(path).join("."))}]`}function escapePathAccess(string){return string.replace(/(\[|\]|\.|'|")/g,"\\$1")}function replacePathInField(path){return`${splitAccessPath(path).map(escapePathAccess).join("\\.")}`}function replaceAll(string,find,replacement){return string.replace(new RegExp(find.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"),"g"),replacement)}function removePathFromField(path){return`${splitAccessPath(path).join(".")}`}function accessPathDepth(path){if(!path){return 0}return splitAccessPath(path).length}function getFirstDefined(...args){return args.find((a=>a!==undefined))}let idCounter=42;function uniqueId(prefix){const id=++idCounter;return prefix?String(prefix)+id:id}function internalField(name){return isInternalField(name)?name:`__${name}`}function isInternalField(name){return name.startsWith("__")}function normalizeAngle(angle){if(angle===undefined){return undefined}return(angle%360+360)%360}function isNumeric(value){if(isNumber$1(value)){return true}return!isNaN(value)&&!isNaN(parseFloat(value))}const clonedProto=Object.getPrototypeOf(structuredClone({}));function deepEqual(a,b){if(a===b)return true;if(a&&b&&typeof a=="object"&&typeof b=="object"){if(a.constructor.name!==b.constructor.name)return false;let length;let i;if(Array.isArray(a)){length=a.length;if(length!=b.length)return false;for(i=length;i--!==0;)if(!deepEqual(a[i],b[i]))return false;return true}if(a instanceof Map&&b instanceof Map){if(a.size!==b.size)return false;for(const e of a.entries())if(!b.has(e[0]))return false;for(const e of a.entries())if(!deepEqual(e[1],b.get(e[0])))return false;return true}if(a instanceof Set&&b instanceof Set){if(a.size!==b.size)return false;for(const e of a.entries())if(!b.has(e[0]))return false;return true}if(ArrayBuffer.isView(a)&&ArrayBuffer.isView(b)){length=a.length;if(length!=b.length)return false;for(i=length;i--!==0;)if(a[i]!==b[i])return false;return true}if(a.constructor===RegExp)return a.source===b.source&&a.flags===b.flags;if(a.valueOf!==Object.prototype.valueOf&&a.valueOf!==clonedProto.valueOf)return a.valueOf()===b.valueOf();if(a.toString!==Object.prototype.toString&&a.toString!==clonedProto.toString)return a.toString()===b.toString();const ks=Object.keys(a);length=ks.length;if(length!==Object.keys(b).length)return false;for(i=length;i--!==0;)if(!Object.prototype.hasOwnProperty.call(b,ks[i]))return false;for(i=length;i--!==0;){const key=ks[i];if(!deepEqual(a[key],b[key]))return false}return true}return a!==a&&b!==b}function stringify(data){const seen=[];return function _stringify(node){if(node&&node.toJSON&&typeof node.toJSON==="function"){node=node.toJSON()}if(node===undefined)return undefined;if(typeof node=="number")return isFinite(node)?""+node:"null";if(typeof node!=="object")return JSON.stringify(node);let i,out;if(Array.isArray(node)){out="[";for(i=0;i<node.length;i++){if(i)out+=",";out+=_stringify(node[i])||"null"}return out+"]"}if(node===null)return"null";if(seen.includes(node)){throw new TypeError("Converting circular structure to JSON")}const seenIndex=seen.push(node)-1;const ks=Object.keys(node).sort();out="";for(i=0;i<ks.length;i++){const key=ks[i];const value=_stringify(node[key]);if(!value)continue;if(out)out+=",";out+=JSON.stringify(key)+":"+value}seen.splice(seenIndex,1);return`{${out}}`}(data)}function hasProperty(obj,key){return isObject(obj)&&has$1(obj,key)&&obj[key]!==undefined}const ROW="row";const COLUMN="column";const FACET="facet";const X="x";const Y="y";const X2="x2";const Y2="y2";const XOFFSET="xOffset";const YOFFSET="yOffset";const RADIUS="radius";const RADIUS2="radius2";const THETA="theta";const THETA2="theta2";const LATITUDE="latitude";const LONGITUDE="longitude";const LATITUDE2="latitude2";const LONGITUDE2="longitude2";const COLOR="color";const FILL="fill";const STROKE="stroke";const SHAPE="shape";const SIZE="size";const ANGLE="angle";const OPACITY="opacity";const FILLOPACITY="fillOpacity";const STROKEOPACITY="strokeOpacity";const STROKEWIDTH="strokeWidth";const STROKEDASH="strokeDash";const TEXT$1="text";const ORDER="order";const DETAIL="detail";const KEY="key";const TOOLTIP="tooltip";const HREF="href";const URL="url";const DESCRIPTION="description";const POSITION_CHANNEL_INDEX={x:1,y:1,x2:1,y2:1};const POLAR_POSITION_CHANNEL_INDEX={theta:1,theta2:1,radius:1,radius2:1};function isPolarPositionChannel(c){return has$1(POLAR_POSITION_CHANNEL_INDEX,c)}const GEO_POSIITON_CHANNEL_INDEX={longitude:1,longitude2:1,latitude:1,latitude2:1};function getPositionChannelFromLatLong(channel){switch(channel){case LATITUDE:return"y";case LATITUDE2:return"y2";case LONGITUDE:return"x";case LONGITUDE2:return"x2"}}function isGeoPositionChannel(c){return has$1(GEO_POSIITON_CHANNEL_INDEX,c)}const GEOPOSITION_CHANNELS=keys(GEO_POSIITON_CHANNEL_INDEX);const UNIT_CHANNEL_INDEX={...POSITION_CHANNEL_INDEX,...POLAR_POSITION_CHANNEL_INDEX,...GEO_POSIITON_CHANNEL_INDEX,xOffset:1,yOffset:1,color:1,fill:1,stroke:1,opacity:1,fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeDash:1,size:1,angle:1,shape:1,order:1,text:1,detail:1,key:1,tooltip:1,href:1,url:1,description:1};function isColorChannel(channel){return channel===COLOR||channel===FILL||channel===STROKE}const FACET_CHANNEL_INDEX={row:1,column:1,facet:1};const FACET_CHANNELS=keys(FACET_CHANNEL_INDEX);const CHANNEL_INDEX={...UNIT_CHANNEL_INDEX,...FACET_CHANNEL_INDEX};const CHANNELS=keys(CHANNEL_INDEX);const{order:_o,detail:_d,tooltip:_tt1,...SINGLE_DEF_CHANNEL_INDEX}=CHANNEL_INDEX;const{row:_r,column:_c,facet:_f,...SINGLE_DEF_UNIT_CHANNEL_INDEX}=SINGLE_DEF_CHANNEL_INDEX;function isSingleDefUnitChannel(str){return has$1(SINGLE_DEF_UNIT_CHANNEL_INDEX,str)}function isChannel(str){return has$1(CHANNEL_INDEX,str)}const SECONDARY_RANGE_CHANNEL=[X2,Y2,LATITUDE2,LONGITUDE2,THETA2,RADIUS2];function isSecondaryRangeChannel(c){const main=getMainRangeChannel(c);return main!==c}function getMainRangeChannel(channel){switch(channel){case X2:return X;case Y2:return Y;case LATITUDE2:return LATITUDE;case LONGITUDE2:return LONGITUDE;case THETA2:return THETA;case RADIUS2:return RADIUS}return channel}function getVgPositionChannel(channel){if(isPolarPositionChannel(channel)){switch(channel){case THETA:return"startAngle";case THETA2:return"endAngle";case RADIUS:return"outerRadius";case RADIUS2:return"innerRadius"}}return channel}function getSecondaryRangeChannel(channel){switch(channel){case X:return X2;case Y:return Y2;case LATITUDE:return LATITUDE2;case LONGITUDE:return LONGITUDE2;case THETA:return THETA2;case RADIUS:return RADIUS2}return undefined}function getSizeChannel(channel){switch(channel){case X:case X2:return"width";case Y:case Y2:return"height"}return undefined}function getOffsetChannel(channel){switch(channel){case X:return"xOffset";case Y:return"yOffset";case X2:return"x2Offset";case Y2:return"y2Offset";case THETA:return"thetaOffset";case RADIUS:return"radiusOffset";case THETA2:return"theta2Offset";case RADIUS2:return"radius2Offset"}return undefined}function getOffsetScaleChannel(channel){switch(channel){case X:return"xOffset";case Y:return"yOffset"}return undefined}function getMainChannelFromOffsetChannel(channel){switch(channel){case"xOffset":return"x";case"yOffset":return"y"}}const UNIT_CHANNELS=keys(UNIT_CHANNEL_INDEX);const{x:_x,y:_y,x2:_x2,y2:_y2,xOffset:_xo,yOffset:_yo,latitude:_latitude,longitude:_longitude,latitude2:_latitude2,longitude2:_longitude2,theta:_theta,theta2:_theta2,radius:_radius,radius2:_radius2,...NONPOSITION_CHANNEL_INDEX}=UNIT_CHANNEL_INDEX;const NONPOSITION_CHANNELS=keys(NONPOSITION_CHANNEL_INDEX);const POSITION_SCALE_CHANNEL_INDEX={x:1,y:1};const POSITION_SCALE_CHANNELS=keys(POSITION_SCALE_CHANNEL_INDEX);function isXorY(channel){return has$1(POSITION_SCALE_CHANNEL_INDEX,channel)}const POLAR_POSITION_SCALE_CHANNEL_INDEX={theta:1,radius:1};const POLAR_POSITION_SCALE_CHANNELS=keys(POLAR_POSITION_SCALE_CHANNEL_INDEX);function getPositionScaleChannel(sizeType){return sizeType==="width"?X:Y}const OFFSET_SCALE_CHANNEL_INDEX={xOffset:1,yOffset:1};function isXorYOffset(channel){return has$1(OFFSET_SCALE_CHANNEL_INDEX,channel)}const{text:_t,tooltip:_tt,href:_hr,url:_u,description:_al,detail:_dd,key:_k,order:_oo,...NONPOSITION_SCALE_CHANNEL_INDEX}=NONPOSITION_CHANNEL_INDEX;const NONPOSITION_SCALE_CHANNELS=keys(NONPOSITION_SCALE_CHANNEL_INDEX);function isNonPositionScaleChannel(channel){return has$1(NONPOSITION_CHANNEL_INDEX,channel)}function supportLegend(channel){switch(channel){case COLOR:case FILL:case STROKE:case SIZE:case SHAPE:case OPACITY:case STROKEWIDTH:case STROKEDASH:return true;case FILLOPACITY:case STROKEOPACITY:case ANGLE:return false}}const SCALE_CHANNEL_INDEX={...POSITION_SCALE_CHANNEL_INDEX,...POLAR_POSITION_SCALE_CHANNEL_INDEX,...OFFSET_SCALE_CHANNEL_INDEX,...NONPOSITION_SCALE_CHANNEL_INDEX};const SCALE_CHANNELS=keys(SCALE_CHANNEL_INDEX);function isScaleChannel(channel){return has$1(SCALE_CHANNEL_INDEX,channel)}function supportMark(channel,mark){return getSupportedMark(channel)[mark]}const ALL_MARKS={arc:"always",area:"always",bar:"always",circle:"always",geoshape:"always",image:"always",line:"always",rule:"always",point:"always",rect:"always",square:"always",trail:"always",text:"always",tick:"always"};const{geoshape:_g,...ALL_MARKS_EXCEPT_GEOSHAPE}=ALL_MARKS;function getSupportedMark(channel){switch(channel){case COLOR:case FILL:case STROKE:case DESCRIPTION:case DETAIL:case KEY:case TOOLTIP:case HREF:case ORDER:case OPACITY:case FILLOPACITY:case STROKEOPACITY:case STROKEWIDTH:case FACET:case ROW:case COLUMN:return ALL_MARKS;case X:case Y:case XOFFSET:case YOFFSET:case LATITUDE:case LONGITUDE:return ALL_MARKS_EXCEPT_GEOSHAPE;case X2:case Y2:case LATITUDE2:case LONGITUDE2:return{area:"always",bar:"always",image:"always",rect:"always",rule:"always",circle:"binned",point:"binned",square:"binned",tick:"binned",line:"binned",trail:"binned"};case SIZE:return{point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",text:"always",line:"always",trail:"always"};case STROKEDASH:return{line:"always",point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",geoshape:"always"};case SHAPE:return{point:"always",geoshape:"always"};case TEXT$1:return{text:"always"};case ANGLE:return{point:"always",square:"always",text:"always"};case URL:return{image:"always"};case THETA:return{text:"always",arc:"always"};case RADIUS:return{text:"always",arc:"always"};case THETA2:case RADIUS2:return{arc:"always"}}}function rangeType(channel){switch(channel){case X:case Y:case THETA:case RADIUS:case XOFFSET:case YOFFSET:case SIZE:case ANGLE:case STROKEWIDTH:case OPACITY:case FILLOPACITY:case STROKEOPACITY:case X2:case Y2:case THETA2:case RADIUS2:return undefined;case FACET:case ROW:case COLUMN:case SHAPE:case STROKEDASH:case TEXT$1:case TOOLTIP:case HREF:case URL:case DESCRIPTION:return"discrete";case COLOR:case FILL:case STROKE:return"flexible";case LATITUDE:case LONGITUDE:case LATITUDE2:case LONGITUDE2:case DETAIL:case KEY:case ORDER:return undefined}}const AGGREGATE_OP_INDEX={argmax:1,argmin:1,average:1,count:1,distinct:1,exponential:1,exponentialb:1,product:1,max:1,mean:1,median:1,min:1,missing:1,q1:1,q3:1,ci0:1,ci1:1,stderr:1,stdev:1,stdevp:1,sum:1,valid:1,values:1,variance:1,variancep:1};const MULTIDOMAIN_SORT_OP_INDEX={count:1,min:1,max:1};function isArgminDef(a){return hasProperty(a,"argmin")}function isArgmaxDef(a){return hasProperty(a,"argmax")}function isAggregateOp(a){return isString(a)&&has$1(AGGREGATE_OP_INDEX,a)}const COUNTING_OPS=new Set(["count","valid","missing","distinct"]);function isCountingAggregateOp(aggregate){return isString(aggregate)&&COUNTING_OPS.has(aggregate)}function isMinMaxOp(aggregate){return isString(aggregate)&&contains(["min","max"],aggregate)}const SUM_OPS=new Set(["count","sum","distinct","valid","missing"]);const SHARED_DOMAIN_OPS=new Set(["mean","average","median","q1","q3","min","max"]);function binToString(bin){if(isBoolean$2(bin)){bin=normalizeBin(bin,undefined)}return"bin"+keys(bin).map((p=>isParameterExtent(bin[p])?varName(`_${p}_${entries$1(bin[p])}`):varName(`_${p}_${bin[p]}`))).join("")}function isBinning(bin){return bin===true||isBinParams(bin)&&!bin.binned}function isBinned(bin){return bin==="binned"||isBinParams(bin)&&bin.binned===true}function isBinParams(bin){return isObject(bin)}function isParameterExtent(extent){return hasProperty(extent,"param")}function autoMaxBins(channel){switch(channel){case ROW:case COLUMN:case SIZE:case COLOR:case FILL:case STROKE:case STROKEWIDTH:case OPACITY:case FILLOPACITY:case STROKEOPACITY:case SHAPE:return 6;case STROKEDASH:return 4;default:return 10}}function isExprRef(o){return hasProperty(o,"expr")}function replaceExprRef(index,{level:level}={level:0}){const props=keys(index||{});const newIndex={};for(const prop of props){newIndex[prop]=level===0?signalRefOrValue(index[prop]):replaceExprRef(index[prop],{level:level-1})}return newIndex}function extractTitleConfig(titleConfig){const{anchor:anchor,frame:frame,offset:offset,orient:orient,angle:angle,limit:limit,color:color,subtitleColor:subtitleColor,subtitleFont:subtitleFont,subtitleFontSize:subtitleFontSize,subtitleFontStyle:subtitleFontStyle,subtitleFontWeight:subtitleFontWeight,subtitleLineHeight:subtitleLineHeight,subtitlePadding:subtitlePadding,...rest}=titleConfig;const titleMarkConfig={...rest,...color?{fill:color}:{}};const nonMarkTitleProperties={...anchor?{anchor:anchor}:{},...frame?{frame:frame}:{},...offset?{offset:offset}:{},...orient?{orient:orient}:{},...angle!==undefined?{angle:angle}:{},...limit!==undefined?{limit:limit}:{}};const subtitle={...subtitleColor?{subtitleColor:subtitleColor}:{},...subtitleFont?{subtitleFont:subtitleFont}:{},...subtitleFontSize?{subtitleFontSize:subtitleFontSize}:{},...subtitleFontStyle?{subtitleFontStyle:subtitleFontStyle}:{},...subtitleFontWeight?{subtitleFontWeight:subtitleFontWeight}:{},...subtitleLineHeight?{subtitleLineHeight:subtitleLineHeight}:{},...subtitlePadding?{subtitlePadding:subtitlePadding}:{}};const subtitleMarkConfig=pick(titleConfig,["align","baseline","dx","dy","limit"]);return{titleMarkConfig:titleMarkConfig,subtitleMarkConfig:subtitleMarkConfig,nonMarkTitleProperties:nonMarkTitleProperties,subtitle:subtitle}}function isText(v){return isString(v)||isArray(v)&&isString(v[0])}function isSignalRef(o){return hasProperty(o,"signal")}function isVgRangeStep(range){return hasProperty(range,"step")}function isDataRefUnionedDomain(domain){if(!isArray(domain)){return hasProperty(domain,"fields")&&!hasProperty(domain,"data")}return false}function isFieldRefUnionDomain(domain){if(!isArray(domain)){return hasProperty(domain,"fields")&&hasProperty(domain,"data")}return false}function isDataRefDomain(domain){if(!isArray(domain)){return hasProperty(domain,"field")&&hasProperty(domain,"data")}return false}const VG_MARK_CONFIG_INDEX={aria:1,description:1,ariaRole:1,ariaRoleDescription:1,blend:1,opacity:1,fill:1,fillOpacity:1,stroke:1,strokeCap:1,strokeWidth:1,strokeOpacity:1,strokeDash:1,strokeDashOffset:1,strokeJoin:1,strokeOffset:1,strokeMiterLimit:1,startAngle:1,endAngle:1,padAngle:1,innerRadius:1,outerRadius:1,size:1,shape:1,interpolate:1,tension:1,orient:1,align:1,baseline:1,text:1,dir:1,dx:1,dy:1,ellipsis:1,limit:1,radius:1,theta:1,angle:1,font:1,fontSize:1,fontWeight:1,fontStyle:1,lineBreak:1,lineHeight:1,cursor:1,href:1,tooltip:1,cornerRadius:1,cornerRadiusTopLeft:1,cornerRadiusTopRight:1,cornerRadiusBottomLeft:1,cornerRadiusBottomRight:1,aspect:1,width:1,height:1,url:1,smooth:1};const VG_MARK_CONFIGS=keys(VG_MARK_CONFIG_INDEX);const VG_MARK_INDEX={arc:1,area:1,group:1,image:1,line:1,path:1,rect:1,rule:1,shape:1,symbol:1,text:1,trail:1};const VG_CORNERRADIUS_CHANNELS=["cornerRadius","cornerRadiusTopLeft","cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight"];function signalOrValueRefWithCondition(val){const condition=isArray(val.condition)?val.condition.map(conditionalSignalRefOrValue):conditionalSignalRefOrValue(val.condition);return{...signalRefOrValue(val),condition:condition}}function signalRefOrValue(value){if(isExprRef(value)){const{expr:expr,...rest}=value;return{signal:expr,...rest}}return value}function conditionalSignalRefOrValue(value){if(isExprRef(value)){const{expr:expr,...rest}=value;return{signal:expr,...rest}}return value}function signalOrValueRef(value){if(isExprRef(value)){const{expr:expr,...rest}=value;return{signal:expr,...rest}}if(isSignalRef(value)){return value}return value!==undefined?{value:value}:undefined}function exprFromSignalRefOrValue(ref){if(isSignalRef(ref)){return ref.signal}return $(ref)}function exprFromValueRefOrSignalRef(ref){if(isSignalRef(ref)){return ref.signal}return $(ref.value)}function signalOrStringValue(v){if(isSignalRef(v)){return v.signal}return v==null?null:$(v)}function applyMarkConfig(e,model,propsList){for(const property of propsList){const value=getMarkConfig(property,model.markDef,model.config);if(value!==undefined){e[property]=signalOrValueRef(value)}}return e}function getStyles(mark){return[].concat(mark.type,mark.style??[])}function getMarkPropOrConfig(channel,mark,config,opt={}){const{vgChannel:vgChannel,ignoreVgConfig:ignoreVgConfig}=opt;if(vgChannel&&hasProperty(mark,vgChannel)){return mark[vgChannel]}else if(mark[channel]!==undefined){return mark[channel]}else if(ignoreVgConfig&&(!vgChannel||vgChannel===channel)){return undefined}return getMarkConfig(channel,mark,config,opt)}function getMarkConfig(channel,mark,config,{vgChannel:vgChannel}={}){const cfg=getMarkStyleConfig(channel,mark,config.style);return getFirstDefined(vgChannel?cfg:undefined,cfg,vgChannel?config[mark.type][vgChannel]:undefined,config[mark.type][channel],vgChannel?config.mark[vgChannel]:config.mark[channel])}function getMarkStyleConfig(prop,mark,styleConfigIndex){return getStyleConfig(prop,getStyles(mark),styleConfigIndex)}function getStyleConfig(p,styles,styleConfigIndex){styles=array$5(styles);let value;for(const style of styles){const styleConfig=styleConfigIndex[style];if(hasProperty(styleConfig,p)){value=styleConfig[p]}}return value}function sortParams(orderDef,fieldRefOption){return array$5(orderDef).reduce(((s,orderChannelDef)=>{s.field.push(vgField(orderChannelDef,fieldRefOption));s.order.push(orderChannelDef.sort??"ascending");return s}),{field:[],order:[]})}function mergeTitleFieldDefs(f1,f2){const merged=[...f1];f2.forEach((fdToMerge=>{for(const fieldDef1 of merged){if(deepEqual(fieldDef1,fdToMerge)){return}}merged.push(fdToMerge)}));return merged}function mergeTitle(title1,title2){if(deepEqual(title1,title2)||!title2){return title1}else if(!title1){return title2}else{return[...array$5(title1),...array$5(title2)].join(", ")}}function mergeTitleComponent(v1,v2){const v1Val=v1.value;const v2Val=v2.value;if(v1Val==null||v2Val===null){return{explicit:v1.explicit,value:null}}else if((isText(v1Val)||isSignalRef(v1Val))&&(isText(v2Val)||isSignalRef(v2Val))){return{explicit:v1.explicit,value:mergeTitle(v1Val,v2Val)}}else if(isText(v1Val)||isSignalRef(v1Val)){return{explicit:v1.explicit,value:v1Val}}else if(isText(v2Val)||isSignalRef(v2Val)){return{explicit:v1.explicit,value:v2Val}}else if(!isText(v1Val)&&!isSignalRef(v1Val)&&!isText(v2Val)&&!isSignalRef(v2Val)){return{explicit:v1.explicit,value:mergeTitleFieldDefs(v1Val,v2Val)}}throw new Error("It should never reach here")}function invalidSpec(spec){return`Invalid specification ${stringify(spec)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`}const FIT_NON_SINGLE='Autosize "fit" only works for single views and layered views.';function containerSizeNonSingle(name){const uName=name=="width"?"Width":"Height";return`${uName} "container" only works for single views and layered views.`}function containerSizeNotCompatibleWithAutosize(name){const uName=name=="width"?"Width":"Height";const fitDirection=name=="width"?"x":"y";return`${uName} "container" only works well with autosize "fit" or "fit-${fitDirection}".`}function droppingFit(channel){return channel?`Dropping "fit-${channel}" because spec has discrete ${getSizeChannel(channel)}.`:`Dropping "fit" because spec has discrete size.`}function unknownField(channel){return`Unknown field for ${channel}. Cannot calculate view size.`}function cannotProjectOnChannelWithoutField(channel){return`Cannot project a selection on encoding channel "${channel}", which has no field.`}function cannotProjectAggregate(channel,aggregate){return`Cannot project a selection on encoding channel "${channel}" as it uses an aggregate function ("${aggregate}").`}function nearestNotSupportForContinuous(mark){return`The "nearest" transform is not supported for ${mark} marks.`}function selectionNotSupported(mark){return`Selection not supported for ${mark} yet.`}function selectionNotFound(name){return`Cannot find a selection named "${name}".`}const SCALE_BINDINGS_CONTINUOUS="Scale bindings are currently only supported for scales with unbinned, continuous domains.";const SEQUENTIAL_SCALE_DEPRECATED="Sequntial scales are deprecated. The available quantitative scale type values are linear, log, pow, sqrt, symlog, time and utc";const LEGEND_BINDINGS_MUST_HAVE_PROJECTION="Legend bindings are only supported for selections over an individual field or encoding channel.";function cannotLookupVariableParameter(name){return`Lookups can only be performed on selection parameters. "${name}" is a variable parameter.`}function noSameUnitLookup(name){return`Cannot define and lookup the "${name}" selection in the same view. `+`Try moving the lookup into a second, layered view?`}const NEEDS_SAME_SELECTION="The same selection must be used to override scale domains in a layered view.";const INTERVAL_INITIALIZED_WITH_POS='Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';function noSuchRepeatedValue(field){return`Unknown repeated value "${field}".`}function columnsNotSupportByRowCol(type){return`The "columns" property cannot be used when "${type}" has nested row/column.`}const CONCAT_CANNOT_SHARE_AXIS="Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";function unrecognizedParse(p){return`Unrecognized parse "${p}".`}function differentParse(field,local,ancestor){return`An ancestor parsed field "${field}" as ${ancestor} but a child wants to parse the field as ${local}.`}const ADD_SAME_CHILD_TWICE="Attempt to add the same child twice.";function invalidTransformIgnored(transform){return`Ignoring an invalid transform: ${stringify(transform)}.`}const NO_FIELDS_NEEDS_AS='If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';function customFormatTypeNotAllowed(channel){return`Config.customFormatTypes is not true, thus custom format type and format for channel ${channel} are dropped.`}function projectionOverridden(opt){const{parentProjection:parentProjection,projection:projection}=opt;return`Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(projection)}.`}const REPLACE_ANGLE_WITH_THETA="Arc marks uses theta channel rather than angle, replacing angle with theta.";function offsetNestedInsideContinuousPositionScaleDropped(mainChannel){return`${mainChannel}Offset dropped because ${mainChannel} is continuous`}function primitiveChannelDef(channel,type,value){return`Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`}function invalidFieldType(type){return`Invalid field type "${type}".`}function invalidFieldTypeForCountAggregate(type,aggregate){return`Invalid field type "${type}" for aggregate: "${aggregate}", using "quantitative" instead.`}function invalidAggregate(aggregate){return`Invalid aggregation operator "${aggregate}".`}function droppingColor(type,opt){const{fill:fill,stroke:stroke}=opt;return`Dropping color ${type} as the plot also has ${fill&&stroke?"fill and stroke":fill?"fill":"stroke"}.`}function relativeBandSizeNotSupported(sizeChannel){return`Position range does not support relative band size for ${sizeChannel}.`}function emptyFieldDef(fieldDef,channel){return`Dropping ${stringify(fieldDef)} from channel "${channel}" since it does not contain any data field, datum, value, or signal.`}const LINE_WITH_VARYING_SIZE="Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";function incompatibleChannel(channel,markOrFacet,when){return`${channel} dropped as it is incompatible with "${markOrFacet}"${""}.`}function invalidEncodingChannel(channel){return`${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`}function channelShouldBeDiscrete(channel){return`${channel} encoding should be discrete (ordinal / nominal / binned).`}function channelShouldBeDiscreteOrDiscretizing(channel){return`${channel} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`}function facetChannelDropped(channels){return`Facet encoding dropped as ${channels.join(" and ")} ${channels.length>1?"are":"is"} also specified.`}function discreteChannelCannotEncode(channel,type){return`Using discrete channel "${channel}" to encode "${type}" field can be misleading as it does not encode ${type==="ordinal"?"order":"magnitude"}.`}function rangeMarkAlignmentCannotBeExpression(align){return`The ${align} for range marks cannot be an expression`}function lineWithRange(hasX2,hasY2){const channels=hasX2&&hasY2?"x2 and y2":hasX2?"x2":"y2";return`Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`}function orientOverridden(original,actual){return`Specified orient "${original}" overridden with "${actual}".`}function cannotUseScalePropertyWithNonColor(prop){return`Cannot use the scale property "${prop}" with non-color channel.`}function cannotUseRelativeBandSizeWithNonBandScale(scaleType){return`Cannot use the relative band size with ${scaleType} scale.`}function unaggregateDomainHasNoEffectForRawField(fieldDef){return`Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`}function unaggregateDomainWithNonSharedDomainOp(aggregate){return`Unaggregated domain not applicable for "${aggregate}" since it produces values outside the origin domain of the source data.`}function unaggregatedDomainWithLogScale(fieldDef){return`Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`}function cannotApplySizeToNonOrientedMark(mark){return`Cannot apply size to non-oriented mark "${mark}".`}function scaleTypeNotWorkWithChannel(channel,scaleType,defaultScaleType){return`Channel "${channel}" does not work with "${scaleType}" scale. We are using "${defaultScaleType}" scale instead.`}function scaleTypeNotWorkWithFieldDef(scaleType,defaultScaleType){return`FieldDef does not work with "${scaleType}" scale. We are using "${defaultScaleType}" scale instead.`}function scalePropertyNotWorkWithScaleType(scaleType,propName,channel){return`${channel}-scale's "${propName}" is dropped as it does not work with ${scaleType} scale.`}function stepDropped(channel){return`The step for "${channel}" is dropped because the ${channel==="width"?"x":"y"} is continuous.`}function mergeConflictingProperty(property,propertyOf,v1,v2){return`Conflicting ${propertyOf.toString()} property "${property.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using ${stringify(v1)}.`}function mergeConflictingDomainProperty(property,propertyOf,v1,v2){return`Conflicting ${propertyOf.toString()} property "${property.toString()}" (${stringify(v1)} and ${stringify(v2)}). Using the union of the two domains.`}function independentScaleMeansIndependentGuide(channel){return`Setting the scale to be independent for "${channel}" means we also have to set the guide (axis or legend) to be independent.`}function domainSortDropped(sort){return`Dropping sort property ${stringify(sort)} as unioned domains only support boolean or op "count", "min", and "max".`}const MORE_THAN_ONE_SORT="Domains that should be unioned has conflicting sort properties. Sort will be set to true.";const FACETED_INDEPENDENT_DIFFERENT_SOURCES="Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.";const FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES="Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.";const FACETED_INDEPENDENT_SAME_SOURCE="Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";function cannotStackRangedMark(channel){return`Cannot stack "${channel}" if there is already "${channel}2".`}function stackNonLinearScale(scaleType){return`Stack is applied to a non-linear scale (${scaleType}).`}function stackNonSummativeAggregate(aggregate){return`Stacking is applied even though the aggregate function is non-summative ("${aggregate}").`}function invalidTimeUnit(unitName,value){return`Invalid ${unitName}: ${stringify(value)}.`}function droppedDay(d){return`Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`}function errorBarCenterAndExtentAreNotNeeded(center,extent){return`${extent?"extent ":""}${extent&&center?"and ":""}${center?"center ":""}${extent&&center?"are ":"is "}not needed when data are aggregated.`}function errorBarCenterIsUsedWithWrongExtent(center,extent,mark){return`${center} is not usually used with ${extent} for ${mark}.`}function errorBarContinuousAxisHasCustomizedAggregate(aggregate,compositeMark){return`Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`}function errorBand1DNotSupport(property){return`1D error band does not support ${property}.`}function channelRequiredForBinned(channel){return`Channel ${channel} is required for "binned" bin.`}function channelShouldNotBeUsedForBinned(channel){return`Channel ${channel} should not be used with "binned" bin.`}function domainRequiredForThresholdScale(channel){return`Domain for ${channel} is required for threshold scale.`}undefined&&undefined.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};undefined&&undefined.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)};const main=logger(Warn);let current=main;function set(newLogger){current=newLogger;return current}function reset(){current=main;return current}function warn(...args){current.warn(...args)}function debug(...args){current.debug(...args)}function isDateTime(o){if(o&&isObject(o)){for(const part of TIMEUNIT_PARTS){if(hasProperty(o,part)){return true}}}return false}const MONTHS=["january","february","march","april","may","june","july","august","september","october","november","december"];const SHORT_MONTHS=MONTHS.map((m=>m.substr(0,3)));const DAYS=["sunday","monday","tuesday","wednesday","thursday","friday","saturday"];const SHORT_DAYS=DAYS.map((d=>d.substr(0,3)));function normalizeQuarter(q){if(isNumeric(q)){q=+q}if(isNumber$1(q)){if(q>4){warn(invalidTimeUnit("quarter",q))}return q-1}else{throw new Error(invalidTimeUnit("quarter",q))}}function normalizeMonth(m){if(isNumeric(m)){m=+m}if(isNumber$1(m)){return m-1}else{const lowerM=m.toLowerCase();const monthIndex=MONTHS.indexOf(lowerM);if(monthIndex!==-1){return monthIndex}const shortM=lowerM.substr(0,3);const shortMonthIndex=SHORT_MONTHS.indexOf(shortM);if(shortMonthIndex!==-1){return shortMonthIndex}throw new Error(invalidTimeUnit("month",m))}}function normalizeDay(d){if(isNumeric(d)){d=+d}if(isNumber$1(d)){return d%7}else{const lowerD=d.toLowerCase();const dayIndex=DAYS.indexOf(lowerD);if(dayIndex!==-1){return dayIndex}const shortD=lowerD.substr(0,3);const shortDayIndex=SHORT_DAYS.indexOf(shortD);if(shortDayIndex!==-1){return shortDayIndex}throw new Error(invalidTimeUnit("day",d))}}function dateTimeParts(d,normalize){const parts=[];if(normalize&&d.day!==undefined){if(keys(d).length>1){warn(droppedDay(d));d=duplicate(d);delete d.day}}if(d.year!==undefined){parts.push(d.year)}else{parts.push(2012)}if(d.month!==undefined){const month=normalize?normalizeMonth(d.month):d.month;parts.push(month)}else if(d.quarter!==undefined){const quarter=normalize?normalizeQuarter(d.quarter):d.quarter;parts.push(isNumber$1(quarter)?quarter*3:`${quarter}*3`)}else{parts.push(0)}if(d.date!==undefined){parts.push(d.date)}else if(d.day!==undefined){const day=normalize?normalizeDay(d.day):d.day;parts.push(isNumber$1(day)?day+1:`${day}+1`)}else{parts.push(1)}for(const timeUnit of["hours","minutes","seconds","milliseconds"]){const unit=d[timeUnit];parts.push(typeof unit==="undefined"?0:unit)}return parts}function dateTimeToExpr(d){const parts=dateTimeParts(d,true);const string=parts.join(", ");if(d.utc){return`utc(${string})`}else{return`datetime(${string})`}}function dateTimeExprToExpr(d){const parts=dateTimeParts(d,false);const string=parts.join(", ");if(d.utc){return`utc(${string})`}else{return`datetime(${string})`}}function dateTimeToTimestamp(d){const parts=dateTimeParts(d,true);if(d.utc){return+new Date(Date.UTC(...parts))}else{return+new Date(...parts)}}const LOCAL_SINGLE_TIMEUNIT_INDEX={year:1,quarter:1,month:1,week:1,day:1,dayofyear:1,date:1,hours:1,minutes:1,seconds:1,milliseconds:1};const TIMEUNIT_PARTS=keys(LOCAL_SINGLE_TIMEUNIT_INDEX);function isLocalSingleTimeUnit(timeUnit){return has$1(LOCAL_SINGLE_TIMEUNIT_INDEX,timeUnit)}function isBinnedTimeUnit(timeUnit){if(isObject(timeUnit)){return timeUnit.binned}return isBinnedTimeUnitString(timeUnit)}function isBinnedTimeUnitString(timeUnit){return timeUnit&&timeUnit.startsWith("binned")}function isUTCTimeUnit(t){return t.startsWith("utc")}function getLocalTimeUnitFromUTCTimeUnit(t){return t.substring(3)}const VEGALITE_TIMEFORMAT={"year-month":"%b %Y ","year-month-date":"%b %d, %Y "};function getTimeUnitParts(timeUnit){return TIMEUNIT_PARTS.filter((part=>containsTimeUnit(timeUnit,part)))}function getSmallestTimeUnitPart(timeUnit){const parts=getTimeUnitParts(timeUnit);return parts[parts.length-1]}function containsTimeUnit(fullTimeUnit,timeUnit){const index=fullTimeUnit.indexOf(timeUnit);if(index<0){return false}if(index>0&&timeUnit==="seconds"&&fullTimeUnit.charAt(index-1)==="i"){return false}if(fullTimeUnit.length>index+3&&timeUnit==="day"&&fullTimeUnit.charAt(index+3)==="o"){return false}if(index>0&&timeUnit==="year"&&fullTimeUnit.charAt(index-1)==="f"){return false}return true}function fieldExpr(fullTimeUnit,field,{end:end}={end:false}){const fieldRef=accessPathWithDatum(field);const utc=isUTCTimeUnit(fullTimeUnit)?"utc":"";function func(timeUnit){if(timeUnit==="quarter"){return`(${utc}quarter(${fieldRef})-1)`}else{return`${utc}${timeUnit}(${fieldRef})`}}let lastTimeUnit;const dateExpr={};for(const part of TIMEUNIT_PARTS){if(containsTimeUnit(fullTimeUnit,part)){dateExpr[part]=func(part);lastTimeUnit=part}}if(end){dateExpr[lastTimeUnit]+="+1"}return dateTimeExprToExpr(dateExpr)}function timeUnitSpecifierExpression(timeUnit){if(!timeUnit){return undefined}const timeUnitParts=getTimeUnitParts(timeUnit);return`timeUnitSpecifier(${stringify(timeUnitParts)}, ${stringify(VEGALITE_TIMEFORMAT)})`}function formatExpression(timeUnit,field,isUTCScale){if(!timeUnit){return undefined}const expr=timeUnitSpecifierExpression(timeUnit);const utc=isUTCScale||isUTCTimeUnit(timeUnit);return`${utc?"utc":"time"}Format(${field}, ${expr})`}function normalizeTimeUnit(timeUnit){if(!timeUnit){return undefined}let params;if(isString(timeUnit)){if(isBinnedTimeUnitString(timeUnit)){params={unit:timeUnit.substring(6),binned:true}}else{params={unit:timeUnit}}}else if(isObject(timeUnit)){params={...timeUnit,...timeUnit.unit?{unit:timeUnit.unit}:{}}}if(isUTCTimeUnit(params.unit)){params.utc=true;params.unit=getLocalTimeUnitFromUTCTimeUnit(params.unit)}return params}function timeUnitToString(tu){const{utc:utc,...rest}=normalizeTimeUnit(tu);if(rest.unit){return(utc?"utc":"")+keys(rest).map((p=>varName(`${p==="unit"?"":`_${p}_`}${rest[p]}`))).join("")}else{return(utc?"utc":"")+"timeunit"+keys(rest).map((p=>varName(`_${p}_${rest[p]}`))).join("")}}function durationExpr(timeUnit,wrap=x=>x){const normalizedTimeUnit=normalizeTimeUnit(timeUnit);const smallestUnitPart=getSmallestTimeUnitPart(normalizedTimeUnit.unit);if(smallestUnitPart&&smallestUnitPart!=="day"){const startDate={year:2001,month:1,date:1,hours:0,minutes:0,seconds:0,milliseconds:0};const{step:step,part:part}=getDateTimePartAndStep(smallestUnitPart,normalizedTimeUnit.step);const endDate={...startDate,[part]:+startDate[part]+step};return`${wrap(dateTimeToExpr(endDate))} - ${wrap(dateTimeToExpr(startDate))}`}return undefined}const DATE_PARTS={year:1,month:1,date:1,hours:1,minutes:1,seconds:1,milliseconds:1};function isDatePart(timeUnit){return has$1(DATE_PARTS,timeUnit)}function getDateTimePartAndStep(timeUnit,step=1){if(isDatePart(timeUnit)){return{part:timeUnit,step:step}}switch(timeUnit){case"day":case"dayofyear":return{part:"date",step:step};case"quarter":return{part:"month",step:step*3};case"week":return{part:"date",step:step*7}}}function isSelectionPredicate(predicate){return hasProperty(predicate,"param")}function isFieldEqualPredicate(predicate){return!!predicate?.field&&predicate.equal!==undefined}function isFieldLTPredicate(predicate){return!!predicate?.field&&predicate.lt!==undefined}function isFieldLTEPredicate(predicate){return!!predicate?.field&&predicate.lte!==undefined}function isFieldGTPredicate(predicate){return!!predicate?.field&&predicate.gt!==undefined}function isFieldGTEPredicate(predicate){return!!predicate?.field&&predicate.gte!==undefined}function isFieldRangePredicate(predicate){if(predicate?.field){if(isArray(predicate.range)&&predicate.range.length===2){return true}else if(isSignalRef(predicate.range)){return true}}return false}function isFieldOneOfPredicate(predicate){return!!predicate?.field&&(isArray(predicate.oneOf)||isArray(predicate.in))}function isFieldValidPredicate(predicate){return!!predicate?.field&&predicate.valid!==undefined}function isFieldPredicate(predicate){return isFieldOneOfPredicate(predicate)||isFieldEqualPredicate(predicate)||isFieldRangePredicate(predicate)||isFieldLTPredicate(predicate)||isFieldGTPredicate(predicate)||isFieldLTEPredicate(predicate)||isFieldGTEPredicate(predicate)}function predicateValueExpr(v,timeUnit){return valueExpr(v,{timeUnit:timeUnit,wrapTime:true})}function predicateValuesExpr(vals,timeUnit){return vals.map((v=>predicateValueExpr(v,timeUnit)))}function fieldFilterExpression(predicate,useInRange=true){const{field:field}=predicate;const normalizedTimeUnit=normalizeTimeUnit(predicate.timeUnit);const{unit:unit,binned:binned}=normalizedTimeUnit||{};const rawFieldExpr=vgField(predicate,{expr:"datum"});const fieldExpr$1=unit?`time(${!binned?fieldExpr(unit,field):rawFieldExpr})`:rawFieldExpr;if(isFieldEqualPredicate(predicate)){return`${fieldExpr$1}===${predicateValueExpr(predicate.equal,unit)}`}else if(isFieldLTPredicate(predicate)){const upper=predicate.lt;return`${fieldExpr$1}<${predicateValueExpr(upper,unit)}`}else if(isFieldGTPredicate(predicate)){const lower=predicate.gt;return`${fieldExpr$1}>${predicateValueExpr(lower,unit)}`}else if(isFieldLTEPredicate(predicate)){const upper=predicate.lte;return`${fieldExpr$1}<=${predicateValueExpr(upper,unit)}`}else if(isFieldGTEPredicate(predicate)){const lower=predicate.gte;return`${fieldExpr$1}>=${predicateValueExpr(lower,unit)}`}else if(isFieldOneOfPredicate(predicate)){return`indexof([${predicateValuesExpr(predicate.oneOf,unit).join(",")}], ${fieldExpr$1}) !== -1`}else if(isFieldValidPredicate(predicate)){return fieldValidPredicate(fieldExpr$1,predicate.valid)}else if(isFieldRangePredicate(predicate)){const{range:range}=replaceExprRef(predicate);const lower=isSignalRef(range)?{signal:`${range.signal}[0]`}:range[0];const upper=isSignalRef(range)?{signal:`${range.signal}[1]`}:range[1];if(lower!==null&&upper!==null&&useInRange){return"inrange("+fieldExpr$1+", ["+predicateValueExpr(lower,unit)+", "+predicateValueExpr(upper,unit)+"])"}const exprs=[];if(lower!==null){exprs.push(`${fieldExpr$1} >= ${predicateValueExpr(lower,unit)}`)}if(upper!==null){exprs.push(`${fieldExpr$1} <= ${predicateValueExpr(upper,unit)}`)}return exprs.length>0?exprs.join(" && "):"true"}throw new Error(`Invalid field predicate: ${stringify(predicate)}`)}function fieldValidPredicate(fieldExpr,valid=true){if(valid){return`isValid(${fieldExpr}) && isFinite(+${fieldExpr})`}else{return`!isValid(${fieldExpr}) || !isFinite(+${fieldExpr})`}}function normalizePredicate$1(f){if(isFieldPredicate(f)&&f.timeUnit){return{...f,timeUnit:normalizeTimeUnit(f.timeUnit)}}return f}const Type={quantitative:"quantitative",ordinal:"ordinal",temporal:"temporal",nominal:"nominal",geojson:"geojson"};function isContinuous(type){return type==="quantitative"||type==="temporal"}function isDiscrete$1(type){return type==="ordinal"||type==="nominal"}const QUANTITATIVE=Type.quantitative;const ORDINAL=Type.ordinal;const TEMPORAL=Type.temporal;const NOMINAL=Type.nominal;const GEOJSON=Type.geojson;function getFullName(type){if(type){type=type.toLowerCase();switch(type){case"q":case QUANTITATIVE:return"quantitative";case"t":case TEMPORAL:return"temporal";case"o":case ORDINAL:return"ordinal";case"n":case NOMINAL:return"nominal";case GEOJSON:return"geojson"}}return undefined}const ScaleType={LINEAR:"linear",LOG:"log",POW:"pow",SQRT:"sqrt",SYMLOG:"symlog",IDENTITY:"identity",SEQUENTIAL:"sequential",TIME:"time",UTC:"utc",QUANTILE:"quantile",QUANTIZE:"quantize",THRESHOLD:"threshold",BIN_ORDINAL:"bin-ordinal",ORDINAL:"ordinal",POINT:"point",BAND:"band"};const SCALE_CATEGORY_INDEX={linear:"numeric",log:"numeric",pow:"numeric",sqrt:"numeric",symlog:"numeric",identity:"numeric",sequential:"numeric",time:"time",utc:"time",ordinal:"ordinal","bin-ordinal":"bin-ordinal",point:"ordinal-position",band:"ordinal-position",quantile:"discretizing",quantize:"discretizing",threshold:"discretizing"};function scaleCompatible(scaleType1,scaleType2){const scaleCategory1=SCALE_CATEGORY_INDEX[scaleType1];const scaleCategory2=SCALE_CATEGORY_INDEX[scaleType2];return scaleCategory1===scaleCategory2||scaleCategory1==="ordinal-position"&&scaleCategory2==="time"||scaleCategory2==="ordinal-position"&&scaleCategory1==="time"}const SCALE_PRECEDENCE_INDEX={linear:0,log:1,pow:1,sqrt:1,symlog:1,identity:1,sequential:1,time:0,utc:0,point:10,band:11,ordinal:0,"bin-ordinal":0,quantile:0,quantize:0,threshold:0};function scaleTypePrecedence(scaleType){return SCALE_PRECEDENCE_INDEX[scaleType]}const QUANTITATIVE_SCALES=new Set(["linear","log","pow","sqrt","symlog"]);const CONTINUOUS_TO_CONTINUOUS_SCALES=new Set([...QUANTITATIVE_SCALES,"time","utc"]);function isQuantitative(type){return QUANTITATIVE_SCALES.has(type)}const CONTINUOUS_TO_DISCRETE_SCALES=new Set(["quantile","quantize","threshold"]);const CONTINUOUS_DOMAIN_SCALES=new Set([...CONTINUOUS_TO_CONTINUOUS_SCALES,...CONTINUOUS_TO_DISCRETE_SCALES,"sequential","identity"]);const DISCRETE_DOMAIN_SCALES=new Set(["ordinal","bin-ordinal","point","band"]);function hasDiscreteDomain(type){return DISCRETE_DOMAIN_SCALES.has(type)}function hasContinuousDomain(type){return CONTINUOUS_DOMAIN_SCALES.has(type)}function isContinuousToContinuous(type){return CONTINUOUS_TO_CONTINUOUS_SCALES.has(type)}function isContinuousToDiscrete(type){return CONTINUOUS_TO_DISCRETE_SCALES.has(type)}const defaultScaleConfig={pointPadding:.5,barBandPaddingInner:.1,rectBandPaddingInner:0,tickBandPaddingInner:.25,bandWithNestedOffsetPaddingInner:.2,bandWithNestedOffsetPaddingOuter:.2,minBandSize:2,minFontSize:8,maxFontSize:40,minOpacity:.3,maxOpacity:.8,minSize:4,minStrokeWidth:1,maxStrokeWidth:4,quantileCount:4,quantizeCount:4,zero:true};function isExtendedScheme(scheme){return!isString(scheme)&&hasProperty(scheme,"name")}function isParameterDomain(domain){return hasProperty(domain,"param")}function isDomainUnionWith(domain){return hasProperty(domain,"unionWith")}function isFieldRange(range){return isObject(range)&&"field"in range}const SCALE_PROPERTY_INDEX={type:1,domain:1,domainMax:1,domainMin:1,domainMid:1,domainRaw:1,align:1,range:1,rangeMax:1,rangeMin:1,scheme:1,bins:1,reverse:1,round:1,clamp:1,nice:1,base:1,exponent:1,constant:1,interpolate:1,zero:1,padding:1,paddingInner:1,paddingOuter:1};const{type:type,domain:domain$1,range:range,rangeMax:rangeMax,rangeMin:rangeMin,scheme:scheme,...NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX}=SCALE_PROPERTY_INDEX;const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES=keys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);function scaleTypeSupportProperty(scaleType,propName){switch(propName){case"type":case"domain":case"reverse":case"range":return true;case"scheme":case"interpolate":return!["point","band","identity"].includes(scaleType);case"bins":return!["point","band","identity","ordinal"].includes(scaleType);case"round":return isContinuousToContinuous(scaleType)||scaleType==="band"||scaleType==="point";case"padding":case"rangeMin":case"rangeMax":return isContinuousToContinuous(scaleType)||["point","band"].includes(scaleType);case"paddingOuter":case"align":return["point","band"].includes(scaleType);case"paddingInner":return scaleType==="band";case"domainMax":case"domainMid":case"domainMin":case"domainRaw":case"clamp":return isContinuousToContinuous(scaleType);case"nice":return isContinuousToContinuous(scaleType)||scaleType==="quantize"||scaleType==="threshold";case"exponent":return scaleType==="pow";case"base":return scaleType==="log";case"constant":return scaleType==="symlog";case"zero":return hasContinuousDomain(scaleType)&&!contains(["log","time","utc","threshold","quantile"],scaleType)}}function channelScalePropertyIncompatability(channel,propName){switch(propName){case"interpolate":case"scheme":case"domainMid":if(!isColorChannel(channel)){return cannotUseScalePropertyWithNonColor(propName)}return undefined;case"align":case"type":case"bins":case"domain":case"domainMax":case"domainMin":case"domainRaw":case"range":case"base":case"exponent":case"constant":case"nice":case"padding":case"paddingInner":case"paddingOuter":case"rangeMax":case"rangeMin":case"reverse":case"round":case"clamp":case"zero":return undefined}}function scaleTypeSupportDataType(specifiedType,fieldDefType){if(contains([ORDINAL,NOMINAL],fieldDefType)){return specifiedType===undefined||hasDiscreteDomain(specifiedType)}else if(fieldDefType===TEMPORAL){return contains([ScaleType.TIME,ScaleType.UTC,undefined],specifiedType)}else if(fieldDefType===QUANTITATIVE){return isQuantitative(specifiedType)||isContinuousToDiscrete(specifiedType)||specifiedType===undefined}return true}function channelSupportScaleType(channel,scaleType,hasNestedOffsetScale=false){if(!isScaleChannel(channel)){return false}switch(channel){case X:case Y:case XOFFSET:case YOFFSET:case THETA:case RADIUS:if(isContinuousToContinuous(scaleType)){return true}else if(scaleType==="band"){return true}else if(scaleType==="point"){return!hasNestedOffsetScale}return false;case SIZE:case STROKEWIDTH:case OPACITY:case FILLOPACITY:case STROKEOPACITY:case ANGLE:return isContinuousToContinuous(scaleType)||isContinuousToDiscrete(scaleType)||contains(["band","point","ordinal"],scaleType);case COLOR:case FILL:case STROKE:return scaleType!=="band";case STROKEDASH:case SHAPE:return scaleType==="ordinal"||isContinuousToDiscrete(scaleType)}}function isScaleInvalidDataIncludeAsValue(invalidDataMode){return isObject(invalidDataMode)&&"value"in invalidDataMode}const Mark={arc:"arc",area:"area",bar:"bar",image:"image",line:"line",point:"point",rect:"rect",rule:"rule",text:"text",tick:"tick",trail:"trail",circle:"circle",square:"square",geoshape:"geoshape"};const ARC=Mark.arc;const AREA=Mark.area;const BAR=Mark.bar;const IMAGE=Mark.image;const LINE=Mark.line;const POINT=Mark.point;const RECT=Mark.rect;const RULE=Mark.rule;const TEXT=Mark.text;const TICK=Mark.tick;const TRAIL=Mark.trail;const CIRCLE=Mark.circle;const SQUARE=Mark.square;const GEOSHAPE=Mark.geoshape;function isPathMark(m){return["line","area","trail"].includes(m)}function isRectBasedMark(m){return["rect","bar","image","arc","tick"].includes(m)}const PRIMITIVE_MARKS=new Set(keys(Mark));function isMarkDef(mark){return hasProperty(mark,"type")}const STROKE_CONFIG=["stroke","strokeWidth","strokeDash","strokeDashOffset","strokeOpacity","strokeJoin","strokeMiterLimit"];const FILL_CONFIG=["fill","fillOpacity"];const FILL_STROKE_CONFIG=[...STROKE_CONFIG,...FILL_CONFIG];const VL_ONLY_MARK_CONFIG_INDEX={color:1,filled:1,invalid:1,order:1,radius2:1,theta2:1,timeUnitBandSize:1,timeUnitBandPosition:1};const VL_ONLY_MARK_CONFIG_PROPERTIES=keys(VL_ONLY_MARK_CONFIG_INDEX);const VL_ONLY_RECT_CONFIG=["binSpacing","continuousBandSize","discreteBandSize","minBandSize"];const VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX={area:["line","point"],bar:VL_ONLY_RECT_CONFIG,rect:VL_ONLY_RECT_CONFIG,line:["point"],tick:["bandSize","thickness",...VL_ONLY_RECT_CONFIG]};const defaultMarkConfig={color:"#4c78a8",invalid:"break-paths-show-path-domains",timeUnitBandSize:1};const MARK_CONFIG_INDEX={mark:1,arc:1,area:1,bar:1,circle:1,image:1,line:1,point:1,rect:1,rule:1,square:1,text:1,tick:1,trail:1,geoshape:1};const MARK_CONFIGS=keys(MARK_CONFIG_INDEX);function isRelativeBandSize(o){return hasProperty(o,"band")}const BAR_CORNER_RADIUS_INDEX={horizontal:["cornerRadiusTopRight","cornerRadiusBottomRight"],vertical:["cornerRadiusTopLeft","cornerRadiusTopRight"]};const DEFAULT_RECT_BAND_SIZE=5;const defaultRectConfig={binSpacing:0,continuousBandSize:DEFAULT_RECT_BAND_SIZE,minBandSize:.25,timeUnitBandPosition:.5};const defaultBarConfig={...defaultRectConfig,binSpacing:1};const defaultTickConfig={...defaultRectConfig,thickness:1};function getMarkType(m){return isMarkDef(m)?m.type:m}function normalizeInvalidDataMode(mode,{isPath:isPath}){if(mode===undefined||mode==="break-paths-show-path-domains"){return isPath?"break-paths-show-domains":"filter"}else if(mode===null){return"show"}return mode}function getScaleInvalidDataMode({markDef:markDef,config:config,scaleChannel:scaleChannel,scaleType:scaleType,isCountAggregate:isCountAggregate}){if(!scaleType||!hasContinuousDomain(scaleType)||isCountAggregate){return"always-valid"}const invalidMode=normalizeInvalidDataMode(getMarkPropOrConfig("invalid",markDef,config),{isPath:isPathMark(markDef.type)});const scaleOutputForInvalid=config.scale?.invalid?.[scaleChannel];if(scaleOutputForInvalid!==undefined){return"show"}return invalidMode}function shouldBreakPath(mode){return mode==="break-paths-filter-domains"||mode==="break-paths-show-domains"}function scaledZeroOrMinOrMax({scaleName:scaleName,scale:scale,mode:mode}){const domain=`domain('${scaleName}')`;if(!scale||!scaleName){return undefined}const min=`${domain}[0]`;const max=`peek(${domain})`;const domainHasZero=scale.domainHasZero();if(domainHasZero==="definitely"){return{scale:scaleName,value:0}}else if(domainHasZero==="maybe"){const nonZeroValue=mode==="zeroOrMin"?min:max;return{signal:`scale('${scaleName}', inrange(0, ${domain}) ? 0 : ${nonZeroValue})`}}else{return{signal:`scale('${scaleName}', ${mode==="zeroOrMin"?min:max})`}}}function getConditionalValueRefForIncludingInvalidValue({scaleChannel:scaleChannel,channelDef:channelDef,scale:scale,scaleName:scaleName,markDef:markDef,config:config}){const scaleType=scale?.get("type");const fieldDef=getFieldDef(channelDef);const isCountAggregate=isCountingAggregateOp(fieldDef?.aggregate);const invalidDataMode=getScaleInvalidDataMode({scaleChannel:scaleChannel,markDef:markDef,config:config,scaleType:scaleType,isCountAggregate:isCountAggregate});if(fieldDef&&invalidDataMode==="show"){const includeAs=config.scale.invalid?.[scaleChannel]??"zero-or-min";return{test:fieldValidPredicate(vgField(fieldDef,{expr:"datum"}),false),...refForInvalidValues(includeAs,scale,scaleName)}}return undefined}function refForInvalidValues(includeAs,scale,scaleName){if(isScaleInvalidDataIncludeAsValue(includeAs)){const{value:value}=includeAs;return isSignalRef(value)?{signal:value.signal}:{value:value}}return scaledZeroOrMinOrMax({scale:scale,scaleName:scaleName,mode:"zeroOrMin"})}function midPointRefWithPositionInvalidTest(params){const{channel:channel,channelDef:channelDef,markDef:markDef,scale:scale,scaleName:scaleName,config:config}=params;const scaleChannel=getMainRangeChannel(channel);const mainRef=midPoint(params);const valueRefForIncludingInvalid=getConditionalValueRefForIncludingInvalidValue({scaleChannel:scaleChannel,channelDef:channelDef,scale:scale,scaleName:scaleName,markDef:markDef,config:config});return valueRefForIncludingInvalid!==undefined?[valueRefForIncludingInvalid,mainRef]:mainRef}function datumDefToExpr(datumDef){const{datum:datum}=datumDef;if(isDateTime(datum)){return dateTimeToExpr(datum)}return`${stringify(datum)}`}function valueRefForFieldOrDatumDef(fieldDef,scaleName,opt,encode){const ref={};if(scaleName){ref.scale=scaleName}if(isDatumDef(fieldDef)){const{datum:datum}=fieldDef;if(isDateTime(datum)){ref.signal=dateTimeToExpr(datum)}else if(isSignalRef(datum)){ref.signal=datum.signal}else if(isExprRef(datum)){ref.signal=datum.expr}else{ref.value=datum}}else{ref.field=vgField(fieldDef,opt)}if(encode){const{offset:offset,band:band}=encode;if(offset){ref.offset=offset}if(band){ref.band=band}}return ref}function interpolatedSignalRef({scaleName:scaleName,fieldOrDatumDef:fieldOrDatumDef,fieldOrDatumDef2:fieldOrDatumDef2,offset:offset,startSuffix:startSuffix,endSuffix:endSuffix="end",bandPosition:bandPosition=.5}){const expr=!isSignalRef(bandPosition)&&0<bandPosition&&bandPosition<1?"datum":undefined;const start=vgField(fieldOrDatumDef,{expr:expr,suffix:startSuffix});const end=fieldOrDatumDef2!==undefined?vgField(fieldOrDatumDef2,{expr:expr}):vgField(fieldOrDatumDef,{suffix:endSuffix,expr:expr});const ref={};if(bandPosition===0||bandPosition===1){ref.scale=scaleName;const field=bandPosition===0?start:end;ref.field=field}else{const datum=isSignalRef(bandPosition)?`(1-${bandPosition.signal}) * ${start} + ${bandPosition.signal} * ${end}`:`${1-bandPosition} * ${start} + ${bandPosition} * ${end}`;ref.signal=`scale("${scaleName}", ${datum})`}if(offset){ref.offset=offset}return ref}function binSizeExpr({scaleName:scaleName,fieldDef:fieldDef}){const start=vgField(fieldDef,{expr:"datum"});const end=vgField(fieldDef,{expr:"datum",suffix:"end"});return`abs(scale("${scaleName}", ${end}) - scale("${scaleName}", ${start}))`}function midPoint({channel:channel,channelDef:channelDef,channel2Def:channel2Def,markDef:markDef,config:config,scaleName:scaleName,scale:scale,stack:stack,offset:offset,defaultRef:defaultRef,bandPosition:bandPosition}){if(channelDef){if(isFieldOrDatumDef(channelDef)){const scaleType=scale?.get("type");if(isTypedFieldDef(channelDef)){bandPosition??(bandPosition=getBandPosition({fieldDef:channelDef,fieldDef2:channel2Def,markDef:markDef,config:config}));const{bin:bin,timeUnit:timeUnit,type:type}=channelDef;if(isBinning(bin)||bandPosition&&timeUnit&&type===TEMPORAL){if(stack?.impute){return valueRefForFieldOrDatumDef(channelDef,scaleName,{binSuffix:"mid"},{offset:offset})}if(bandPosition&&!hasDiscreteDomain(scaleType)){return interpolatedSignalRef({scaleName:scaleName,fieldOrDatumDef:channelDef,bandPosition:bandPosition,offset:offset})}return valueRefForFieldOrDatumDef(channelDef,scaleName,binRequiresRange(channelDef,channel)?{binSuffix:"range"}:{},{offset:offset})}else if(isBinned(bin)){if(isFieldDef(channel2Def)){return interpolatedSignalRef({scaleName:scaleName,fieldOrDatumDef:channelDef,fieldOrDatumDef2:channel2Def,bandPosition:bandPosition,offset:offset})}else{const channel2=channel===X?X2:Y2;warn(channelRequiredForBinned(channel2))}}}return valueRefForFieldOrDatumDef(channelDef,scaleName,hasDiscreteDomain(scaleType)?{binSuffix:"range"}:{},{offset:offset,band:scaleType==="band"?bandPosition??channelDef.bandPosition??.5:undefined})}else if(isValueDef(channelDef)){const value=channelDef.value;const offsetMixins=offset?{offset:offset}:{};return{...widthHeightValueOrSignalRef(channel,value),...offsetMixins}}}if(isFunction(defaultRef)){defaultRef=defaultRef()}if(defaultRef){return{...defaultRef,...offset?{offset:offset}:{}}}return defaultRef}function widthHeightValueOrSignalRef(channel,value){if(contains(["x","x2"],channel)&&value==="width"){return{field:{group:"width"}}}else if(contains(["y","y2"],channel)&&value==="height"){return{field:{group:"height"}}}return signalOrValueRef(value)}function isCustomFormatType(formatType){return formatType&&formatType!=="number"&&formatType!=="time"}function customFormatExpr(formatType,field,format){return`${formatType}(${field}${format?`, ${stringify(format)}`:""})`}const BIN_RANGE_DELIMITER=" – ";function formatSignalRef({fieldOrDatumDef:fieldOrDatumDef,format:format,formatType:formatType,expr:expr,normalizeStack:normalizeStack,config:config}){if(isCustomFormatType(formatType)){return formatCustomType({fieldOrDatumDef:fieldOrDatumDef,format:format,formatType:formatType,expr:expr,config:config})}const field=fieldToFormat(fieldOrDatumDef,expr,normalizeStack);const type=channelDefType(fieldOrDatumDef);if(format===undefined&&formatType===undefined&&config.customFormatTypes){if(type==="quantitative"){if(normalizeStack&&config.normalizedNumberFormatType)return formatCustomType({fieldOrDatumDef:fieldOrDatumDef,format:config.normalizedNumberFormat,formatType:config.normalizedNumberFormatType,expr:expr,config:config});if(config.numberFormatType){return formatCustomType({fieldOrDatumDef:fieldOrDatumDef,format:config.numberFormat,formatType:config.numberFormatType,expr:expr,config:config})}}if(type==="temporal"&&config.timeFormatType&&isFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.timeUnit===undefined){return formatCustomType({fieldOrDatumDef:fieldOrDatumDef,format:config.timeFormat,formatType:config.timeFormatType,expr:expr,config:config})}}if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){const signal=timeFormatExpression({field:field,timeUnit:isFieldDef(fieldOrDatumDef)?normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit:undefined,format:format,formatType:config.timeFormatType,rawTimeFormat:config.timeFormat,isUTCScale:isScaleFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.scale?.type===ScaleType.UTC});return signal?{signal:signal}:undefined}format=numberFormat({type:type,specifiedFormat:format,config:config,normalizeStack:normalizeStack});if(isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)){const endField=vgField(fieldOrDatumDef,{expr:expr,binSuffix:"end"});return{signal:binFormatExpression(field,endField,format,formatType,config)}}else if(format||channelDefType(fieldOrDatumDef)==="quantitative"){return{signal:`${formatExpr(field,format)}`}}else{return{signal:`isValid(${field}) ? ${field} : ""+${field}`}}}function fieldToFormat(fieldOrDatumDef,expr,normalizeStack){if(isFieldDef(fieldOrDatumDef)){if(normalizeStack){return`${vgField(fieldOrDatumDef,{expr:expr,suffix:"end"})}-${vgField(fieldOrDatumDef,{expr:expr,suffix:"start"})}`}else{return vgField(fieldOrDatumDef,{expr:expr})}}else{return datumDefToExpr(fieldOrDatumDef)}}function formatCustomType({fieldOrDatumDef:fieldOrDatumDef,format:format,formatType:formatType,expr:expr,normalizeStack:normalizeStack,config:config,field:field}){field??(field=fieldToFormat(fieldOrDatumDef,expr,normalizeStack));if(field!=="datum.value"&&isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)){const endField=vgField(fieldOrDatumDef,{expr:expr,binSuffix:"end"});return{signal:binFormatExpression(field,endField,format,formatType,config)}}return{signal:customFormatExpr(formatType,field,format)}}function guideFormat(fieldOrDatumDef,type,format,formatType,config,omitTimeFormatConfig){if(isString(formatType)&&isCustomFormatType(formatType)){return undefined}else if(format===undefined&&formatType===undefined&&config.customFormatTypes){if(channelDefType(fieldOrDatumDef)==="quantitative"){if(config.normalizedNumberFormatType&&isPositionFieldOrDatumDef(fieldOrDatumDef)&&fieldOrDatumDef.stack==="normalize"){return undefined}if(config.numberFormatType){return undefined}}}if(isPositionFieldOrDatumDef(fieldOrDatumDef)&&fieldOrDatumDef.stack==="normalize"&&config.normalizedNumberFormat){return numberFormat({type:"quantitative",config:config,normalizeStack:true})}if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){const timeUnit=isFieldDef(fieldOrDatumDef)?normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit:undefined;if(timeUnit===undefined&&config.customFormatTypes&&config.timeFormatType){return undefined}return timeFormat({specifiedFormat:format,timeUnit:timeUnit,config:config,omitTimeFormatConfig:omitTimeFormatConfig})}return numberFormat({type:type,specifiedFormat:format,config:config})}function guideFormatType(formatType,fieldOrDatumDef,scaleType){if(formatType&&(isSignalRef(formatType)||formatType==="number"||formatType==="time")){return formatType}if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)&&scaleType!=="time"&&scaleType!=="utc"){return isFieldDef(fieldOrDatumDef)&&normalizeTimeUnit(fieldOrDatumDef?.timeUnit)?.utc?"utc":"time"}return undefined}function numberFormat({type:type,specifiedFormat:specifiedFormat,config:config,normalizeStack:normalizeStack}){if(isString(specifiedFormat)){return specifiedFormat}if(type===QUANTITATIVE){return normalizeStack?config.normalizedNumberFormat:config.numberFormat}return undefined}function timeFormat({specifiedFormat:specifiedFormat,timeUnit:timeUnit,config:config,omitTimeFormatConfig:omitTimeFormatConfig}){if(specifiedFormat){return specifiedFormat}if(timeUnit){return{signal:timeUnitSpecifierExpression(timeUnit)}}return omitTimeFormatConfig?undefined:config.timeFormat}function formatExpr(field,format){return`format(${field}, "${format||""}")`}function binNumberFormatExpr(field,format,formatType,config){if(isCustomFormatType(formatType)){return customFormatExpr(formatType,field,format)}return formatExpr(field,(isString(format)?format:undefined)??config.numberFormat)}function binFormatExpression(startField,endField,format,formatType,config){if(format===undefined&&formatType===undefined&&config.customFormatTypes&&config.numberFormatType){return binFormatExpression(startField,endField,config.numberFormat,config.numberFormatType,config)}const start=binNumberFormatExpr(startField,format,formatType,config);const end=binNumberFormatExpr(endField,format,formatType,config);return`${fieldValidPredicate(startField,false)} ? "null" : ${start} + "${BIN_RANGE_DELIMITER}" + ${end}`}function timeFormatExpression({field:field,timeUnit:timeUnit,format:format,formatType:formatType,rawTimeFormat:rawTimeFormat,isUTCScale:isUTCScale}){if(!timeUnit||format){if(!timeUnit&&formatType){return`${formatType}(${field}, '${format}')`}format=isString(format)?format:rawTimeFormat;return`${isUTCScale?"utc":"time"}Format(${field}, '${format}')`}else{return formatExpression(timeUnit,field,isUTCScale)}}const DEFAULT_SORT_OP="min";const SORT_BY_CHANNEL_INDEX={x:1,y:1,color:1,fill:1,stroke:1,strokeWidth:1,size:1,shape:1,fillOpacity:1,strokeOpacity:1,opacity:1,text:1};function isSortByChannel(c){return has$1(SORT_BY_CHANNEL_INDEX,c)}function isSortByEncoding(sort){return hasProperty(sort,"encoding")}function isSortField(sort){return sort&&(sort.op==="count"||hasProperty(sort,"field"))}function isSortArray(sort){return sort&&isArray(sort)}function isFacetMapping(f){return hasProperty(f,"row")||hasProperty(f,"column")}function isFacetFieldDef(channelDef){return hasProperty(channelDef,"header")}function isFacetSpec(spec){return hasProperty(spec,"facet")}function isConditionalParameter(c){return hasProperty(c,"param")}function isRepeatRef(field){return!isString(field)&&hasProperty(field,"repeat")}function toFieldDefBase(fieldDef){const{field:field,timeUnit:timeUnit,bin:bin,aggregate:aggregate}=fieldDef;return{...timeUnit?{timeUnit:timeUnit}:{},...bin?{bin:bin}:{},...aggregate?{aggregate:aggregate}:{},field:field}}function isSortableFieldDef(fieldDef){return hasProperty(fieldDef,"sort")}function getBandPosition({fieldDef:fieldDef,fieldDef2:fieldDef2,markDef:mark,config:config}){if(isFieldOrDatumDef(fieldDef)&&fieldDef.bandPosition!==undefined){return fieldDef.bandPosition}if(isFieldDef(fieldDef)){const{timeUnit:timeUnit,bin:bin}=fieldDef;if(timeUnit&&!fieldDef2){return getMarkConfig("timeUnitBandPosition",mark,config)}else if(isBinning(bin)){return.5}}return undefined}function getBandSize({channel:channel,fieldDef:fieldDef,fieldDef2:fieldDef2,markDef:mark,config:config,scaleType:scaleType,useVlSizeChannel:useVlSizeChannel}){const sizeChannel=getSizeChannel(channel);const size=getMarkPropOrConfig(useVlSizeChannel?"size":sizeChannel,mark,config,{vgChannel:sizeChannel});if(size!==undefined){return size}if(isFieldDef(fieldDef)){const{timeUnit:timeUnit,bin:bin}=fieldDef;if(timeUnit&&!fieldDef2){return{band:getMarkConfig("timeUnitBandSize",mark,config)}}else if(isBinning(bin)&&!hasDiscreteDomain(scaleType)){return{band:1}}}if(isRectBasedMark(mark.type)){if(scaleType){if(hasDiscreteDomain(scaleType)){return config[mark.type]?.discreteBandSize||{band:1}}else{return config[mark.type]?.continuousBandSize}}return config[mark.type]?.discreteBandSize}return undefined}function hasBandEnd(fieldDef,fieldDef2,markDef,config){if(isBinning(fieldDef.bin)||fieldDef.timeUnit&&isTypedFieldDef(fieldDef)&&fieldDef.type==="temporal"){return getBandPosition({fieldDef:fieldDef,fieldDef2:fieldDef2,markDef:markDef,config:config})!==undefined}return false}function isOrderOnlyDef(orderDef){return hasProperty(orderDef,"sort")&&!hasProperty(orderDef,"field")}function isConditionalDef(channelDef){return hasProperty(channelDef,"condition")}function hasConditionalFieldDef(channelDef){const condition=channelDef?.["condition"];return!!condition&&!isArray(condition)&&isFieldDef(condition)}function hasConditionalFieldOrDatumDef(channelDef){const condition=channelDef?.["condition"];return!!condition&&!isArray(condition)&&isFieldOrDatumDef(condition)}function hasConditionalValueDef(channelDef){const condition=channelDef?.["condition"];return!!condition&&(isArray(condition)||isValueDef(condition))}function isFieldDef(channelDef){return hasProperty(channelDef,"field")||channelDef?.aggregate==="count"}function channelDefType(channelDef){return channelDef?.["type"]}function isDatumDef(channelDef){return hasProperty(channelDef,"datum")}function isContinuousFieldOrDatumDef(cd){return isTypedFieldDef(cd)&&!isDiscrete(cd)||isNumericDataDef(cd)}function isUnbinnedQuantitativeFieldOrDatumDef(cd){return isTypedFieldDef(cd)&&cd.type==="quantitative"&&!cd.bin||isNumericDataDef(cd)}function isNumericDataDef(cd){return isDatumDef(cd)&&isNumber$1(cd.datum)}function isFieldOrDatumDef(channelDef){return isFieldDef(channelDef)||isDatumDef(channelDef)}function isTypedFieldDef(channelDef){return channelDef&&(hasProperty(channelDef,"field")||channelDef["aggregate"]==="count")&&hasProperty(channelDef,"type")}function isValueDef(channelDef){return hasProperty(channelDef,"value")}function isScaleFieldDef(channelDef){return hasProperty(channelDef,"scale")||hasProperty(channelDef,"sort")}function isPositionFieldOrDatumDef(channelDef){return hasProperty(channelDef,"axis")||hasProperty(channelDef,"stack")||hasProperty(channelDef,"impute")}function isMarkPropFieldOrDatumDef(channelDef){return hasProperty(channelDef,"legend")}function isStringFieldOrDatumDef(channelDef){return hasProperty(channelDef,"format")||hasProperty(channelDef,"formatType")}function toStringFieldDef(fieldDef){return omit(fieldDef,["legend","axis","header","scale"])}function isOpFieldDef(fieldDef){return hasProperty(fieldDef,"op")}function vgField(fieldDef,opt={}){let field=fieldDef.field;const prefix=opt.prefix;let suffix=opt.suffix;let argAccessor="";if(isCount(fieldDef)){field=internalField("count")}else{let fn;if(!opt.nofn){if(isOpFieldDef(fieldDef)){fn=fieldDef.op}else{const{bin:bin,aggregate:aggregate,timeUnit:timeUnit}=fieldDef;if(isBinning(bin)){fn=binToString(bin);suffix=(opt.binSuffix??"")+(opt.suffix??"")}else if(aggregate){if(isArgmaxDef(aggregate)){argAccessor=`["${field}"]`;field=`argmax_${aggregate.argmax}`}else if(isArgminDef(aggregate)){argAccessor=`["${field}"]`;field=`argmin_${aggregate.argmin}`}else{fn=String(aggregate)}}else if(timeUnit&&!isBinnedTimeUnit(timeUnit)){fn=timeUnitToString(timeUnit);suffix=(!["range","mid"].includes(opt.binSuffix)&&opt.binSuffix||"")+(opt.suffix??"")}}}if(fn){field=field?`${fn}_${field}`:fn}}if(suffix){field=`${field}_${suffix}`}if(prefix){field=`${prefix}_${field}`}if(opt.forAs){return removePathFromField(field)}else if(opt.expr){return flatAccessWithDatum(field,opt.expr)+argAccessor}else{return replacePathInField(field)+argAccessor}}function isDiscrete(def){switch(def.type){case"nominal":case"ordinal":case"geojson":return true;case"quantitative":return isFieldDef(def)&&!!def.bin;case"temporal":return false}throw new Error(invalidFieldType(def.type))}function isDiscretizing(def){return isScaleFieldDef(def)&&isContinuousToDiscrete(def.scale?.type)}function isCount(fieldDef){return fieldDef.aggregate==="count"}function verbalTitleFormatter(fieldDef,config){const{field:field,bin:bin,timeUnit:timeUnit,aggregate:aggregate}=fieldDef;if(aggregate==="count"){return config.countTitle}else if(isBinning(bin)){return`${field} (binned)`}else if(timeUnit&&!isBinnedTimeUnit(timeUnit)){const unit=normalizeTimeUnit(timeUnit)?.unit;if(unit){return`${field} (${getTimeUnitParts(unit).join("-")})`}}else if(aggregate){if(isArgmaxDef(aggregate)){return`${field} for max ${aggregate.argmax}`}else if(isArgminDef(aggregate)){return`${field} for min ${aggregate.argmin}`}else{return`${titleCase(aggregate)} of ${field}`}}return field}function functionalTitleFormatter(fieldDef){const{aggregate:aggregate,bin:bin,timeUnit:timeUnit,field:field}=fieldDef;if(isArgmaxDef(aggregate)){return`${field} for argmax(${aggregate.argmax})`}else if(isArgminDef(aggregate)){return`${field} for argmin(${aggregate.argmin})`}const timeUnitParams=timeUnit&&!isBinnedTimeUnit(timeUnit)?normalizeTimeUnit(timeUnit):undefined;const fn=aggregate||timeUnitParams?.unit||timeUnitParams?.maxbins&&"timeunit"||isBinning(bin)&&"bin";return fn?`${fn.toUpperCase()}(${field})`:field}const defaultTitleFormatter=(fieldDef,config)=>{switch(config.fieldTitle){case"plain":return fieldDef.field;case"functional":return functionalTitleFormatter(fieldDef);default:return verbalTitleFormatter(fieldDef,config)}};let titleFormatter=defaultTitleFormatter;function setTitleFormatter(formatter){titleFormatter=formatter}function resetTitleFormatter(){setTitleFormatter(defaultTitleFormatter)}function title(fieldOrDatumDef,config,{allowDisabling:allowDisabling,includeDefault:includeDefault=true}){const guideTitle=getGuide(fieldOrDatumDef)?.title;if(!isFieldDef(fieldOrDatumDef)){return guideTitle??fieldOrDatumDef.title}const fieldDef=fieldOrDatumDef;const def=includeDefault?defaultTitle(fieldDef,config):undefined;if(allowDisabling){return getFirstDefined(guideTitle,fieldDef.title,def)}else{return guideTitle??fieldDef.title??def}}function getGuide(fieldDef){if(isPositionFieldOrDatumDef(fieldDef)&&fieldDef.axis){return fieldDef.axis}else if(isMarkPropFieldOrDatumDef(fieldDef)&&fieldDef.legend){return fieldDef.legend}else if(isFacetFieldDef(fieldDef)&&fieldDef.header){return fieldDef.header}return undefined}function defaultTitle(fieldDef,config){return titleFormatter(fieldDef,config)}function getFormatMixins(fieldDef){if(isStringFieldOrDatumDef(fieldDef)){const{format:format,formatType:formatType}=fieldDef;return{format:format,formatType:formatType}}else{const guide=getGuide(fieldDef)??{};const{format:format,formatType:formatType}=guide;return{format:format,formatType:formatType}}}function defaultType$2(fieldDef,channel){switch(channel){case"latitude":case"longitude":return"quantitative";case"row":case"column":case"facet":case"shape":case"strokeDash":return"nominal";case"order":return"ordinal"}if(isSortableFieldDef(fieldDef)&&isArray(fieldDef.sort)){return"ordinal"}const{aggregate:aggregate,bin:bin,timeUnit:timeUnit}=fieldDef;if(timeUnit){return"temporal"}if(bin||aggregate&&!isArgmaxDef(aggregate)&&!isArgminDef(aggregate)){return"quantitative"}if(isScaleFieldDef(fieldDef)&&fieldDef.scale?.type){switch(SCALE_CATEGORY_INDEX[fieldDef.scale.type]){case"numeric":case"discretizing":return"quantitative";case"time":return"temporal"}}return"nominal"}function getFieldDef(channelDef){if(isFieldDef(channelDef)){return channelDef}else if(hasConditionalFieldDef(channelDef)){return channelDef.condition}return undefined}function getFieldOrDatumDef(channelDef){if(isFieldOrDatumDef(channelDef)){return channelDef}else if(hasConditionalFieldOrDatumDef(channelDef)){return channelDef.condition}return undefined}function initChannelDef(channelDef,channel,config,opt={}){if(isString(channelDef)||isNumber$1(channelDef)||isBoolean$2(channelDef)){const primitiveType=isString(channelDef)?"string":isNumber$1(channelDef)?"number":"boolean";warn(primitiveChannelDef(channel,primitiveType,channelDef));return{value:channelDef}}if(isFieldOrDatumDef(channelDef)){return initFieldOrDatumDef(channelDef,channel,config,opt)}else if(hasConditionalFieldOrDatumDef(channelDef)){return{...channelDef,condition:initFieldOrDatumDef(channelDef.condition,channel,config,opt)}}return channelDef}function initFieldOrDatumDef(fd,channel,config,opt){if(isStringFieldOrDatumDef(fd)){const{format:format,formatType:formatType,...rest}=fd;if(isCustomFormatType(formatType)&&!config.customFormatTypes){warn(customFormatTypeNotAllowed(channel));return initFieldOrDatumDef(rest,channel,config,opt)}}else{const guideType=isPositionFieldOrDatumDef(fd)?"axis":isMarkPropFieldOrDatumDef(fd)?"legend":isFacetFieldDef(fd)?"header":null;if(guideType&&fd[guideType]){const{format:format,formatType:formatType,...newGuide}=fd[guideType];if(isCustomFormatType(formatType)&&!config.customFormatTypes){warn(customFormatTypeNotAllowed(channel));return initFieldOrDatumDef({...fd,[guideType]:newGuide},channel,config,opt)}}}if(isFieldDef(fd)){return initFieldDef(fd,channel,opt)}return initDatumDef(fd)}function initDatumDef(datumDef){let type=datumDef["type"];if(type){return datumDef}const{datum:datum}=datumDef;type=isNumber$1(datum)?"quantitative":isString(datum)?"nominal":isDateTime(datum)?"temporal":undefined;return{...datumDef,type:type}}function initFieldDef(fd,channel,{compositeMark:compositeMark=false}={}){const{aggregate:aggregate,timeUnit:timeUnit,bin:bin,field:field}=fd;const fieldDef={...fd};if(!compositeMark&&aggregate&&!isAggregateOp(aggregate)&&!isArgmaxDef(aggregate)&&!isArgminDef(aggregate)){warn(invalidAggregate(aggregate));delete fieldDef.aggregate}if(timeUnit){fieldDef.timeUnit=normalizeTimeUnit(timeUnit)}if(field){fieldDef.field=`${field}`}if(isBinning(bin)){fieldDef.bin=normalizeBin(bin,channel)}if(isBinned(bin)&&!isXorY(channel)){warn(channelShouldNotBeUsedForBinned(channel))}if(isTypedFieldDef(fieldDef)){const{type:type}=fieldDef;const fullType=getFullName(type);if(type!==fullType){fieldDef.type=fullType}if(type!=="quantitative"){if(isCountingAggregateOp(aggregate)){warn(invalidFieldTypeForCountAggregate(type,aggregate));fieldDef.type="quantitative"}}}else if(!isSecondaryRangeChannel(channel)){const newType=defaultType$2(fieldDef,channel);fieldDef["type"]=newType}if(isTypedFieldDef(fieldDef)){const{compatible:compatible,warning:warning}=channelCompatibility(fieldDef,channel)||{};if(compatible===false){warn(warning)}}if(isSortableFieldDef(fieldDef)&&isString(fieldDef.sort)){const{sort:sort}=fieldDef;if(isSortByChannel(sort)){return{...fieldDef,sort:{encoding:sort}}}const sub=sort.substring(1);if(sort.charAt(0)==="-"&&isSortByChannel(sub)){return{...fieldDef,sort:{encoding:sub,order:"descending"}}}}if(isFacetFieldDef(fieldDef)){const{header:header}=fieldDef;if(header){const{orient:orient,...rest}=header;if(orient){return{...fieldDef,header:{...rest,labelOrient:header.labelOrient||orient,titleOrient:header.titleOrient||orient}}}}}return fieldDef}function normalizeBin(bin,channel){if(isBoolean$2(bin)){return{maxbins:autoMaxBins(channel)}}else if(bin==="binned"){return{binned:true}}else if(!bin.maxbins&&!bin.step){return{...bin,maxbins:autoMaxBins(channel)}}else{return bin}}const COMPATIBLE={compatible:true};function channelCompatibility(fieldDef,channel){const type=fieldDef.type;if(type==="geojson"&&channel!=="shape"){return{compatible:false,warning:`Channel ${channel} should not be used with a geojson data.`}}switch(channel){case ROW:case COLUMN:case FACET:if(!isDiscrete(fieldDef)){return{compatible:false,warning:channelShouldBeDiscrete(channel)}}return COMPATIBLE;case X:case Y:case XOFFSET:case YOFFSET:case COLOR:case FILL:case STROKE:case TEXT$1:case DETAIL:case KEY:case TOOLTIP:case HREF:case URL:case ANGLE:case THETA:case RADIUS:case DESCRIPTION:return COMPATIBLE;case LONGITUDE:case LONGITUDE2:case LATITUDE:case LATITUDE2:if(type!==QUANTITATIVE){return{compatible:false,warning:`Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`}}return COMPATIBLE;case OPACITY:case FILLOPACITY:case STROKEOPACITY:case STROKEWIDTH:case SIZE:case THETA2:case RADIUS2:case X2:case Y2:if(type==="nominal"&&!fieldDef["sort"]){return{compatible:false,warning:`Channel ${channel} should not be used with an unsorted discrete field.`}}return COMPATIBLE;case SHAPE:case STROKEDASH:if(!isDiscrete(fieldDef)&&!isDiscretizing(fieldDef)){return{compatible:false,warning:channelShouldBeDiscreteOrDiscretizing(channel)}}return COMPATIBLE;case ORDER:if(fieldDef.type==="nominal"&&!("sort"in fieldDef)){return{compatible:false,warning:`Channel order is inappropriate for nominal field, which has no inherent order.`}}return COMPATIBLE}}function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef){const{formatType:formatType}=getFormatMixins(fieldOrDatumDef);return formatType==="time"||!formatType&&isTimeFieldDef(fieldOrDatumDef)}function isTimeFieldDef(def){return def&&(def["type"]==="temporal"||isFieldDef(def)&&!!def.timeUnit)}function valueExpr(v,{timeUnit:timeUnit,type:type,wrapTime:wrapTime,undefinedIfExprNotRequired:undefinedIfExprNotRequired}){const unit=timeUnit&&normalizeTimeUnit(timeUnit)?.unit;let isTime=unit||type==="temporal";let expr;if(isExprRef(v)){expr=v.expr}else if(isSignalRef(v)){expr=v.signal}else if(isDateTime(v)){isTime=true;expr=dateTimeToExpr(v)}else if(isString(v)||isNumber$1(v)){if(isTime){expr=`datetime(${stringify(v)})`;if(isLocalSingleTimeUnit(unit)){if(isNumber$1(v)&&v<1e4||isString(v)&&isNaN(Date.parse(v))){expr=dateTimeToExpr({[unit]:v})}}}}if(expr){return wrapTime&&isTime?`time(${expr})`:expr}return undefinedIfExprNotRequired?undefined:stringify(v)}function valueArray(fieldOrDatumDef,values){const{type:type}=fieldOrDatumDef;return values.map((v=>{const timeUnit=isFieldDef(fieldOrDatumDef)&&!isBinnedTimeUnit(fieldOrDatumDef.timeUnit)?fieldOrDatumDef.timeUnit:undefined;const expr=valueExpr(v,{timeUnit:timeUnit,type:type,undefinedIfExprNotRequired:true});if(expr!==undefined){return{signal:expr}}return v}))}function binRequiresRange(fieldDef,channel){if(!isBinning(fieldDef.bin)){console.warn("Only call this method for binned field defs.");return false}return isScaleChannel(channel)&&["ordinal","nominal"].includes(fieldDef.type)}const CONDITIONAL_AXIS_PROP_INDEX={labelAlign:{part:"labels",vgProp:"align"},labelBaseline:{part:"labels",vgProp:"baseline"},labelColor:{part:"labels",vgProp:"fill"},labelFont:{part:"labels",vgProp:"font"},labelFontSize:{part:"labels",vgProp:"fontSize"},labelFontStyle:{part:"labels",vgProp:"fontStyle"},labelFontWeight:{part:"labels",vgProp:"fontWeight"},labelOpacity:{part:"labels",vgProp:"opacity"},labelOffset:null,labelPadding:null,gridColor:{part:"grid",vgProp:"stroke"},gridDash:{part:"grid",vgProp:"strokeDash"},gridDashOffset:{part:"grid",vgProp:"strokeDashOffset"},gridOpacity:{part:"grid",vgProp:"opacity"},gridWidth:{part:"grid",vgProp:"strokeWidth"},tickColor:{part:"ticks",vgProp:"stroke"},tickDash:{part:"ticks",vgProp:"strokeDash"},tickDashOffset:{part:"ticks",vgProp:"strokeDashOffset"},tickOpacity:{part:"ticks",vgProp:"opacity"},tickSize:null,tickWidth:{part:"ticks",vgProp:"strokeWidth"}};function isConditionalAxisValue(v){return v?.condition}const AXIS_PARTS=["domain","grid","labels","ticks","title"];const AXIS_PROPERTY_TYPE={grid:"grid",gridCap:"grid",gridColor:"grid",gridDash:"grid",gridDashOffset:"grid",gridOpacity:"grid",gridScale:"grid",gridWidth:"grid",orient:"main",bandPosition:"both",aria:"main",description:"main",domain:"main",domainCap:"main",domainColor:"main",domainDash:"main",domainDashOffset:"main",domainOpacity:"main",domainWidth:"main",format:"main",formatType:"main",labelAlign:"main",labelAngle:"main",labelBaseline:"main",labelBound:"main",labelColor:"main",labelFlush:"main",labelFlushOffset:"main",labelFont:"main",labelFontSize:"main",labelFontStyle:"main",labelFontWeight:"main",labelLimit:"main",labelLineHeight:"main",labelOffset:"main",labelOpacity:"main",labelOverlap:"main",labelPadding:"main",labels:"main",labelSeparation:"main",maxExtent:"main",minExtent:"main",offset:"both",position:"main",tickCap:"main",tickColor:"main",tickDash:"main",tickDashOffset:"main",tickMinStep:"both",tickOffset:"both",tickOpacity:"main",tickRound:"both",ticks:"main",tickSize:"main",tickWidth:"both",title:"main",titleAlign:"main",titleAnchor:"main",titleAngle:"main",titleBaseline:"main",titleColor:"main",titleFont:"main",titleFontSize:"main",titleFontStyle:"main",titleFontWeight:"main",titleLimit:"main",titleLineHeight:"main",titleOpacity:"main",titlePadding:"main",titleX:"main",titleY:"main",encode:"both",scale:"both",tickBand:"both",tickCount:"both",tickExtra:"both",translate:"both",values:"both",zindex:"both"};const COMMON_AXIS_PROPERTIES_INDEX={orient:1,aria:1,bandPosition:1,description:1,domain:1,domainCap:1,domainColor:1,domainDash:1,domainDashOffset:1,domainOpacity:1,domainWidth:1,format:1,formatType:1,grid:1,gridCap:1,gridColor:1,gridDash:1,gridDashOffset:1,gridOpacity:1,gridWidth:1,labelAlign:1,labelAngle:1,labelBaseline:1,labelBound:1,labelColor:1,labelFlush:1,labelFlushOffset:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,labelLimit:1,labelLineHeight:1,labelOffset:1,labelOpacity:1,labelOverlap:1,labelPadding:1,labels:1,labelSeparation:1,maxExtent:1,minExtent:1,offset:1,position:1,tickBand:1,tickCap:1,tickColor:1,tickCount:1,tickDash:1,tickDashOffset:1,tickExtra:1,tickMinStep:1,tickOffset:1,tickOpacity:1,tickRound:1,ticks:1,tickSize:1,tickWidth:1,title:1,titleAlign:1,titleAnchor:1,titleAngle:1,titleBaseline:1,titleColor:1,titleFont:1,titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,titleOpacity:1,titlePadding:1,titleX:1,titleY:1,translate:1,values:1,zindex:1};const AXIS_PROPERTIES_INDEX={...COMMON_AXIS_PROPERTIES_INDEX,style:1,labelExpr:1,encoding:1};function isAxisProperty(prop){return has$1(AXIS_PROPERTIES_INDEX,prop)}const AXIS_CONFIGS_INDEX={axis:1,axisBand:1,axisBottom:1,axisDiscrete:1,axisLeft:1,axisPoint:1,axisQuantitative:1,axisRight:1,axisTemporal:1,axisTop:1,axisX:1,axisXBand:1,axisXDiscrete:1,axisXPoint:1,axisXQuantitative:1,axisXTemporal:1,axisY:1,axisYBand:1,axisYDiscrete:1,axisYPoint:1,axisYQuantitative:1,axisYTemporal:1};const AXIS_CONFIGS=keys(AXIS_CONFIGS_INDEX);function isUnitSpec(spec){return hasProperty(spec,"mark")}class CompositeMarkNormalizer{constructor(name,run){this.name=name;this.run=run}hasMatchingType(spec){if(isUnitSpec(spec)){return getMarkType(spec.mark)===this.name}return false}}function channelHasField(encoding,channel){const channelDef=encoding&&encoding[channel];if(channelDef){if(isArray(channelDef)){return some(channelDef,(fieldDef=>!!fieldDef.field))}else{return isFieldDef(channelDef)||hasConditionalFieldDef(channelDef)}}return false}function channelHasFieldOrDatum(encoding,channel){const channelDef=encoding&&encoding[channel];if(channelDef){if(isArray(channelDef)){return some(channelDef,(fieldDef=>!!fieldDef.field))}else{return isFieldDef(channelDef)||isDatumDef(channelDef)||hasConditionalFieldOrDatumDef(channelDef)}}return false}function channelHasNestedOffsetScale(encoding,channel){if(isXorY(channel)){const fieldDef=encoding[channel];if((isFieldDef(fieldDef)||isDatumDef(fieldDef))&&(isDiscrete$1(fieldDef.type)||isFieldDef(fieldDef)&&fieldDef.timeUnit)){const offsetChannel=getOffsetScaleChannel(channel);return channelHasFieldOrDatum(encoding,offsetChannel)}}return false}function isAggregate$1(encoding){return some(CHANNELS,(channel=>{if(channelHasField(encoding,channel)){const channelDef=encoding[channel];if(isArray(channelDef)){return some(channelDef,(fieldDef=>!!fieldDef.aggregate))}else{const fieldDef=getFieldDef(channelDef);return fieldDef&&!!fieldDef.aggregate}}return false}))}function extractTransformsFromEncoding(oldEncoding,config){const groupby=[];const bins=[];const timeUnits=[];const aggregate=[];const encoding={};forEach(oldEncoding,((channelDef,channel)=>{if(isFieldDef(channelDef)){const{field:field,aggregate:aggOp,bin:bin,timeUnit:timeUnit,...remaining}=channelDef;if(aggOp||timeUnit||bin){const guide=getGuide(channelDef);const isTitleDefined=guide?.title;let newField=vgField(channelDef,{forAs:true});const newFieldDef={...isTitleDefined?[]:{title:title(channelDef,config,{allowDisabling:true})},...remaining,field:newField};if(aggOp){let op;if(isArgmaxDef(aggOp)){op="argmax";newField=vgField({op:"argmax",field:aggOp.argmax},{forAs:true});newFieldDef.field=`${newField}.${field}`}else if(isArgminDef(aggOp)){op="argmin";newField=vgField({op:"argmin",field:aggOp.argmin},{forAs:true});newFieldDef.field=`${newField}.${field}`}else if(aggOp!=="boxplot"&&aggOp!=="errorbar"&&aggOp!=="errorband"){op=aggOp}if(op){const aggregateEntry={op:op,as:newField};if(field){aggregateEntry.field=field}aggregate.push(aggregateEntry)}}else{groupby.push(newField);if(isTypedFieldDef(channelDef)&&isBinning(bin)){bins.push({bin:bin,field:field,as:newField});groupby.push(vgField(channelDef,{binSuffix:"end"}));if(binRequiresRange(channelDef,channel)){groupby.push(vgField(channelDef,{binSuffix:"range"}))}if(isXorY(channel)){const secondaryChannel={field:`${newField}_end`};encoding[`${channel}2`]=secondaryChannel}newFieldDef.bin="binned";if(!isSecondaryRangeChannel(channel)){newFieldDef["type"]=QUANTITATIVE}}else if(timeUnit&&!isBinnedTimeUnit(timeUnit)){timeUnits.push({timeUnit:timeUnit,field:field,as:newField});const formatType=isTypedFieldDef(channelDef)&&channelDef.type!==TEMPORAL&&"time";if(formatType){if(channel===TEXT$1||channel===TOOLTIP){newFieldDef["formatType"]=formatType}else if(isNonPositionScaleChannel(channel)){newFieldDef["legend"]={formatType:formatType,...newFieldDef["legend"]}}else if(isXorY(channel)){newFieldDef["axis"]={formatType:formatType,...newFieldDef["axis"]}}}}}encoding[channel]=newFieldDef}else{groupby.push(field);encoding[channel]=oldEncoding[channel]}}else{encoding[channel]=oldEncoding[channel]}}));return{bins:bins,timeUnits:timeUnits,aggregate:aggregate,groupby:groupby,encoding:encoding}}function markChannelCompatible(encoding,channel,mark){const markSupported=supportMark(channel,mark);if(!markSupported){return false}else if(markSupported==="binned"){const primaryFieldDef=encoding[channel===X2?X:Y];if(isFieldDef(primaryFieldDef)&&isFieldDef(encoding[channel])&&isBinned(primaryFieldDef.bin)){return true}else{return false}}return true}function initEncoding(encoding,mark,filled,config){const normalizedEncoding={};for(const key of keys(encoding)){if(!isChannel(key)){warn(invalidEncodingChannel(key))}}for(let channel of UNIT_CHANNELS){if(!encoding[channel]){continue}const channelDef=encoding[channel];if(isXorYOffset(channel)){const mainChannel=getMainChannelFromOffsetChannel(channel);const positionDef=normalizedEncoding[mainChannel];if(isFieldDef(positionDef)){if(isContinuous(positionDef.type)){if(isFieldDef(channelDef)&&!positionDef.timeUnit){warn(offsetNestedInsideContinuousPositionScaleDropped(mainChannel));continue}}}}if(channel==="angle"&&mark==="arc"&&!encoding.theta){warn(REPLACE_ANGLE_WITH_THETA);channel=THETA}if(!markChannelCompatible(encoding,channel,mark)){warn(incompatibleChannel(channel,mark));continue}if(channel===SIZE&&mark==="line"){const fieldDef=getFieldDef(encoding[channel]);if(fieldDef?.aggregate){warn(LINE_WITH_VARYING_SIZE);continue}}if(channel===COLOR&&(filled?"fill"in encoding:"stroke"in encoding)){warn(droppingColor("encoding",{fill:"fill"in encoding,stroke:"stroke"in encoding}));continue}if(channel===DETAIL||channel===ORDER&&!isArray(channelDef)&&!isValueDef(channelDef)||channel===TOOLTIP&&isArray(channelDef)){if(channelDef){if(channel===ORDER){const def=encoding[channel];if(isOrderOnlyDef(def)){normalizedEncoding[channel]=def;continue}}normalizedEncoding[channel]=array$5(channelDef).reduce(((defs,fieldDef)=>{if(!isFieldDef(fieldDef)){warn(emptyFieldDef(fieldDef,channel))}else{defs.push(initFieldDef(fieldDef,channel))}return defs}),[])}}else{if(channel===TOOLTIP&&channelDef===null){normalizedEncoding[channel]=null}else if(!isFieldDef(channelDef)&&!isDatumDef(channelDef)&&!isValueDef(channelDef)&&!isConditionalDef(channelDef)&&!isSignalRef(channelDef)){warn(emptyFieldDef(channelDef,channel));continue}normalizedEncoding[channel]=initChannelDef(channelDef,channel,config)}}return normalizedEncoding}function normalizeEncoding(encoding,config){const normalizedEncoding={};for(const channel of keys(encoding)){const newChannelDef=initChannelDef(encoding[channel],channel,config,{compositeMark:true});normalizedEncoding[channel]=newChannelDef}return normalizedEncoding}function fieldDefs(encoding){const arr=[];for(const channel of keys(encoding)){if(channelHasField(encoding,channel)){const channelDef=encoding[channel];const channelDefArray=array$5(channelDef);for(const def of channelDefArray){if(isFieldDef(def)){arr.push(def)}else if(hasConditionalFieldDef(def)){arr.push(def.condition)}}}}return arr}function forEach(mapping,f,thisArg){if(!mapping){return}for(const channel of keys(mapping)){const el=mapping[channel];if(isArray(el)){for(const channelDef of el){f.call(thisArg,channelDef,channel)}}else{f.call(thisArg,el,channel)}}}function reduce(mapping,f,init,thisArg){if(!mapping){return init}return keys(mapping).reduce(((r,channel)=>{const map=mapping[channel];if(isArray(map)){return map.reduce(((r1,channelDef)=>f.call(thisArg,r1,channelDef,channel)),r)}else{return f.call(thisArg,r,map,channel)}}),init)}function pathGroupingFields(mark,encoding){return keys(encoding).reduce(((details,channel)=>{switch(channel){case X:case Y:case HREF:case DESCRIPTION:case URL:case X2:case Y2:case XOFFSET:case YOFFSET:case THETA:case THETA2:case RADIUS:case RADIUS2:case LATITUDE:case LONGITUDE:case LATITUDE2:case LONGITUDE2:case TEXT$1:case SHAPE:case ANGLE:case TOOLTIP:return details;case ORDER:if(mark==="line"||mark==="trail"){return details}case DETAIL:case KEY:{const channelDef=encoding[channel];if(isArray(channelDef)||isFieldDef(channelDef)){for(const fieldDef of array$5(channelDef)){if(!fieldDef.aggregate){details.push(vgField(fieldDef,{}))}}}return details}case SIZE:if(mark==="trail"){return details}case COLOR:case FILL:case STROKE:case OPACITY:case FILLOPACITY:case STROKEOPACITY:case STROKEDASH:case STROKEWIDTH:{const fieldDef=getFieldDef(encoding[channel]);if(fieldDef&&!fieldDef.aggregate){details.push(vgField(fieldDef,{}))}return details}}}),[])}function filterTooltipWithAggregatedField(oldEncoding){const{tooltip:tooltip,...filteredEncoding}=oldEncoding;if(!tooltip){return{filteredEncoding:filteredEncoding}}let customTooltipWithAggregatedField;let customTooltipWithoutAggregatedField;if(isArray(tooltip)){for(const t of tooltip){if(t.aggregate){if(!customTooltipWithAggregatedField){customTooltipWithAggregatedField=[]}customTooltipWithAggregatedField.push(t)}else{if(!customTooltipWithoutAggregatedField){customTooltipWithoutAggregatedField=[]}customTooltipWithoutAggregatedField.push(t)}}if(customTooltipWithAggregatedField){filteredEncoding.tooltip=customTooltipWithAggregatedField}}else{if(tooltip.aggregate){filteredEncoding.tooltip=tooltip}else{customTooltipWithoutAggregatedField=tooltip}}if(isArray(customTooltipWithoutAggregatedField)&&customTooltipWithoutAggregatedField.length===1){customTooltipWithoutAggregatedField=customTooltipWithoutAggregatedField[0]}return{customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField,filteredEncoding:filteredEncoding}}function getCompositeMarkTooltip(tooltipSummary,continuousAxisChannelDef,encodingWithoutContinuousAxis,withFieldName=true){if("tooltip"in encodingWithoutContinuousAxis){return{tooltip:encodingWithoutContinuousAxis.tooltip}}const fiveSummaryTooltip=tooltipSummary.map((({fieldPrefix:fieldPrefix,titlePrefix:titlePrefix})=>{const mainTitle=withFieldName?` of ${getTitle(continuousAxisChannelDef)}`:"";return{field:fieldPrefix+continuousAxisChannelDef.field,type:continuousAxisChannelDef.type,title:isSignalRef(titlePrefix)?{signal:`${titlePrefix}"${escape(mainTitle)}"`}:titlePrefix+mainTitle}}));const tooltipFieldDefs=fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);return{tooltip:[...fiveSummaryTooltip,...unique(tooltipFieldDefs,hash)]}}function getTitle(continuousAxisChannelDef){const{title:title,field:field}=continuousAxisChannelDef;return getFirstDefined(title,field)}function makeCompositeAggregatePartFactory(compositeMarkDef,continuousAxis,continuousAxisChannelDef,sharedEncoding,compositeMarkConfig){const{scale:scale,axis:axis}=continuousAxisChannelDef;return({partName:partName,mark:mark,positionPrefix:positionPrefix,endPositionPrefix:endPositionPrefix=undefined,extraEncoding:extraEncoding={}})=>{const title=getTitle(continuousAxisChannelDef);return partLayerMixins(compositeMarkDef,partName,compositeMarkConfig,{mark:mark,encoding:{[continuousAxis]:{field:`${positionPrefix}_${continuousAxisChannelDef.field}`,type:continuousAxisChannelDef.type,...title!==undefined?{title:title}:{},...scale!==undefined?{scale:scale}:{},...axis!==undefined?{axis:axis}:{}},...isString(endPositionPrefix)?{[`${continuousAxis}2`]:{field:`${endPositionPrefix}_${continuousAxisChannelDef.field}`}}:{},...sharedEncoding,...extraEncoding}})}}function partLayerMixins(markDef,part,compositeMarkConfig,partBaseSpec){const{clip:clip,color:color,opacity:opacity}=markDef;const mark=markDef.type;if(markDef[part]||markDef[part]===undefined&&compositeMarkConfig[part]){return[{...partBaseSpec,mark:{...compositeMarkConfig[part],...clip?{clip:clip}:{},...color?{color:color}:{},...opacity?{opacity:opacity}:{},...isMarkDef(partBaseSpec.mark)?partBaseSpec.mark:{type:partBaseSpec.mark},style:`${mark}-${String(part)}`,...isBoolean$2(markDef[part])?{}:markDef[part]}}]}return[]}function compositeMarkContinuousAxis(spec,orient,compositeMark){const{encoding:encoding}=spec;const continuousAxis=orient==="vertical"?"y":"x";const continuousAxisChannelDef=encoding[continuousAxis];const continuousAxisChannelDef2=encoding[`${continuousAxis}2`];const continuousAxisChannelDefError=encoding[`${continuousAxis}Error`];const continuousAxisChannelDefError2=encoding[`${continuousAxis}Error2`];return{continuousAxisChannelDef:filterAggregateFromChannelDef(continuousAxisChannelDef,compositeMark),continuousAxisChannelDef2:filterAggregateFromChannelDef(continuousAxisChannelDef2,compositeMark),continuousAxisChannelDefError:filterAggregateFromChannelDef(continuousAxisChannelDefError,compositeMark),continuousAxisChannelDefError2:filterAggregateFromChannelDef(continuousAxisChannelDefError2,compositeMark),continuousAxis:continuousAxis}}function filterAggregateFromChannelDef(continuousAxisChannelDef,compositeMark){if(continuousAxisChannelDef?.aggregate){const{aggregate:aggregate,...continuousAxisWithoutAggregate}=continuousAxisChannelDef;if(aggregate!==compositeMark){warn(errorBarContinuousAxisHasCustomizedAggregate(aggregate,compositeMark))}return continuousAxisWithoutAggregate}else{return continuousAxisChannelDef}}function compositeMarkOrient(spec,compositeMark){const{mark:mark,encoding:encoding}=spec;const{x:x,y:y}=encoding;if(isMarkDef(mark)&&mark.orient){return mark.orient}if(isContinuousFieldOrDatumDef(x)){if(isContinuousFieldOrDatumDef(y)){const xAggregate=isFieldDef(x)&&x.aggregate;const yAggregate=isFieldDef(y)&&y.aggregate;if(!xAggregate&&yAggregate===compositeMark){return"vertical"}else if(!yAggregate&&xAggregate===compositeMark){return"horizontal"}else if(xAggregate===compositeMark&&yAggregate===compositeMark){throw new Error("Both x and y cannot have aggregate")}else{if(isFieldOrDatumDefForTimeFormat(y)&&!isFieldOrDatumDefForTimeFormat(x)){return"horizontal"}return"vertical"}}return"horizontal"}else if(isContinuousFieldOrDatumDef(y)){return"vertical"}else{throw new Error(`Need a valid continuous axis for ${compositeMark}s`)}}const BOXPLOT="boxplot";const BOXPLOT_PARTS=["box","median","outliers","rule","ticks"];const boxPlotNormalizer=new CompositeMarkNormalizer(BOXPLOT,normalizeBoxPlot);function getBoxPlotType(extent){if(isNumber$1(extent)){return"tukey"}return extent}function normalizeBoxPlot(spec,{config:config}){spec={...spec,encoding:normalizeEncoding(spec.encoding,config)};const{mark:mark,encoding:_encoding,params:params,projection:_p,...outerSpec}=spec;const markDef=isMarkDef(mark)?mark:{type:mark};if(params){warn(selectionNotSupported("boxplot"))}const extent=markDef.extent??config.boxplot.extent;const sizeValue=getMarkPropOrConfig("size",markDef,config);const invalid=markDef.invalid;const boxPlotType=getBoxPlotType(extent);const{bins:bins,timeUnits:timeUnits,transform:transform,continuousAxisChannelDef:continuousAxisChannelDef,continuousAxis:continuousAxis,groupby:groupby,aggregate:aggregate,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis,ticksOrient:ticksOrient,boxOrient:boxOrient,customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField}=boxParams(spec,extent,config);const aliasedFieldName=removePathFromField(continuousAxisChannelDef.field);const{color:color,size:size,...encodingWithoutSizeColorAndContinuousAxis}=encodingWithoutContinuousAxis;const makeBoxPlotPart=sharedEncoding=>makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,sharedEncoding,config.boxplot);const makeBoxPlotExtent=makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);const makeBoxPlotBox=makeBoxPlotPart(encodingWithoutContinuousAxis);const defaultBoxColor=(isObject(config.boxplot.box)?config.boxplot.box.color:config.mark.color)||"#4c78a8";const makeBoxPlotMidTick=makeBoxPlotPart({...encodingWithoutSizeColorAndContinuousAxis,...size?{size:size}:{},color:{condition:{test:`datum['lower_box_${continuousAxisChannelDef.field}'] >= datum['upper_box_${continuousAxisChannelDef.field}']`,...color||{value:defaultBoxColor}}}});const fiveSummaryTooltipEncoding=getCompositeMarkTooltip([{fieldPrefix:boxPlotType==="min-max"?"upper_whisker_":"max_",titlePrefix:"Max"},{fieldPrefix:"upper_box_",titlePrefix:"Q3"},{fieldPrefix:"mid_box_",titlePrefix:"Median"},{fieldPrefix:"lower_box_",titlePrefix:"Q1"},{fieldPrefix:boxPlotType==="min-max"?"lower_whisker_":"min_",titlePrefix:"Min"}],continuousAxisChannelDef,encodingWithoutContinuousAxis);const endTick={type:"tick",color:"black",opacity:1,orient:ticksOrient,invalid:invalid,aria:false};const whiskerTooltipEncoding=boxPlotType==="min-max"?fiveSummaryTooltipEncoding:getCompositeMarkTooltip([{fieldPrefix:"upper_whisker_",titlePrefix:"Upper Whisker"},{fieldPrefix:"lower_whisker_",titlePrefix:"Lower Whisker"}],continuousAxisChannelDef,encodingWithoutContinuousAxis);const whiskerLayers=[...makeBoxPlotExtent({partName:"rule",mark:{type:"rule",invalid:invalid,aria:false},positionPrefix:"lower_whisker",endPositionPrefix:"lower_box",extraEncoding:whiskerTooltipEncoding}),...makeBoxPlotExtent({partName:"rule",mark:{type:"rule",invalid:invalid,aria:false},positionPrefix:"upper_box",endPositionPrefix:"upper_whisker",extraEncoding:whiskerTooltipEncoding}),...makeBoxPlotExtent({partName:"ticks",mark:endTick,positionPrefix:"lower_whisker",extraEncoding:whiskerTooltipEncoding}),...makeBoxPlotExtent({partName:"ticks",mark:endTick,positionPrefix:"upper_whisker",extraEncoding:whiskerTooltipEncoding})];const boxLayers=[...boxPlotType!=="tukey"?whiskerLayers:[],...makeBoxPlotBox({partName:"box",mark:{type:"bar",...sizeValue?{size:sizeValue}:{},orient:boxOrient,invalid:invalid,ariaRoleDescription:"box"},positionPrefix:"lower_box",endPositionPrefix:"upper_box",extraEncoding:fiveSummaryTooltipEncoding}),...makeBoxPlotMidTick({partName:"median",mark:{type:"tick",invalid:invalid,...isObject(config.boxplot.median)&&config.boxplot.median.color?{color:config.boxplot.median.color}:{},...sizeValue?{size:sizeValue}:{},orient:ticksOrient,aria:false},positionPrefix:"mid_box",extraEncoding:fiveSummaryTooltipEncoding})];if(boxPlotType==="min-max"){return{...outerSpec,transform:(outerSpec.transform??[]).concat(transform),layer:boxLayers}}const lowerBoxExpr=`datum["lower_box_${continuousAxisChannelDef.field}"]`;const upperBoxExpr=`datum["upper_box_${continuousAxisChannelDef.field}"]`;const iqrExpr=`(${upperBoxExpr} - ${lowerBoxExpr})`;const lowerWhiskerExpr=`${lowerBoxExpr} - ${extent} * ${iqrExpr}`;const upperWhiskerExpr=`${upperBoxExpr} + ${extent} * ${iqrExpr}`;const fieldExpr=`datum["${continuousAxisChannelDef.field}"]`;const joinaggregateTransform={joinaggregate:boxParamsQuartiles(continuousAxisChannelDef.field),groupby:groupby};const filteredWhiskerSpec={transform:[{filter:`(${lowerWhiskerExpr} <= ${fieldExpr}) && (${fieldExpr} <= ${upperWhiskerExpr})`},{aggregate:[{op:"min",field:continuousAxisChannelDef.field,as:`lower_whisker_${aliasedFieldName}`},{op:"max",field:continuousAxisChannelDef.field,as:`upper_whisker_${aliasedFieldName}`},{op:"min",field:`lower_box_${continuousAxisChannelDef.field}`,as:`lower_box_${aliasedFieldName}`},{op:"max",field:`upper_box_${continuousAxisChannelDef.field}`,as:`upper_box_${aliasedFieldName}`},...aggregate],groupby:groupby}],layer:whiskerLayers};const{tooltip:tooltip,...encodingWithoutSizeColorContinuousAxisAndTooltip}=encodingWithoutSizeColorAndContinuousAxis;const{scale:scale,axis:axis}=continuousAxisChannelDef;const title=getTitle(continuousAxisChannelDef);const axisWithoutTitle=omit(axis,["title"]);const outlierLayersMixins=partLayerMixins(markDef,"outliers",config.boxplot,{transform:[{filter:`(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})`}],mark:"point",encoding:{[continuousAxis]:{field:continuousAxisChannelDef.field,type:continuousAxisChannelDef.type,...title!==undefined?{title:title}:{},...scale!==undefined?{scale:scale}:{},...isEmpty(axisWithoutTitle)?{}:{axis:axisWithoutTitle}},...encodingWithoutSizeColorContinuousAxisAndTooltip,...color?{color:color}:{},...customTooltipWithoutAggregatedField?{tooltip:customTooltipWithoutAggregatedField}:{}}})[0];let filteredLayersMixins;const filteredLayersMixinsTransforms=[...bins,...timeUnits,joinaggregateTransform];if(outlierLayersMixins){filteredLayersMixins={transform:filteredLayersMixinsTransforms,layer:[outlierLayersMixins,filteredWhiskerSpec]}}else{filteredLayersMixins=filteredWhiskerSpec;filteredLayersMixins.transform.unshift(...filteredLayersMixinsTransforms)}return{...outerSpec,layer:[filteredLayersMixins,{transform:transform,layer:boxLayers}]}}function boxParamsQuartiles(continousAxisField){const aliasedFieldName=removePathFromField(continousAxisField);return[{op:"q1",field:continousAxisField,as:`lower_box_${aliasedFieldName}`},{op:"q3",field:continousAxisField,as:`upper_box_${aliasedFieldName}`}]}function boxParams(spec,extent,config){const orient=compositeMarkOrient(spec,BOXPLOT);const{continuousAxisChannelDef:continuousAxisChannelDef,continuousAxis:continuousAxis}=compositeMarkContinuousAxis(spec,orient,BOXPLOT);const continuousFieldName=continuousAxisChannelDef.field;const aliasedFieldName=removePathFromField(continuousFieldName);const boxPlotType=getBoxPlotType(extent);const boxplotSpecificAggregate=[...boxParamsQuartiles(continuousFieldName),{op:"median",field:continuousFieldName,as:`mid_box_${aliasedFieldName}`},{op:"min",field:continuousFieldName,as:(boxPlotType==="min-max"?"lower_whisker_":"min_")+aliasedFieldName},{op:"max",field:continuousFieldName,as:(boxPlotType==="min-max"?"upper_whisker_":"max_")+aliasedFieldName}];const postAggregateCalculates=boxPlotType==="min-max"||boxPlotType==="tukey"?[]:[{calculate:`datum["upper_box_${aliasedFieldName}"] - datum["lower_box_${aliasedFieldName}"]`,as:`iqr_${aliasedFieldName}`},{calculate:`min(datum["upper_box_${aliasedFieldName}"] + datum["iqr_${aliasedFieldName}"] * ${extent}, datum["max_${aliasedFieldName}"])`,as:`upper_whisker_${aliasedFieldName}`},{calculate:`max(datum["lower_box_${aliasedFieldName}"] - datum["iqr_${aliasedFieldName}"] * ${extent}, datum["min_${aliasedFieldName}"])`,as:`lower_whisker_${aliasedFieldName}`}];const{[continuousAxis]:oldContinuousAxisChannelDef,...oldEncodingWithoutContinuousAxis}=spec.encoding;const{customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField,filteredEncoding:filteredEncoding}=filterTooltipWithAggregatedField(oldEncodingWithoutContinuousAxis);const{bins:bins,timeUnits:timeUnits,aggregate:aggregate,groupby:groupby,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(filteredEncoding,config);const ticksOrient=orient==="vertical"?"horizontal":"vertical";const boxOrient=orient;const transform=[...bins,...timeUnits,{aggregate:[...aggregate,...boxplotSpecificAggregate],groupby:groupby},...postAggregateCalculates];return{bins:bins,timeUnits:timeUnits,transform:transform,groupby:groupby,aggregate:aggregate,continuousAxisChannelDef:continuousAxisChannelDef,continuousAxis:continuousAxis,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis,ticksOrient:ticksOrient,boxOrient:boxOrient,customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField}}const ERRORBAR="errorbar";const ERRORBAR_PARTS=["ticks","rule"];const errorBarNormalizer=new CompositeMarkNormalizer(ERRORBAR,normalizeErrorBar);function normalizeErrorBar(spec,{config:config}){spec={...spec,encoding:normalizeEncoding(spec.encoding,config)};const{transform:transform,continuousAxisChannelDef:continuousAxisChannelDef,continuousAxis:continuousAxis,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis,ticksOrient:ticksOrient,markDef:markDef,outerSpec:outerSpec,tooltipEncoding:tooltipEncoding}=errorBarParams(spec,ERRORBAR,config);delete encodingWithoutContinuousAxis.size;const makeErrorBarPart=makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,config.errorbar);const thickness=markDef.thickness;const size=markDef.size;const tick={type:"tick",orient:ticksOrient,aria:false,...thickness!==undefined?{thickness:thickness}:{},...size!==undefined?{size:size}:{}};const layer=[...makeErrorBarPart({partName:"ticks",mark:tick,positionPrefix:"lower",extraEncoding:tooltipEncoding}),...makeErrorBarPart({partName:"ticks",mark:tick,positionPrefix:"upper",extraEncoding:tooltipEncoding}),...makeErrorBarPart({partName:"rule",mark:{type:"rule",ariaRoleDescription:"errorbar",...thickness!==undefined?{size:thickness}:{}},positionPrefix:"lower",endPositionPrefix:"upper",extraEncoding:tooltipEncoding})];return{...outerSpec,transform:transform,...layer.length>1?{layer:layer}:{...layer[0]}}}function errorBarOrientAndInputType(spec,compositeMark){const{encoding:encoding}=spec;if(errorBarIsInputTypeRaw(encoding)){return{orient:compositeMarkOrient(spec,compositeMark),inputType:"raw"}}const isTypeAggregatedUpperLower=errorBarIsInputTypeAggregatedUpperLower(encoding);const isTypeAggregatedError=errorBarIsInputTypeAggregatedError(encoding);const x=encoding.x;const y=encoding.y;if(isTypeAggregatedUpperLower){if(isTypeAggregatedError){throw new Error(`${compositeMark} cannot be both type aggregated-upper-lower and aggregated-error`)}const x2=encoding.x2;const y2=encoding.y2;if(isFieldOrDatumDef(x2)&&isFieldOrDatumDef(y2)){throw new Error(`${compositeMark} cannot have both x2 and y2`)}else if(isFieldOrDatumDef(x2)){if(isContinuousFieldOrDatumDef(x)){return{orient:"horizontal",inputType:"aggregated-upper-lower"}}else{throw new Error(`Both x and x2 have to be quantitative in ${compositeMark}`)}}else if(isFieldOrDatumDef(y2)){if(isContinuousFieldOrDatumDef(y)){return{orient:"vertical",inputType:"aggregated-upper-lower"}}else{throw new Error(`Both y and y2 have to be quantitative in ${compositeMark}`)}}throw new Error("No ranged axis")}else{const xError=encoding.xError;const xError2=encoding.xError2;const yError=encoding.yError;const yError2=encoding.yError2;if(isFieldOrDatumDef(xError2)&&!isFieldOrDatumDef(xError)){throw new Error(`${compositeMark} cannot have xError2 without xError`)}if(isFieldOrDatumDef(yError2)&&!isFieldOrDatumDef(yError)){throw new Error(`${compositeMark} cannot have yError2 without yError`)}if(isFieldOrDatumDef(xError)&&isFieldOrDatumDef(yError)){throw new Error(`${compositeMark} cannot have both xError and yError with both are quantiative`)}else if(isFieldOrDatumDef(xError)){if(isContinuousFieldOrDatumDef(x)){return{orient:"horizontal",inputType:"aggregated-error"}}else{throw new Error("All x, xError, and xError2 (if exist) have to be quantitative")}}else if(isFieldOrDatumDef(yError)){if(isContinuousFieldOrDatumDef(y)){return{orient:"vertical",inputType:"aggregated-error"}}else{throw new Error("All y, yError, and yError2 (if exist) have to be quantitative")}}throw new Error("No ranged axis")}}function errorBarIsInputTypeRaw(encoding){return(isFieldOrDatumDef(encoding.x)||isFieldOrDatumDef(encoding.y))&&!isFieldOrDatumDef(encoding.x2)&&!isFieldOrDatumDef(encoding.y2)&&!isFieldOrDatumDef(encoding.xError)&&!isFieldOrDatumDef(encoding.xError2)&&!isFieldOrDatumDef(encoding.yError)&&!isFieldOrDatumDef(encoding.yError2)}function errorBarIsInputTypeAggregatedUpperLower(encoding){return isFieldOrDatumDef(encoding.x2)||isFieldOrDatumDef(encoding.y2)}function errorBarIsInputTypeAggregatedError(encoding){return isFieldOrDatumDef(encoding.xError)||isFieldOrDatumDef(encoding.xError2)||isFieldOrDatumDef(encoding.yError)||isFieldOrDatumDef(encoding.yError2)}function errorBarParams(spec,compositeMark,config){const{mark:mark,encoding:encoding,params:params,projection:_p,...outerSpec}=spec;const markDef=isMarkDef(mark)?mark:{type:mark};if(params){warn(selectionNotSupported(compositeMark))}const{orient:orient,inputType:inputType}=errorBarOrientAndInputType(spec,compositeMark);const{continuousAxisChannelDef:continuousAxisChannelDef,continuousAxisChannelDef2:continuousAxisChannelDef2,continuousAxisChannelDefError:continuousAxisChannelDefError,continuousAxisChannelDefError2:continuousAxisChannelDefError2,continuousAxis:continuousAxis}=compositeMarkContinuousAxis(spec,orient,compositeMark);const{errorBarSpecificAggregate:errorBarSpecificAggregate,postAggregateCalculates:postAggregateCalculates,tooltipSummary:tooltipSummary,tooltipTitleWithFieldName:tooltipTitleWithFieldName}=errorBarAggregationAndCalculation(markDef,continuousAxisChannelDef,continuousAxisChannelDef2,continuousAxisChannelDefError,continuousAxisChannelDefError2,inputType,compositeMark,config);const{[continuousAxis]:oldContinuousAxisChannelDef,[continuousAxis==="x"?"x2":"y2"]:oldContinuousAxisChannelDef2,[continuousAxis==="x"?"xError":"yError"]:oldContinuousAxisChannelDefError,[continuousAxis==="x"?"xError2":"yError2"]:oldContinuousAxisChannelDefError2,...oldEncodingWithoutContinuousAxis}=encoding;const{bins:bins,timeUnits:timeUnits,aggregate:oldAggregate,groupby:oldGroupBy,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis,config);const aggregate=[...oldAggregate,...errorBarSpecificAggregate];const groupby=inputType!=="raw"?[]:oldGroupBy;const tooltipEncoding=getCompositeMarkTooltip(tooltipSummary,continuousAxisChannelDef,encodingWithoutContinuousAxis,tooltipTitleWithFieldName);return{transform:[...outerSpec.transform??[],...bins,...timeUnits,...aggregate.length===0?[]:[{aggregate:aggregate,groupby:groupby}],...postAggregateCalculates],groupby:groupby,continuousAxisChannelDef:continuousAxisChannelDef,continuousAxis:continuousAxis,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis,ticksOrient:orient==="vertical"?"horizontal":"vertical",markDef:markDef,outerSpec:outerSpec,tooltipEncoding:tooltipEncoding}}function errorBarAggregationAndCalculation(markDef,continuousAxisChannelDef,continuousAxisChannelDef2,continuousAxisChannelDefError,continuousAxisChannelDefError2,inputType,compositeMark,config){let errorBarSpecificAggregate=[];let postAggregateCalculates=[];const continuousFieldName=continuousAxisChannelDef.field;let tooltipSummary;let tooltipTitleWithFieldName=false;if(inputType==="raw"){const center=markDef.center?markDef.center:markDef.extent?markDef.extent==="iqr"?"median":"mean":config.errorbar.center;const extent=markDef.extent?markDef.extent:center==="mean"?"stderr":"iqr";if(center==="median"!==(extent==="iqr")){warn(errorBarCenterIsUsedWithWrongExtent(center,extent,compositeMark))}if(extent==="stderr"||extent==="stdev"){errorBarSpecificAggregate=[{op:extent,field:continuousFieldName,as:`extent_${continuousFieldName}`},{op:center,field:continuousFieldName,as:`center_${continuousFieldName}`}];postAggregateCalculates=[{calculate:`datum["center_${continuousFieldName}"] + datum["extent_${continuousFieldName}"]`,as:`upper_${continuousFieldName}`},{calculate:`datum["center_${continuousFieldName}"] - datum["extent_${continuousFieldName}"]`,as:`lower_${continuousFieldName}`}];tooltipSummary=[{fieldPrefix:"center_",titlePrefix:titleCase(center)},{fieldPrefix:"upper_",titlePrefix:getTitlePrefix(center,extent,"+")},{fieldPrefix:"lower_",titlePrefix:getTitlePrefix(center,extent,"-")}];tooltipTitleWithFieldName=true}else{let centerOp;let lowerExtentOp;let upperExtentOp;if(extent==="ci"){centerOp="mean";lowerExtentOp="ci0";upperExtentOp="ci1"}else{centerOp="median";lowerExtentOp="q1";upperExtentOp="q3"}errorBarSpecificAggregate=[{op:lowerExtentOp,field:continuousFieldName,as:`lower_${continuousFieldName}`},{op:upperExtentOp,field:continuousFieldName,as:`upper_${continuousFieldName}`},{op:centerOp,field:continuousFieldName,as:`center_${continuousFieldName}`}];tooltipSummary=[{fieldPrefix:"upper_",titlePrefix:title({field:continuousFieldName,aggregate:upperExtentOp,type:"quantitative"},config,{allowDisabling:false})},{fieldPrefix:"lower_",titlePrefix:title({field:continuousFieldName,aggregate:lowerExtentOp,type:"quantitative"},config,{allowDisabling:false})},{fieldPrefix:"center_",titlePrefix:title({field:continuousFieldName,aggregate:centerOp,type:"quantitative"},config,{allowDisabling:false})}]}}else{if(markDef.center||markDef.extent){warn(errorBarCenterAndExtentAreNotNeeded(markDef.center,markDef.extent))}if(inputType==="aggregated-upper-lower"){tooltipSummary=[];postAggregateCalculates=[{calculate:`datum["${continuousAxisChannelDef2.field}"]`,as:`upper_${continuousFieldName}`},{calculate:`datum["${continuousFieldName}"]`,as:`lower_${continuousFieldName}`}]}else if(inputType==="aggregated-error"){tooltipSummary=[{fieldPrefix:"",titlePrefix:continuousFieldName}];postAggregateCalculates=[{calculate:`datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError.field}"]`,as:`upper_${continuousFieldName}`}];if(continuousAxisChannelDefError2){postAggregateCalculates.push({calculate:`datum["${continuousFieldName}"] + datum["${continuousAxisChannelDefError2.field}"]`,as:`lower_${continuousFieldName}`})}else{postAggregateCalculates.push({calculate:`datum["${continuousFieldName}"] - datum["${continuousAxisChannelDefError.field}"]`,as:`lower_${continuousFieldName}`})}}for(const postAggregateCalculate of postAggregateCalculates){tooltipSummary.push({fieldPrefix:postAggregateCalculate.as.substring(0,6),titlePrefix:replaceAll(replaceAll(postAggregateCalculate.calculate,'datum["',""),'"]',"")})}}return{postAggregateCalculates:postAggregateCalculates,errorBarSpecificAggregate:errorBarSpecificAggregate,tooltipSummary:tooltipSummary,tooltipTitleWithFieldName:tooltipTitleWithFieldName}}function getTitlePrefix(center,extent,operation){return`${titleCase(center)} ${operation} ${extent}`}const ERRORBAND="errorband";const ERRORBAND_PARTS=["band","borders"];const errorBandNormalizer=new CompositeMarkNormalizer(ERRORBAND,normalizeErrorBand);function normalizeErrorBand(spec,{config:config}){spec={...spec,encoding:normalizeEncoding(spec.encoding,config)};const{transform:transform,continuousAxisChannelDef:continuousAxisChannelDef,continuousAxis:continuousAxis,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis,markDef:markDef,outerSpec:outerSpec,tooltipEncoding:tooltipEncoding}=errorBarParams(spec,ERRORBAND,config);const errorBandDef=markDef;const makeErrorBandPart=makeCompositeAggregatePartFactory(errorBandDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,config.errorband);const is2D=spec.encoding.x!==undefined&&spec.encoding.y!==undefined;let bandMark={type:is2D?"area":"rect"};let bordersMark={type:is2D?"line":"rule"};const interpolate={...errorBandDef.interpolate?{interpolate:errorBandDef.interpolate}:{},...errorBandDef.tension&&errorBandDef.interpolate?{tension:errorBandDef.tension}:{}};if(is2D){bandMark={...bandMark,...interpolate,ariaRoleDescription:"errorband"};bordersMark={...bordersMark,...interpolate,aria:false}}else if(errorBandDef.interpolate){warn(errorBand1DNotSupport("interpolate"))}else if(errorBandDef.tension){warn(errorBand1DNotSupport("tension"))}return{...outerSpec,transform:transform,layer:[...makeErrorBandPart({partName:"band",mark:bandMark,positionPrefix:"lower",endPositionPrefix:"upper",extraEncoding:tooltipEncoding}),...makeErrorBandPart({partName:"borders",mark:bordersMark,positionPrefix:"lower",extraEncoding:tooltipEncoding}),...makeErrorBandPart({partName:"borders",mark:bordersMark,positionPrefix:"upper",extraEncoding:tooltipEncoding})]}}const compositeMarkRegistry={};function add(mark,run,parts){const normalizer=new CompositeMarkNormalizer(mark,run);compositeMarkRegistry[mark]={normalizer:normalizer,parts:parts}}function getAllCompositeMarks(){return keys(compositeMarkRegistry)}add(BOXPLOT,normalizeBoxPlot,BOXPLOT_PARTS);add(ERRORBAR,normalizeErrorBar,ERRORBAR_PARTS);add(ERRORBAND,normalizeErrorBand,ERRORBAND_PARTS);const VL_ONLY_LEGEND_CONFIG=["gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","unselectedOpacity"];const HEADER_TITLE_PROPERTIES_MAP={titleAlign:"align",titleAnchor:"anchor",titleAngle:"angle",titleBaseline:"baseline",titleColor:"color",titleFont:"font",titleFontSize:"fontSize",titleFontStyle:"fontStyle",titleFontWeight:"fontWeight",titleLimit:"limit",titleLineHeight:"lineHeight",titleOrient:"orient",titlePadding:"offset"};const HEADER_LABEL_PROPERTIES_MAP={labelAlign:"align",labelAnchor:"anchor",labelAngle:"angle",labelBaseline:"baseline",labelColor:"color",labelFont:"font",labelFontSize:"fontSize",labelFontStyle:"fontStyle",labelFontWeight:"fontWeight",labelLimit:"limit",labelLineHeight:"lineHeight",labelOrient:"orient",labelPadding:"offset"};const HEADER_TITLE_PROPERTIES=keys(HEADER_TITLE_PROPERTIES_MAP);const HEADER_LABEL_PROPERTIES=keys(HEADER_LABEL_PROPERTIES_MAP);const HEADER_CONFIGS_INDEX={header:1,headerRow:1,headerColumn:1,headerFacet:1};const HEADER_CONFIGS=keys(HEADER_CONFIGS_INDEX);const LEGEND_SCALE_CHANNELS=["size","shape","fill","stroke","strokeDash","strokeWidth","opacity"];const defaultLegendConfig={gradientHorizontalMaxLength:200,gradientHorizontalMinLength:100,gradientVerticalMaxLength:200,gradientVerticalMinLength:64,unselectedOpacity:.35};const COMMON_LEGEND_PROPERTY_INDEX={aria:1,clipHeight:1,columnPadding:1,columns:1,cornerRadius:1,description:1,direction:1,fillColor:1,format:1,formatType:1,gradientLength:1,gradientOpacity:1,gradientStrokeColor:1,gradientStrokeWidth:1,gradientThickness:1,gridAlign:1,labelAlign:1,labelBaseline:1,labelColor:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,labelLimit:1,labelOffset:1,labelOpacity:1,labelOverlap:1,labelPadding:1,labelSeparation:1,legendX:1,legendY:1,offset:1,orient:1,padding:1,rowPadding:1,strokeColor:1,symbolDash:1,symbolDashOffset:1,symbolFillColor:1,symbolLimit:1,symbolOffset:1,symbolOpacity:1,symbolSize:1,symbolStrokeColor:1,symbolStrokeWidth:1,symbolType:1,tickCount:1,tickMinStep:1,title:1,titleAlign:1,titleAnchor:1,titleBaseline:1,titleColor:1,titleFont:1,titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,titleOpacity:1,titleOrient:1,titlePadding:1,type:1,values:1,zindex:1};const SELECTION_ID="_vgsid_";const defaultConfig$1={point:{on:"click",fields:[SELECTION_ID],toggle:"event.shiftKey",resolve:"global",clear:"dblclick"},interval:{on:"[pointerdown, window:pointerup] > window:pointermove!",encodings:["x","y"],translate:"[pointerdown, window:pointerup] > window:pointermove!",zoom:"wheel!",mark:{fill:"#333",fillOpacity:.125,stroke:"white"},resolve:"global",clear:"dblclick"}};function isLegendBinding(bind){return bind==="legend"||!!bind?.legend}function isLegendStreamBinding(bind){return isLegendBinding(bind)&&isObject(bind)}function isSelectionParameter(param){return!!param?.["select"]}function assembleParameterSignals(params){const signals=[];for(const param of params||[]){if(isSelectionParameter(param))continue;const{expr:expr,bind:bind,...rest}=param;if(bind&&expr){const signal={...rest,bind:bind,init:expr};signals.push(signal)}else{const signal={...rest,...expr?{update:expr}:{},...bind?{bind:bind}:{}};signals.push(signal)}}return signals}function isAnyConcatSpec(spec){return isVConcatSpec(spec)||isHConcatSpec(spec)||isConcatSpec(spec)}function isConcatSpec(spec){return hasProperty(spec,"concat")}function isVConcatSpec(spec){return hasProperty(spec,"vconcat")}function isHConcatSpec(spec){return hasProperty(spec,"hconcat")}function getStepFor({step:step,offsetIsDiscrete:offsetIsDiscrete}){if(offsetIsDiscrete){return step.for??"offset"}else{return"position"}}function isStep(size){return hasProperty(size,"step")}function isFrameMixins(o){return hasProperty(o,"view")||hasProperty(o,"width")||hasProperty(o,"height")}const DEFAULT_SPACING=20;const COMPOSITION_LAYOUT_INDEX={align:1,bounds:1,center:1,columns:1,spacing:1};const COMPOSITION_LAYOUT_PROPERTIES=keys(COMPOSITION_LAYOUT_INDEX);function extractCompositionLayout(spec,specType,config){const compositionConfig=config[specType];const layout={};const{spacing:spacingConfig,columns:columns}=compositionConfig;if(spacingConfig!==undefined){layout.spacing=spacingConfig}if(columns!==undefined){if(isFacetSpec(spec)&&!isFacetMapping(spec.facet)||isConcatSpec(spec)){layout.columns=columns}}if(isVConcatSpec(spec)){layout.columns=1}for(const prop of COMPOSITION_LAYOUT_PROPERTIES){if(spec[prop]!==undefined){if(prop==="spacing"){const spacing=spec[prop];layout[prop]=isNumber$1(spacing)?spacing:{row:spacing.row??spacingConfig,column:spacing.column??spacingConfig}}else{layout[prop]=spec[prop]}}}return layout}function getViewConfigContinuousSize(viewConfig,channel){return viewConfig[channel]??viewConfig[channel==="width"?"continuousWidth":"continuousHeight"]}function getViewConfigDiscreteStep(viewConfig,channel){const size=getViewConfigDiscreteSize(viewConfig,channel);return isStep(size)?size.step:DEFAULT_STEP}function getViewConfigDiscreteSize(viewConfig,channel){const size=viewConfig[channel]??viewConfig[channel==="width"?"discreteWidth":"discreteHeight"];return getFirstDefined(size,{step:viewConfig.step})}const DEFAULT_STEP=20;const defaultViewConfig={continuousWidth:200,continuousHeight:200,step:DEFAULT_STEP};const defaultConfig={background:"white",padding:5,timeFormat:"%b %d, %Y",countTitle:"Count of Records",view:defaultViewConfig,mark:defaultMarkConfig,arc:{},area:{},bar:defaultBarConfig,circle:{},geoshape:{},image:{},line:{},point:{},rect:defaultRectConfig,rule:{color:"black"},square:{},text:{color:"black"},tick:defaultTickConfig,trail:{},boxplot:{size:14,extent:1.5,box:{},median:{color:"white"},outliers:{},rule:{},ticks:null},errorbar:{center:"mean",rule:true,ticks:false},errorband:{band:{opacity:.3},borders:false},scale:defaultScaleConfig,projection:{},legend:defaultLegendConfig,header:{titlePadding:10,labelPadding:10},headerColumn:{},headerRow:{},headerFacet:{},selection:defaultConfig$1,style:{},title:{},facet:{spacing:DEFAULT_SPACING},concat:{spacing:DEFAULT_SPACING},normalizedNumberFormat:".0%"};const tab10=["#4c78a8","#f58518","#e45756","#72b7b2","#54a24b","#eeca3b","#b279a2","#ff9da6","#9d755d","#bab0ac"];const DEFAULT_FONT_SIZE={text:11,guideLabel:10,guideTitle:11,groupTitle:13,groupSubtitle:12};const DEFAULT_COLOR={blue:tab10[0],orange:tab10[1],red:tab10[2],teal:tab10[3],green:tab10[4],yellow:tab10[5],purple:tab10[6],pink:tab10[7],brown:tab10[8],gray0:"#000",gray1:"#111",gray2:"#222",gray3:"#333",gray4:"#444",gray5:"#555",gray6:"#666",gray7:"#777",gray8:"#888",gray9:"#999",gray10:"#aaa",gray11:"#bbb",gray12:"#ccc",gray13:"#ddd",gray14:"#eee",gray15:"#fff"};function colorSignalConfig(color={}){return{signals:[{name:"color",value:isObject(color)?{...DEFAULT_COLOR,...color}:DEFAULT_COLOR}],mark:{color:{signal:"color.blue"}},rule:{color:{signal:"color.gray0"}},text:{color:{signal:"color.gray0"}},style:{"guide-label":{fill:{signal:"color.gray0"}},"guide-title":{fill:{signal:"color.gray0"}},"group-title":{fill:{signal:"color.gray0"}},"group-subtitle":{fill:{signal:"color.gray0"}},cell:{stroke:{signal:"color.gray8"}}},axis:{domainColor:{signal:"color.gray13"},gridColor:{signal:"color.gray8"},tickColor:{signal:"color.gray13"}},range:{category:[{signal:"color.blue"},{signal:"color.orange"},{signal:"color.red"},{signal:"color.teal"},{signal:"color.green"},{signal:"color.yellow"},{signal:"color.purple"},{signal:"color.pink"},{signal:"color.brown"},{signal:"color.grey8"}]}}}function fontSizeSignalConfig(fontSize){return{signals:[{name:"fontSize",value:isObject(fontSize)?{...DEFAULT_FONT_SIZE,...fontSize}:DEFAULT_FONT_SIZE}],text:{fontSize:{signal:"fontSize.text"}},style:{"guide-label":{fontSize:{signal:"fontSize.guideLabel"}},"guide-title":{fontSize:{signal:"fontSize.guideTitle"}},"group-title":{fontSize:{signal:"fontSize.groupTitle"}},"group-subtitle":{fontSize:{signal:"fontSize.groupSubtitle"}}}}}function fontConfig(font){return{text:{font:font},style:{"guide-label":{font:font},"guide-title":{font:font},"group-title":{font:font},"group-subtitle":{font:font}}}}function getAxisConfigInternal(axisConfig){const props=keys(axisConfig||{});const axisConfigInternal={};for(const prop of props){const val=axisConfig[prop];axisConfigInternal[prop]=isConditionalAxisValue(val)?signalOrValueRefWithCondition(val):signalRefOrValue(val)}return axisConfigInternal}function getStyleConfigInternal(styleConfig){const props=keys(styleConfig);const styleConfigInternal={};for(const prop of props){styleConfigInternal[prop]=getAxisConfigInternal(styleConfig[prop])}return styleConfigInternal}const configPropsWithExpr=[...MARK_CONFIGS,...AXIS_CONFIGS,...HEADER_CONFIGS,"background","padding","legend","lineBreak","scale","style","title","view"];function initConfig(specifiedConfig={}){const{color:color,font:font,fontSize:fontSize,selection:selection,...restConfig}=specifiedConfig;const mergedConfig=mergeConfig({},duplicate(defaultConfig),font?fontConfig(font):{},color?colorSignalConfig(color):{},fontSize?fontSizeSignalConfig(fontSize):{},restConfig||{});if(selection){writeConfig(mergedConfig,"selection",selection,true)}const outputConfig=omit(mergedConfig,configPropsWithExpr);for(const prop of["background","lineBreak","padding"]){if(mergedConfig[prop]){outputConfig[prop]=signalRefOrValue(mergedConfig[prop])}}for(const markConfigType of MARK_CONFIGS){if(mergedConfig[markConfigType]){outputConfig[markConfigType]=replaceExprRef(mergedConfig[markConfigType])}}for(const axisConfigType of AXIS_CONFIGS){if(mergedConfig[axisConfigType]){outputConfig[axisConfigType]=getAxisConfigInternal(mergedConfig[axisConfigType])}}for(const headerConfigType of HEADER_CONFIGS){if(mergedConfig[headerConfigType]){outputConfig[headerConfigType]=replaceExprRef(mergedConfig[headerConfigType])}}if(mergedConfig.legend){outputConfig.legend=replaceExprRef(mergedConfig.legend)}if(mergedConfig.scale){const{invalid:invalid,...otherScaleConfig}=mergedConfig.scale;const newScaleInvalid=replaceExprRef(invalid,{level:1});outputConfig.scale={...replaceExprRef(otherScaleConfig),...keys(newScaleInvalid).length>0?{invalid:newScaleInvalid}:{}}}if(mergedConfig.style){outputConfig.style=getStyleConfigInternal(mergedConfig.style)}if(mergedConfig.title){outputConfig.title=replaceExprRef(mergedConfig.title)}if(mergedConfig.view){outputConfig.view=replaceExprRef(mergedConfig.view)}return outputConfig}const MARK_STYLES=new Set(["view",...PRIMITIVE_MARKS]);const VL_ONLY_CONFIG_PROPERTIES=["color","fontSize","background","padding","facet","concat","numberFormat","numberFormatType","normalizedNumberFormat","normalizedNumberFormatType","timeFormat","countTitle","header","axisQuantitative","axisTemporal","axisDiscrete","axisPoint","axisXBand","axisXPoint","axisXDiscrete","axisXQuantitative","axisXTemporal","axisYBand","axisYPoint","axisYDiscrete","axisYQuantitative","axisYTemporal","scale","selection","overlay"];const VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX={view:["continuousWidth","continuousHeight","discreteWidth","discreteHeight","step"],...VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX};function stripAndRedirectConfig(config){config=duplicate(config);for(const prop of VL_ONLY_CONFIG_PROPERTIES){delete config[prop]}if(config.axis){for(const prop in config.axis){if(isConditionalAxisValue(config.axis[prop])){delete config.axis[prop]}}}if(config.legend){for(const prop of VL_ONLY_LEGEND_CONFIG){delete config.legend[prop]}}if(config.mark){for(const prop of VL_ONLY_MARK_CONFIG_PROPERTIES){delete config.mark[prop]}if(config.mark.tooltip&&isObject(config.mark.tooltip)){delete config.mark.tooltip}}if(config.params){config.signals=(config.signals||[]).concat(assembleParameterSignals(config.params));delete config.params}for(const markType of MARK_STYLES){for(const prop of VL_ONLY_MARK_CONFIG_PROPERTIES){delete config[markType][prop]}const vlOnlyMarkSpecificConfigs=VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType];if(vlOnlyMarkSpecificConfigs){for(const prop of vlOnlyMarkSpecificConfigs){delete config[markType][prop]}}redirectConfigToStyleConfig(config,markType)}for(const m of getAllCompositeMarks()){delete config[m]}redirectTitleConfig(config);for(const prop in config){if(isObject(config[prop])&&isEmpty(config[prop])){delete config[prop]}}return isEmpty(config)?undefined:config}function redirectTitleConfig(config){const{titleMarkConfig:titleMarkConfig,subtitleMarkConfig:subtitleMarkConfig,subtitle:subtitle}=extractTitleConfig(config.title);if(!isEmpty(titleMarkConfig)){config.style["group-title"]={...config.style["group-title"],...titleMarkConfig}}if(!isEmpty(subtitleMarkConfig)){config.style["group-subtitle"]={...config.style["group-subtitle"],...subtitleMarkConfig}}if(!isEmpty(subtitle)){config.title=subtitle}else{delete config.title}}function redirectConfigToStyleConfig(config,prop,toProp,compositeMarkPart){const propConfig=config[prop];if(prop==="view"){toProp="cell"}const style={...propConfig,...config.style[toProp??prop]};if(!isEmpty(style)){config.style[toProp??prop]=style}{delete config[prop]}}function isLayerSpec(spec){return hasProperty(spec,"layer")}function isRepeatSpec(spec){return hasProperty(spec,"repeat")}function isLayerRepeatSpec(spec){return!isArray(spec.repeat)&&hasProperty(spec.repeat,"layer")}class SpecMapper{map(spec,params){if(isFacetSpec(spec)){return this.mapFacet(spec,params)}else if(isRepeatSpec(spec)){return this.mapRepeat(spec,params)}else if(isHConcatSpec(spec)){return this.mapHConcat(spec,params)}else if(isVConcatSpec(spec)){return this.mapVConcat(spec,params)}else if(isConcatSpec(spec)){return this.mapConcat(spec,params)}else{return this.mapLayerOrUnit(spec,params)}}mapLayerOrUnit(spec,params){if(isLayerSpec(spec)){return this.mapLayer(spec,params)}else if(isUnitSpec(spec)){return this.mapUnit(spec,params)}throw new Error(invalidSpec(spec))}mapLayer(spec,params){return{...spec,layer:spec.layer.map((subspec=>this.mapLayerOrUnit(subspec,params)))}}mapHConcat(spec,params){return{...spec,hconcat:spec.hconcat.map((subspec=>this.map(subspec,params)))}}mapVConcat(spec,params){return{...spec,vconcat:spec.vconcat.map((subspec=>this.map(subspec,params)))}}mapConcat(spec,params){const{concat:concat,...rest}=spec;return{...rest,concat:concat.map((subspec=>this.map(subspec,params)))}}mapFacet(spec,params){return{...spec,spec:this.map(spec.spec,params)}}mapRepeat(spec,params){return{...spec,spec:this.map(spec.spec,params)}}}const STACK_OFFSET_INDEX={zero:1,center:1,normalize:1};function isStackOffset(s){return has$1(STACK_OFFSET_INDEX,s)}const STACKABLE_MARKS=new Set([ARC,BAR,AREA,RULE,POINT,CIRCLE,SQUARE,LINE,TEXT,TICK]);const STACK_BY_DEFAULT_MARKS=new Set([BAR,AREA,ARC]);function isUnbinnedQuantitative(channelDef){return isFieldDef(channelDef)&&channelDefType(channelDef)==="quantitative"&&!channelDef.bin}function potentialStackedChannel(encoding,x,{orient:orient,type:mark}){const y=x==="x"?"y":"radius";const isCartesianBarOrArea=x==="x"&&["bar","area"].includes(mark);const xDef=encoding[x];const yDef=encoding[y];if(isFieldDef(xDef)&&isFieldDef(yDef)){if(isUnbinnedQuantitative(xDef)&&isUnbinnedQuantitative(yDef)){if(xDef.stack){return x}else if(yDef.stack){return y}const xAggregate=isFieldDef(xDef)&&!!xDef.aggregate;const yAggregate=isFieldDef(yDef)&&!!yDef.aggregate;if(xAggregate!==yAggregate){return xAggregate?x:y}if(isCartesianBarOrArea){if(orient==="vertical"){return y}else if(orient==="horizontal"){return x}}}else if(isUnbinnedQuantitative(xDef)){return x}else if(isUnbinnedQuantitative(yDef)){return y}}else if(isUnbinnedQuantitative(xDef)){if(isCartesianBarOrArea&&orient==="vertical"){return undefined}return x}else if(isUnbinnedQuantitative(yDef)){if(isCartesianBarOrArea&&orient==="horizontal"){return undefined}return y}return undefined}function getDimensionChannel(channel){switch(channel){case"x":return"y";case"y":return"x";case"theta":return"radius";case"radius":return"theta"}}function stack(m,encoding){const markDef=isMarkDef(m)?m:{type:m};const mark=markDef.type;if(!STACKABLE_MARKS.has(mark)){return null}const fieldChannel=potentialStackedChannel(encoding,"x",markDef)||potentialStackedChannel(encoding,"theta",markDef);if(!fieldChannel){return null}const stackedFieldDef=encoding[fieldChannel];const stackedField=isFieldDef(stackedFieldDef)?vgField(stackedFieldDef,{}):undefined;const dimensionChannel=getDimensionChannel(fieldChannel);const groupbyChannels=[];const groupbyFields=new Set;if(encoding[dimensionChannel]){const dimensionDef=encoding[dimensionChannel];const dimensionField=isFieldDef(dimensionDef)?vgField(dimensionDef,{}):undefined;if(dimensionField&&dimensionField!==stackedField){groupbyChannels.push(dimensionChannel);groupbyFields.add(dimensionField)}}const dimensionOffsetChannel=dimensionChannel==="x"?"xOffset":"yOffset";const dimensionOffsetDef=encoding[dimensionOffsetChannel];const dimensionOffsetField=isFieldDef(dimensionOffsetDef)?vgField(dimensionOffsetDef,{}):undefined;if(dimensionOffsetField&&dimensionOffsetField!==stackedField){groupbyChannels.push(dimensionOffsetChannel);groupbyFields.add(dimensionOffsetField)}const stackBy=NONPOSITION_CHANNELS.reduce(((sc,channel)=>{if(channel!=="tooltip"&&channelHasField(encoding,channel)){const channelDef=encoding[channel];for(const cDef of array$5(channelDef)){const fieldDef=getFieldDef(cDef);if(fieldDef.aggregate){continue}const f=vgField(fieldDef,{});if(!f||!groupbyFields.has(f)){sc.push({channel:channel,fieldDef:fieldDef})}}}return sc}),[]);let offset;if(stackedFieldDef.stack!==undefined){if(isBoolean$2(stackedFieldDef.stack)){offset=stackedFieldDef.stack?"zero":null}else{offset=stackedFieldDef.stack}}else if(STACK_BY_DEFAULT_MARKS.has(mark)){offset="zero"}if(!offset||!isStackOffset(offset)){return null}if(isAggregate$1(encoding)&&stackBy.length===0){return null}if(stackedFieldDef?.scale?.type&&stackedFieldDef?.scale?.type!==ScaleType.LINEAR){if(stackedFieldDef?.stack){warn(stackNonLinearScale(stackedFieldDef.scale.type))}}if(isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)])){if(stackedFieldDef.stack!==undefined){warn(cannotStackRangedMark(fieldChannel))}return null}if(isFieldDef(stackedFieldDef)&&stackedFieldDef.aggregate&&!SUM_OPS.has(stackedFieldDef.aggregate)){warn(stackNonSummativeAggregate(stackedFieldDef.aggregate))}return{groupbyChannels:groupbyChannels,groupbyFields:groupbyFields,fieldChannel:fieldChannel,impute:stackedFieldDef.impute===null?false:isPathMark(mark),stackBy:stackBy,offset:offset}}function initMarkdef(originalMarkDef,encoding,config){const markDef=replaceExprRef(originalMarkDef);const specifiedOrient=getMarkPropOrConfig("orient",markDef,config);markDef.orient=orient(markDef.type,encoding,specifiedOrient);if(specifiedOrient!==undefined&&specifiedOrient!==markDef.orient){warn(orientOverridden(markDef.orient,specifiedOrient))}if(markDef.type==="bar"&&markDef.orient){const cornerRadiusEnd=getMarkPropOrConfig("cornerRadiusEnd",markDef,config);if(cornerRadiusEnd!==undefined){const newProps=markDef.orient==="horizontal"&&encoding.x2||markDef.orient==="vertical"&&encoding.y2?["cornerRadius"]:BAR_CORNER_RADIUS_INDEX[markDef.orient];for(const newProp of newProps){markDef[newProp]=cornerRadiusEnd}if(markDef.cornerRadiusEnd!==undefined){delete markDef.cornerRadiusEnd}}}const specifiedOpacity=getMarkPropOrConfig("opacity",markDef,config);const specifiedfillOpacity=getMarkPropOrConfig("fillOpacity",markDef,config);if(specifiedOpacity===undefined&&specifiedfillOpacity===undefined){markDef.opacity=opacity(markDef.type,encoding)}const specifiedCursor=getMarkPropOrConfig("cursor",markDef,config);if(specifiedCursor===undefined){markDef.cursor=cursor(markDef,encoding,config)}return markDef}function cursor(markDef,encoding,config){if(encoding.href||markDef.href||getMarkPropOrConfig("href",markDef,config)){return"pointer"}return markDef.cursor}function opacity(mark,encoding){if(contains([POINT,TICK,CIRCLE,SQUARE],mark)){if(!isAggregate$1(encoding)){return.7}}return undefined}function defaultFilled(markDef,config,{graticule:graticule}){if(graticule){return false}const filledConfig=getMarkConfig("filled",markDef,config);const mark=markDef.type;return getFirstDefined(filledConfig,mark!==POINT&&mark!==LINE&&mark!==RULE)}function orient(mark,encoding,specifiedOrient){switch(mark){case POINT:case CIRCLE:case SQUARE:case TEXT:case RECT:case IMAGE:return undefined}const{x:x,y:y,x2:x2,y2:y2}=encoding;switch(mark){case BAR:if(isFieldDef(x)&&(isBinned(x.bin)||isFieldDef(y)&&y.aggregate&&!x.aggregate)){return"vertical"}if(isFieldDef(y)&&(isBinned(y.bin)||isFieldDef(x)&&x.aggregate&&!y.aggregate)){return"horizontal"}if(y2||x2){if(specifiedOrient){return specifiedOrient}if(!x2){if(isFieldDef(x)&&x.type===QUANTITATIVE&&!isBinning(x.bin)||isNumericDataDef(x)){if(isFieldDef(y)&&isBinned(y.bin)){return"horizontal"}}return"vertical"}if(!y2){if(isFieldDef(y)&&y.type===QUANTITATIVE&&!isBinning(y.bin)||isNumericDataDef(y)){if(isFieldDef(x)&&isBinned(x.bin)){return"vertical"}}return"horizontal"}}case RULE:if(x2&&!(isFieldDef(x)&&isBinned(x.bin))&&y2&&!(isFieldDef(y)&&isBinned(y.bin))){return undefined}case AREA:if(y2){if(isFieldDef(y)&&isBinned(y.bin)){return"horizontal"}else{return"vertical"}}else if(x2){if(isFieldDef(x)&&isBinned(x.bin)){return"vertical"}else{return"horizontal"}}else if(mark===RULE){if(x&&!y){return"vertical"}else if(y&&!x){return"horizontal"}}case LINE:case TICK:{const xIsMeasure=isUnbinnedQuantitativeFieldOrDatumDef(x);const yIsMeasure=isUnbinnedQuantitativeFieldOrDatumDef(y);if(specifiedOrient){return specifiedOrient}else if(xIsMeasure&&!yIsMeasure){return mark!=="tick"?"horizontal":"vertical"}else if(!xIsMeasure&&yIsMeasure){return mark!=="tick"?"vertical":"horizontal"}else if(xIsMeasure&&yIsMeasure){return"vertical"}else{const xIsTemporal=isTypedFieldDef(x)&&x.type===TEMPORAL;const yIsTemporal=isTypedFieldDef(y)&&y.type===TEMPORAL;if(xIsTemporal&&!yIsTemporal){return"vertical"}else if(!xIsTemporal&&yIsTemporal){return"horizontal"}}return undefined}}return"vertical"}function dropLineAndPoint(markDef){const{point:_point,line:_line,...mark}=markDef;return keys(mark).length>1?mark:mark.type}function dropLineAndPointFromConfig(config){for(const mark of["line","area","rule","trail"]){if(config[mark]){config={...config,[mark]:omit(config[mark],["point","line"])}}}return config}function getPointOverlay(markDef,markConfig={},encoding){if(markDef.point==="transparent"){return{opacity:0}}else if(markDef.point){return isObject(markDef.point)?markDef.point:{}}else if(markDef.point!==undefined){return null}else{if(markConfig.point||encoding.shape){return isObject(markConfig.point)?markConfig.point:{}}return undefined}}function getLineOverlay(markDef,markConfig={}){if(markDef.line){return markDef.line===true?{}:markDef.line}else if(markDef.line!==undefined){return null}else{if(markConfig.line){return markConfig.line===true?{}:markConfig.line}return undefined}}class PathOverlayNormalizer{constructor(){this.name="path-overlay"}hasMatchingType(spec,config){if(isUnitSpec(spec)){const{mark:mark,encoding:encoding}=spec;const markDef=isMarkDef(mark)?mark:{type:mark};switch(markDef.type){case"line":case"rule":case"trail":return!!getPointOverlay(markDef,config[markDef.type],encoding);case"area":return!!getPointOverlay(markDef,config[markDef.type],encoding)||!!getLineOverlay(markDef,config[markDef.type])}}return false}run(spec,normParams,normalize){const{config:config}=normParams;const{params:params,projection:projection,mark:mark,name:name,encoding:e,...outerSpec}=spec;const encoding=normalizeEncoding(e,config);const markDef=isMarkDef(mark)?mark:{type:mark};const pointOverlay=getPointOverlay(markDef,config[markDef.type],encoding);const lineOverlay=markDef.type==="area"&&getLineOverlay(markDef,config[markDef.type]);const layer=[{name:name,...params?{params:params}:{},mark:dropLineAndPoint({...markDef.type==="area"&&markDef.opacity===undefined&&markDef.fillOpacity===undefined?{opacity:.7}:{},...markDef}),encoding:omit(encoding,["shape"])}];const stackProps=stack(initMarkdef(markDef,encoding,config),encoding);let overlayEncoding=encoding;if(stackProps){const{fieldChannel:stackFieldChannel,offset:offset}=stackProps;overlayEncoding={...encoding,[stackFieldChannel]:{...encoding[stackFieldChannel],...offset?{stack:offset}:{}}}}overlayEncoding=omit(overlayEncoding,["y2","x2"]);if(lineOverlay){layer.push({...projection?{projection:projection}:{},mark:{type:"line",...pick(markDef,["clip","interpolate","tension","tooltip"]),...lineOverlay},encoding:overlayEncoding})}if(pointOverlay){layer.push({...projection?{projection:projection}:{},mark:{type:"point",opacity:1,filled:true,...pick(markDef,["clip","tooltip"]),...pointOverlay},encoding:overlayEncoding})}return normalize({...outerSpec,layer:layer},{...normParams,config:dropLineAndPointFromConfig(config)})}}function replaceRepeaterInFacet(facet,repeater){if(!repeater){return facet}if(isFacetMapping(facet)){return replaceRepeaterInMapping(facet,repeater)}return replaceRepeaterInFieldDef(facet,repeater)}function replaceRepeaterInEncoding(encoding,repeater){if(!repeater){return encoding}return replaceRepeaterInMapping(encoding,repeater)}function replaceRepeatInProp(prop,o,repeater){const val=o[prop];if(isRepeatRef(val)){if(val.repeat in repeater){return{...o,[prop]:repeater[val.repeat]}}else{warn(noSuchRepeatedValue(val.repeat));return undefined}}return o}function replaceRepeaterInFieldDef(fieldDef,repeater){fieldDef=replaceRepeatInProp("field",fieldDef,repeater);if(fieldDef===undefined){return undefined}else if(fieldDef===null){return null}if(isSortableFieldDef(fieldDef)&&isSortField(fieldDef.sort)){const sort=replaceRepeatInProp("field",fieldDef.sort,repeater);fieldDef={...fieldDef,...sort?{sort:sort}:{}}}return fieldDef}function replaceRepeaterInFieldOrDatumDef(def,repeater){if(isFieldDef(def)){return replaceRepeaterInFieldDef(def,repeater)}else{const datumDef=replaceRepeatInProp("datum",def,repeater);if(datumDef!==def&&!datumDef.type){datumDef.type="nominal"}return datumDef}}function replaceRepeaterInChannelDef(channelDef,repeater){if(isFieldOrDatumDef(channelDef)){const fd=replaceRepeaterInFieldOrDatumDef(channelDef,repeater);if(fd){return fd}else if(isConditionalDef(channelDef)){return{condition:channelDef.condition}}}else{if(hasConditionalFieldOrDatumDef(channelDef)){const fd=replaceRepeaterInFieldOrDatumDef(channelDef.condition,repeater);if(fd){return{...channelDef,condition:fd}}else{const{condition:condition,...channelDefWithoutCondition}=channelDef;return channelDefWithoutCondition}}return channelDef}return undefined}function replaceRepeaterInMapping(mapping,repeater){const out={};for(const channel in mapping){if(hasProperty(mapping,channel)){const channelDef=mapping[channel];if(isArray(channelDef)){out[channel]=channelDef.map((cd=>replaceRepeaterInChannelDef(cd,repeater))).filter((cd=>cd))}else{const cd=replaceRepeaterInChannelDef(channelDef,repeater);if(cd!==undefined){out[channel]=cd}}}}return out}class RuleForRangedLineNormalizer{constructor(){this.name="RuleForRangedLine"}hasMatchingType(spec){if(isUnitSpec(spec)){const{encoding:encoding,mark:mark}=spec;if(mark==="line"||isMarkDef(mark)&&mark.type==="line"){for(const channel of SECONDARY_RANGE_CHANNEL){const mainChannel=getMainRangeChannel(channel);const mainChannelDef=encoding[mainChannel];if(encoding[channel]){if(isFieldDef(mainChannelDef)&&!isBinned(mainChannelDef.bin)||isDatumDef(mainChannelDef)){return true}}}}}return false}run(spec,params,normalize){const{encoding:encoding,mark:mark}=spec;warn(lineWithRange(!!encoding.x2,!!encoding.y2));return normalize({...spec,mark:isObject(mark)?{...mark,type:"rule"}:"rule"},params)}}class CoreNormalizer extends SpecMapper{constructor(){super(...arguments);this.nonFacetUnitNormalizers=[boxPlotNormalizer,errorBarNormalizer,errorBandNormalizer,new PathOverlayNormalizer,new RuleForRangedLineNormalizer]}map(spec,params){if(isUnitSpec(spec)){const hasRow=channelHasField(spec.encoding,ROW);const hasColumn=channelHasField(spec.encoding,COLUMN);const hasFacet=channelHasField(spec.encoding,FACET);if(hasRow||hasColumn||hasFacet){return this.mapFacetedUnit(spec,params)}}return super.map(spec,params)}mapUnit(spec,params){const{parentEncoding:parentEncoding,parentProjection:parentProjection}=params;const encoding=replaceRepeaterInEncoding(spec.encoding,params.repeater);const specWithReplacedEncoding={...spec,...spec.name?{name:[params.repeaterPrefix,spec.name].filter((n=>n)).join("_")}:{},...encoding?{encoding:encoding}:{}};if(parentEncoding||parentProjection){return this.mapUnitWithParentEncodingOrProjection(specWithReplacedEncoding,params)}const normalizeLayerOrUnit=this.mapLayerOrUnit.bind(this);for(const unitNormalizer of this.nonFacetUnitNormalizers){if(unitNormalizer.hasMatchingType(specWithReplacedEncoding,params.config)){return unitNormalizer.run(specWithReplacedEncoding,params,normalizeLayerOrUnit)}}return specWithReplacedEncoding}mapRepeat(spec,params){if(isLayerRepeatSpec(spec)){return this.mapLayerRepeat(spec,params)}else{return this.mapNonLayerRepeat(spec,params)}}mapLayerRepeat(spec,params){const{repeat:repeat,spec:childSpec,...rest}=spec;const{row:row,column:column,layer:layer}=repeat;const{repeater:repeater={},repeaterPrefix:repeaterPrefix=""}=params;if(row||column){return this.mapRepeat({...spec,repeat:{...row?{row:row}:{},...column?{column:column}:{}},spec:{repeat:{layer:layer},spec:childSpec}},params)}else{return{...rest,layer:layer.map((layerValue=>{const childRepeater={...repeater,layer:layerValue};const childName=`${(childSpec.name?`${childSpec.name}_`:"")+repeaterPrefix}child__layer_${varName(layerValue)}`;const child=this.mapLayerOrUnit(childSpec,{...params,repeater:childRepeater,repeaterPrefix:childName});child.name=childName;return child}))}}}mapNonLayerRepeat(spec,params){const{repeat:repeat,spec:childSpec,data:data,...remainingProperties}=spec;if(!isArray(repeat)&&spec.columns){spec=omit(spec,["columns"]);warn(columnsNotSupportByRowCol("repeat"))}const concat=[];const{repeater:repeater={},repeaterPrefix:repeaterPrefix=""}=params;const row=!isArray(repeat)&&repeat.row||[repeater?repeater.row:null];const column=!isArray(repeat)&&repeat.column||[repeater?repeater.column:null];const repeatValues=isArray(repeat)&&repeat||[repeater?repeater.repeat:null];for(const repeatValue of repeatValues){for(const rowValue of row){for(const columnValue of column){const childRepeater={repeat:repeatValue,row:rowValue,column:columnValue,layer:repeater.layer};const childName=(childSpec.name?`${childSpec.name}_`:"")+repeaterPrefix+"child__"+(isArray(repeat)?`${varName(repeatValue)}`:(repeat.row?`row_${varName(rowValue)}`:"")+(repeat.column?`column_${varName(columnValue)}`:""));const child=this.map(childSpec,{...params,repeater:childRepeater,repeaterPrefix:childName});child.name=childName;concat.push(omit(child,["data"]))}}}const columns=isArray(repeat)?spec.columns:repeat.column?repeat.column.length:1;return{data:childSpec.data??data,align:"all",...remainingProperties,columns:columns,concat:concat}}mapFacet(spec,params){const{facet:facet}=spec;if(isFacetMapping(facet)&&spec.columns){spec=omit(spec,["columns"]);warn(columnsNotSupportByRowCol("facet"))}return super.mapFacet(spec,params)}mapUnitWithParentEncodingOrProjection(spec,params){const{encoding:encoding,projection:projection}=spec;const{parentEncoding:parentEncoding,parentProjection:parentProjection,config:config}=params;const mergedProjection=mergeProjection({parentProjection:parentProjection,projection:projection});const mergedEncoding=mergeEncoding({parentEncoding:parentEncoding,encoding:replaceRepeaterInEncoding(encoding,params.repeater)});return this.mapUnit({...spec,...mergedProjection?{projection:mergedProjection}:{},...mergedEncoding?{encoding:mergedEncoding}:{}},{config:config})}mapFacetedUnit(spec,normParams){const{row:row,column:column,facet:facet,...encoding}=spec.encoding;const{mark:mark,width:width,projection:projection,height:height,view:view,params:params,encoding:_,...outerSpec}=spec;const{facetMapping:facetMapping,layout:layout}=this.getFacetMappingAndLayout({row:row,column:column,facet:facet},normParams);const newEncoding=replaceRepeaterInEncoding(encoding,normParams.repeater);return this.mapFacet({...outerSpec,...layout,facet:facetMapping,spec:{...width?{width:width}:{},...height?{height:height}:{},...view?{view:view}:{},...projection?{projection:projection}:{},mark:mark,encoding:newEncoding,...params?{params:params}:{}}},normParams)}getFacetMappingAndLayout(facets,params){const{row:row,column:column,facet:facet}=facets;if(row||column){if(facet){warn(facetChannelDropped([...row?[ROW]:[],...column?[COLUMN]:[]]))}const facetMapping={};const layout={};for(const channel of[ROW,COLUMN]){const def=facets[channel];if(def){const{align:align,center:center,spacing:spacing,columns:columns,...defWithoutLayout}=def;facetMapping[channel]=defWithoutLayout;for(const prop of["align","center","spacing"]){if(def[prop]!==undefined){layout[prop]??(layout[prop]={});layout[prop][channel]=def[prop]}}}}return{facetMapping:facetMapping,layout:layout}}else{const{align:align,center:center,spacing:spacing,columns:columns,...facetMapping}=facet;return{facetMapping:replaceRepeaterInFacet(facetMapping,params.repeater),layout:{...align?{align:align}:{},...center?{center:center}:{},...spacing?{spacing:spacing}:{},...columns?{columns:columns}:{}}}}}mapLayer(spec,{parentEncoding:parentEncoding,parentProjection:parentProjection,...otherParams}){const{encoding:encoding,projection:projection,...rest}=spec;const params={...otherParams,parentEncoding:mergeEncoding({parentEncoding:parentEncoding,encoding:encoding,layer:true}),parentProjection:mergeProjection({parentProjection:parentProjection,projection:projection})};return super.mapLayer({...rest,...spec.name?{name:[params.repeaterPrefix,spec.name].filter((n=>n)).join("_")}:{}},params)}}function mergeEncoding({parentEncoding:parentEncoding,encoding:encoding={},layer:layer}){let merged={};if(parentEncoding){const channels=new Set([...keys(parentEncoding),...keys(encoding)]);for(const channel of channels){const channelDef=encoding[channel];const parentChannelDef=parentEncoding[channel];if(isFieldOrDatumDef(channelDef)){const mergedChannelDef={...parentChannelDef,...channelDef};merged[channel]=mergedChannelDef}else if(hasConditionalFieldOrDatumDef(channelDef)){merged[channel]={...channelDef,condition:{...parentChannelDef,...channelDef.condition}}}else if(channelDef||channelDef===null){merged[channel]=channelDef}else if(layer||isValueDef(parentChannelDef)||isSignalRef(parentChannelDef)||isFieldOrDatumDef(parentChannelDef)||isArray(parentChannelDef)){merged[channel]=parentChannelDef}}}else{merged=encoding}return!merged||isEmpty(merged)?undefined:merged}function mergeProjection(opt){const{parentProjection:parentProjection,projection:projection}=opt;if(parentProjection&&projection){warn(projectionOverridden({parentProjection:parentProjection,projection:projection}))}return projection??parentProjection}function isFilter(t){return hasProperty(t,"filter")}function isImputeSequence(t){return hasProperty(t,"stop")}function isLookup(t){return hasProperty(t,"lookup")}function isLookupData(from){return hasProperty(from,"data")}function isLookupSelection(from){return hasProperty(from,"param")}function isPivot(t){return hasProperty(t,"pivot")}function isDensity(t){return hasProperty(t,"density")}function isQuantile(t){return hasProperty(t,"quantile")}function isRegression(t){return hasProperty(t,"regression")}function isLoess(t){return hasProperty(t,"loess")}function isSample(t){return hasProperty(t,"sample")}function isWindow(t){return hasProperty(t,"window")}function isJoinAggregate(t){return hasProperty(t,"joinaggregate")}function isFlatten(t){return hasProperty(t,"flatten")}function isCalculate(t){return hasProperty(t,"calculate")}function isBin(t){return hasProperty(t,"bin")}function isImpute(t){return hasProperty(t,"impute")}function isTimeUnit(t){return hasProperty(t,"timeUnit")}function isAggregate(t){return hasProperty(t,"aggregate")}function isStack(t){return hasProperty(t,"stack")}function isFold(t){return hasProperty(t,"fold")}function isExtent(t){return hasProperty(t,"extent")&&!hasProperty(t,"density")&&!hasProperty(t,"regression")}function normalizeTransform(transform){return transform.map((t=>{if(isFilter(t)){return{filter:normalizeLogicalComposition(t.filter,normalizePredicate$1)}}return t}))}class SelectionCompatibilityNormalizer extends SpecMapper{map(spec,normParams){normParams.emptySelections??(normParams.emptySelections={});normParams.selectionPredicates??(normParams.selectionPredicates={});spec=normalizeTransforms(spec,normParams);return super.map(spec,normParams)}mapLayerOrUnit(spec,normParams){spec=normalizeTransforms(spec,normParams);if(spec.encoding){const encoding={};for(const[channel,enc]of entries$1(spec.encoding)){encoding[channel]=normalizeChannelDef(enc,normParams)}spec={...spec,encoding:encoding}}return super.mapLayerOrUnit(spec,normParams)}mapUnit(spec,normParams){const{selection:selection,...rest}=spec;if(selection){return{...rest,params:entries$1(selection).map((([name,selDef])=>{const{init:value,bind:bind,empty:empty,...select}=selDef;if(select.type==="single"){select.type="point";select.toggle=false}else if(select.type==="multi"){select.type="point"}normParams.emptySelections[name]=empty!=="none";for(const pred of vals(normParams.selectionPredicates[name]??{})){pred.empty=empty!=="none"}return{name:name,value:value,select:select,bind:bind}}))}}return spec}}function normalizeTransforms(spec,normParams){const{transform:tx,...rest}=spec;if(tx){const transform=tx.map((t=>{if(isFilter(t)){return{filter:normalizePredicate(t,normParams)}}else if(isBin(t)&&isBinParams(t.bin)){return{...t,bin:normalizeBinExtent(t.bin)}}else if(isLookup(t)){const{selection:param,...from}=t.from;return param?{...t,from:{param:param,...from}}:t}return t}));return{...rest,transform:transform}}return spec}function normalizeChannelDef(obj,normParams){const enc=duplicate(obj);if(isFieldDef(enc)&&isBinParams(enc.bin)){enc.bin=normalizeBinExtent(enc.bin)}if(isScaleFieldDef(enc)&&enc.scale?.domain?.selection){const{selection:param,...domain}=enc.scale.domain;enc.scale.domain={...domain,...param?{param:param}:{}}}if(isConditionalDef(enc)){if(isArray(enc.condition)){enc.condition=enc.condition.map((c=>{const{selection:selection,param:param,test:test,...cond}=c;return param?c:{...cond,test:normalizePredicate(c,normParams)}}))}else{const{selection:selection,param:param,test:test,...cond}=normalizeChannelDef(enc.condition,normParams);enc.condition=param?enc.condition:{...cond,test:normalizePredicate(enc.condition,normParams)}}}return enc}function normalizeBinExtent(bin){const ext=bin.extent;if(ext?.selection){const{selection:param,...rest}=ext;return{...bin,extent:{...rest,param:param}}}return bin}function normalizePredicate(op,normParams){const normalizeSelectionComposition=o=>normalizeLogicalComposition(o,(param=>{var _a;const empty=normParams.emptySelections[param]??true;const pred={param:param,empty:empty};(_a=normParams.selectionPredicates)[param]??(_a[param]=[]);normParams.selectionPredicates[param].push(pred);return pred}));return op.selection?normalizeSelectionComposition(op.selection):normalizeLogicalComposition(op.test||op.filter,(o=>o.selection?normalizeSelectionComposition(o.selection):o))}class TopLevelSelectionsNormalizer extends SpecMapper{map(spec,normParams){const selections=normParams.selections??[];if(spec.params&&!isUnitSpec(spec)){const params=[];for(const param of spec.params){if(isSelectionParameter(param)){selections.push(param)}else{params.push(param)}}spec.params=params}normParams.selections=selections;return super.map(spec,normParams)}mapUnit(spec,normParams){const selections=normParams.selections;if(!selections||!selections.length)return spec;const path=(normParams.path??[]).concat(spec.name);const params=[];for(const selection of selections){if(!selection.views||!selection.views.length){params.push(selection)}else{for(const view of selection.views){if(isString(view)&&(view===spec.name||path.includes(view))||isArray(view)&&view.map((v=>path.indexOf(v))).every(((v,i,arr)=>v!==-1&&(i===0||v>arr[i-1])))){params.push(selection)}}}}if(params.length)spec.params=params;return spec}}for(const method of["mapFacet","mapRepeat","mapHConcat","mapVConcat","mapLayer"]){const proto=TopLevelSelectionsNormalizer.prototype[method];TopLevelSelectionsNormalizer.prototype[method]=function(spec,params){return proto.call(this,spec,addSpecNameToParams(spec,params))}}function addSpecNameToParams(spec,params){return spec.name?{...params,path:(params.path??[]).concat(spec.name)}:params}function normalize(spec,config){if(config===undefined){config=initConfig(spec.config)}const normalizedSpec=normalizeGenericSpec(spec,config);const{width:width,height:height}=spec;const autosize=normalizeAutoSize(normalizedSpec,{width:width,height:height,autosize:spec.autosize},config);return{...normalizedSpec,...autosize?{autosize:autosize}:{}}}const coreNormalizer=new CoreNormalizer;const selectionCompatNormalizer=new SelectionCompatibilityNormalizer;const topLevelSelectionNormalizer=new TopLevelSelectionsNormalizer;function normalizeGenericSpec(spec,config={}){const normParams={config:config};return topLevelSelectionNormalizer.map(coreNormalizer.map(selectionCompatNormalizer.map(spec,normParams),normParams),normParams)}function _normalizeAutoSize(autosize){return isString(autosize)?{type:autosize}:autosize??{}}function normalizeAutoSize(spec,sizeInfo,config){let{width:width,height:height}=sizeInfo;const isFitCompatible=isUnitSpec(spec)||isLayerSpec(spec);const autosizeDefault={};if(!isFitCompatible){if(width=="container"){warn(containerSizeNonSingle("width"));width=undefined}if(height=="container"){warn(containerSizeNonSingle("height"));height=undefined}}else{if(width=="container"&&height=="container"){autosizeDefault.type="fit";autosizeDefault.contains="padding"}else if(width=="container"){autosizeDefault.type="fit-x";autosizeDefault.contains="padding"}else if(height=="container"){autosizeDefault.type="fit-y";autosizeDefault.contains="padding"}}const autosize={type:"pad",...autosizeDefault,...config?_normalizeAutoSize(config.autosize):{},..._normalizeAutoSize(spec.autosize)};if(autosize.type==="fit"&&!isFitCompatible){warn(FIT_NON_SINGLE);autosize.type="pad"}if(width=="container"&&!(autosize.type=="fit"||autosize.type=="fit-x")){warn(containerSizeNotCompatibleWithAutosize("width"))}if(height=="container"&&!(autosize.type=="fit"||autosize.type=="fit-y")){warn(containerSizeNotCompatibleWithAutosize("height"))}if(deepEqual(autosize,{type:"pad"})){return undefined}return autosize}function isFitType(autoSizeType){return["fit","fit-x","fit-y"].includes(autoSizeType)}function getFitType(sizeType){return sizeType?`fit-${getPositionScaleChannel(sizeType)}`:"fit"}const TOP_LEVEL_PROPERTIES=["background","padding"];function extractTopLevelProperties(t,includeParams){const o={};for(const p of TOP_LEVEL_PROPERTIES){if(t&&t[p]!==undefined){o[p]=signalRefOrValue(t[p])}}if(includeParams){o.params=t.params}return o}class Split{constructor(explicit={},implicit={}){this.explicit=explicit;this.implicit=implicit}clone(){return new Split(duplicate(this.explicit),duplicate(this.implicit))}combine(){return{...this.explicit,...this.implicit}}get(key){return getFirstDefined(this.explicit[key],this.implicit[key])}getWithExplicit(key){if(this.explicit[key]!==undefined){return{explicit:true,value:this.explicit[key]}}else if(this.implicit[key]!==undefined){return{explicit:false,value:this.implicit[key]}}return{explicit:false,value:undefined}}setWithExplicit(key,{value:value,explicit:explicit}){if(value!==undefined){this.set(key,value,explicit)}}set(key,value,explicit){delete this[explicit?"implicit":"explicit"][key];this[explicit?"explicit":"implicit"][key]=value;return this}copyKeyFromSplit(key,{explicit:explicit,implicit:implicit}){if(explicit[key]!==undefined){this.set(key,explicit[key],true)}else if(implicit[key]!==undefined){this.set(key,implicit[key],false)}}copyKeyFromObject(key,s){if(s[key]!==undefined){this.set(key,s[key],true)}}copyAll(other){for(const key of keys(other.combine())){const val=other.getWithExplicit(key);this.setWithExplicit(key,val)}}}function makeExplicit(value){return{explicit:true,value:value}}function makeImplicit(value){return{explicit:false,value:value}}function tieBreakByComparing(compare){return(v1,v2,property,propertyOf)=>{const diff=compare(v1.value,v2.value);if(diff>0){return v1}else if(diff<0){return v2}return defaultTieBreaker(v1,v2,property,propertyOf)}}function defaultTieBreaker(v1,v2,property,propertyOf){if(v1.explicit&&v2.explicit){warn(mergeConflictingProperty(property,propertyOf,v1.value,v2.value))}return v1}function mergeValuesWithExplicit(v1,v2,property,propertyOf,tieBreaker=defaultTieBreaker){if(v1===undefined||v1.value===undefined){return v2}if(v1.explicit&&!v2.explicit){return v1}else if(v2.explicit&&!v1.explicit){return v2}else if(deepEqual(v1.value,v2.value)){return v1}else{return tieBreaker(v1,v2,property,propertyOf)}}class AncestorParse extends Split{constructor(explicit={},implicit={},parseNothing=false){super(explicit,implicit);this.explicit=explicit;this.implicit=implicit;this.parseNothing=parseNothing}clone(){const clone=super.clone();clone.parseNothing=this.parseNothing;return clone}}function isUrlData(data){return hasProperty(data,"url")}function isInlineData(data){return hasProperty(data,"values")}function isNamedData(data){return hasProperty(data,"name")&&!isUrlData(data)&&!isInlineData(data)&&!isGenerator(data)}function isGenerator(data){return data&&(isSequenceGenerator(data)||isSphereGenerator(data)||isGraticuleGenerator(data))}function isSequenceGenerator(data){return hasProperty(data,"sequence")}function isSphereGenerator(data){return hasProperty(data,"sphere")}function isGraticuleGenerator(data){return hasProperty(data,"graticule")}var DataSourceType;(function(DataSourceType){DataSourceType[DataSourceType["Raw"]=0]="Raw";DataSourceType[DataSourceType["Main"]=1]="Main";DataSourceType[DataSourceType["Row"]=2]="Row";DataSourceType[DataSourceType["Column"]=3]="Column";DataSourceType[DataSourceType["Lookup"]=4]="Lookup";DataSourceType[DataSourceType["PreFilterInvalid"]=5]="PreFilterInvalid";DataSourceType[DataSourceType["PostFilterInvalid"]=6]="PostFilterInvalid"})(DataSourceType||(DataSourceType={}));function getDataSourcesForHandlingInvalidValues({invalid:invalid,isPath:isPath}){const normalizedInvalid=normalizeInvalidDataMode(invalid,{isPath:isPath});switch(normalizedInvalid){case"filter":return{marks:"exclude-invalid-values",scales:"exclude-invalid-values"};case"break-paths-show-domains":return{marks:isPath?"include-invalid-values":"exclude-invalid-values",scales:"include-invalid-values"};case"break-paths-filter-domains":return{marks:isPath?"include-invalid-values":"exclude-invalid-values",scales:"exclude-invalid-values"};case"show":return{marks:"include-invalid-values",scales:"include-invalid-values"}}}function getScaleDataSourceForHandlingInvalidValues(props){const{marks:marks,scales:scales}=getDataSourcesForHandlingInvalidValues(props);if(marks===scales){return DataSourceType.Main}return scales==="include-invalid-values"?DataSourceType.PreFilterInvalid:DataSourceType.PostFilterInvalid}function assembleProjection(proj){const{signals:signals,hasLegend:hasLegend,index:index,...rest}=proj;rest.field=replacePathInField(rest.field);return rest}function assembleInit(init,isExpr=true,wrap=identity$6){if(isArray(init)){const assembled=init.map((v=>assembleInit(v,isExpr,wrap)));return isExpr?`[${assembled.join(", ")}]`:assembled}else if(isDateTime(init)){if(isExpr){return wrap(dateTimeToExpr(init))}else{return wrap(dateTimeToTimestamp(init))}}return isExpr?wrap(stringify(init)):init}function assembleUnitSelectionSignals(model,signals){for(const selCmpt of vals(model.component.selection??{})){const name=selCmpt.name;let modifyExpr=`${name}${TUPLE}, ${selCmpt.resolve==="global"?"true":`{unit: ${unitName(model)}}`}`;for(const c of selectionCompilers){if(!c.defined(selCmpt))continue;if(c.signals)signals=c.signals(model,selCmpt,signals);if(c.modifyExpr)modifyExpr=c.modifyExpr(model,selCmpt,modifyExpr)}signals.push({name:name+MODIFY,on:[{events:{signal:selCmpt.name+TUPLE},update:`modify(${$(selCmpt.name+STORE)}, ${modifyExpr})`}]})}return cleanupEmptyOnArray(signals)}function assembleFacetSignals(model,signals){if(model.component.selection&&keys(model.component.selection).length){const name=$(model.getName("cell"));signals.unshift({name:"facet",value:{},on:[{events:eventSelector("pointermove","scope"),update:`isTuple(facet) ? facet : group(${name}).datum`}]})}return cleanupEmptyOnArray(signals)}function assembleTopLevelSignals(model,signals){let hasSelections=false;for(const selCmpt of vals(model.component.selection??{})){const name=selCmpt.name;const store=$(name+STORE);const hasSg=signals.filter((s=>s.name===name));if(hasSg.length===0){const resolve=selCmpt.resolve==="global"?"union":selCmpt.resolve;const isPoint=selCmpt.type==="point"?", true, true)":")";signals.push({name:selCmpt.name,update:`${VL_SELECTION_RESOLVE}(${store}, ${$(resolve)}${isPoint}`})}hasSelections=true;for(const c of selectionCompilers){if(c.defined(selCmpt)&&c.topLevelSignals){signals=c.topLevelSignals(model,selCmpt,signals)}}}if(hasSelections){const hasUnit=signals.filter((s=>s.name==="unit"));if(hasUnit.length===0){signals.unshift({name:"unit",value:{},on:[{events:"pointermove",update:"isTuple(group()) ? group() : unit"}]})}}return cleanupEmptyOnArray(signals)}function assembleUnitSelectionData(model,data){const dataCopy=[...data];const unit=unitName(model,{escape:false});for(const selCmpt of vals(model.component.selection??{})){const store={name:selCmpt.name+STORE};if(selCmpt.project.hasSelectionId){store.transform=[{type:"collect",sort:{field:SELECTION_ID}}]}if(selCmpt.init){const fields=selCmpt.project.items.map(assembleProjection);store.values=selCmpt.project.hasSelectionId?selCmpt.init.map((i=>({unit:unit,[SELECTION_ID]:assembleInit(i,false)[0]}))):selCmpt.init.map((i=>({unit:unit,fields:fields,values:assembleInit(i,false)})))}const contains=dataCopy.filter((d=>d.name===selCmpt.name+STORE));if(!contains.length){dataCopy.push(store)}}return dataCopy}function assembleUnitSelectionMarks(model,marks){for(const selCmpt of vals(model.component.selection??{})){for(const c of selectionCompilers){if(c.defined(selCmpt)&&c.marks){marks=c.marks(model,selCmpt,marks)}}}return marks}function assembleLayerSelectionMarks(model,marks){for(const child of model.children){if(isUnitModel(child)){marks=assembleUnitSelectionMarks(child,marks)}}return marks}function assembleSelectionScaleDomain(model,extent,scaleCmpt,domain){const parsedExtent=parseSelectionExtent(model,extent.param,extent);return{signal:hasContinuousDomain(scaleCmpt.get("type"))&&isArray(domain)&&domain[0]>domain[1]?`isValid(${parsedExtent}) && reverse(${parsedExtent})`:parsedExtent}}function cleanupEmptyOnArray(signals){return signals.map((s=>{if(s.on&&!s.on.length)delete s.on;return s}))}class DataFlowNode{constructor(parent,debugName){this.debugName=debugName;this._children=[];this._parent=null;if(parent){this.parent=parent}}clone(){throw new Error("Cannot clone node")}get parent(){return this._parent}set parent(parent){this._parent=parent;if(parent){parent.addChild(this)}}get children(){return this._children}numChildren(){return this._children.length}addChild(child,loc){if(this._children.includes(child)){warn(ADD_SAME_CHILD_TWICE);return}if(loc!==undefined){this._children.splice(loc,0,child)}else{this._children.push(child)}}removeChild(oldChild){const loc=this._children.indexOf(oldChild);this._children.splice(loc,1);return loc}remove(){let loc=this._parent.removeChild(this);for(const child of this._children){child._parent=this._parent;this._parent.addChild(child,loc++)}}insertAsParentOf(other){const parent=other.parent;parent.removeChild(this);this.parent=parent;other.parent=this}swapWithParent(){const parent=this._parent;const newParent=parent.parent;for(const child of this._children){child.parent=parent}this._children=[];parent.removeChild(this);const loc=parent.parent.removeChild(parent);this._parent=newParent;newParent.addChild(this,loc);parent.parent=this}}class OutputNode extends DataFlowNode{clone(){const cloneObj=new this.constructor;cloneObj.debugName=`clone_${this.debugName}`;cloneObj._source=this._source;cloneObj._name=`clone_${this._name}`;cloneObj.type=this.type;cloneObj.refCounts=this.refCounts;cloneObj.refCounts[cloneObj._name]=0;return cloneObj}constructor(parent,source,type,refCounts){super(parent,source);this.type=type;this.refCounts=refCounts;this._source=this._name=source;if(this.refCounts&&!(this._name in this.refCounts)){this.refCounts[this._name]=0}}dependentFields(){return new Set}producedFields(){return new Set}hash(){if(this._hash===undefined){this._hash=`Output ${uniqueId()}`}return this._hash}getSource(){this.refCounts[this._name]++;return this._source}isRequired(){return!!this.refCounts[this._name]}setSource(source){this._source=source}}function isTimeUnitTransformComponent(timeUnitComponent){return timeUnitComponent.as!==undefined}function offsetAs(field){return`${field}_end`}class TimeUnitNode extends DataFlowNode{clone(){return new TimeUnitNode(null,duplicate(this.timeUnits))}constructor(parent,timeUnits){super(parent);this.timeUnits=timeUnits}static makeFromEncoding(parent,model){const formula=model.reduceFieldDef(((timeUnitComponent,fieldDef,channel)=>{const{field:field,timeUnit:timeUnit}=fieldDef;if(timeUnit){let component;if(isBinnedTimeUnit(timeUnit)){if(isUnitModel(model)){const{mark:mark,markDef:markDef,config:config}=model;const bandPosition=getBandPosition({fieldDef:fieldDef,markDef:markDef,config:config});if(isRectBasedMark(mark)||!!bandPosition){component={timeUnit:normalizeTimeUnit(timeUnit),field:field}}}}else{component={as:vgField(fieldDef,{forAs:true}),field:field,timeUnit:timeUnit}}if(isUnitModel(model)){const{mark:mark,markDef:markDef,config:config}=model;const bandPosition=getBandPosition({fieldDef:fieldDef,markDef:markDef,config:config});if(isRectBasedMark(mark)&&isXorY(channel)&&bandPosition!==.5){component.rectBandPosition=bandPosition}}if(component){timeUnitComponent[hash(component)]=component}}return timeUnitComponent}),{});if(isEmpty(formula)){return null}return new TimeUnitNode(parent,formula)}static makeFromTransform(parent,t){const{timeUnit:timeUnit,...other}={...t};const normalizedTimeUnit=normalizeTimeUnit(timeUnit);const component={...other,timeUnit:normalizedTimeUnit};return new TimeUnitNode(parent,{[hash(component)]:component})}merge(other){this.timeUnits={...this.timeUnits};for(const key in other.timeUnits){if(!this.timeUnits[key]){this.timeUnits[key]=other.timeUnits[key]}}for(const child of other.children){other.removeChild(child);child.parent=this}other.remove()}removeFormulas(fields){const newFormula={};for(const[key,timeUnitComponent]of entries$1(this.timeUnits)){const fieldAs=isTimeUnitTransformComponent(timeUnitComponent)?timeUnitComponent.as:`${timeUnitComponent.field}_end`;if(!fields.has(fieldAs)){newFormula[key]=timeUnitComponent}}this.timeUnits=newFormula}producedFields(){return new Set(vals(this.timeUnits).map((f=>isTimeUnitTransformComponent(f)?f.as:offsetAs(f.field))))}dependentFields(){return new Set(vals(this.timeUnits).map((f=>f.field)))}hash(){return`TimeUnit ${hash(this.timeUnits)}`}assemble(){const transforms=[];for(const f of vals(this.timeUnits)){const{rectBandPosition:rectBandPosition}=f;const normalizedTimeUnit=normalizeTimeUnit(f.timeUnit);if(isTimeUnitTransformComponent(f)){const{field:field,as:as}=f;const{unit:unit,utc:utc,...params}=normalizedTimeUnit;const startEnd=[as,`${as}_end`];transforms.push({field:replacePathInField(field),type:"timeunit",...unit?{units:getTimeUnitParts(unit)}:{},...utc?{timezone:"utc"}:{},...params,as:startEnd});transforms.push(...offsetedRectFormulas(startEnd,rectBandPosition,normalizedTimeUnit))}else if(f){const{field:escapedField}=f;const field=escapedField.replaceAll("\\.",".");const expr=offsetExpr({timeUnit:normalizedTimeUnit,field:field});const endAs=offsetAs(field);transforms.push({type:"formula",expr:expr,as:endAs});transforms.push(...offsetedRectFormulas([field,endAs],rectBandPosition,normalizedTimeUnit))}}return transforms}}const OFFSETTED_RECT_START_SUFFIX="offsetted_rect_start";const OFFSETTED_RECT_END_SUFFIX="offsetted_rect_end";function offsetExpr({timeUnit:timeUnit,field:field,reverse:reverse}){const{unit:unit,utc:utc}=timeUnit;const smallestUnit=getSmallestTimeUnitPart(unit);const{part:part,step:step}=getDateTimePartAndStep(smallestUnit,timeUnit.step);const offsetFn=utc?"utcOffset":"timeOffset";const expr=`${offsetFn}('${part}', datum['${field}'], ${reverse?-step:step})`;return expr}function offsetedRectFormulas([startField,endField],rectBandPosition,timeUnit){if(rectBandPosition!==undefined&&rectBandPosition!==.5){const startExpr=`datum['${startField}']`;const endExpr=`datum['${endField}']`;return[{type:"formula",expr:interpolateExpr([offsetExpr({timeUnit:timeUnit,field:startField,reverse:true}),startExpr],rectBandPosition+.5),as:`${startField}_${OFFSETTED_RECT_START_SUFFIX}`},{type:"formula",expr:interpolateExpr([startExpr,endExpr],rectBandPosition+.5),as:`${startField}_${OFFSETTED_RECT_END_SUFFIX}`}]}return[]}function interpolateExpr([start,end],fraction){return`${1-fraction} * ${start} + ${fraction} * ${end}`}const TUPLE_FIELDS="_tuple_fields";class SelectionProjectionComponent{constructor(...items){this.items=items;this.hasChannel={};this.hasField={};this.hasSelectionId=false}}const project={defined:()=>true,parse:(model,selCmpt,selDef)=>{const name=selCmpt.name;const proj=selCmpt.project??(selCmpt.project=new SelectionProjectionComponent);const parsed={};const timeUnits={};const signals=new Set;const signalName=(p,range)=>{const suffix=range==="visual"?p.channel:p.field;let sg=varName(`${name}_${suffix}`);for(let counter=1;signals.has(sg);counter++){sg=varName(`${name}_${suffix}_${counter}`)}signals.add(sg);return{[range]:sg}};const type=selCmpt.type;const cfg=model.config.selection[type];const init=selDef.value!==undefined?array$5(selDef.value):null;let{fields:fields,encodings:encodings}=isObject(selDef.select)?selDef.select:{};if(!fields&&!encodings&&init){for(const initVal of init){if(!isObject(initVal)){continue}for(const key of keys(initVal)){if(isSingleDefUnitChannel(key)){(encodings||(encodings=[])).push(key)}else{if(type==="interval"){warn(INTERVAL_INITIALIZED_WITH_POS);encodings=cfg.encodings}else{(fields??(fields=[])).push(key)}}}}}if(!fields&&!encodings){encodings=cfg.encodings;if("fields"in cfg){fields=cfg.fields}}for(const channel of encodings??[]){const fieldDef=model.fieldDef(channel);if(fieldDef){let field=fieldDef.field;if(fieldDef.aggregate){warn(cannotProjectAggregate(channel,fieldDef.aggregate));continue}else if(!field){warn(cannotProjectOnChannelWithoutField(channel));continue}if(fieldDef.timeUnit&&!isBinnedTimeUnit(fieldDef.timeUnit)){field=model.vgField(channel);const component={timeUnit:fieldDef.timeUnit,as:field,field:fieldDef.field};timeUnits[hash(component)]=component}if(!parsed[field]){const tplType=type==="interval"&&isScaleChannel(channel)&&hasContinuousDomain(model.getScaleComponent(channel).get("type"))?"R":fieldDef.bin?"R-RE":"E";const p={field:field,channel:channel,type:tplType,index:proj.items.length};p.signals={...signalName(p,"data"),...signalName(p,"visual")};proj.items.push(parsed[field]=p);proj.hasField[field]=parsed[field];proj.hasSelectionId=proj.hasSelectionId||field===SELECTION_ID;if(isGeoPositionChannel(channel)){p.geoChannel=channel;p.channel=getPositionChannelFromLatLong(channel);proj.hasChannel[p.channel]=parsed[field]}else{proj.hasChannel[channel]=parsed[field]}}}else{warn(cannotProjectOnChannelWithoutField(channel))}}for(const field of fields??[]){if(proj.hasField[field])continue;const p={type:"E",field:field,index:proj.items.length};p.signals={...signalName(p,"data")};proj.items.push(p);proj.hasField[field]=p;proj.hasSelectionId=proj.hasSelectionId||field===SELECTION_ID}if(init){selCmpt.init=init.map((v=>proj.items.map((p=>isObject(v)?v[p.geoChannel||p.channel]!==undefined?v[p.geoChannel||p.channel]:v[p.field]:v))))}if(!isEmpty(timeUnits)){proj.timeUnit=new TimeUnitNode(null,timeUnits)}},signals:(model,selCmpt,allSignals)=>{const name=selCmpt.name+TUPLE_FIELDS;const hasSignal=allSignals.filter((s=>s.name===name));return hasSignal.length>0||selCmpt.project.hasSelectionId?allSignals:allSignals.concat({name:name,value:selCmpt.project.items.map(assembleProjection)})}};const scaleBindings={defined:selCmpt=>selCmpt.type==="interval"&&selCmpt.resolve==="global"&&selCmpt.bind&&selCmpt.bind==="scales",parse:(model,selCmpt)=>{const bound=selCmpt.scales=[];for(const proj of selCmpt.project.items){const channel=proj.channel;if(!isScaleChannel(channel)){continue}const scale=model.getScaleComponent(channel);const scaleType=scale?scale.get("type"):undefined;if(scaleType=="sequential"){warn(SEQUENTIAL_SCALE_DEPRECATED)}if(!scale||!hasContinuousDomain(scaleType)){warn(SCALE_BINDINGS_CONTINUOUS);continue}scale.set("selectionExtent",{param:selCmpt.name,field:proj.field},true);bound.push(proj)}},topLevelSignals:(model,selCmpt,signals)=>{const bound=selCmpt.scales.filter((proj=>signals.filter((s=>s.name===proj.signals.data)).length===0));if(!model.parent||isTopLevelLayer(model)||bound.length===0){return signals}const namedSg=signals.find((s=>s.name===selCmpt.name));let update=namedSg.update;if(update.includes(VL_SELECTION_RESOLVE)){namedSg.update=`{${bound.map((proj=>`${$(replacePathInField(proj.field))}: ${proj.signals.data}`)).join(", ")}}`}else{for(const proj of bound){const mapping=`${$(replacePathInField(proj.field))}: ${proj.signals.data}`;if(!update.includes(mapping)){update=`${update.substring(0,update.length-1)}, ${mapping}}`}}namedSg.update=update}return signals.concat(bound.map((proj=>({name:proj.signals.data}))))},signals:(model,selCmpt,signals)=>{if(model.parent&&!isTopLevelLayer(model)){for(const proj of selCmpt.scales){const signal=signals.find((s=>s.name===proj.signals.data));signal.push="outer";delete signal.value;delete signal.update}}return signals}};function domain(model,channel){const scale=$(model.scaleName(channel));return`domain(${scale})`}function isTopLevelLayer(model){return model.parent&&isLayerModel(model.parent)&&(!model.parent.parent??isTopLevelLayer(model.parent.parent))}const BRUSH="_brush";const SCALE_TRIGGER="_scale_trigger";const GEO_INIT_TICK="geo_interval_init_tick";const INIT="_init";const CENTER="_center";const interval={defined:selCmpt=>selCmpt.type==="interval",parse:(model,selCmpt,selDef)=>{var _a;if(model.hasProjection){const def={...isObject(selDef.select)?selDef.select:{}};def.fields=[SELECTION_ID];if(!def.encodings){def.encodings=selDef.value?keys(selDef.value):[LONGITUDE,LATITUDE]}selDef.select={type:"interval",...def}}if(selCmpt.translate&&!scaleBindings.defined(selCmpt)){const filterExpr=`!event.item || event.item.mark.name !== ${$(selCmpt.name+BRUSH)}`;for(const evt of selCmpt.events){if(!evt.between){warn(`${evt} is not an ordered event stream for interval selections.`);continue}const filters=array$5((_a=evt.between[0]).filter??(_a.filter=[]));if(!filters.includes(filterExpr)){filters.push(filterExpr)}}}},signals:(model,selCmpt,signals)=>{const name=selCmpt.name;const tupleSg=name+TUPLE;const channels=vals(selCmpt.project.hasChannel).filter((p=>p.channel===X||p.channel===Y));const init=selCmpt.init?selCmpt.init[0]:null;signals.push(...channels.reduce(((arr,proj)=>arr.concat(channelSignals(model,selCmpt,proj,init&&init[proj.index]))),[]));if(!model.hasProjection){if(!scaleBindings.defined(selCmpt)){const triggerSg=name+SCALE_TRIGGER;const scaleTriggers=channels.map((proj=>{const channel=proj.channel;const{data:dname,visual:vname}=proj.signals;const scaleName=$(model.scaleName(channel));const scaleType=model.getScaleComponent(channel).get("type");const toNum=hasContinuousDomain(scaleType)?"+":"";return`(!isArray(${dname}) || `+`(${toNum}invert(${scaleName}, ${vname})[0] === ${toNum}${dname}[0] && `+`${toNum}invert(${scaleName}, ${vname})[1] === ${toNum}${dname}[1]))`}));if(scaleTriggers.length){signals.push({name:triggerSg,value:{},on:[{events:channels.map((proj=>({scale:model.scaleName(proj.channel)}))),update:scaleTriggers.join(" && ")+` ? ${triggerSg} : {}`}]})}}const dataSignals=channels.map((proj=>proj.signals.data));const update=`unit: ${unitName(model)}, fields: ${name+TUPLE_FIELDS}, values`;return signals.concat({name:tupleSg,...init?{init:`{${update}: ${assembleInit(init)}}`}:{},...dataSignals.length?{on:[{events:[{signal:dataSignals.join(" || ")}],update:`${dataSignals.join(" && ")} ? {${update}: [${dataSignals}]} : null`}]}:{}})}else{const projection=$(model.projectionName());const centerSg=model.projectionName()+CENTER;const{x:x,y:y}=selCmpt.project.hasChannel;const xvname=x&&x.signals.visual;const yvname=y&&y.signals.visual;const xinit=x?init&&init[x.index]:`${centerSg}[0]`;const yinit=y?init&&init[y.index]:`${centerSg}[1]`;const sizeSg=layout=>model.getSizeSignalRef(layout).signal;const bbox=`[`+`[${xvname?xvname+"[0]":"0"}, ${yvname?yvname+"[0]":"0"}],`+`[${xvname?xvname+"[1]":sizeSg("width")}, `+`${yvname?yvname+"[1]":sizeSg("height")}]`+`]`;if(init){signals.unshift({name:name+INIT,init:`[scale(${projection}, [${x?xinit[0]:xinit}, ${y?yinit[0]:yinit}]), `+`scale(${projection}, [${x?xinit[1]:xinit}, ${y?yinit[1]:yinit}])]`});if(!x||!y){const hasCenterSg=signals.find((s=>s.name===centerSg));if(!hasCenterSg){signals.unshift({name:centerSg,update:`invert(${projection}, [${sizeSg("width")}/2, ${sizeSg("height")}/2])`})}}}const intersect=`intersect(${bbox}, {markname: ${$(model.getName("marks"))}}, unit.mark)`;const base=`{unit: ${unitName(model)}}`;const update=`vlSelectionTuples(${intersect}, ${base})`;const visualSignals=channels.map((proj=>proj.signals.visual));return signals.concat({name:tupleSg,on:[{events:[...visualSignals.length?[{signal:visualSignals.join(" || ")}]:[],...init?[{signal:GEO_INIT_TICK}]:[]],update:update}]})}},topLevelSignals:(model,selCmpt,signals)=>{if(isUnitModel(model)&&model.hasProjection&&selCmpt.init){const hasTick=signals.filter((s=>s.name===GEO_INIT_TICK));if(!hasTick.length){signals.unshift({name:GEO_INIT_TICK,value:null,on:[{events:"timer{1}",update:`${GEO_INIT_TICK} === null ? {} : ${GEO_INIT_TICK}`}]})}}return signals},marks:(model,selCmpt,marks)=>{const name=selCmpt.name;const{x:x,y:y}=selCmpt.project.hasChannel;const xvname=x?.signals.visual;const yvname=y?.signals.visual;const store=`data(${$(selCmpt.name+STORE)})`;if(scaleBindings.defined(selCmpt)||!x&&!y){return marks}const update={x:x!==undefined?{signal:`${xvname}[0]`}:{value:0},y:y!==undefined?{signal:`${yvname}[0]`}:{value:0},x2:x!==undefined?{signal:`${xvname}[1]`}:{field:{group:"width"}},y2:y!==undefined?{signal:`${yvname}[1]`}:{field:{group:"height"}}};if(selCmpt.resolve==="global"){for(const key of keys(update)){update[key]=[{test:`${store}.length && ${store}[0].unit === ${unitName(model)}`,...update[key]},{value:0}]}}const{fill:fill,fillOpacity:fillOpacity,cursor:cursor,...stroke}=selCmpt.mark;const vgStroke=keys(stroke).reduce(((def,k)=>{def[k]=[{test:[x!==undefined&&`${xvname}[0] !== ${xvname}[1]`,y!==undefined&&`${yvname}[0] !== ${yvname}[1]`].filter((t=>t)).join(" && "),value:stroke[k]},{value:null}];return def}),{});const vgCursor=cursor??(selCmpt.translate?"move":null);return[{name:`${name+BRUSH}_bg`,type:"rect",clip:true,encode:{enter:{fill:{value:fill},fillOpacity:{value:fillOpacity}},update:update}},...marks,{name:name+BRUSH,type:"rect",clip:true,encode:{enter:{...vgCursor?{cursor:{value:vgCursor}}:{},fill:{value:"transparent"}},update:{...update,...vgStroke}}}]}};function channelSignals(model,selCmpt,proj,init){const scaledInterval=!model.hasProjection;const channel=proj.channel;const vname=proj.signals.visual;const scaleName=$(scaledInterval?model.scaleName(channel):model.projectionName());const scaled=str=>`scale(${scaleName}, ${str})`;const size=model.getSizeSignalRef(channel===X?"width":"height").signal;const coord=`${channel}(unit)`;const von=selCmpt.events.reduce(((def,evt)=>[...def,{events:evt.between[0],update:`[${coord}, ${coord}]`},{events:evt,update:`[${vname}[0], clamp(${coord}, 0, ${size})]`}]),[]);if(scaledInterval){const dname=proj.signals.data;const hasScales=scaleBindings.defined(selCmpt);const scale=model.getScaleComponent(channel);const scaleType=scale?scale.get("type"):undefined;const vinit=init?{init:assembleInit(init,true,scaled)}:{value:[]};von.push({events:{signal:selCmpt.name+SCALE_TRIGGER},update:hasContinuousDomain(scaleType)?`[${scaled(`${dname}[0]`)}, ${scaled(`${dname}[1]`)}]`:`[0, 0]`});return hasScales?[{name:dname,on:[]}]:[{name:vname,...vinit,on:von},{name:dname,...init?{init:assembleInit(init)}:{},on:[{events:{signal:vname},update:`${vname}[0] === ${vname}[1] ? null : invert(${scaleName}, ${vname})`}]}]}else{const initIdx=channel===X?0:1;const initSg=selCmpt.name+INIT;const vinit=init?{init:`[${initSg}[0][${initIdx}], ${initSg}[1][${initIdx}]]`}:{value:[]};return[{name:vname,...vinit,on:von}]}}const point$1={defined:selCmpt=>selCmpt.type==="point",signals:(model,selCmpt,signals)=>{const name=selCmpt.name;const fieldsSg=name+TUPLE_FIELDS;const project=selCmpt.project;const datum="(item().isVoronoi ? datum.datum : datum)";const brushes=vals(model.component.selection??{}).reduce(((acc,cmpt)=>cmpt.type==="interval"?acc.concat(cmpt.name+BRUSH):acc),[]).map((b=>`indexof(item().mark.name, '${b}') < 0`)).join(" && ");const test=`datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${brushes?` && ${brushes}`:""}`;let update=`unit: ${unitName(model)}, `;if(selCmpt.project.hasSelectionId){update+=`${SELECTION_ID}: ${datum}[${$(SELECTION_ID)}]`}else{const values=project.items.map((p=>{const fieldDef=model.fieldDef(p.channel);return fieldDef?.bin?`[${datum}[${$(model.vgField(p.channel,{}))}], `+`${datum}[${$(model.vgField(p.channel,{binSuffix:"end"}))}]]`:`${datum}[${$(p.field)}]`})).join(", ");update+=`fields: ${fieldsSg}, values: [${values}]`}const events=selCmpt.events;return signals.concat([{name:name+TUPLE,on:events?[{events:events,update:`${test} ? {${update}} : null`,force:true}]:[]}])}};function wrapCondition({model:model,channelDef:channelDef,vgChannel:vgChannel,invalidValueRef:invalidValueRef,mainRefFn:mainRefFn}){const condition=isConditionalDef(channelDef)&&channelDef.condition;let valueRefs=[];if(condition){const conditions=array$5(condition);valueRefs=conditions.map((c=>{const conditionValueRef=mainRefFn(c);if(isConditionalParameter(c)){const{param:param,empty:empty}=c;const test=parseSelectionPredicate(model,{param:param,empty:empty});return{test:test,...conditionValueRef}}else{const test=expression(model,c.test);return{test:test,...conditionValueRef}}}))}if(invalidValueRef!==undefined){valueRefs.push(invalidValueRef)}const mainValueRef=mainRefFn(channelDef);if(mainValueRef!==undefined){valueRefs.push(mainValueRef)}if(valueRefs.length>1||valueRefs.length===1&&Boolean(valueRefs[0].test)){return{[vgChannel]:valueRefs}}else if(valueRefs.length===1){return{[vgChannel]:valueRefs[0]}}return{}}function text$1(model,channel="text"){const channelDef=model.encoding[channel];return wrapCondition({model:model,channelDef:channelDef,vgChannel:channel,mainRefFn:cDef=>textRef(cDef,model.config),invalidValueRef:undefined})}function textRef(channelDef,config,expr="datum"){if(channelDef){if(isValueDef(channelDef)){return signalOrValueRef(channelDef.value)}if(isFieldOrDatumDef(channelDef)){const{format:format,formatType:formatType}=getFormatMixins(channelDef);return formatSignalRef({fieldOrDatumDef:channelDef,format:format,formatType:formatType,expr:expr,config:config})}}return undefined}function tooltip(model,opt={}){const{encoding:encoding,markDef:markDef,config:config,stack:stack}=model;const channelDef=encoding.tooltip;if(isArray(channelDef)){return{tooltip:tooltipRefForEncoding({tooltip:channelDef},stack,config,opt)}}else{const datum=opt.reactiveGeom?"datum.datum":"datum";const mainRefFn=cDef=>{const tooltipRefFromChannelDef=textRef(cDef,config,datum);if(tooltipRefFromChannelDef){return tooltipRefFromChannelDef}if(cDef===null){return undefined}let markTooltip=getMarkPropOrConfig("tooltip",markDef,config);if(markTooltip===true){markTooltip={content:"encoding"}}if(isString(markTooltip)){return{value:markTooltip}}else if(isObject(markTooltip)){if(isSignalRef(markTooltip)){return markTooltip}else if(markTooltip.content==="encoding"){return tooltipRefForEncoding(encoding,stack,config,opt)}else{return{signal:datum}}}return undefined};return wrapCondition({model:model,channelDef:channelDef,vgChannel:"tooltip",mainRefFn:mainRefFn,invalidValueRef:undefined})}}function tooltipData(encoding,stack,config,{reactiveGeom:reactiveGeom}={}){const formatConfig={...config,...config.tooltipFormat};const toSkip=new Set;const expr=reactiveGeom?"datum.datum":"datum";const tuples=[];function add(fDef,channel){const mainChannel=getMainRangeChannel(channel);const fieldDef=isTypedFieldDef(fDef)?fDef:{...fDef,type:encoding[mainChannel].type};const title=fieldDef.title||defaultTitle(fieldDef,formatConfig);const key=array$5(title).join(", ").replaceAll(/"/g,'\\"');let value;if(isXorY(channel)){const channel2=channel==="x"?"x2":"y2";const fieldDef2=getFieldDef(encoding[channel2]);if(isBinned(fieldDef.bin)&&fieldDef2){const startField=vgField(fieldDef,{expr:expr});const endField=vgField(fieldDef2,{expr:expr});const{format:format,formatType:formatType}=getFormatMixins(fieldDef);value=binFormatExpression(startField,endField,format,formatType,formatConfig);toSkip.add(channel2)}}if((isXorY(channel)||channel===THETA||channel===RADIUS)&&stack&&stack.fieldChannel===channel&&stack.offset==="normalize"){const{format:format,formatType:formatType}=getFormatMixins(fieldDef);value=formatSignalRef({fieldOrDatumDef:fieldDef,format:format,formatType:formatType,expr:expr,config:formatConfig,normalizeStack:true}).signal}value??(value=textRef(fieldDef,formatConfig,expr).signal);tuples.push({channel:channel,key:key,value:value})}forEach(encoding,((channelDef,channel)=>{if(isFieldDef(channelDef)){add(channelDef,channel)}else if(hasConditionalFieldDef(channelDef)){add(channelDef.condition,channel)}}));const out={};for(const{channel:channel,key:key,value:value}of tuples){if(!toSkip.has(channel)&&!out[key]){out[key]=value}}return out}function tooltipRefForEncoding(encoding,stack,config,{reactiveGeom:reactiveGeom}={}){const data=tooltipData(encoding,stack,config,{reactiveGeom:reactiveGeom});const keyValues=entries$1(data).map((([key,value])=>`"${key}": ${value}`));return keyValues.length>0?{signal:`{${keyValues.join(", ")}}`}:undefined}function aria(model){const{markDef:markDef,config:config}=model;const enableAria=getMarkPropOrConfig("aria",markDef,config);if(enableAria===false){return{}}return{...enableAria?{aria:enableAria}:{},...ariaRoleDescription(model),...description(model)}}function ariaRoleDescription(model){const{mark:mark,markDef:markDef,config:config}=model;if(config.aria===false){return{}}const ariaRoleDesc=getMarkPropOrConfig("ariaRoleDescription",markDef,config);if(ariaRoleDesc!=null){return{ariaRoleDescription:{value:ariaRoleDesc}}}return has$1(VG_MARK_INDEX,mark)?{}:{ariaRoleDescription:{value:mark}}}function description(model){const{encoding:encoding,markDef:markDef,config:config,stack:stack}=model;const channelDef=encoding.description;if(channelDef){return wrapCondition({model:model,channelDef:channelDef,vgChannel:"description",mainRefFn:cDef=>textRef(cDef,model.config),invalidValueRef:undefined})}const descriptionValue=getMarkPropOrConfig("description",markDef,config);if(descriptionValue!=null){return{description:signalOrValueRef(descriptionValue)}}if(config.aria===false){return{}}const data=tooltipData(encoding,stack,config);if(isEmpty(data)){return undefined}return{description:{signal:entries$1(data).map((([key,value],index)=>`"${index>0?"; ":""}${key}: " + (${value})`)).join(" + ")}}}function nonPosition(channel,model,opt={}){const{markDef:markDef,encoding:encoding,config:config}=model;const{vgChannel:vgChannel}=opt;let{defaultRef:defaultRef,defaultValue:defaultValue}=opt;const channelDef=encoding[channel];if(defaultRef===undefined){defaultValue??(defaultValue=getMarkPropOrConfig(channel,markDef,config,{vgChannel:vgChannel,ignoreVgConfig:!isConditionalDef(channelDef)}));if(defaultValue!==undefined){defaultRef=signalOrValueRef(defaultValue)}}const commonProps={markDef:markDef,config:config,scaleName:model.scaleName(channel),scale:model.getScaleComponent(channel)};const invalidValueRef=getConditionalValueRefForIncludingInvalidValue({...commonProps,scaleChannel:channel,channelDef:channelDef});const mainRefFn=cDef=>midPoint({...commonProps,channel:channel,channelDef:cDef,stack:null,defaultRef:defaultRef});return wrapCondition({model:model,channelDef:channelDef,vgChannel:vgChannel??channel,invalidValueRef:invalidValueRef,mainRefFn:mainRefFn})}function color(model,opt={filled:undefined}){const{markDef:markDef,encoding:encoding,config:config}=model;const{type:markType}=markDef;const filled=opt.filled??getMarkPropOrConfig("filled",markDef,config);const transparentIfNeeded=contains(["bar","point","circle","square","geoshape"],markType)?"transparent":undefined;const defaultFill=getMarkPropOrConfig(filled===true?"color":undefined,markDef,config,{vgChannel:"fill"})??config.mark[filled===true&&"color"]??transparentIfNeeded;const defaultStroke=getMarkPropOrConfig(filled===false?"color":undefined,markDef,config,{vgChannel:"stroke"})??config.mark[filled===false&&"color"];const colorVgChannel=filled?"fill":"stroke";const fillStrokeMarkDefAndConfig={...defaultFill?{fill:signalOrValueRef(defaultFill)}:{},...defaultStroke?{stroke:signalOrValueRef(defaultStroke)}:{}};if(markDef.color&&(filled?markDef.fill:markDef.stroke)){warn(droppingColor("property",{fill:"fill"in markDef,stroke:"stroke"in markDef}))}return{...fillStrokeMarkDefAndConfig,...nonPosition("color",model,{vgChannel:colorVgChannel,defaultValue:filled?defaultFill:defaultStroke}),...nonPosition("fill",model,{defaultValue:encoding.fill?defaultFill:undefined}),...nonPosition("stroke",model,{defaultValue:encoding.stroke?defaultStroke:undefined})}}function zindex(model){const{encoding:encoding,mark:mark}=model;const order=encoding.order;if(!isPathMark(mark)&&isValueDef(order)){return wrapCondition({model:model,channelDef:order,vgChannel:"zindex",mainRefFn:cd=>signalOrValueRef(cd.value),invalidValueRef:undefined})}return{}}function positionOffset({channel:baseChannel,markDef:markDef,encoding:encoding={},model:model,bandPosition:bandPosition}){const channel=`${baseChannel}Offset`;const defaultValue=markDef[channel];const channelDef=encoding[channel];if((channel==="xOffset"||channel==="yOffset")&&channelDef){const ref=midPoint({channel:channel,channelDef:channelDef,markDef:markDef,config:model?.config,scaleName:model.scaleName(channel),scale:model.getScaleComponent(channel),stack:null,defaultRef:signalOrValueRef(defaultValue),bandPosition:bandPosition});return{offsetType:"encoding",offset:ref}}const markDefOffsetValue=markDef[channel];if(markDefOffsetValue){return{offsetType:"visual",offset:markDefOffsetValue}}return{}}function pointPosition(channel,model,{defaultPos:defaultPos,vgChannel:vgChannel}){const{encoding:encoding,markDef:markDef,config:config,stack:stack}=model;const channelDef=encoding[channel];const channel2Def=encoding[getSecondaryRangeChannel(channel)];const scaleName=model.scaleName(channel);const scale=model.getScaleComponent(channel);const{offset:offset,offsetType:offsetType}=positionOffset({channel:channel,markDef:markDef,encoding:encoding,model:model,bandPosition:.5});const defaultRef=pointPositionDefaultRef({model:model,defaultPos:defaultPos,channel:channel,scaleName:scaleName,scale:scale});const valueRef=!channelDef&&isXorY(channel)&&(encoding.latitude||encoding.longitude)?{field:model.getName(channel)}:positionRef({channel:channel,channelDef:channelDef,channel2Def:channel2Def,markDef:markDef,config:config,scaleName:scaleName,scale:scale,stack:stack,offset:offset,defaultRef:defaultRef,bandPosition:offsetType==="encoding"?0:undefined});return valueRef?{[vgChannel||channel]:valueRef}:undefined}function positionRef(params){const{channel:channel,channelDef:channelDef,scaleName:scaleName,stack:stack,offset:offset,markDef:markDef}=params;if(isFieldOrDatumDef(channelDef)&&stack&&channel===stack.fieldChannel){if(isFieldDef(channelDef)){let bandPosition=channelDef.bandPosition;if(bandPosition===undefined&&markDef.type==="text"&&(channel==="radius"||channel==="theta")){bandPosition=.5}if(bandPosition!==undefined){return interpolatedSignalRef({scaleName:scaleName,fieldOrDatumDef:channelDef,startSuffix:"start",bandPosition:bandPosition,offset:offset})}}return valueRefForFieldOrDatumDef(channelDef,scaleName,{suffix:"end"},{offset:offset})}return midPointRefWithPositionInvalidTest(params)}function pointPositionDefaultRef({model:model,defaultPos:defaultPos,channel:channel,scaleName:scaleName,scale:scale}){const{markDef:markDef,config:config}=model;return()=>{const mainChannel=getMainRangeChannel(channel);const vgChannel=getVgPositionChannel(channel);const definedValueOrConfig=getMarkPropOrConfig(channel,markDef,config,{vgChannel:vgChannel});if(definedValueOrConfig!==undefined){return widthHeightValueOrSignalRef(channel,definedValueOrConfig)}switch(defaultPos){case"zeroOrMin":return zeroOrMinOrMaxPosition({scaleName:scaleName,scale:scale,mode:"zeroOrMin",mainChannel:mainChannel,config:config});case"zeroOrMax":return zeroOrMinOrMaxPosition({scaleName:scaleName,scale:scale,mode:{zeroOrMax:{widthSignal:model.width.signal,heightSignal:model.height.signal}},mainChannel:mainChannel,config:config});case"mid":{const sizeRef=model[getSizeChannel(channel)];return{...sizeRef,mult:.5}}}return undefined}}function zeroOrMinOrMaxPosition({mainChannel:mainChannel,config:config,...otherProps}){const scaledValueRef=scaledZeroOrMinOrMax(otherProps);const{mode:mode}=otherProps;if(scaledValueRef){return scaledValueRef}switch(mainChannel){case"radius":{if(mode==="zeroOrMin"){return{value:0}}const{widthSignal:widthSignal,heightSignal:heightSignal}=mode.zeroOrMax;return{signal:`min(${widthSignal},${heightSignal})/2`}}case"theta":return mode==="zeroOrMin"?{value:0}:{signal:"2*PI"};case"x":return mode==="zeroOrMin"?{value:0}:{field:{group:"width"}};case"y":return mode==="zeroOrMin"?{field:{group:"height"}}:{value:0}}}const ALIGNED_X_CHANNEL={left:"x",center:"xc",right:"x2"};const BASELINED_Y_CHANNEL={top:"y",middle:"yc",bottom:"y2"};function vgAlignedPositionChannel(channel,markDef,config,defaultAlign="middle"){if(channel==="radius"||channel==="theta"){return getVgPositionChannel(channel)}const alignChannel=channel==="x"?"align":"baseline";const align=getMarkPropOrConfig(alignChannel,markDef,config);let alignExcludingSignal;if(isSignalRef(align)){warn(rangeMarkAlignmentCannotBeExpression(alignChannel));alignExcludingSignal=undefined}else{alignExcludingSignal=align}if(channel==="x"){return ALIGNED_X_CHANNEL[alignExcludingSignal||(defaultAlign==="top"?"left":"center")]}else{return BASELINED_Y_CHANNEL[alignExcludingSignal||defaultAlign]}}function pointOrRangePosition(channel,model,{defaultPos:defaultPos,defaultPos2:defaultPos2,range:range}){if(range){return rangePosition(channel,model,{defaultPos:defaultPos,defaultPos2:defaultPos2})}return pointPosition(channel,model,{defaultPos:defaultPos})}function rangePosition(channel,model,{defaultPos:defaultPos,defaultPos2:defaultPos2}){const{markDef:markDef,config:config}=model;const channel2=getSecondaryRangeChannel(channel);const sizeChannel=getSizeChannel(channel);const pos2Mixins=pointPosition2OrSize(model,defaultPos2,channel2);const vgChannel=pos2Mixins[sizeChannel]?vgAlignedPositionChannel(channel,markDef,config):getVgPositionChannel(channel);return{...pointPosition(channel,model,{defaultPos:defaultPos,vgChannel:vgChannel}),...pos2Mixins}}function pointPosition2OrSize(model,defaultPos,channel){const{encoding:encoding,mark:mark,markDef:markDef,stack:stack,config:config}=model;const baseChannel=getMainRangeChannel(channel);const sizeChannel=getSizeChannel(channel);const vgChannel=getVgPositionChannel(channel);const channelDef=encoding[baseChannel];const scaleName=model.scaleName(baseChannel);const scale=model.getScaleComponent(baseChannel);const{offset:offset}=channel in encoding||channel in markDef?positionOffset({channel:channel,markDef:markDef,encoding:encoding,model:model}):positionOffset({channel:baseChannel,markDef:markDef,encoding:encoding,model:model});if(!channelDef&&(channel==="x2"||channel==="y2")&&(encoding.latitude||encoding.longitude)){const vgSizeChannel=getSizeChannel(channel);const size=model.markDef[vgSizeChannel];if(size!=null){return{[vgSizeChannel]:{value:size}}}else{return{[vgChannel]:{field:model.getName(channel)}}}}const valueRef=position2Ref({channel:channel,channelDef:channelDef,channel2Def:encoding[channel],markDef:markDef,config:config,scaleName:scaleName,scale:scale,stack:stack,offset:offset,defaultRef:undefined});if(valueRef!==undefined){return{[vgChannel]:valueRef}}return position2orSize(channel,markDef)||position2orSize(channel,{[channel]:getMarkStyleConfig(channel,markDef,config.style),[sizeChannel]:getMarkStyleConfig(sizeChannel,markDef,config.style)})||position2orSize(channel,config[mark])||position2orSize(channel,config.mark)||{[vgChannel]:pointPositionDefaultRef({model:model,defaultPos:defaultPos,channel:channel,scaleName:scaleName,scale:scale})()}}function position2Ref({channel:channel,channelDef:channelDef,channel2Def:channel2Def,markDef:markDef,config:config,scaleName:scaleName,scale:scale,stack:stack,offset:offset,defaultRef:defaultRef}){if(isFieldOrDatumDef(channelDef)&&stack&&channel.charAt(0)===stack.fieldChannel.charAt(0)){return valueRefForFieldOrDatumDef(channelDef,scaleName,{suffix:"start"},{offset:offset})}return midPointRefWithPositionInvalidTest({channel:channel,channelDef:channel2Def,scaleName:scaleName,scale:scale,stack:stack,markDef:markDef,config:config,offset:offset,defaultRef:defaultRef})}function position2orSize(channel,markDef){const sizeChannel=getSizeChannel(channel);const vgChannel=getVgPositionChannel(channel);if(markDef[vgChannel]!==undefined){return{[vgChannel]:widthHeightValueOrSignalRef(channel,markDef[vgChannel])}}else if(markDef[channel]!==undefined){return{[vgChannel]:widthHeightValueOrSignalRef(channel,markDef[channel])}}else if(markDef[sizeChannel]){const dimensionSize=markDef[sizeChannel];if(isRelativeBandSize(dimensionSize)){warn(relativeBandSizeNotSupported(sizeChannel))}else{return{[sizeChannel]:widthHeightValueOrSignalRef(channel,dimensionSize)}}}return undefined}function rectPosition(model,channel){const{config:config,encoding:encoding,markDef:markDef}=model;const mark=markDef.type;const channel2=getSecondaryRangeChannel(channel);const sizeChannel=getSizeChannel(channel);const channelDef=encoding[channel];const channelDef2=encoding[channel2];const scale=model.getScaleComponent(channel);const scaleType=scale?scale.get("type"):undefined;const orient=markDef.orient;const hasSizeDef=encoding[sizeChannel]??encoding.size??getMarkPropOrConfig("size",markDef,config,{vgChannel:sizeChannel});const offsetScaleChannel=getOffsetChannel(channel);const isBarOrTickBand=mark==="bar"&&(channel==="x"?orient==="vertical":orient==="horizontal")||mark==="tick"&&(channel==="y"?orient==="vertical":orient==="horizontal");if(isFieldDef(channelDef)&&(isBinning(channelDef.bin)||isBinned(channelDef.bin)||channelDef.timeUnit&&!channelDef2)&&!(hasSizeDef&&!isRelativeBandSize(hasSizeDef))&&!encoding[offsetScaleChannel]&&!hasDiscreteDomain(scaleType)){return rectBinPosition({fieldDef:channelDef,fieldDef2:channelDef2,channel:channel,model:model})}else if((isFieldOrDatumDef(channelDef)&&hasDiscreteDomain(scaleType)||isBarOrTickBand)&&!channelDef2){return positionAndSize(channelDef,channel,model)}else{return rangePosition(channel,model,{defaultPos:"zeroOrMax",defaultPos2:"zeroOrMin"})}}function defaultSizeRef(sizeChannel,scaleName,scale,config,bandSize,hasFieldDef,mark){if(isRelativeBandSize(bandSize)){if(scale){const scaleType=scale.get("type");if(scaleType==="band"){let bandWidth=`bandwidth('${scaleName}')`;if(bandSize.band!==1){bandWidth=`${bandSize.band} * ${bandWidth}`}const minBandSize=getMarkConfig("minBandSize",{type:mark},config);return{signal:minBandSize?`max(${signalOrStringValue(minBandSize)}, ${bandWidth})`:bandWidth}}else if(bandSize.band!==1){warn(cannotUseRelativeBandSizeWithNonBandScale(scaleType));bandSize=undefined}}else{return{mult:bandSize.band,field:{group:sizeChannel}}}}else if(isSignalRef(bandSize)){return bandSize}else if(bandSize){return{value:bandSize}}if(scale){const scaleRange=scale.get("range");if(isVgRangeStep(scaleRange)&&isNumber$1(scaleRange.step)){return{value:scaleRange.step-2}}}if(!hasFieldDef){const{bandPaddingInner:bandPaddingInner,barBandPaddingInner:barBandPaddingInner,rectBandPaddingInner:rectBandPaddingInner,tickBandPaddingInner:tickBandPaddingInner}=config.scale;const padding=getFirstDefined(bandPaddingInner,mark==="tick"?tickBandPaddingInner:mark==="bar"?barBandPaddingInner:rectBandPaddingInner);if(isSignalRef(padding)){return{signal:`(1 - (${padding.signal})) * ${sizeChannel}`}}else if(isNumber$1(padding)){return{signal:`${1-padding} * ${sizeChannel}`}}}const defaultStep=getViewConfigDiscreteStep(config.view,sizeChannel);return{value:defaultStep-2}}function positionAndSize(fieldDef,channel,model){const{markDef:markDef,encoding:encoding,config:config,stack:stack}=model;const orient=markDef.orient;const scaleName=model.scaleName(channel);const scale=model.getScaleComponent(channel);const vgSizeChannel=getSizeChannel(channel);const channel2=getSecondaryRangeChannel(channel);const offsetScaleChannel=getOffsetChannel(channel);const offsetScaleName=model.scaleName(offsetScaleChannel);const offsetScale=model.getScaleComponent(getOffsetScaleChannel(channel));const useVlSizeChannel=markDef.type==="tick"||orient==="horizontal"&&channel==="y"||orient==="vertical"&&channel==="x";let sizeMixins;if(encoding.size||markDef.size){if(useVlSizeChannel){sizeMixins=nonPosition("size",model,{vgChannel:vgSizeChannel,defaultRef:signalOrValueRef(markDef.size)})}else{warn(cannotApplySizeToNonOrientedMark(markDef.type))}}const hasSizeFromMarkOrEncoding=!!sizeMixins;const bandSize=getBandSize({channel:channel,fieldDef:fieldDef,markDef:markDef,config:config,scaleType:(scale||offsetScale)?.get("type"),useVlSizeChannel:useVlSizeChannel});sizeMixins=sizeMixins||{[vgSizeChannel]:defaultSizeRef(vgSizeChannel,offsetScaleName||scaleName,offsetScale||scale,config,bandSize,!!fieldDef,markDef.type)};const defaultBandAlign=(scale||offsetScale)?.get("type")==="band"&&isRelativeBandSize(bandSize)&&!hasSizeFromMarkOrEncoding?"top":"middle";const vgChannel=vgAlignedPositionChannel(channel,markDef,config,defaultBandAlign);const center=vgChannel==="xc"||vgChannel==="yc";const{offset:offset,offsetType:offsetType}=positionOffset({channel:channel,markDef:markDef,encoding:encoding,model:model,bandPosition:center?.5:0});const posRef=midPointRefWithPositionInvalidTest({channel:channel,channelDef:fieldDef,markDef:markDef,config:config,scaleName:scaleName,scale:scale,stack:stack,offset:offset,defaultRef:pointPositionDefaultRef({model:model,defaultPos:"mid",channel:channel,scaleName:scaleName,scale:scale}),bandPosition:center?offsetType==="encoding"?0:.5:isSignalRef(bandSize)?{signal:`(1-${bandSize})/2`}:isRelativeBandSize(bandSize)?(1-bandSize.band)/2:0});if(vgSizeChannel){return{[vgChannel]:posRef,...sizeMixins}}else{const vgChannel2=getVgPositionChannel(channel2);const sizeRef=sizeMixins[vgSizeChannel];const sizeOffset=offset?{...sizeRef,offset:offset}:sizeRef;return{[vgChannel]:posRef,[vgChannel2]:isArray(posRef)?[posRef[0],{...posRef[1],offset:sizeOffset}]:{...posRef,offset:sizeOffset}}}}function getBinSpacing(channel,spacing,reverse,axisTranslate,offset,minBandSize,bandSizeExpr){if(isPolarPositionChannel(channel)){return 0}const isEnd=channel==="x"||channel==="y2";const spacingOffset=isEnd?-spacing/2:spacing/2;if(isSignalRef(reverse)||isSignalRef(offset)||isSignalRef(axisTranslate)||minBandSize){const reverseExpr=signalOrStringValue(reverse);const offsetExpr=signalOrStringValue(offset);const axisTranslateExpr=signalOrStringValue(axisTranslate);const minBandSizeExpr=signalOrStringValue(minBandSize);const sign=isEnd?"":"-";const spacingAndSizeOffset=minBandSize?`(${bandSizeExpr} < ${minBandSizeExpr} ? ${sign}0.5 * (${minBandSizeExpr} - (${bandSizeExpr})) : ${spacingOffset})`:spacingOffset;const t=axisTranslateExpr?`${axisTranslateExpr} + `:"";const r=reverseExpr?`(${reverseExpr} ? -1 : 1) * `:"";const o=offsetExpr?`(${offsetExpr} + ${spacingAndSizeOffset})`:spacingAndSizeOffset;return{signal:t+r+o}}else{offset=offset||0;return axisTranslate+(reverse?-offset-spacingOffset:+offset+spacingOffset)}}function rectBinPosition({fieldDef:fieldDef,fieldDef2:fieldDef2,channel:channel,model:model}){const{config:config,markDef:markDef,encoding:encoding}=model;const scale=model.getScaleComponent(channel);const scaleName=model.scaleName(channel);const scaleType=scale?scale.get("type"):undefined;const reverse=scale.get("reverse");const bandSize=getBandSize({channel:channel,fieldDef:fieldDef,markDef:markDef,config:config,scaleType:scaleType});const axis=model.component.axes[channel]?.[0];const axisTranslate=axis?.get("translate")??.5;const spacing=isXorY(channel)?getMarkPropOrConfig("binSpacing",markDef,config)??0:0;const channel2=getSecondaryRangeChannel(channel);const vgChannel=getVgPositionChannel(channel);const vgChannel2=getVgPositionChannel(channel2);const minBandSize=getMarkConfig("minBandSize",markDef,config);const{offset:offset}=positionOffset({channel:channel,markDef:markDef,encoding:encoding,model:model,bandPosition:0});const{offset:offset2}=positionOffset({channel:channel2,markDef:markDef,encoding:encoding,model:model,bandPosition:0});const bandSizeExpr=binSizeExpr({fieldDef:fieldDef,scaleName:scaleName});const binSpacingOffset=getBinSpacing(channel,spacing,reverse,axisTranslate,offset,minBandSize,bandSizeExpr);const binSpacingOffset2=getBinSpacing(channel2,spacing,reverse,axisTranslate,offset2??offset,minBandSize,bandSizeExpr);const bandPositionForBandSize=isSignalRef(bandSize)?{signal:`(1-${bandSize.signal})/2`}:isRelativeBandSize(bandSize)?(1-bandSize.band)/2:.5;const bandPosition=getBandPosition({fieldDef:fieldDef,fieldDef2:fieldDef2,markDef:markDef,config:config});if(isBinning(fieldDef.bin)||fieldDef.timeUnit){const useRectOffsetField=fieldDef.timeUnit&&bandPosition!==.5;return{[vgChannel2]:rectBinRef({fieldDef:fieldDef,scaleName:scaleName,bandPosition:bandPositionForBandSize,offset:binSpacingOffset2,useRectOffsetField:useRectOffsetField}),[vgChannel]:rectBinRef({fieldDef:fieldDef,scaleName:scaleName,bandPosition:isSignalRef(bandPositionForBandSize)?{signal:`1-${bandPositionForBandSize.signal}`}:1-bandPositionForBandSize,offset:binSpacingOffset,useRectOffsetField:useRectOffsetField})}}else if(isBinned(fieldDef.bin)){const startRef=valueRefForFieldOrDatumDef(fieldDef,scaleName,{},{offset:binSpacingOffset2});if(isFieldDef(fieldDef2)){return{[vgChannel2]:startRef,[vgChannel]:valueRefForFieldOrDatumDef(fieldDef2,scaleName,{},{offset:binSpacingOffset})}}else if(isBinParams(fieldDef.bin)&&fieldDef.bin.step){return{[vgChannel2]:startRef,[vgChannel]:{signal:`scale("${scaleName}", ${vgField(fieldDef,{expr:"datum"})} + ${fieldDef.bin.step})`,offset:binSpacingOffset}}}}warn(channelRequiredForBinned(channel2));return undefined}function rectBinRef({fieldDef:fieldDef,scaleName:scaleName,bandPosition:bandPosition,offset:offset,useRectOffsetField:useRectOffsetField}){return interpolatedSignalRef({scaleName:scaleName,fieldOrDatumDef:fieldDef,bandPosition:bandPosition,offset:offset,...useRectOffsetField?{startSuffix:OFFSETTED_RECT_START_SUFFIX,endSuffix:OFFSETTED_RECT_END_SUFFIX}:{}})}const ALWAYS_IGNORE=new Set(["aria","width","height"]);function baseEncodeEntry(model,ignore){const{fill:fill=undefined,stroke:stroke=undefined}=ignore.color==="include"?color(model):{};return{...markDefProperties(model.markDef,ignore),...colorRef("fill",fill),...colorRef("stroke",stroke),...nonPosition("opacity",model),...nonPosition("fillOpacity",model),...nonPosition("strokeOpacity",model),...nonPosition("strokeWidth",model),...nonPosition("strokeDash",model),...zindex(model),...tooltip(model),...text$1(model,"href"),...aria(model)}}function colorRef(channel,valueRef){return valueRef?{[channel]:valueRef}:{}}function markDefProperties(mark,ignore){return VG_MARK_CONFIGS.reduce(((m,prop)=>{if(!ALWAYS_IGNORE.has(prop)&&hasProperty(mark,prop)&&ignore[prop]!=="ignore"){m[prop]=signalOrValueRef(mark[prop])}return m}),{})}function defined(model){const{config:config,markDef:markDef}=model;const fieldsToBreakPath=new Set;model.forEachFieldDef(((fieldDef,channel)=>{let scaleType;if(!isScaleChannel(channel)||!(scaleType=model.getScaleType(channel))){return}const isCountAggregate=isCountingAggregateOp(fieldDef.aggregate);const invalidDataMode=getScaleInvalidDataMode({scaleChannel:channel,markDef:markDef,config:config,scaleType:scaleType,isCountAggregate:isCountAggregate});if(shouldBreakPath(invalidDataMode)){const field=model.vgField(channel,{expr:"datum",binSuffix:model.stack?.impute?"mid":undefined});if(field){fieldsToBreakPath.add(field)}}}));if(fieldsToBreakPath.size>0){const signal=[...fieldsToBreakPath].map((field=>fieldValidPredicate(field,true))).join(" && ");return{defined:{signal:signal}}}return undefined}function valueIfDefined(prop,value){if(value!==undefined){return{[prop]:signalOrValueRef(value)}}return undefined}const VORONOI="voronoi";const nearest={defined:selCmpt=>selCmpt.type==="point"&&selCmpt.nearest,parse:(model,selCmpt)=>{if(selCmpt.events){for(const s of selCmpt.events){s.markname=model.getName(VORONOI)}}},marks:(model,selCmpt,marks)=>{const{x:x,y:y}=selCmpt.project.hasChannel;const markType=model.mark;if(isPathMark(markType)){warn(nearestNotSupportForContinuous(markType));return marks}const cellDef={name:model.getName(VORONOI),type:"path",interactive:true,from:{data:model.getName("marks")},encode:{update:{fill:{value:"transparent"},strokeWidth:{value:.35},stroke:{value:"transparent"},isVoronoi:{value:true},...tooltip(model,{reactiveGeom:true})}},transform:[{type:"voronoi",x:{expr:x||!y?"datum.datum.x || 0":"0"},y:{expr:y||!x?"datum.datum.y || 0":"0"},size:[model.getSizeSignalRef("width"),model.getSizeSignalRef("height")]}]};let index=0;let exists=false;marks.forEach(((mark,i)=>{const name=mark.name??"";if(name===model.component.mark[0].name){index=i}else if(name.includes(VORONOI)){exists=true}}));if(!exists){marks.splice(index+1,0,cellDef)}return marks}};const inputBindings={defined:selCmpt=>selCmpt.type==="point"&&selCmpt.resolve==="global"&&selCmpt.bind&&selCmpt.bind!=="scales"&&!isLegendBinding(selCmpt.bind),parse:(model,selCmpt,selDef)=>disableDirectManipulation(selCmpt,selDef),topLevelSignals:(model,selCmpt,signals)=>{const name=selCmpt.name;const proj=selCmpt.project;const bind=selCmpt.bind;const init=selCmpt.init&&selCmpt.init[0];const datum=nearest.defined(selCmpt)?"(item().isVoronoi ? datum.datum : datum)":"datum";proj.items.forEach(((p,i)=>{const sgname=varName(`${name}_${p.field}`);const hasSignal=signals.filter((s=>s.name===sgname));if(!hasSignal.length){signals.unshift({name:sgname,...init?{init:assembleInit(init[i])}:{value:null},on:selCmpt.events?[{events:selCmpt.events,update:`datum && item().mark.marktype !== 'group' ? ${datum}[${$(p.field)}] : null`}]:[],bind:bind[p.field]??bind[p.channel]??bind})}}));return signals},signals:(model,selCmpt,signals)=>{const name=selCmpt.name;const proj=selCmpt.project;const signal=signals.find((s=>s.name===name+TUPLE));const fields=name+TUPLE_FIELDS;const values=proj.items.map((p=>varName(`${name}_${p.field}`)));const valid=values.map((v=>`${v} !== null`)).join(" && ");if(values.length){signal.update=`${valid} ? {fields: ${fields}, values: [${values.join(", ")}]} : null`}delete signal.value;delete signal.on;return signals}};const TOGGLE="_toggle";const toggle={defined:selCmpt=>selCmpt.type==="point"&&!!selCmpt.toggle,signals:(model,selCmpt,signals)=>signals.concat({name:selCmpt.name+TOGGLE,value:false,on:[{events:selCmpt.events,update:selCmpt.toggle}]}),modifyExpr:(model,selCmpt)=>{const tpl=selCmpt.name+TUPLE;const signal=selCmpt.name+TOGGLE;return`${signal} ? null : ${tpl}, `+(selCmpt.resolve==="global"?`${signal} ? null : true, `:`${signal} ? null : {unit: ${unitName(model)}}, `)+`${signal} ? ${tpl} : null`}};const clear={defined:selCmpt=>selCmpt.clear!==undefined&&selCmpt.clear!==false,parse:(model,selCmpt)=>{if(selCmpt.clear){selCmpt.clear=isString(selCmpt.clear)?eventSelector(selCmpt.clear,"view"):selCmpt.clear}},topLevelSignals:(model,selCmpt,signals)=>{if(inputBindings.defined(selCmpt)){for(const proj of selCmpt.project.items){const idx=signals.findIndex((n=>n.name===varName(`${selCmpt.name}_${proj.field}`)));if(idx!==-1){signals[idx].on.push({events:selCmpt.clear,update:"null"})}}}return signals},signals:(model,selCmpt,signals)=>{function addClear(idx,update){if(idx!==-1&&signals[idx].on){signals[idx].on.push({events:selCmpt.clear,update:update})}}if(selCmpt.type==="interval"){for(const proj of selCmpt.project.items){const vIdx=signals.findIndex((n=>n.name===proj.signals.visual));addClear(vIdx,"[0, 0]");if(vIdx===-1){const dIdx=signals.findIndex((n=>n.name===proj.signals.data));addClear(dIdx,"null")}}}else{let tIdx=signals.findIndex((n=>n.name===selCmpt.name+TUPLE));addClear(tIdx,"null");if(toggle.defined(selCmpt)){tIdx=signals.findIndex((n=>n.name===selCmpt.name+TOGGLE));addClear(tIdx,"false")}}return signals}};const legendBindings={defined:selCmpt=>{const spec=selCmpt.resolve==="global"&&selCmpt.bind&&isLegendBinding(selCmpt.bind);const projLen=selCmpt.project.items.length===1&&selCmpt.project.items[0].field!==SELECTION_ID;if(spec&&!projLen){warn(LEGEND_BINDINGS_MUST_HAVE_PROJECTION)}return spec&&projLen},parse:(model,selCmpt,selDef)=>{const selDef_=duplicate(selDef);selDef_.select=isString(selDef_.select)?{type:selDef_.select,toggle:selCmpt.toggle}:{...selDef_.select,toggle:selCmpt.toggle};disableDirectManipulation(selCmpt,selDef_);if(isObject(selDef.select)&&(selDef.select.on||selDef.select.clear)){const legendFilter='event.item && indexof(event.item.mark.role, "legend") < 0';for(const evt of selCmpt.events){evt.filter=array$5(evt.filter??[]);if(!evt.filter.includes(legendFilter)){evt.filter.push(legendFilter)}}}const evt=isLegendStreamBinding(selCmpt.bind)?selCmpt.bind.legend:"click";const stream=isString(evt)?eventSelector(evt,"view"):array$5(evt);selCmpt.bind={legend:{merge:stream}}},topLevelSignals:(model,selCmpt,signals)=>{const selName=selCmpt.name;const stream=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend;const markName=name=>s=>{const ds=duplicate(s);ds.markname=name;return ds};for(const proj of selCmpt.project.items){if(!proj.hasLegend)continue;const prefix=`${varName(proj.field)}_legend`;const sgName=`${selName}_${prefix}`;const hasSignal=signals.filter((s=>s.name===sgName));if(hasSignal.length===0){const events=stream.merge.map(markName(`${prefix}_symbols`)).concat(stream.merge.map(markName(`${prefix}_labels`))).concat(stream.merge.map(markName(`${prefix}_entries`)));signals.unshift({name:sgName,...!selCmpt.init?{value:null}:{},on:[{events:events,update:"isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",force:true},{events:stream.merge,update:`!event.item || !datum ? null : ${sgName}`,force:true}]})}}return signals},signals:(model,selCmpt,signals)=>{const name=selCmpt.name;const proj=selCmpt.project;const tuple=signals.find((s=>s.name===name+TUPLE));const fields=name+TUPLE_FIELDS;const values=proj.items.filter((p=>p.hasLegend)).map((p=>varName(`${name}_${varName(p.field)}_legend`)));const valid=values.map((v=>`${v} !== null`)).join(" && ");const update=`${valid} ? {fields: ${fields}, values: [${values.join(", ")}]} : null`;if(selCmpt.events&&values.length>0){tuple.on.push({events:values.map((signal=>({signal:signal}))),update:update})}else if(values.length>0){tuple.update=update;delete tuple.value;delete tuple.on}const toggle=signals.find((s=>s.name===name+TOGGLE));const events=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend;if(toggle){if(!selCmpt.events)toggle.on[0].events=events;else toggle.on.push({...toggle.on[0],events:events})}return signals}};function parseInteractiveLegend(model,channel,legendCmpt){const field=model.fieldDef(channel)?.field;for(const selCmpt of vals(model.component.selection??{})){const proj=selCmpt.project.hasField[field]??selCmpt.project.hasChannel[channel];if(proj&&legendBindings.defined(selCmpt)){const legendSelections=legendCmpt.get("selections")??[];legendSelections.push(selCmpt.name);legendCmpt.set("selections",legendSelections,false);proj.hasLegend=true}}}const ANCHOR$1="_translate_anchor";const DELTA$1="_translate_delta";const translate={defined:selCmpt=>selCmpt.type==="interval"&&selCmpt.translate,signals:(model,selCmpt,signals)=>{const name=selCmpt.name;const boundScales=scaleBindings.defined(selCmpt);const anchor=name+ANCHOR$1;const{x:x,y:y}=selCmpt.project.hasChannel;let events=eventSelector(selCmpt.translate,"scope");if(!boundScales){events=events.map((e=>(e.between[0].markname=name+BRUSH,e)))}signals.push({name:anchor,value:{},on:[{events:events.map((e=>e.between[0])),update:"{x: x(unit), y: y(unit)"+(x!==undefined?`, extent_x: ${boundScales?domain(model,X):`slice(${x.signals.visual})`}`:"")+(y!==undefined?`, extent_y: ${boundScales?domain(model,Y):`slice(${y.signals.visual})`}`:"")+"}"}]},{name:name+DELTA$1,value:{},on:[{events:events,update:`{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`}]});if(x!==undefined){onDelta$1(model,selCmpt,x,"width",signals)}if(y!==undefined){onDelta$1(model,selCmpt,y,"height",signals)}return signals}};function onDelta$1(model,selCmpt,proj,size,signals){const name=selCmpt.name;const anchor=name+ANCHOR$1;const delta=name+DELTA$1;const channel=proj.channel;const boundScales=scaleBindings.defined(selCmpt);const signal=signals.find((s=>s.name===proj.signals[boundScales?"data":"visual"]));const sizeSg=model.getSizeSignalRef(size).signal;const scaleCmpt=model.getScaleComponent(channel);const scaleType=scaleCmpt&&scaleCmpt.get("type");const reversed=scaleCmpt&&scaleCmpt.get("reverse");const sign=!boundScales?"":channel===X?reversed?"":"-":reversed?"-":"";const extent=`${anchor}.extent_${channel}`;const offset=`${sign}${delta}.${channel} / ${boundScales?`${sizeSg}`:`span(${extent})`}`;const panFn=!boundScales||!scaleCmpt?"panLinear":scaleType==="log"?"panLog":scaleType==="symlog"?"panSymlog":scaleType==="pow"?"panPow":"panLinear";const arg=!boundScales?"":scaleType==="pow"?`, ${scaleCmpt.get("exponent")??1}`:scaleType==="symlog"?`, ${scaleCmpt.get("constant")??1}`:"";const update=`${panFn}(${extent}, ${offset}${arg})`;signal.on.push({events:{signal:delta},update:boundScales?update:`clampRange(${update}, 0, ${sizeSg})`})}const ANCHOR="_zoom_anchor";const DELTA="_zoom_delta";const zoom={defined:selCmpt=>selCmpt.type==="interval"&&selCmpt.zoom,signals:(model,selCmpt,signals)=>{const name=selCmpt.name;const boundScales=scaleBindings.defined(selCmpt);const delta=name+DELTA;const{x:x,y:y}=selCmpt.project.hasChannel;const sx=$(model.scaleName(X));const sy=$(model.scaleName(Y));let events=eventSelector(selCmpt.zoom,"scope");if(!boundScales){events=events.map((e=>(e.markname=name+BRUSH,e)))}signals.push({name:name+ANCHOR,on:[{events:events,update:!boundScales?`{x: x(unit), y: y(unit)}`:"{"+[sx?`x: invert(${sx}, x(unit))`:"",sy?`y: invert(${sy}, y(unit))`:""].filter((expr=>expr)).join(", ")+"}"}]},{name:delta,on:[{events:events,force:true,update:"pow(1.001, event.deltaY * pow(16, event.deltaMode))"}]});if(x!==undefined){onDelta(model,selCmpt,x,"width",signals)}if(y!==undefined){onDelta(model,selCmpt,y,"height",signals)}return signals}};function onDelta(model,selCmpt,proj,size,signals){const name=selCmpt.name;const channel=proj.channel;const boundScales=scaleBindings.defined(selCmpt);const signal=signals.find((s=>s.name===proj.signals[boundScales?"data":"visual"]));const sizeSg=model.getSizeSignalRef(size).signal;const scaleCmpt=model.getScaleComponent(channel);const scaleType=scaleCmpt&&scaleCmpt.get("type");const base=boundScales?domain(model,channel):signal.name;const delta=name+DELTA;const anchor=`${name}${ANCHOR}.${channel}`;const zoomFn=!boundScales||!scaleCmpt?"zoomLinear":scaleType==="log"?"zoomLog":scaleType==="symlog"?"zoomSymlog":scaleType==="pow"?"zoomPow":"zoomLinear";const arg=!boundScales?"":scaleType==="pow"?`, ${scaleCmpt.get("exponent")??1}`:scaleType==="symlog"?`, ${scaleCmpt.get("constant")??1}`:"";const update=`${zoomFn}(${base}, ${anchor}, ${delta}${arg})`;signal.on.push({events:{signal:delta},update:boundScales?update:`clampRange(${update}, 0, ${sizeSg})`})}const STORE="_store";const TUPLE="_tuple";const MODIFY="_modify";const VL_SELECTION_RESOLVE="vlSelectionResolve";const selectionCompilers=[point$1,interval,project,toggle,inputBindings,scaleBindings,legendBindings,clear,translate,zoom,nearest];function getFacetModel(model){let parent=model.parent;while(parent){if(isFacetModel(parent))break;parent=parent.parent}return parent}function unitName(model,{escape:escape}={escape:true}){let name=escape?$(model.name):model.name;const facetModel=getFacetModel(model);if(facetModel){const{facet:facet}=facetModel;for(const channel of FACET_CHANNELS){if(facet[channel]){name+=` + '__facet_${channel}_' + (facet[${$(facetModel.vgField(channel))}])`}}}return name}function requiresSelectionId(model){return vals(model.component.selection??{}).reduce(((identifier,selCmpt)=>identifier||selCmpt.project.hasSelectionId),false)}function disableDirectManipulation(selCmpt,selDef){if(isString(selDef.select)||!selDef.select.on)delete selCmpt.events;if(isString(selDef.select)||!selDef.select.clear)delete selCmpt.clear;if(isString(selDef.select)||!selDef.select.toggle)delete selCmpt.toggle}function getName(node){const name=[];if(node.type==="Identifier"){return[node.name]}if(node.type==="Literal"){return[node.value]}if(node.type==="MemberExpression"){name.push(...getName(node.object));name.push(...getName(node.property))}return name}function startsWithDatum(node){if(node.object.type==="MemberExpression"){return startsWithDatum(node.object)}return node.object.name==="datum"}function getDependentFields(expression){const ast=parser$1(expression);const dependents=new Set;ast.visit((node=>{if(node.type==="MemberExpression"&&startsWithDatum(node)){dependents.add(getName(node).slice(1).join("."))}}));return dependents}class FilterNode extends DataFlowNode{clone(){return new FilterNode(null,this.model,duplicate(this.filter))}constructor(parent,model,filter){super(parent);this.model=model;this.filter=filter;this.expr=expression(this.model,this.filter,this);this._dependentFields=getDependentFields(this.expr)}dependentFields(){return this._dependentFields}producedFields(){return new Set}assemble(){return{type:"filter",expr:this.expr}}hash(){return`Filter ${this.expr}`}}function parseUnitSelection(model,selDefs){const selCmpts={};const selectionConfig=model.config.selection;if(!selDefs||!selDefs.length)return selCmpts;for(const def of selDefs){const name=varName(def.name);const selDef=def.select;const type=isString(selDef)?selDef:selDef.type;const defaults=isObject(selDef)?duplicate(selDef):{type:type};const cfg=selectionConfig[type];for(const key in cfg){if(key==="fields"||key==="encodings"){continue}if(key==="mark"){defaults.mark={...cfg.mark,...defaults.mark}}if(defaults[key]===undefined||defaults[key]===true){defaults[key]=duplicate(cfg[key]??defaults[key])}}const selCmpt=selCmpts[name]={...defaults,name:name,type:type,init:def.value,bind:def.bind,events:isString(defaults.on)?eventSelector(defaults.on,"scope"):array$5(duplicate(defaults.on))};const def_=duplicate(def);for(const c of selectionCompilers){if(c.defined(selCmpt)&&c.parse){c.parse(model,selCmpt,def_)}}}return selCmpts}function parseSelectionPredicate(model,pred,dfnode,datum="datum"){const name=isString(pred)?pred:pred.param;const vname=varName(name);const store=$(vname+STORE);let selCmpt;try{selCmpt=model.getSelectionComponent(vname,name)}catch(e){return`!!${vname}`}if(selCmpt.project.timeUnit){const child=dfnode??model.component.data.raw;const tunode=selCmpt.project.timeUnit.clone();if(child.parent){tunode.insertAsParentOf(child)}else{child.parent=tunode}}const fn=selCmpt.project.hasSelectionId?"vlSelectionIdTest(":"vlSelectionTest(";const resolve=selCmpt.resolve==="global"?")":`, ${$(selCmpt.resolve)})`;const test=`${fn}${store}, ${datum}${resolve}`;const length=`length(data(${store}))`;return pred.empty===false?`${length} && ${test}`:`!${length} || ${test}`}function parseSelectionExtent(model,name,extent){const vname=varName(name);const encoding=extent.encoding;let field=extent.field;let selCmpt;try{selCmpt=model.getSelectionComponent(vname,name)}catch(e){return vname}if(!encoding&&!field){field=selCmpt.project.items[0].field;if(selCmpt.project.items.length>1){warn('A "field" or "encoding" must be specified when using a selection as a scale domain. '+`Using "field": ${$(field)}.`)}}else if(encoding&&!field){const encodings=selCmpt.project.items.filter((p=>p.channel===encoding));if(!encodings.length||encodings.length>1){field=selCmpt.project.items[0].field;warn((!encodings.length?"No ":"Multiple ")+`matching ${$(encoding)} encoding found for selection ${$(extent.param)}. `+`Using "field": ${$(field)}.`)}else{field=encodings[0].field}}return`${selCmpt.name}[${$(replacePathInField(field))}]`}function materializeSelections(model,main){for(const[selection,selCmpt]of entries$1(model.component.selection??{})){const lookupName=model.getName(`lookup_${selection}`);model.component.data.outputNodes[lookupName]=selCmpt.materialized=new OutputNode(new FilterNode(main,model,{param:selection}),lookupName,DataSourceType.Lookup,model.component.data.outputNodeRefCounts)}}function expression(model,filterOp,node){return logicalExpr(filterOp,(predicate=>{if(isString(predicate)){return predicate}else if(isSelectionPredicate(predicate)){return parseSelectionPredicate(model,predicate,node)}else{return fieldFilterExpression(predicate)}}))}function assembleTitle(title,config){if(!title){return undefined}if(isArray(title)&&!isText(title)){return title.map((fieldDef=>defaultTitle(fieldDef,config))).join(", ")}return title}function setAxisEncode(axis,part,vgProp,vgRef){var _a,_b;axis.encode??(axis.encode={});(_a=axis.encode)[part]??(_a[part]={});(_b=axis.encode[part]).update??(_b.update={});axis.encode[part].update[vgProp]=vgRef}function assembleAxis(axisCmpt,kind,config,opt={header:false}){const{disable:disable,orient:orient,scale:scale,labelExpr:labelExpr,title:title,zindex:zindex,...axis}=axisCmpt.combine();if(disable){return undefined}for(const p in axis){const prop=p;const propType=AXIS_PROPERTY_TYPE[prop];const propValue=axis[prop];if(propType&&propType!==kind&&propType!=="both"){delete axis[prop]}else if(isConditionalAxisValue(propValue)){const{condition:condition,...valueOrSignalRef}=propValue;const conditions=array$5(condition);const propIndex=CONDITIONAL_AXIS_PROP_INDEX[prop];if(propIndex){const{vgProp:vgProp,part:part}=propIndex;const vgRef=[...conditions.map((c=>{const{test:test,...valueOrSignalCRef}=c;return{test:expression(null,test),...valueOrSignalCRef}})),valueOrSignalRef];setAxisEncode(axis,part,vgProp,vgRef);delete axis[prop]}else if(propIndex===null){const signalRef={signal:conditions.map((c=>{const{test:test,...valueOrSignalCRef}=c;return`${expression(null,test)} ? ${exprFromValueRefOrSignalRef(valueOrSignalCRef)} : `})).join("")+exprFromValueRefOrSignalRef(valueOrSignalRef)};axis[prop]=signalRef}}else if(isSignalRef(propValue)){const propIndex=CONDITIONAL_AXIS_PROP_INDEX[prop];if(propIndex){const{vgProp:vgProp,part:part}=propIndex;setAxisEncode(axis,part,vgProp,propValue);delete axis[prop]}}if(contains(["labelAlign","labelBaseline"],prop)&&axis[prop]===null){delete axis[prop]}}if(kind==="grid"){if(!axis.grid){return undefined}if(axis.encode){const{grid:grid}=axis.encode;axis.encode={...grid?{grid:grid}:{}};if(isEmpty(axis.encode)){delete axis.encode}}return{scale:scale,orient:orient,...axis,domain:false,labels:false,aria:false,maxExtent:0,minExtent:0,ticks:false,zindex:getFirstDefined(zindex,0)}}else{if(!opt.header&&axisCmpt.mainExtracted){return undefined}if(labelExpr!==undefined){let expr=labelExpr;if(axis.encode?.labels?.update&&isSignalRef(axis.encode.labels.update.text)){expr=replaceAll(labelExpr,"datum.label",axis.encode.labels.update.text.signal)}setAxisEncode(axis,"labels","text",{signal:expr})}if(axis.labelAlign===null){delete axis.labelAlign}if(axis.encode){for(const part of AXIS_PARTS){if(!axisCmpt.hasAxisPart(part)){delete axis.encode[part]}}if(isEmpty(axis.encode)){delete axis.encode}}const titleString=assembleTitle(title,config);return{scale:scale,orient:orient,grid:false,...titleString?{title:titleString}:{},...axis,...config.aria===false?{aria:false}:{},zindex:getFirstDefined(zindex,0)}}}function assembleAxisSignals(model){const{axes:axes}=model.component;const signals=[];for(const channel of POSITION_SCALE_CHANNELS){if(axes[channel]){for(const axis of axes[channel]){if(!axis.get("disable")&&!axis.get("gridScale")){const sizeType=channel==="x"?"height":"width";const update=model.getSizeSignalRef(sizeType).signal;if(sizeType!==update){signals.push({name:sizeType,update:update})}}}}}return signals}function assembleAxes(axisComponents,config){const{x:x=[],y:y=[]}=axisComponents;return[...x.map((a=>assembleAxis(a,"grid",config))),...y.map((a=>assembleAxis(a,"grid",config))),...x.map((a=>assembleAxis(a,"main",config))),...y.map((a=>assembleAxis(a,"main",config)))].filter((a=>a))}function getAxisConfigFromConfigTypes(configTypes,config,channel,orient){return Object.assign.apply(null,[{},...configTypes.map((configType=>{if(configType==="axisOrient"){const orient1=channel==="x"?"bottom":"left";const orientConfig1=config[channel==="x"?"axisBottom":"axisLeft"]||{};const orientConfig2=config[channel==="x"?"axisTop":"axisRight"]||{};const props=new Set([...keys(orientConfig1),...keys(orientConfig2)]);const conditionalOrientAxisConfig={};for(const prop of props.values()){conditionalOrientAxisConfig[prop]={signal:`${orient["signal"]} === "${orient1}" ? ${signalOrStringValue(orientConfig1[prop])} : ${signalOrStringValue(orientConfig2[prop])}`}}return conditionalOrientAxisConfig}return config[configType]}))])}function getAxisConfigs(channel,scaleType,orient,config){const typeBasedConfigTypes=scaleType==="band"?["axisDiscrete","axisBand"]:scaleType==="point"?["axisDiscrete","axisPoint"]:isQuantitative(scaleType)?["axisQuantitative"]:scaleType==="time"||scaleType==="utc"?["axisTemporal"]:[];const axisChannel=channel==="x"?"axisX":"axisY";const axisOrient=isSignalRef(orient)?"axisOrient":`axis${titleCase(orient)}`;const vlOnlyConfigTypes=[...typeBasedConfigTypes,...typeBasedConfigTypes.map((c=>axisChannel+c.substr(4)))];const vgConfigTypes=["axis",axisOrient,axisChannel];return{vlOnlyAxisConfig:getAxisConfigFromConfigTypes(vlOnlyConfigTypes,config,channel,orient),vgAxisConfig:getAxisConfigFromConfigTypes(vgConfigTypes,config,channel,orient),axisConfigStyle:getAxisConfigStyle([...vgConfigTypes,...vlOnlyConfigTypes],config)}}function getAxisConfigStyle(axisConfigTypes,config){const toMerge=[{}];for(const configType of axisConfigTypes){let style=config[configType]?.style;if(style){style=array$5(style);for(const s of style){toMerge.push(config.style[s])}}}return Object.assign.apply(null,toMerge)}function getAxisConfig(property,styleConfigIndex,style,axisConfigs={}){const styleConfig=getStyleConfig(property,style,styleConfigIndex);if(styleConfig!==undefined){return{configFrom:"style",configValue:styleConfig}}for(const configFrom of["vlOnlyAxisConfig","vgAxisConfig","axisConfigStyle"]){if(axisConfigs[configFrom]?.[property]!==undefined){return{configFrom:configFrom,configValue:axisConfigs[configFrom][property]}}}return{}}const axisRules={scale:({model:model,channel:channel})=>model.scaleName(channel),format:({format:format})=>format,formatType:({formatType:formatType})=>formatType,grid:({fieldOrDatumDef:fieldOrDatumDef,axis:axis,scaleType:scaleType})=>axis.grid??defaultGrid(scaleType,fieldOrDatumDef),gridScale:({model:model,channel:channel})=>gridScale(model,channel),labelAlign:({axis:axis,labelAngle:labelAngle,orient:orient,channel:channel})=>axis.labelAlign||defaultLabelAlign(labelAngle,orient,channel),labelAngle:({labelAngle:labelAngle})=>labelAngle,labelBaseline:({axis:axis,labelAngle:labelAngle,orient:orient,channel:channel})=>axis.labelBaseline||defaultLabelBaseline(labelAngle,orient,channel),labelFlush:({axis:axis,fieldOrDatumDef:fieldOrDatumDef,channel:channel})=>axis.labelFlush??defaultLabelFlush(fieldOrDatumDef.type,channel),labelOverlap:({axis:axis,fieldOrDatumDef:fieldOrDatumDef,scaleType:scaleType})=>axis.labelOverlap??defaultLabelOverlap$1(fieldOrDatumDef.type,scaleType,isFieldDef(fieldOrDatumDef)&&!!fieldOrDatumDef.timeUnit,isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.sort:undefined),orient:({orient:orient})=>orient,tickCount:({channel:channel,model:model,axis:axis,fieldOrDatumDef:fieldOrDatumDef,scaleType:scaleType})=>{const sizeType=channel==="x"?"width":channel==="y"?"height":undefined;const size=sizeType?model.getSizeSignalRef(sizeType):undefined;return axis.tickCount??defaultTickCount({fieldOrDatumDef:fieldOrDatumDef,scaleType:scaleType,size:size,values:axis.values})},tickMinStep:defaultTickMinStep,title:({axis:axis,model:model,channel:channel})=>{if(axis.title!==undefined){return axis.title}const fieldDefTitle=getFieldDefTitle(model,channel);if(fieldDefTitle!==undefined){return fieldDefTitle}const fieldDef=model.typedFieldDef(channel);const channel2=channel==="x"?"x2":"y2";const fieldDef2=model.fieldDef(channel2);return mergeTitleFieldDefs(fieldDef?[toFieldDefBase(fieldDef)]:[],isFieldDef(fieldDef2)?[toFieldDefBase(fieldDef2)]:[])},values:({axis:axis,fieldOrDatumDef:fieldOrDatumDef})=>values$1(axis,fieldOrDatumDef),zindex:({axis:axis,fieldOrDatumDef:fieldOrDatumDef,mark:mark})=>axis.zindex??defaultZindex(mark,fieldOrDatumDef)};function defaultGrid(scaleType,fieldDef){return!hasDiscreteDomain(scaleType)&&isFieldDef(fieldDef)&&!isBinning(fieldDef?.bin)&&!isBinned(fieldDef?.bin)}function gridScale(model,channel){const gridChannel=channel==="x"?"y":"x";if(model.getScaleComponent(gridChannel)){return model.scaleName(gridChannel)}return undefined}function getLabelAngle(fieldOrDatumDef,axis,channel,styleConfig,axisConfigs){const labelAngle=axis?.labelAngle;if(labelAngle!==undefined){return isSignalRef(labelAngle)?labelAngle:normalizeAngle(labelAngle)}else{const{configValue:angle}=getAxisConfig("labelAngle",styleConfig,axis?.style,axisConfigs);if(angle!==undefined){return normalizeAngle(angle)}else{if(channel===X&&contains([NOMINAL,ORDINAL],fieldOrDatumDef.type)&&!(isFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.timeUnit)){return 270}return undefined}}}function normalizeAngleExpr(angle){return`(((${angle.signal} % 360) + 360) % 360)`}function defaultLabelBaseline(angle,orient,channel,alwaysIncludeMiddle){if(angle!==undefined){if(channel==="x"){if(isSignalRef(angle)){const a=normalizeAngleExpr(angle);const orientIsTop=isSignalRef(orient)?`(${orient.signal} === "top")`:orient==="top";return{signal:`(45 < ${a} && ${a} < 135) || (225 < ${a} && ${a} < 315) ? "middle" :`+`(${a} <= 45 || 315 <= ${a}) === ${orientIsTop} ? "bottom" : "top"`}}if(45<angle&&angle<135||225<angle&&angle<315){return"middle"}if(isSignalRef(orient)){const op=angle<=45||315<=angle?"===":"!==";return{signal:`${orient.signal} ${op} "top" ? "bottom" : "top"`}}return(angle<=45||315<=angle)===(orient==="top")?"bottom":"top"}else{if(isSignalRef(angle)){const a=normalizeAngleExpr(angle);const orientIsLeft=isSignalRef(orient)?`(${orient.signal} === "left")`:orient==="left";const middle=alwaysIncludeMiddle?'"middle"':"null";return{signal:`${a} <= 45 || 315 <= ${a} || (135 <= ${a} && ${a} <= 225) ? ${middle} : (45 <= ${a} && ${a} <= 135) === ${orientIsLeft} ? "top" : "bottom"`}}if(angle<=45||315<=angle||135<=angle&&angle<=225){return alwaysIncludeMiddle?"middle":null}if(isSignalRef(orient)){const op=45<=angle&&angle<=135?"===":"!==";return{signal:`${orient.signal} ${op} "left" ? "top" : "bottom"`}}return(45<=angle&&angle<=135)===(orient==="left")?"top":"bottom"}}return undefined}function defaultLabelAlign(angle,orient,channel){if(angle===undefined){return undefined}const isX=channel==="x";const startAngle=isX?0:90;const mainOrient=isX?"bottom":"left";if(isSignalRef(angle)){const a=normalizeAngleExpr(angle);const orientIsMain=isSignalRef(orient)?`(${orient.signal} === "${mainOrient}")`:orient===mainOrient;return{signal:`(${startAngle?`(${a} + 90)`:a} % 180 === 0) ? ${isX?null:'"center"'} :`+`(${startAngle} < ${a} && ${a} < ${180+startAngle}) === ${orientIsMain} ? "left" : "right"`}}if((angle+startAngle)%180===0){return isX?null:"center"}if(isSignalRef(orient)){const op=startAngle<angle&&angle<180+startAngle?"===":"!==";const orientIsMain=`${orient.signal} ${op} "${mainOrient}"`;return{signal:`${orientIsMain} ? "left" : "right"`}}if((startAngle<angle&&angle<180+startAngle)===(orient===mainOrient)){return"left"}return"right"}function defaultLabelFlush(type,channel){if(channel==="x"&&contains(["quantitative","temporal"],type)){return true}return undefined}function defaultLabelOverlap$1(type,scaleType,hasTimeUnit,sort){if(hasTimeUnit&&!isObject(sort)||type!=="nominal"&&type!=="ordinal"){if(scaleType==="log"||scaleType==="symlog"){return"greedy"}return true}return undefined}function defaultOrient(channel){return channel==="x"?"bottom":"left"}function defaultTickCount({fieldOrDatumDef:fieldOrDatumDef,scaleType:scaleType,size:size,values:vals}){if(!vals&&!hasDiscreteDomain(scaleType)&&scaleType!=="log"){if(isFieldDef(fieldOrDatumDef)){if(isBinning(fieldOrDatumDef.bin)){return{signal:`ceil(${size.signal}/10)`}}if(fieldOrDatumDef.timeUnit&&contains(["month","hours","day","quarter"],normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit)){return undefined}}return{signal:`ceil(${size.signal}/40)`}}return undefined}function defaultTickMinStep({format:format,fieldOrDatumDef:fieldOrDatumDef}){if(format==="d"){return 1}if(isFieldDef(fieldOrDatumDef)){const{timeUnit:timeUnit}=fieldOrDatumDef;if(timeUnit){const signal=durationExpr(timeUnit);if(signal){return{signal:signal}}}}return undefined}function getFieldDefTitle(model,channel){const channel2=channel==="x"?"x2":"y2";const fieldDef=model.fieldDef(channel);const fieldDef2=model.fieldDef(channel2);const title1=fieldDef?fieldDef.title:undefined;const title2=fieldDef2?fieldDef2.title:undefined;if(title1&&title2){return mergeTitle(title1,title2)}else if(title1){return title1}else if(title2){return title2}else if(title1!==undefined){return title1}else if(title2!==undefined){return title2}return undefined}function values$1(axis,fieldOrDatumDef){const vals=axis.values;if(isArray(vals)){return valueArray(fieldOrDatumDef,vals)}else if(isSignalRef(vals)){return vals}return undefined}function defaultZindex(mark,fieldDef){if(mark==="rect"&&isDiscrete(fieldDef)){return 1}return 0}class CalculateNode extends DataFlowNode{clone(){return new CalculateNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this._dependentFields=getDependentFields(this.transform.calculate)}static parseAllForSortIndex(parent,model){model.forEachFieldDef(((fieldDef,channel)=>{if(!isScaleFieldDef(fieldDef)){return}if(isSortArray(fieldDef.sort)){const{field:field,timeUnit:timeUnit}=fieldDef;const sort=fieldDef.sort;const calculate=sort.map(((sortValue,i)=>`${fieldFilterExpression({field:field,timeUnit:timeUnit,equal:sortValue})} ? ${i} : `)).join("")+sort.length;parent=new CalculateNode(parent,{calculate:calculate,as:sortArrayIndexField(fieldDef,channel,{forAs:true})})}}));return parent}producedFields(){return new Set([this.transform.as])}dependentFields(){return this._dependentFields}assemble(){return{type:"formula",expr:this.transform.calculate,as:this.transform.as}}hash(){return`Calculate ${hash(this.transform)}`}}function sortArrayIndexField(fieldDef,channel,opt){return vgField(fieldDef,{prefix:channel,suffix:"sort_index",...opt})}function getHeaderChannel(channel,orient){if(contains(["top","bottom"],orient)){return"column"}else if(contains(["left","right"],orient)){return"row"}return channel==="row"?"row":"column"}function getHeaderProperty(prop,header,config,channel){const headerSpecificConfig=channel==="row"?config.headerRow:channel==="column"?config.headerColumn:config.headerFacet;return getFirstDefined((header||{})[prop],headerSpecificConfig[prop],config.header[prop])}function getHeaderProperties(properties,header,config,channel){const props={};for(const prop of properties){const value=getHeaderProperty(prop,header||{},config,channel);if(value!==undefined){props[prop]=value}}return props}const HEADER_CHANNELS=["row","column"];const HEADER_TYPES=["header","footer"];function assembleTitleGroup(model,channel){const title=model.component.layoutHeaders[channel].title;const config=model.config?model.config:undefined;const facetFieldDef=model.component.layoutHeaders[channel].facetFieldDef?model.component.layoutHeaders[channel].facetFieldDef:undefined;const{titleAnchor:titleAnchor,titleAngle:ta,titleOrient:titleOrient}=getHeaderProperties(["titleAnchor","titleAngle","titleOrient"],facetFieldDef.header,config,channel);const headerChannel=getHeaderChannel(channel,titleOrient);const titleAngle=normalizeAngle(ta);return{name:`${channel}-title`,type:"group",role:`${headerChannel}-title`,title:{text:title,...channel==="row"?{orient:"left"}:{},style:"guide-title",...defaultHeaderGuideBaseline(titleAngle,headerChannel),...defaultHeaderGuideAlign(headerChannel,titleAngle,titleAnchor),...assembleHeaderProperties(config,facetFieldDef,channel,HEADER_TITLE_PROPERTIES,HEADER_TITLE_PROPERTIES_MAP)}}}function defaultHeaderGuideAlign(headerChannel,angle,anchor="middle"){switch(anchor){case"start":return{align:"left"};case"end":return{align:"right"}}const align=defaultLabelAlign(angle,headerChannel==="row"?"left":"top",headerChannel==="row"?"y":"x");return align?{align:align}:{}}function defaultHeaderGuideBaseline(angle,channel){const baseline=defaultLabelBaseline(angle,channel==="row"?"left":"top",channel==="row"?"y":"x",true);return baseline?{baseline:baseline}:{}}function assembleHeaderGroups(model,channel){const layoutHeader=model.component.layoutHeaders[channel];const groups=[];for(const headerType of HEADER_TYPES){if(layoutHeader[headerType]){for(const headerComponent of layoutHeader[headerType]){const group=assembleHeaderGroup(model,channel,headerType,layoutHeader,headerComponent);if(group!=null){groups.push(group)}}}}return groups}function getSort$1(facetFieldDef,channel){const{sort:sort}=facetFieldDef;if(isSortField(sort)){return{field:vgField(sort,{expr:"datum"}),order:sort.order??"ascending"}}else if(isArray(sort)){return{field:sortArrayIndexField(facetFieldDef,channel,{expr:"datum"}),order:"ascending"}}else{return{field:vgField(facetFieldDef,{expr:"datum"}),order:sort??"ascending"}}}function assembleLabelTitle(facetFieldDef,channel,config){const{format:format,formatType:formatType,labelAngle:labelAngle,labelAnchor:labelAnchor,labelOrient:labelOrient,labelExpr:labelExpr}=getHeaderProperties(["format","formatType","labelAngle","labelAnchor","labelOrient","labelExpr"],facetFieldDef.header,config,channel);const titleTextExpr=formatSignalRef({fieldOrDatumDef:facetFieldDef,format:format,formatType:formatType,expr:"parent",config:config}).signal;const headerChannel=getHeaderChannel(channel,labelOrient);return{text:{signal:labelExpr?replaceAll(replaceAll(labelExpr,"datum.label",titleTextExpr),"datum.value",vgField(facetFieldDef,{expr:"parent"})):titleTextExpr},...channel==="row"?{orient:"left"}:{},style:"guide-label",frame:"group",...defaultHeaderGuideBaseline(labelAngle,headerChannel),...defaultHeaderGuideAlign(headerChannel,labelAngle,labelAnchor),...assembleHeaderProperties(config,facetFieldDef,channel,HEADER_LABEL_PROPERTIES,HEADER_LABEL_PROPERTIES_MAP)}}function assembleHeaderGroup(model,channel,headerType,layoutHeader,headerComponent){if(headerComponent){let title=null;const{facetFieldDef:facetFieldDef}=layoutHeader;const config=model.config?model.config:undefined;if(facetFieldDef&&headerComponent.labels){const{labelOrient:labelOrient}=getHeaderProperties(["labelOrient"],facetFieldDef.header,config,channel);if(channel==="row"&&!contains(["top","bottom"],labelOrient)||channel==="column"&&!contains(["left","right"],labelOrient)){title=assembleLabelTitle(facetFieldDef,channel,config)}}const isFacetWithoutRowCol=isFacetModel(model)&&!isFacetMapping(model.facet);const axes=headerComponent.axes;const hasAxes=axes?.length>0;if(title||hasAxes){const sizeChannel=channel==="row"?"height":"width";return{name:model.getName(`${channel}_${headerType}`),type:"group",role:`${channel}-${headerType}`,...layoutHeader.facetFieldDef?{from:{data:model.getName(`${channel}_domain`)},sort:getSort$1(facetFieldDef,channel)}:{},...hasAxes&&isFacetWithoutRowCol?{from:{data:model.getName(`facet_domain_${channel}`)}}:{},...title?{title:title}:{},...headerComponent.sizeSignal?{encode:{update:{[sizeChannel]:headerComponent.sizeSignal}}}:{},...hasAxes?{axes:axes}:{}}}}return null}const LAYOUT_TITLE_BAND={column:{start:0,end:1},row:{start:1,end:0}};function getLayoutTitleBand(titleAnchor,headerChannel){return LAYOUT_TITLE_BAND[headerChannel][titleAnchor]}function assembleLayoutTitleBand(headerComponentIndex,config){const titleBand={};for(const channel of FACET_CHANNELS){const headerComponent=headerComponentIndex[channel];if(headerComponent?.facetFieldDef){const{titleAnchor:titleAnchor,titleOrient:titleOrient}=getHeaderProperties(["titleAnchor","titleOrient"],headerComponent.facetFieldDef.header,config,channel);const headerChannel=getHeaderChannel(channel,titleOrient);const band=getLayoutTitleBand(titleAnchor,headerChannel);if(band!==undefined){titleBand[headerChannel]=band}}}return isEmpty(titleBand)?undefined:titleBand}function assembleHeaderProperties(config,facetFieldDef,channel,properties,propertiesMap){const props={};for(const prop of properties){if(!propertiesMap[prop]){continue}const value=getHeaderProperty(prop,facetFieldDef?.header,config,channel);if(value!==undefined){props[propertiesMap[prop]]=value}}return props}function assembleLayoutSignals(model){return[...sizeSignals(model,"width"),...sizeSignals(model,"height"),...sizeSignals(model,"childWidth"),...sizeSignals(model,"childHeight")]}function sizeSignals(model,sizeType){const channel=sizeType==="width"?"x":"y";const size=model.component.layoutSize.get(sizeType);if(!size||size==="merged"){return[]}const name=model.getSizeSignalRef(sizeType).signal;if(size==="step"){const scaleComponent=model.getScaleComponent(channel);if(scaleComponent){const type=scaleComponent.get("type");const range=scaleComponent.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range)){const scaleName=model.scaleName(channel);if(isFacetModel(model.parent)){const parentResolve=model.parent.component.resolve;if(parentResolve.scale[channel]==="independent"){return[stepSignal(scaleName,range)]}}return[stepSignal(scaleName,range),{name:name,update:sizeExpr(scaleName,scaleComponent,`domain('${scaleName}').length`)}]}}throw new Error("layout size is step although width/height is not step.")}else if(size=="container"){const isWidth=name.endsWith("width");const expr=isWidth?"containerSize()[0]":"containerSize()[1]";const defaultValue=getViewConfigContinuousSize(model.config.view,isWidth?"width":"height");const safeExpr=`isFinite(${expr}) ? ${expr} : ${defaultValue}`;return[{name:name,init:safeExpr,on:[{update:safeExpr,events:"window:resize"}]}]}else{return[{name:name,value:size}]}}function stepSignal(scaleName,range){const name=`${scaleName}_step`;if(isSignalRef(range.step)){return{name:name,update:range.step.signal}}else{return{name:name,value:range.step}}}function sizeExpr(scaleName,scaleComponent,cardinality){const type=scaleComponent.get("type");const padding=scaleComponent.get("padding");const paddingOuter=getFirstDefined(scaleComponent.get("paddingOuter"),padding);let paddingInner=scaleComponent.get("paddingInner");paddingInner=type==="band"?paddingInner!==undefined?paddingInner:padding:1;return`bandspace(${cardinality}, ${signalOrStringValue(paddingInner)}, ${signalOrStringValue(paddingOuter)}) * ${scaleName}_step`}function getSizeTypeFromLayoutSizeType(layoutSizeType){return layoutSizeType==="childWidth"?"width":layoutSizeType==="childHeight"?"height":layoutSizeType}function guideEncodeEntry(encoding,model){return keys(encoding).reduce(((encode,channel)=>({...encode,...wrapCondition({model:model,channelDef:encoding[channel],vgChannel:channel,mainRefFn:def=>signalOrValueRef(def.value),invalidValueRef:undefined})})),{})}function defaultScaleResolve(channel,model){if(isFacetModel(model)){return channel==="theta"?"independent":"shared"}else if(isLayerModel(model)){return"shared"}else if(isConcatModel(model)){return isXorY(channel)||channel==="theta"||channel==="radius"?"independent":"shared"}throw new Error("invalid model type for resolve")}function parseGuideResolve(resolve,channel){const channelScaleResolve=resolve.scale[channel];const guide=isXorY(channel)?"axis":"legend";if(channelScaleResolve==="independent"){if(resolve[guide][channel]==="shared"){warn(independentScaleMeansIndependentGuide(channel))}return"independent"}return resolve[guide][channel]||"shared"}const LEGEND_COMPONENT_PROPERTY_INDEX={...COMMON_LEGEND_PROPERTY_INDEX,disable:1,labelExpr:1,selections:1,opacity:1,shape:1,stroke:1,fill:1,size:1,strokeWidth:1,strokeDash:1,encode:1};const LEGEND_COMPONENT_PROPERTIES=keys(LEGEND_COMPONENT_PROPERTY_INDEX);class LegendComponent extends Split{}const legendEncodeRules={symbols:symbols,gradient:gradient,labels:labels$1,entries:entries};function symbols(symbolsSpec,{fieldOrDatumDef:fieldOrDatumDef,model:model,channel:channel,legendCmpt:legendCmpt,legendType:legendType}){if(legendType!=="symbol"){return undefined}const{markDef:markDef,encoding:encoding,config:config,mark:mark}=model;const filled=markDef.filled&&mark!=="trail";let out={...applyMarkConfig({},model,FILL_STROKE_CONFIG),...color(model,{filled:filled})};const symbolOpacity=legendCmpt.get("symbolOpacity")??config.legend.symbolOpacity;const symbolFillColor=legendCmpt.get("symbolFillColor")??config.legend.symbolFillColor;const symbolStrokeColor=legendCmpt.get("symbolStrokeColor")??config.legend.symbolStrokeColor;const opacity=symbolOpacity===undefined?getMaxValue(encoding.opacity)??markDef.opacity:undefined;if(out.fill){if(channel==="fill"||filled&&channel===COLOR){delete out.fill}else if(hasProperty(out.fill,"field")){if(symbolFillColor){delete out.fill}else{out.fill=signalOrValueRef(config.legend.symbolBaseFillColor??"black");out.fillOpacity=signalOrValueRef(opacity??1)}}else if(isArray(out.fill)){const fill=getFirstConditionValue(encoding.fill??encoding.color)??markDef.fill??(filled&&markDef.color);if(fill){out.fill=signalOrValueRef(fill)}}}if(out.stroke){if(channel==="stroke"||!filled&&channel===COLOR){delete out.stroke}else if(hasProperty(out.stroke,"field")||symbolStrokeColor){delete out.stroke}else if(isArray(out.stroke)){const stroke=getFirstDefined(getFirstConditionValue(encoding.stroke||encoding.color),markDef.stroke,filled?markDef.color:undefined);if(stroke){out.stroke={value:stroke}}}}if(channel!==OPACITY){const condition=isFieldDef(fieldOrDatumDef)&&selectedCondition(model,legendCmpt,fieldOrDatumDef);if(condition){out.opacity=[{test:condition,...signalOrValueRef(opacity??1)},signalOrValueRef(config.legend.unselectedOpacity)]}else if(opacity){out.opacity=signalOrValueRef(opacity)}}out={...out,...symbolsSpec};return isEmpty(out)?undefined:out}function gradient(gradientSpec,{model:model,legendType:legendType,legendCmpt:legendCmpt}){if(legendType!=="gradient"){return undefined}const{config:config,markDef:markDef,encoding:encoding}=model;let out={};const gradientOpacity=legendCmpt.get("gradientOpacity")??config.legend.gradientOpacity;const opacity=gradientOpacity===undefined?getMaxValue(encoding.opacity)||markDef.opacity:undefined;if(opacity){out.opacity=signalOrValueRef(opacity)}out={...out,...gradientSpec};return isEmpty(out)?undefined:out}function labels$1(specifiedlabelsSpec,{fieldOrDatumDef:fieldOrDatumDef,model:model,channel:channel,legendCmpt:legendCmpt}){const legend=model.legend(channel)||{};const config=model.config;const condition=isFieldDef(fieldOrDatumDef)?selectedCondition(model,legendCmpt,fieldOrDatumDef):undefined;const opacity=condition?[{test:condition,value:1},{value:config.legend.unselectedOpacity}]:undefined;const{format:format,formatType:formatType}=legend;let text=undefined;if(isCustomFormatType(formatType)){text=formatCustomType({fieldOrDatumDef:fieldOrDatumDef,field:"datum.value",format:format,formatType:formatType,config:config})}else if(format===undefined&&formatType===undefined&&config.customFormatTypes){if(fieldOrDatumDef.type==="quantitative"&&config.numberFormatType){text=formatCustomType({fieldOrDatumDef:fieldOrDatumDef,field:"datum.value",format:config.numberFormat,formatType:config.numberFormatType,config:config})}else if(fieldOrDatumDef.type==="temporal"&&config.timeFormatType&&isFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.timeUnit===undefined){text=formatCustomType({fieldOrDatumDef:fieldOrDatumDef,field:"datum.value",format:config.timeFormat,formatType:config.timeFormatType,config:config})}}const labelsSpec={...opacity?{opacity:opacity}:{},...text?{text:text}:{},...specifiedlabelsSpec};return isEmpty(labelsSpec)?undefined:labelsSpec}function entries(entriesSpec,{legendCmpt:legendCmpt}){const selections=legendCmpt.get("selections");return selections?.length?{...entriesSpec,fill:{value:"transparent"}}:entriesSpec}function getMaxValue(channelDef){return getConditionValue(channelDef,((v,conditionalDef)=>Math.max(v,conditionalDef.value)))}function getFirstConditionValue(channelDef){return getConditionValue(channelDef,((v,conditionalDef)=>getFirstDefined(v,conditionalDef.value)))}function getConditionValue(channelDef,reducer){if(hasConditionalValueDef(channelDef)){return array$5(channelDef.condition).reduce(reducer,channelDef.value)}else if(isValueDef(channelDef)){return channelDef.value}return undefined}function selectedCondition(model,legendCmpt,fieldDef){const selections=legendCmpt.get("selections");if(!selections?.length)return undefined;const field=$(fieldDef.field);return selections.map((name=>{const store=$(varName(name)+STORE);return`(!length(data(${store})) || (${name}[${field}] && indexof(${name}[${field}], datum.value) >= 0))`})).join(" || ")}const legendRules={direction:({direction:direction})=>direction,format:({fieldOrDatumDef:fieldOrDatumDef,legend:legend,config:config})=>{const{format:format,formatType:formatType}=legend;return guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,format,formatType,config,false)},formatType:({legend:legend,fieldOrDatumDef:fieldOrDatumDef,scaleType:scaleType})=>{const{formatType:formatType}=legend;return guideFormatType(formatType,fieldOrDatumDef,scaleType)},gradientLength:params=>{const{legend:legend,legendConfig:legendConfig}=params;return legend.gradientLength??legendConfig.gradientLength??defaultGradientLength(params)},labelOverlap:({legend:legend,legendConfig:legendConfig,scaleType:scaleType})=>legend.labelOverlap??legendConfig.labelOverlap??defaultLabelOverlap(scaleType),symbolType:({legend:legend,markDef:markDef,channel:channel,encoding:encoding})=>legend.symbolType??defaultSymbolType(markDef.type,channel,encoding.shape,markDef.shape),title:({fieldOrDatumDef:fieldOrDatumDef,config:config})=>title(fieldOrDatumDef,config,{allowDisabling:true}),type:({legendType:legendType,scaleType:scaleType,channel:channel})=>{if(isColorChannel(channel)&&isContinuousToContinuous(scaleType)){if(legendType==="gradient"){return undefined}}else if(legendType==="symbol"){return undefined}return legendType},values:({fieldOrDatumDef:fieldOrDatumDef,legend:legend})=>values(legend,fieldOrDatumDef)};function values(legend,fieldOrDatumDef){const vals=legend.values;if(isArray(vals)){return valueArray(fieldOrDatumDef,vals)}else if(isSignalRef(vals)){return vals}return undefined}function defaultSymbolType(mark,channel,shapeChannelDef,markShape){if(channel!=="shape"){const shape=getFirstConditionValue(shapeChannelDef)??markShape;if(shape){return shape}}switch(mark){case"bar":case"rect":case"image":case"square":return"square";case"line":case"trail":case"rule":return"stroke";case"arc":case"point":case"circle":case"tick":case"geoshape":case"area":case"text":return"circle"}}function getLegendType(params){const{legend:legend}=params;return getFirstDefined(legend.type,defaultType$1(params))}function defaultType$1({channel:channel,timeUnit:timeUnit,scaleType:scaleType}){if(isColorChannel(channel)){if(contains(["quarter","month","day"],timeUnit)){return"symbol"}if(isContinuousToContinuous(scaleType)){return"gradient"}}return"symbol"}function getDirection({legendConfig:legendConfig,legendType:legendType,orient:orient,legend:legend}){return legend.direction??legendConfig[legendType?"gradientDirection":"symbolDirection"]??defaultDirection(orient,legendType)}function defaultDirection(orient,legendType){switch(orient){case"top":case"bottom":return"horizontal";case"left":case"right":case"none":case undefined:return undefined;default:return legendType==="gradient"?"horizontal":undefined}}function defaultGradientLength({legendConfig:legendConfig,model:model,direction:direction,orient:orient,scaleType:scaleType}){const{gradientHorizontalMaxLength:gradientHorizontalMaxLength,gradientHorizontalMinLength:gradientHorizontalMinLength,gradientVerticalMaxLength:gradientVerticalMaxLength,gradientVerticalMinLength:gradientVerticalMinLength}=legendConfig;if(isContinuousToContinuous(scaleType)){if(direction==="horizontal"){if(orient==="top"||orient==="bottom"){return gradientLengthSignal(model,"width",gradientHorizontalMinLength,gradientHorizontalMaxLength)}else{return gradientHorizontalMinLength}}else{return gradientLengthSignal(model,"height",gradientVerticalMinLength,gradientVerticalMaxLength)}}return undefined}function gradientLengthSignal(model,sizeType,min,max){const sizeSignal=model.getSizeSignalRef(sizeType).signal;return{signal:`clamp(${sizeSignal}, ${min}, ${max})`}}function defaultLabelOverlap(scaleType){if(contains(["quantile","threshold","log","symlog"],scaleType)){return"greedy"}return undefined}function parseLegend(model){const legendComponent=isUnitModel(model)?parseUnitLegend(model):parseNonUnitLegend(model);model.component.legends=legendComponent;return legendComponent}function parseUnitLegend(model){const{encoding:encoding}=model;const legendComponent={};for(const channel of[COLOR,...LEGEND_SCALE_CHANNELS]){const def=getFieldOrDatumDef(encoding[channel]);if(!def||!model.getScaleComponent(channel)){continue}if(channel===SHAPE&&isFieldDef(def)&&def.type===GEOJSON){continue}legendComponent[channel]=parseLegendForChannel(model,channel)}return legendComponent}function getLegendDefWithScale(model,channel){const scale=model.scaleName(channel);if(model.mark==="trail"){if(channel==="color"){return{stroke:scale}}else if(channel==="size"){return{strokeWidth:scale}}}if(channel==="color"){return model.markDef.filled?{fill:scale}:{stroke:scale}}return{[channel]:scale}}function isExplicit$1(value,property,legend,fieldDef){switch(property){case"disable":return legend!==undefined;case"values":return!!legend?.values;case"title":if(property==="title"&&value===fieldDef?.title){return true}}return value===(legend||{})[property]}function parseLegendForChannel(model,channel){let legend=model.legend(channel);const{markDef:markDef,encoding:encoding,config:config}=model;const legendConfig=config.legend;const legendCmpt=new LegendComponent({},getLegendDefWithScale(model,channel));parseInteractiveLegend(model,channel,legendCmpt);const disable=legend!==undefined?!legend:legendConfig.disable;legendCmpt.set("disable",disable,legend!==undefined);if(disable){return legendCmpt}legend=legend||{};const scaleType=model.getScaleComponent(channel).get("type");const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);const timeUnit=isFieldDef(fieldOrDatumDef)?normalizeTimeUnit(fieldOrDatumDef.timeUnit)?.unit:undefined;const orient=legend.orient||config.legend.orient||"right";const legendType=getLegendType({legend:legend,channel:channel,timeUnit:timeUnit,scaleType:scaleType});const direction=getDirection({legend:legend,legendType:legendType,orient:orient,legendConfig:legendConfig});const ruleParams={legend:legend,channel:channel,model:model,markDef:markDef,encoding:encoding,fieldOrDatumDef:fieldOrDatumDef,legendConfig:legendConfig,config:config,scaleType:scaleType,orient:orient,legendType:legendType,direction:direction};for(const property of LEGEND_COMPONENT_PROPERTIES){if(legendType==="gradient"&&property.startsWith("symbol")||legendType==="symbol"&&property.startsWith("gradient")){continue}const value=property in legendRules?legendRules[property](ruleParams):legend[property];if(value!==undefined){const explicit=isExplicit$1(value,property,legend,model.fieldDef(channel));if(explicit||config.legend[property]===undefined){legendCmpt.set(property,value,explicit)}}}const legendEncoding=legend?.encoding??{};const selections=legendCmpt.get("selections");const legendEncode={};const legendEncodeParams={fieldOrDatumDef:fieldOrDatumDef,model:model,channel:channel,legendCmpt:legendCmpt,legendType:legendType};for(const part of["labels","legend","title","symbols","gradient","entries"]){const legendEncodingPart=guideEncodeEntry(legendEncoding[part]??{},model);const value=part in legendEncodeRules?legendEncodeRules[part](legendEncodingPart,legendEncodeParams):legendEncodingPart;if(value!==undefined&&!isEmpty(value)){legendEncode[part]={...selections?.length&&isFieldDef(fieldOrDatumDef)?{name:`${varName(fieldOrDatumDef.field)}_legend_${part}`}:{},...selections?.length?{interactive:!!selections}:{},update:value}}}if(!isEmpty(legendEncode)){legendCmpt.set("encode",legendEncode,!!legend?.encoding)}return legendCmpt}function parseNonUnitLegend(model){const{legends:legends,resolve:resolve}=model.component;for(const child of model.children){parseLegend(child);for(const channel of keys(child.component.legends)){resolve.legend[channel]=parseGuideResolve(model.component.resolve,channel);if(resolve.legend[channel]==="shared"){legends[channel]=mergeLegendComponent(legends[channel],child.component.legends[channel]);if(!legends[channel]){resolve.legend[channel]="independent";delete legends[channel]}}}}for(const channel of keys(legends)){for(const child of model.children){if(!child.component.legends[channel]){continue}if(resolve.legend[channel]==="shared"){delete child.component.legends[channel]}}}return legends}function mergeLegendComponent(mergedLegend,childLegend){if(!mergedLegend){return childLegend.clone()}const mergedOrient=mergedLegend.getWithExplicit("orient");const childOrient=childLegend.getWithExplicit("orient");if(mergedOrient.explicit&&childOrient.explicit&&mergedOrient.value!==childOrient.value){return undefined}let typeMerged=false;for(const prop of LEGEND_COMPONENT_PROPERTIES){const mergedValueWithExplicit=mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop),childLegend.getWithExplicit(prop),prop,"legend",((v1,v2)=>{switch(prop){case"symbolType":return mergeSymbolType(v1,v2);case"title":return mergeTitleComponent(v1,v2);case"type":typeMerged=true;return makeImplicit("symbol")}return defaultTieBreaker(v1,v2,prop,"legend")}));mergedLegend.setWithExplicit(prop,mergedValueWithExplicit)}if(typeMerged){if(mergedLegend.implicit?.encode?.gradient){deleteNestedProperty(mergedLegend.implicit,["encode","gradient"])}if(mergedLegend.explicit?.encode?.gradient){deleteNestedProperty(mergedLegend.explicit,["encode","gradient"])}}return mergedLegend}function mergeSymbolType(st1,st2){if(st2.value==="circle"){return st2}return st1}function setLegendEncode(legend,part,vgProp,vgRef){var _a,_b;legend.encode??(legend.encode={});(_a=legend.encode)[part]??(_a[part]={});(_b=legend.encode[part]).update??(_b.update={});legend.encode[part].update[vgProp]=vgRef}function assembleLegends(model){const legendComponentIndex=model.component.legends;const legendByDomain={};for(const channel of keys(legendComponentIndex)){const scaleComponent=model.getScaleComponent(channel);const domainHash=stringify(scaleComponent.get("domains"));if(legendByDomain[domainHash]){for(const mergedLegendComponent of legendByDomain[domainHash]){const merged=mergeLegendComponent(mergedLegendComponent,legendComponentIndex[channel]);if(!merged){legendByDomain[domainHash].push(legendComponentIndex[channel])}}}else{legendByDomain[domainHash]=[legendComponentIndex[channel].clone()]}}const legends=vals(legendByDomain).flat().map((l=>assembleLegend(l,model.config))).filter((l=>l!==undefined));return legends}function assembleLegend(legendCmpt,config){const{disable:disable,labelExpr:labelExpr,selections:selections,...legend}=legendCmpt.combine();if(disable){return undefined}if(config.aria===false&&legend.aria==undefined){legend.aria=false}if(legend.encode?.symbols){const out=legend.encode.symbols.update;if(out.fill&&out.fill["value"]!=="transparent"&&!out.stroke&&!legend.stroke){out.stroke={value:"transparent"}}for(const property of LEGEND_SCALE_CHANNELS){if(legend[property]){delete out[property]}}}if(!legend.title){delete legend.title}if(labelExpr!==undefined){let expr=labelExpr;if(legend.encode?.labels?.update&&isSignalRef(legend.encode.labels.update.text)){expr=replaceAll(labelExpr,"datum.label",legend.encode.labels.update.text.signal)}setLegendEncode(legend,"labels","text",{signal:expr})}return legend}function assembleProjections(model){if(isLayerModel(model)||isConcatModel(model)){return assembleProjectionsForModelAndChildren(model)}else{return assembleProjectionForModel(model)}}function assembleProjectionsForModelAndChildren(model){return model.children.reduce(((projections,child)=>projections.concat(child.assembleProjections())),assembleProjectionForModel(model))}function assembleProjectionForModel(model){const component=model.component.projection;if(!component||component.merged){return[]}const projection=component.combine();const{name:name}=projection;if(!component.data){return[{name:name,translate:{signal:"[width / 2, height / 2]"},...projection}]}else{const size={signal:`[${component.size.map((ref=>ref.signal)).join(", ")}]`};const fits=component.data.reduce(((sources,data)=>{const source=isSignalRef(data)?data.signal:`data('${model.lookupDataSource(data)}')`;if(!contains(sources,source)){sources.push(source)}return sources}),[]);if(fits.length<=0){throw new Error("Projection's fit didn't find any data sources")}return[{name:name,size:size,fit:{signal:fits.length>1?`[${fits.join(", ")}]`:fits[0]},...projection}]}}const PROJECTION_PROPERTIES=["type","clipAngle","clipExtent","center","rotate","precision","reflectX","reflectY","coefficient","distance","fraction","lobes","parallel","radius","ratio","spacing","tilt"];class ProjectionComponent extends Split{constructor(name,specifiedProjection,size,data){super({...specifiedProjection},{name:name});this.specifiedProjection=specifiedProjection;this.size=size;this.data=data;this.merged=false}get isFit(){return!!this.data}}function parseProjection(model){model.component.projection=isUnitModel(model)?parseUnitProjection(model):parseNonUnitProjections(model)}function parseUnitProjection(model){if(model.hasProjection){const proj=replaceExprRef(model.specifiedProjection);const fit=!(proj&&(proj.scale!=null||proj.translate!=null));const size=fit?[model.getSizeSignalRef("width"),model.getSizeSignalRef("height")]:undefined;const data=fit?gatherFitData(model):undefined;const projComp=new ProjectionComponent(model.projectionName(true),{...replaceExprRef(model.config.projection),...proj},size,data);if(!projComp.get("type")){projComp.set("type","equalEarth",false)}return projComp}return undefined}function gatherFitData(model){const data=[];const{encoding:encoding}=model;for(const posssiblePair of[[LONGITUDE,LATITUDE],[LONGITUDE2,LATITUDE2]]){if(getFieldOrDatumDef(encoding[posssiblePair[0]])||getFieldOrDatumDef(encoding[posssiblePair[1]])){data.push({signal:model.getName(`geojson_${data.length}`)})}}if(model.channelHasField(SHAPE)&&model.typedFieldDef(SHAPE).type===GEOJSON){data.push({signal:model.getName(`geojson_${data.length}`)})}if(data.length===0){data.push(model.requestDataName(DataSourceType.Main))}return data}function mergeIfNoConflict(first,second){const allPropertiesShared=every(PROJECTION_PROPERTIES,(prop=>{if(!has$1(first.explicit,prop)&&!has$1(second.explicit,prop)){return true}if(has$1(first.explicit,prop)&&has$1(second.explicit,prop)&&deepEqual(first.get(prop),second.get(prop))){return true}return false}));const size=deepEqual(first.size,second.size);if(size){if(allPropertiesShared){return first}else if(deepEqual(first.explicit,{})){return second}else if(deepEqual(second.explicit,{})){return first}}return null}function parseNonUnitProjections(model){if(model.children.length===0){return undefined}let nonUnitProjection;for(const child of model.children){parseProjection(child)}const mergable=every(model.children,(child=>{const projection=child.component.projection;if(!projection){return true}else if(!nonUnitProjection){nonUnitProjection=projection;return true}else{const merge=mergeIfNoConflict(nonUnitProjection,projection);if(merge){nonUnitProjection=merge}return!!merge}}));if(nonUnitProjection&&mergable){const name=model.projectionName(true);const modelProjection=new ProjectionComponent(name,nonUnitProjection.specifiedProjection,nonUnitProjection.size,duplicate(nonUnitProjection.data));for(const child of model.children){const projection=child.component.projection;if(projection){if(projection.isFit){modelProjection.data.push(...child.component.projection.data)}child.renameProjection(projection.get("name"),name);projection.merged=true}}return modelProjection}return undefined}function rangeFormula(model,fieldDef,channel,config){if(binRequiresRange(fieldDef,channel)){const guide=isUnitModel(model)?model.axis(channel)??model.legend(channel)??{}:{};const startField=vgField(fieldDef,{expr:"datum"});const endField=vgField(fieldDef,{expr:"datum",binSuffix:"end"});return{formulaAs:vgField(fieldDef,{binSuffix:"range",forAs:true}),formula:binFormatExpression(startField,endField,guide.format,guide.formatType,config)}}return{}}function binKey(bin,field){return`${binToString(bin)}_${field}`}function getSignalsFromModel(model,key){return{signal:model.getName(`${key}_bins`),extentSignal:model.getName(`${key}_extent`)}}function getBinSignalName(model,field,bin){const normalizedBin=normalizeBin(bin,undefined)??{};const key=binKey(normalizedBin,field);return model.getName(`${key}_bins`)}function isBinTransform(t){return"as"in t}function createBinComponent(t,bin,model){let as;let span;if(isBinTransform(t)){as=isString(t.as)?[t.as,`${t.as}_end`]:[t.as[0],t.as[1]]}else{as=[vgField(t,{forAs:true}),vgField(t,{binSuffix:"end",forAs:true})]}const normalizedBin={...normalizeBin(bin,undefined)};const key=binKey(normalizedBin,t.field);const{signal:signal,extentSignal:extentSignal}=getSignalsFromModel(model,key);if(isParameterExtent(normalizedBin.extent)){const ext=normalizedBin.extent;span=parseSelectionExtent(model,ext.param,ext);delete normalizedBin.extent}const binComponent={bin:normalizedBin,field:t.field,as:[as],...signal?{signal:signal}:{},...extentSignal?{extentSignal:extentSignal}:{},...span?{span:span}:{}};return{key:key,binComponent:binComponent}}class BinNode extends DataFlowNode{clone(){return new BinNode(null,duplicate(this.bins))}constructor(parent,bins){super(parent);this.bins=bins}static makeFromEncoding(parent,model){const bins=model.reduceFieldDef(((binComponentIndex,fieldDef,channel)=>{if(isTypedFieldDef(fieldDef)&&isBinning(fieldDef.bin)){const{key:key,binComponent:binComponent}=createBinComponent(fieldDef,fieldDef.bin,model);binComponentIndex[key]={...binComponent,...binComponentIndex[key],...rangeFormula(model,fieldDef,channel,model.config)}}return binComponentIndex}),{});if(isEmpty(bins)){return null}return new BinNode(parent,bins)}static makeFromTransform(parent,t,model){const{key:key,binComponent:binComponent}=createBinComponent(t,t.bin,model);return new BinNode(parent,{[key]:binComponent})}merge(other,renameSignal){for(const key of keys(other.bins)){if(key in this.bins){renameSignal(other.bins[key].signal,this.bins[key].signal);this.bins[key].as=unique([...this.bins[key].as,...other.bins[key].as],hash)}else{this.bins[key]=other.bins[key]}}for(const child of other.children){other.removeChild(child);child.parent=this}other.remove()}producedFields(){return new Set(vals(this.bins).map((c=>c.as)).flat(2))}dependentFields(){return new Set(vals(this.bins).map((c=>c.field)))}hash(){return`Bin ${hash(this.bins)}`}assemble(){return vals(this.bins).flatMap((bin=>{const transform=[];const[binAs,...remainingAs]=bin.as;const{extent:extent,...params}=bin.bin;const binTrans={type:"bin",field:replacePathInField(bin.field),as:binAs,signal:bin.signal,...!isParameterExtent(extent)?{extent:extent}:{extent:null},...bin.span?{span:{signal:`span(${bin.span})`}}:{},...params};if(!extent&&bin.extentSignal){transform.push({type:"extent",field:replacePathInField(bin.field),signal:bin.extentSignal});binTrans.extent={signal:bin.extentSignal}}transform.push(binTrans);for(const as of remainingAs){for(let i=0;i<2;i++){transform.push({type:"formula",expr:vgField({field:binAs[i]},{expr:"datum"}),as:as[i]})}}if(bin.formula){transform.push({type:"formula",expr:bin.formula,as:bin.formulaAs})}return transform}))}}function addDimension(dims,channel,fieldDef,model){const channelDef2=isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:undefined;if(isTypedFieldDef(fieldDef)&&isUnitModel(model)&&hasBandEnd(fieldDef,channelDef2,model.markDef,model.config)){dims.add(vgField(fieldDef,{}));dims.add(vgField(fieldDef,{suffix:"end"}));const{mark:mark,markDef:markDef,config:config}=model;const bandPosition=getBandPosition({fieldDef:fieldDef,markDef:markDef,config:config});if(isRectBasedMark(mark)&&bandPosition!==.5&&isXorY(channel)){dims.add(vgField(fieldDef,{suffix:OFFSETTED_RECT_START_SUFFIX}));dims.add(vgField(fieldDef,{suffix:OFFSETTED_RECT_END_SUFFIX}))}if(fieldDef.bin&&binRequiresRange(fieldDef,channel)){dims.add(vgField(fieldDef,{binSuffix:"range"}))}}else if(isGeoPositionChannel(channel)){const posChannel=getPositionChannelFromLatLong(channel);dims.add(model.getName(posChannel))}else{dims.add(vgField(fieldDef))}if(isScaleFieldDef(fieldDef)&&isFieldRange(fieldDef.scale?.range)){dims.add(fieldDef.scale.range.field)}return dims}function mergeMeasures(parentMeasures,childMeasures){for(const field of keys(childMeasures)){const ops=childMeasures[field];for(const op of keys(ops)){if(field in parentMeasures){parentMeasures[field][op]=new Set([...parentMeasures[field][op]??[],...ops[op]])}else{parentMeasures[field]={[op]:ops[op]}}}}}class AggregateNode extends DataFlowNode{clone(){return new AggregateNode(null,new Set(this.dimensions),duplicate(this.measures))}constructor(parent,dimensions,measures){super(parent);this.dimensions=dimensions;this.measures=measures}get groupBy(){return this.dimensions}static makeFromEncoding(parent,model){let isAggregate=false;model.forEachFieldDef((fd=>{if(fd.aggregate){isAggregate=true}}));const meas={};const dims=new Set;if(!isAggregate){return null}model.forEachFieldDef(((fieldDef,channel)=>{const{aggregate:aggregate,field:field}=fieldDef;if(aggregate){if(aggregate==="count"){meas["*"]??(meas["*"]={});meas["*"]["count"]=new Set([vgField(fieldDef,{forAs:true})])}else{if(isArgminDef(aggregate)||isArgmaxDef(aggregate)){const op=isArgminDef(aggregate)?"argmin":"argmax";const argField=aggregate[op];meas[argField]??(meas[argField]={});meas[argField][op]=new Set([vgField({op:op,field:argField},{forAs:true})])}else{meas[field]??(meas[field]={});meas[field][aggregate]=new Set([vgField(fieldDef,{forAs:true})])}if(isScaleChannel(channel)&&model.scaleDomain(channel)==="unaggregated"){meas[field]??(meas[field]={});meas[field]["min"]=new Set([vgField({field:field,aggregate:"min"},{forAs:true})]);meas[field]["max"]=new Set([vgField({field:field,aggregate:"max"},{forAs:true})])}}}else{addDimension(dims,channel,fieldDef,model)}}));if(dims.size+keys(meas).length===0){return null}return new AggregateNode(parent,dims,meas)}static makeFromTransform(parent,t){var _a;const dims=new Set;const meas={};for(const s of t.aggregate){const{op:op,field:field,as:as}=s;if(op){if(op==="count"){meas["*"]??(meas["*"]={});meas["*"]["count"]=new Set([as?as:vgField(s,{forAs:true})])}else{meas[field]??(meas[field]={});(_a=meas[field])[op]??(_a[op]=new Set);meas[field][op].add(as?as:vgField(s,{forAs:true}))}}}for(const s of t.groupby??[]){dims.add(s)}if(dims.size+keys(meas).length===0){return null}return new AggregateNode(parent,dims,meas)}merge(other){if(setEqual(this.dimensions,other.dimensions)){mergeMeasures(this.measures,other.measures);return true}debug("different dimensions, cannot merge");return false}addDimensions(fields){fields.forEach(this.dimensions.add,this.dimensions)}dependentFields(){return new Set([...this.dimensions,...keys(this.measures)])}producedFields(){const out=new Set;for(const field of keys(this.measures)){for(const op of keys(this.measures[field])){const m=this.measures[field][op];if(m.size===0){out.add(`${op}_${field}`)}else{m.forEach(out.add,out)}}}return out}hash(){return`Aggregate ${hash({dimensions:this.dimensions,measures:this.measures})}`}assemble(){const ops=[];const fields=[];const as=[];for(const field of keys(this.measures)){for(const op of keys(this.measures[field])){for(const alias of this.measures[field][op]){as.push(alias);ops.push(op);fields.push(field==="*"?null:replacePathInField(field))}}}const result={type:"aggregate",groupby:[...this.dimensions].map(replacePathInField),ops:ops,fields:fields,as:as};return result}}class FacetNode extends DataFlowNode{constructor(parent,model,name,data){super(parent);this.model=model;this.name=name;this.data=data;for(const channel of FACET_CHANNELS){const fieldDef=model.facet[channel];if(fieldDef){const{bin:bin,sort:sort}=fieldDef;this[channel]={name:model.getName(`${channel}_domain`),fields:[vgField(fieldDef),...isBinning(bin)?[vgField(fieldDef,{binSuffix:"end"})]:[]],...isSortField(sort)?{sortField:sort}:isArray(sort)?{sortIndexField:sortArrayIndexField(fieldDef,channel)}:{}}}}this.childModel=model.child}hash(){let out=`Facet`;for(const channel of FACET_CHANNELS){if(this[channel]){out+=` ${channel.charAt(0)}:${hash(this[channel])}`}}return out}get fields(){const f=[];for(const channel of FACET_CHANNELS){if(this[channel]?.fields){f.push(...this[channel].fields)}}return f}dependentFields(){const depFields=new Set(this.fields);for(const channel of FACET_CHANNELS){if(this[channel]){if(this[channel].sortField){depFields.add(this[channel].sortField.field)}if(this[channel].sortIndexField){depFields.add(this[channel].sortIndexField)}}}return depFields}producedFields(){return new Set}getSource(){return this.name}getChildIndependentFieldsWithStep(){const childIndependentFieldsWithStep={};for(const channel of POSITION_SCALE_CHANNELS){const childScaleComponent=this.childModel.component.scales[channel];if(childScaleComponent&&!childScaleComponent.merged){const type=childScaleComponent.get("type");const range=childScaleComponent.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range)){const domain=assembleDomain(this.childModel,channel);const field=getFieldFromDomain(domain);if(field){childIndependentFieldsWithStep[channel]=field}else{warn(unknownField(channel))}}}}return childIndependentFieldsWithStep}assembleRowColumnHeaderData(channel,crossedDataName,childIndependentFieldsWithStep){const childChannel={row:"y",column:"x",facet:undefined}[channel];const fields=[];const ops=[];const as=[];if(childChannel&&childIndependentFieldsWithStep&&childIndependentFieldsWithStep[childChannel]){if(crossedDataName){fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);ops.push("max")}else{fields.push(childIndependentFieldsWithStep[childChannel]);ops.push("distinct")}as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`)}const{sortField:sortField,sortIndexField:sortIndexField}=this[channel];if(sortField){const{op:op=DEFAULT_SORT_OP,field:field}=sortField;fields.push(field);ops.push(op);as.push(vgField(sortField,{forAs:true}))}else if(sortIndexField){fields.push(sortIndexField);ops.push("max");as.push(sortIndexField)}return{name:this[channel].name,source:crossedDataName??this.data,transform:[{type:"aggregate",groupby:this[channel].fields,...fields.length?{fields:fields,ops:ops,as:as}:{}}]}}assembleFacetHeaderData(childIndependentFieldsWithStep){const{columns:columns}=this.model.layout;const{layoutHeaders:layoutHeaders}=this.model.component;const data=[];const hasSharedAxis={};for(const headerChannel of HEADER_CHANNELS){for(const headerType of HEADER_TYPES){const headers=(layoutHeaders[headerChannel]&&layoutHeaders[headerChannel][headerType])??[];for(const header of headers){if(header.axes?.length>0){hasSharedAxis[headerChannel]=true;break}}}if(hasSharedAxis[headerChannel]){const cardinality=`length(data("${this.facet.name}"))`;const stop=headerChannel==="row"?columns?{signal:`ceil(${cardinality} / ${columns})`}:1:columns?{signal:`min(${cardinality}, ${columns})`}:{signal:cardinality};data.push({name:`${this.facet.name}_${headerChannel}`,transform:[{type:"sequence",start:0,stop:stop}]})}}const{row:row,column:column}=hasSharedAxis;if(row||column){data.unshift(this.assembleRowColumnHeaderData("facet",null,childIndependentFieldsWithStep))}return data}assemble(){const data=[];let crossedDataName=null;const childIndependentFieldsWithStep=this.getChildIndependentFieldsWithStep();const{column:column,row:row,facet:facet}=this;if(column&&row&&(childIndependentFieldsWithStep.x||childIndependentFieldsWithStep.y)){crossedDataName=`cross_${this.column.name}_${this.row.name}`;const fields=[].concat(childIndependentFieldsWithStep.x??[],childIndependentFieldsWithStep.y??[]);const ops=fields.map((()=>"distinct"));data.push({name:crossedDataName,source:this.data,transform:[{type:"aggregate",groupby:this.fields,fields:fields,ops:ops}]})}for(const channel of[COLUMN,ROW]){if(this[channel]){data.push(this.assembleRowColumnHeaderData(channel,crossedDataName,childIndependentFieldsWithStep))}}if(facet){const facetData=this.assembleFacetHeaderData(childIndependentFieldsWithStep);if(facetData){data.push(...facetData)}}return data}}function unquote(pattern){if(pattern.startsWith("'")&&pattern.endsWith("'")||pattern.startsWith('"')&&pattern.endsWith('"')){return pattern.slice(1,-1)}return pattern}function parseExpression(field,parse){const f=accessPathWithDatum(field);if(parse==="number"){return`toNumber(${f})`}else if(parse==="boolean"){return`toBoolean(${f})`}else if(parse==="string"){return`toString(${f})`}else if(parse==="date"){return`toDate(${f})`}else if(parse==="flatten"){return f}else if(parse.startsWith("date:")){const specifier=unquote(parse.slice(5,parse.length));return`timeParse(${f},'${specifier}')`}else if(parse.startsWith("utc:")){const specifier=unquote(parse.slice(4,parse.length));return`utcParse(${f},'${specifier}')`}else{warn(unrecognizedParse(parse));return null}}function getImplicitFromFilterTransform(transform){const implicit={};forEachLeaf(transform.filter,(filter=>{if(isFieldPredicate(filter)){let val=null;if(isFieldEqualPredicate(filter)){val=signalRefOrValue(filter.equal)}else if(isFieldLTEPredicate(filter)){val=signalRefOrValue(filter.lte)}else if(isFieldLTPredicate(filter)){val=signalRefOrValue(filter.lt)}else if(isFieldGTPredicate(filter)){val=signalRefOrValue(filter.gt)}else if(isFieldGTEPredicate(filter)){val=signalRefOrValue(filter.gte)}else if(isFieldRangePredicate(filter)){val=filter.range[0]}else if(isFieldOneOfPredicate(filter)){val=(filter.oneOf??filter.in)[0]}if(val){if(isDateTime(val)){implicit[filter.field]="date"}else if(isNumber$1(val)){implicit[filter.field]="number"}else if(isString(val)){implicit[filter.field]="string"}}if(filter.timeUnit){implicit[filter.field]="date"}}}));return implicit}function getImplicitFromEncoding(model){const implicit={};function add(fieldDef){if(isFieldOrDatumDefForTimeFormat(fieldDef)){implicit[fieldDef.field]="date"}else if(fieldDef.type==="quantitative"&&isMinMaxOp(fieldDef.aggregate)){implicit[fieldDef.field]="number"}else if(accessPathDepth(fieldDef.field)>1){if(!(fieldDef.field in implicit)){implicit[fieldDef.field]="flatten"}}else if(isScaleFieldDef(fieldDef)&&isSortField(fieldDef.sort)&&accessPathDepth(fieldDef.sort.field)>1){if(!(fieldDef.sort.field in implicit)){implicit[fieldDef.sort.field]="flatten"}}}if(isUnitModel(model)||isFacetModel(model)){model.forEachFieldDef(((fieldDef,channel)=>{if(isTypedFieldDef(fieldDef)){add(fieldDef)}else{const mainChannel=getMainRangeChannel(channel);const mainFieldDef=model.fieldDef(mainChannel);add({...fieldDef,type:mainFieldDef.type})}}))}if(isUnitModel(model)){const{mark:mark,markDef:markDef,encoding:encoding}=model;if(isPathMark(mark)&&!model.encoding.order){const dimensionChannel=markDef.orient==="horizontal"?"y":"x";const dimensionChannelDef=encoding[dimensionChannel];if(isFieldDef(dimensionChannelDef)&&dimensionChannelDef.type==="quantitative"&&!(dimensionChannelDef.field in implicit)){implicit[dimensionChannelDef.field]="number"}}}return implicit}function getImplicitFromSelection(model){const implicit={};if(isUnitModel(model)&&model.component.selection){for(const name of keys(model.component.selection)){const selCmpt=model.component.selection[name];for(const proj of selCmpt.project.items){if(!proj.channel&&accessPathDepth(proj.field)>1){implicit[proj.field]="flatten"}}}}return implicit}class ParseNode extends DataFlowNode{clone(){return new ParseNode(null,duplicate(this._parse))}constructor(parent,parse){super(parent);this._parse=parse}hash(){return`Parse ${hash(this._parse)}`}static makeExplicit(parent,model,ancestorParse){let explicit={};const data=model.data;if(!isGenerator(data)&&data?.format?.parse){explicit=data.format.parse}return this.makeWithAncestors(parent,explicit,{},ancestorParse)}static makeWithAncestors(parent,explicit,implicit,ancestorParse){for(const field of keys(implicit)){const parsedAs=ancestorParse.getWithExplicit(field);if(parsedAs.value!==undefined){if(parsedAs.explicit||parsedAs.value===implicit[field]||parsedAs.value==="derived"||implicit[field]==="flatten"){delete implicit[field]}else{warn(differentParse(field,implicit[field],parsedAs.value))}}}for(const field of keys(explicit)){const parsedAs=ancestorParse.get(field);if(parsedAs!==undefined){if(parsedAs===explicit[field]){delete explicit[field]}else{warn(differentParse(field,explicit[field],parsedAs))}}}const parse=new Split(explicit,implicit);ancestorParse.copyAll(parse);const p={};for(const key of keys(parse.combine())){const val=parse.get(key);if(val!==null){p[key]=val}}if(keys(p).length===0||ancestorParse.parseNothing){return null}return new ParseNode(parent,p)}get parse(){return this._parse}merge(other){this._parse={...this._parse,...other.parse};other.remove()}assembleFormatParse(){const formatParse={};for(const field of keys(this._parse)){const p=this._parse[field];if(accessPathDepth(field)===1){formatParse[field]=p}}return formatParse}producedFields(){return new Set(keys(this._parse))}dependentFields(){return new Set(keys(this._parse))}assembleTransforms(onlyNested=false){return keys(this._parse).filter((field=>onlyNested?accessPathDepth(field)>1:true)).map((field=>{const expr=parseExpression(field,this._parse[field]);if(!expr){return null}const formula={type:"formula",expr:expr,as:removePathFromField(field)};return formula})).filter((t=>t!==null))}}class IdentifierNode extends DataFlowNode{clone(){return new IdentifierNode(null)}constructor(parent){super(parent)}dependentFields(){return new Set}producedFields(){return new Set([SELECTION_ID])}hash(){return"Identifier"}assemble(){return{type:"identifier",as:SELECTION_ID}}}class GraticuleNode extends DataFlowNode{clone(){return new GraticuleNode(null,this.params)}constructor(parent,params){super(parent);this.params=params}dependentFields(){return new Set}producedFields(){return undefined}hash(){return`Graticule ${hash(this.params)}`}assemble(){return{type:"graticule",...this.params===true?{}:this.params}}}class SequenceNode extends DataFlowNode{clone(){return new SequenceNode(null,this.params)}constructor(parent,params){super(parent);this.params=params}dependentFields(){return new Set}producedFields(){return new Set([this.params.as??"data"])}hash(){return`Hash ${hash(this.params)}`}assemble(){return{type:"sequence",...this.params}}}class SourceNode extends DataFlowNode{constructor(data){super(null);data??(data={name:"source"});let format;if(!isGenerator(data)){format=data.format?{...omit(data.format,["parse"])}:{}}if(isInlineData(data)){this._data={values:data.values}}else if(isUrlData(data)){this._data={url:data.url};if(!format.type){let defaultExtension=/(?:\.([^.]+))?$/.exec(data.url)[1];if(!contains(["json","csv","tsv","dsv","topojson"],defaultExtension)){defaultExtension="json"}format.type=defaultExtension}}else if(isSphereGenerator(data)){this._data={values:[{type:"Sphere"}]}}else if(isNamedData(data)||isGenerator(data)){this._data={}}this._generator=isGenerator(data);if(data.name){this._name=data.name}if(format&&!isEmpty(format)){this._data.format=format}}dependentFields(){return new Set}producedFields(){return undefined}get data(){return this._data}hasName(){return!!this._name}get isGenerator(){return this._generator}get dataName(){return this._name}set dataName(name){this._name=name}set parent(parent){throw new Error("Source nodes have to be roots.")}remove(){throw new Error("Source nodes are roots and cannot be removed.")}hash(){throw new Error("Cannot hash sources")}assemble(){return{name:this._name,...this._data,transform:[]}}}var __classPrivateFieldSet=undefined&&undefined.__classPrivateFieldSet||function(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value};var __classPrivateFieldGet=undefined&&undefined.__classPrivateFieldGet||function(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver)};var _Optimizer_modified;function isDataSourceNode(node){return node instanceof SourceNode||node instanceof GraticuleNode||node instanceof SequenceNode}class Optimizer{constructor(){_Optimizer_modified.set(this,void 0);__classPrivateFieldSet(this,_Optimizer_modified,false,"f")}setModified(){__classPrivateFieldSet(this,_Optimizer_modified,true,"f")}get modifiedFlag(){return __classPrivateFieldGet(this,_Optimizer_modified,"f")}}_Optimizer_modified=new WeakMap;class BottomUpOptimizer extends Optimizer{getNodeDepths(node,depth,depths){depths.set(node,depth);for(const child of node.children){this.getNodeDepths(child,depth+1,depths)}return depths}optimize(node){const depths=this.getNodeDepths(node,0,new Map);const topologicalSort=[...depths.entries()].sort(((a,b)=>b[1]-a[1]));for(const tuple of topologicalSort){this.run(tuple[0])}return this.modifiedFlag}}class TopDownOptimizer extends Optimizer{optimize(node){this.run(node);for(const child of node.children){this.optimize(child)}return this.modifiedFlag}}class MergeIdenticalNodes extends TopDownOptimizer{mergeNodes(parent,nodes){const mergedNode=nodes.shift();for(const node of nodes){parent.removeChild(node);node.parent=mergedNode;node.remove()}}run(node){const hashes=node.children.map((x=>x.hash()));const buckets={};for(let i=0;i<hashes.length;i++){if(buckets[hashes[i]]===undefined){buckets[hashes[i]]=[node.children[i]]}else{buckets[hashes[i]].push(node.children[i])}}for(const k of keys(buckets)){if(buckets[k].length>1){this.setModified();this.mergeNodes(node,buckets[k])}}}}class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer{constructor(model){super();this.requiresSelectionId=model&&requiresSelectionId(model)}run(node){if(node instanceof IdentifierNode){if(!(this.requiresSelectionId&&(isDataSourceNode(node.parent)||node.parent instanceof AggregateNode||node.parent instanceof ParseNode))){this.setModified();node.remove()}}}}class RemoveDuplicateTimeUnits extends Optimizer{optimize(node){this.run(node,new Set);return this.modifiedFlag}run(node,timeUnitFields){let producedFields=new Set;if(node instanceof TimeUnitNode){producedFields=node.producedFields();if(hasIntersection(producedFields,timeUnitFields)){this.setModified();node.removeFormulas(timeUnitFields);if(node.producedFields.length===0){node.remove()}}}for(const child of node.children){this.run(child,new Set([...timeUnitFields,...producedFields]))}}}class RemoveUnnecessaryOutputNodes extends TopDownOptimizer{constructor(){super()}run(node){if(node instanceof OutputNode&&!node.isRequired()){this.setModified();node.remove()}}}class MoveParseUp extends BottomUpOptimizer{run(node){if(isDataSourceNode(node)){return}if(node.numChildren()>1){return}for(const child of node.children){if(child instanceof ParseNode){if(node instanceof ParseNode){this.setModified();node.merge(child)}else{if(fieldIntersection(node.producedFields(),child.dependentFields())){continue}this.setModified();child.swapWithParent()}}}return}}class MergeParse extends BottomUpOptimizer{run(node){const originalChildren=[...node.children];const parseChildren=node.children.filter((child=>child instanceof ParseNode));if(node.numChildren()>1&&parseChildren.length>=1){const commonParse={};const conflictingParse=new Set;for(const parseNode of parseChildren){const parse=parseNode.parse;for(const k of keys(parse)){if(!(k in commonParse)){commonParse[k]=parse[k]}else if(commonParse[k]!==parse[k]){conflictingParse.add(k)}}}for(const field of conflictingParse){delete commonParse[field]}if(!isEmpty(commonParse)){this.setModified();const mergedParseNode=new ParseNode(node,commonParse);for(const childNode of originalChildren){if(childNode instanceof ParseNode){for(const key of keys(commonParse)){delete childNode.parse[key]}}node.removeChild(childNode);childNode.parent=mergedParseNode;if(childNode instanceof ParseNode&&keys(childNode.parse).length===0){childNode.remove()}}}}}}class RemoveUnusedSubtrees extends BottomUpOptimizer{run(node){if(node instanceof OutputNode||node.numChildren()>0||node instanceof FacetNode);else if(node instanceof SourceNode);else{this.setModified();node.remove()}}}class MergeTimeUnits extends BottomUpOptimizer{run(node){const timeUnitChildren=node.children.filter((x=>x instanceof TimeUnitNode));const combination=timeUnitChildren.pop();for(const timeUnit of timeUnitChildren){this.setModified();combination.merge(timeUnit)}}}class MergeAggregates extends BottomUpOptimizer{run(node){const aggChildren=node.children.filter((child=>child instanceof AggregateNode));const groupedAggregates={};for(const agg of aggChildren){const groupBys=hash(agg.groupBy);if(!(groupBys in groupedAggregates)){groupedAggregates[groupBys]=[]}groupedAggregates[groupBys].push(agg)}for(const group of keys(groupedAggregates)){const mergeableAggs=groupedAggregates[group];if(mergeableAggs.length>1){const mergedAggs=mergeableAggs.pop();for(const agg of mergeableAggs){if(mergedAggs.merge(agg)){node.removeChild(agg);agg.parent=mergedAggs;agg.remove();this.setModified()}}}}}}class MergeBins extends BottomUpOptimizer{constructor(model){super();this.model=model}run(node){const moveBinsUp=!(isDataSourceNode(node)||node instanceof FilterNode||node instanceof ParseNode||node instanceof IdentifierNode);const promotableBins=[];const remainingBins=[];for(const child of node.children){if(child instanceof BinNode){if(moveBinsUp&&!fieldIntersection(node.producedFields(),child.dependentFields())){promotableBins.push(child)}else{remainingBins.push(child)}}}if(promotableBins.length>0){const promotedBin=promotableBins.pop();for(const bin of promotableBins){promotedBin.merge(bin,this.model.renameSignal.bind(this.model))}this.setModified();if(node instanceof BinNode){node.merge(promotedBin,this.model.renameSignal.bind(this.model))}else{promotedBin.swapWithParent()}}if(remainingBins.length>1){const remainingBin=remainingBins.pop();for(const bin of remainingBins){remainingBin.merge(bin,this.model.renameSignal.bind(this.model))}this.setModified()}}}class MergeOutputs extends BottomUpOptimizer{run(node){const children=[...node.children];const hasOutputChild=some(children,(child=>child instanceof OutputNode));if(!hasOutputChild||node.numChildren()<=1){return}const otherChildren=[];let mainOutput;for(const child of children){if(child instanceof OutputNode){let lastOutput=child;while(lastOutput.numChildren()===1){const[theChild]=lastOutput.children;if(theChild instanceof OutputNode){lastOutput=theChild}else{break}}otherChildren.push(...lastOutput.children);if(mainOutput){node.removeChild(child);child.parent=mainOutput.parent;mainOutput.parent.removeChild(mainOutput);mainOutput.parent=lastOutput;this.setModified()}else{mainOutput=lastOutput}}else{otherChildren.push(child)}}if(otherChildren.length){this.setModified();for(const child of otherChildren){child.parent.removeChild(child);child.parent=mainOutput}}}}class JoinAggregateTransformNode extends DataFlowNode{clone(){return new JoinAggregateTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),(d=>d))}dependentFields(){const out=new Set;if(this.transform.groupby){this.transform.groupby.forEach(out.add,out)}this.transform.joinaggregate.map((w=>w.field)).filter((f=>f!==undefined)).forEach(out.add,out);return out}producedFields(){return new Set(this.transform.joinaggregate.map(this.getDefaultName))}getDefaultName(joinAggregateFieldDef){return joinAggregateFieldDef.as??vgField(joinAggregateFieldDef)}hash(){return`JoinAggregateTransform ${hash(this.transform)}`}assemble(){const fields=[];const ops=[];const as=[];for(const joinaggregate of this.transform.joinaggregate){ops.push(joinaggregate.op);as.push(this.getDefaultName(joinaggregate));fields.push(joinaggregate.field===undefined?null:joinaggregate.field)}const groupby=this.transform.groupby;return{type:"joinaggregate",as:as,ops:ops,fields:fields,...groupby!==undefined?{groupby:groupby}:{}}}}class FilterInvalidNode extends DataFlowNode{clone(){return new FilterInvalidNode(null,{...this.filter})}constructor(parent,filter){super(parent);this.filter=filter}static make(parent,model,dataSourcesForHandlingInvalidValues){const{config:config,markDef:markDef}=model;const{marks:marks,scales:scales}=dataSourcesForHandlingInvalidValues;if(marks==="include-invalid-values"&&scales==="include-invalid-values"){return null}const filter=model.reduceFieldDef(((aggregator,fieldDef,channel)=>{const scaleComponent=isScaleChannel(channel)&&model.getScaleComponent(channel);if(scaleComponent){const scaleType=scaleComponent.get("type");const{aggregate:aggregate}=fieldDef;const invalidDataMode=getScaleInvalidDataMode({scaleChannel:channel,markDef:markDef,config:config,scaleType:scaleType,isCountAggregate:isCountingAggregateOp(aggregate)});if(invalidDataMode!=="show"&&invalidDataMode!=="always-valid"){aggregator[fieldDef.field]=fieldDef}}return aggregator}),{});if(!keys(filter).length){return null}return new FilterInvalidNode(parent,filter)}dependentFields(){return new Set(keys(this.filter))}producedFields(){return new Set}hash(){return`FilterInvalid ${hash(this.filter)}`}assemble(){const filters=keys(this.filter).reduce(((vegaFilters,field)=>{const fieldDef=this.filter[field];const ref=vgField(fieldDef,{expr:"datum"});if(fieldDef!==null){if(fieldDef.type==="temporal"){vegaFilters.push(`(isDate(${ref}) || (${isValidFiniteNumberExpr(ref)}))`)}else if(fieldDef.type==="quantitative"){vegaFilters.push(isValidFiniteNumberExpr(ref))}else;}return vegaFilters}),[]);return filters.length>0?{type:"filter",expr:filters.join(" && ")}:null}}function isValidFiniteNumberExpr(ref){return`isValid(${ref}) && isFinite(+${ref})`}function getStackByFields(model){return model.stack.stackBy.reduce(((fields,by)=>{const fieldDef=by.fieldDef;const _field=vgField(fieldDef);if(_field){fields.push(_field)}return fields}),[])}function isValidAsArray(as){return isArray(as)&&as.every((s=>isString(s)))&&as.length>1}class StackNode extends DataFlowNode{clone(){return new StackNode(null,duplicate(this._stack))}constructor(parent,stack){super(parent);this._stack=stack}static makeFromTransform(parent,stackTransform){const{stack:stack,groupby:groupby,as:as,offset:offset="zero"}=stackTransform;const sortFields=[];const sortOrder=[];if(stackTransform.sort!==undefined){for(const sortField of stackTransform.sort){sortFields.push(sortField.field);sortOrder.push(getFirstDefined(sortField.order,"ascending"))}}const sort={field:sortFields,order:sortOrder};let normalizedAs;if(isValidAsArray(as)){normalizedAs=as}else if(isString(as)){normalizedAs=[as,`${as}_end`]}else{normalizedAs=[`${stackTransform.stack}_start`,`${stackTransform.stack}_end`]}return new StackNode(parent,{dimensionFieldDefs:[],stackField:stack,groupby:groupby,offset:offset,sort:sort,facetby:[],as:normalizedAs})}static makeFromEncoding(parent,model){const stackProperties=model.stack;const{encoding:encoding}=model;if(!stackProperties){return null}const{groupbyChannels:groupbyChannels,fieldChannel:fieldChannel,offset:offset,impute:impute}=stackProperties;const dimensionFieldDefs=groupbyChannels.map((groupbyChannel=>{const cDef=encoding[groupbyChannel];return getFieldDef(cDef)})).filter((def=>!!def));const stackby=getStackByFields(model);const orderDef=model.encoding.order;let sort;if(isArray(orderDef)||isFieldDef(orderDef)){sort=sortParams(orderDef)}else{const sortOrder=isOrderOnlyDef(orderDef)?orderDef.sort:fieldChannel==="y"?"descending":"ascending";sort=stackby.reduce(((s,field)=>{if(!s.field.includes(field)){s.field.push(field);s.order.push(sortOrder)}return s}),{field:[],order:[]})}return new StackNode(parent,{dimensionFieldDefs:dimensionFieldDefs,stackField:model.vgField(fieldChannel),facetby:[],stackby:stackby,sort:sort,offset:offset,impute:impute,as:[model.vgField(fieldChannel,{suffix:"start",forAs:true}),model.vgField(fieldChannel,{suffix:"end",forAs:true})]})}get stack(){return this._stack}addDimensions(fields){this._stack.facetby.push(...fields)}dependentFields(){const out=new Set;out.add(this._stack.stackField);this.getGroupbyFields().forEach(out.add,out);this._stack.facetby.forEach(out.add,out);this._stack.sort.field.forEach(out.add,out);return out}producedFields(){return new Set(this._stack.as)}hash(){return`Stack ${hash(this._stack)}`}getGroupbyFields(){const{dimensionFieldDefs:dimensionFieldDefs,impute:impute,groupby:groupby}=this._stack;if(dimensionFieldDefs.length>0){return dimensionFieldDefs.map((dimensionFieldDef=>{if(dimensionFieldDef.bin){if(impute){return[vgField(dimensionFieldDef,{binSuffix:"mid"})]}return[vgField(dimensionFieldDef,{}),vgField(dimensionFieldDef,{binSuffix:"end"})]}return[vgField(dimensionFieldDef)]})).flat()}return groupby??[]}assemble(){const transform=[];const{facetby:facetby,dimensionFieldDefs:dimensionFieldDefs,stackField:field,stackby:stackby,sort:sort,offset:offset,impute:impute,as:as}=this._stack;if(impute){for(const dimensionFieldDef of dimensionFieldDefs){const{bandPosition:bandPosition=.5,bin:bin}=dimensionFieldDef;if(bin){const binStart=vgField(dimensionFieldDef,{expr:"datum"});const binEnd=vgField(dimensionFieldDef,{expr:"datum",binSuffix:"end"});transform.push({type:"formula",expr:`${isValidFiniteNumberExpr(binStart)} ? ${bandPosition}*${binStart}+${1-bandPosition}*${binEnd} : ${binStart}`,as:vgField(dimensionFieldDef,{binSuffix:"mid",forAs:true})})}transform.push({type:"impute",field:field,groupby:[...stackby,...facetby],key:vgField(dimensionFieldDef,{binSuffix:"mid"}),method:"value",value:0})}}transform.push({type:"stack",groupby:[...this.getGroupbyFields(),...facetby],field:field,sort:sort,as:as,offset:offset});return transform}}class WindowTransformNode extends DataFlowNode{clone(){return new WindowTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),(d=>d))}dependentFields(){const out=new Set;(this.transform.groupby??[]).forEach(out.add,out);(this.transform.sort??[]).forEach((m=>out.add(m.field)));this.transform.window.map((w=>w.field)).filter((f=>f!==undefined)).forEach(out.add,out);return out}producedFields(){return new Set(this.transform.window.map(this.getDefaultName))}getDefaultName(windowFieldDef){return windowFieldDef.as??vgField(windowFieldDef)}hash(){return`WindowTransform ${hash(this.transform)}`}assemble(){const fields=[];const ops=[];const as=[];const params=[];for(const window of this.transform.window){ops.push(window.op);as.push(this.getDefaultName(window));params.push(window.param===undefined?null:window.param);fields.push(window.field===undefined?null:window.field)}const frame=this.transform.frame;const groupby=this.transform.groupby;if(frame&&frame[0]===null&&frame[1]===null&&ops.every((o=>isAggregateOp(o)))){return{type:"joinaggregate",as:as,ops:ops,fields:fields,...groupby!==undefined?{groupby:groupby}:{}}}const sortFields=[];const sortOrder=[];if(this.transform.sort!==undefined){for(const sortField of this.transform.sort){sortFields.push(sortField.field);sortOrder.push(sortField.order??"ascending")}}const sort={field:sortFields,order:sortOrder};const ignorePeers=this.transform.ignorePeers;return{type:"window",params:params,as:as,ops:ops,fields:fields,sort:sort,...ignorePeers!==undefined?{ignorePeers:ignorePeers}:{},...groupby!==undefined?{groupby:groupby}:{},...frame!==undefined?{frame:frame}:{}}}}function cloneSubtree(facet){function clone(node){if(!(node instanceof FacetNode)){const copy=node.clone();if(copy instanceof OutputNode){const newName=FACET_SCALE_PREFIX+copy.getSource();copy.setSource(newName);facet.model.component.data.outputNodes[newName]=copy}else if(copy instanceof AggregateNode||copy instanceof StackNode||copy instanceof WindowTransformNode||copy instanceof JoinAggregateTransformNode){copy.addDimensions(facet.fields)}for(const n of node.children.flatMap(clone)){n.parent=copy}return[copy]}return node.children.flatMap(clone)}return clone}function moveFacetDown(node){if(node instanceof FacetNode){if(node.numChildren()===1&&!(node.children[0]instanceof OutputNode)){const child=node.children[0];if(child instanceof AggregateNode||child instanceof StackNode||child instanceof WindowTransformNode||child instanceof JoinAggregateTransformNode){child.addDimensions(node.fields)}child.swapWithParent();moveFacetDown(node)}else{const facetMain=node.model.component.data.main;moveMainDownToFacet(facetMain);const cloner=cloneSubtree(node);const copy=node.children.map(cloner).flat();for(const c of copy){c.parent=facetMain}}}else{node.children.map(moveFacetDown)}}function moveMainDownToFacet(node){if(node instanceof OutputNode&&node.type===DataSourceType.Main){if(node.numChildren()===1){const child=node.children[0];if(!(child instanceof FacetNode)){child.swapWithParent();moveMainDownToFacet(node)}}}}const FACET_SCALE_PREFIX="scale_";const MAX_OPTIMIZATION_RUNS=5;function checkLinks(nodes){for(const node of nodes){for(const child of node.children){if(child.parent!==node){return false}}if(!checkLinks(node.children)){return false}}return true}function runOptimizer(optimizer,nodes){let modified=false;for(const node of nodes){modified=optimizer.optimize(node)||modified}return modified}function optimizationDataflowHelper(dataComponent,model,firstPass){let roots=dataComponent.sources;let modified=false;modified=runOptimizer(new RemoveUnnecessaryOutputNodes,roots)||modified;modified=runOptimizer(new RemoveUnnecessaryIdentifierNodes(model),roots)||modified;roots=roots.filter((r=>r.numChildren()>0));modified=runOptimizer(new RemoveUnusedSubtrees,roots)||modified;roots=roots.filter((r=>r.numChildren()>0));if(!firstPass){modified=runOptimizer(new MoveParseUp,roots)||modified;modified=runOptimizer(new MergeBins(model),roots)||modified;modified=runOptimizer(new RemoveDuplicateTimeUnits,roots)||modified;modified=runOptimizer(new MergeParse,roots)||modified;modified=runOptimizer(new MergeAggregates,roots)||modified;modified=runOptimizer(new MergeTimeUnits,roots)||modified;modified=runOptimizer(new MergeIdenticalNodes,roots)||modified;modified=runOptimizer(new MergeOutputs,roots)||modified}dataComponent.sources=roots;return modified}function optimizeDataflow(data,model){checkLinks(data.sources);let firstPassCounter=0;let secondPassCounter=0;for(let i=0;i<MAX_OPTIMIZATION_RUNS;i++){if(!optimizationDataflowHelper(data,model,true)){break}firstPassCounter++}data.sources.map(moveFacetDown);for(let i=0;i<MAX_OPTIMIZATION_RUNS;i++){if(!optimizationDataflowHelper(data,model,false)){break}secondPassCounter++}checkLinks(data.sources);if(Math.max(firstPassCounter,secondPassCounter)===MAX_OPTIMIZATION_RUNS){warn(`Maximum optimization runs(${MAX_OPTIMIZATION_RUNS}) reached.`)}}class SignalRefWrapper{constructor(exprGenerator){Object.defineProperty(this,"signal",{enumerable:true,get:exprGenerator})}static fromName(rename,signalName){return new SignalRefWrapper((()=>rename(signalName)))}}function parseScaleDomain(model){if(isUnitModel(model)){parseUnitScaleDomain(model)}else{parseNonUnitScaleDomain(model)}}function parseUnitScaleDomain(model){const localScaleComponents=model.component.scales;for(const channel of keys(localScaleComponents)){const domains=parseDomainForChannel(model,channel);const localScaleCmpt=localScaleComponents[channel];localScaleCmpt.setWithExplicit("domains",domains);parseSelectionDomain(model,channel);if(model.component.data.isFaceted){let facetParent=model;while(!isFacetModel(facetParent)&&facetParent.parent){facetParent=facetParent.parent}const resolve=facetParent.component.resolve.scale[channel];if(resolve==="shared"){for(const domain of domains.value){if(isDataRefDomain(domain)){domain.data=FACET_SCALE_PREFIX+domain.data.replace(FACET_SCALE_PREFIX,"")}}}}}}function parseNonUnitScaleDomain(model){for(const child of model.children){parseScaleDomain(child)}const localScaleComponents=model.component.scales;for(const channel of keys(localScaleComponents)){let domains;let selectionExtent=null;for(const child of model.children){const childComponent=child.component.scales[channel];if(childComponent){if(domains===undefined){domains=childComponent.getWithExplicit("domains")}else{domains=mergeValuesWithExplicit(domains,childComponent.getWithExplicit("domains"),"domains","scale",domainsTieBreaker)}const se=childComponent.get("selectionExtent");if(selectionExtent&&se&&selectionExtent.param!==se.param){warn(NEEDS_SAME_SELECTION)}selectionExtent=se}}localScaleComponents[channel].setWithExplicit("domains",domains);if(selectionExtent){localScaleComponents[channel].set("selectionExtent",selectionExtent,true)}}}function normalizeUnaggregatedDomain(domain,fieldDef,scaleType,scaleConfig){if(domain==="unaggregated"){const{valid:valid,reason:reason}=canUseUnaggregatedDomain(fieldDef,scaleType);if(!valid){warn(reason);return undefined}}else if(domain===undefined&&scaleConfig.useUnaggregatedDomain){const{valid:valid}=canUseUnaggregatedDomain(fieldDef,scaleType);if(valid){return"unaggregated"}}return domain}function parseDomainForChannel(model,channel){const scaleType=model.getScaleComponent(channel).get("type");const{encoding:encoding}=model;const domain=normalizeUnaggregatedDomain(model.scaleDomain(channel),model.typedFieldDef(channel),scaleType,model.config.scale);if(domain!==model.scaleDomain(channel)){model.specifiedScales[channel]={...model.specifiedScales[channel],domain:domain}}if(channel==="x"&&getFieldOrDatumDef(encoding.x2)){if(getFieldOrDatumDef(encoding.x)){return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,domain,model,"x"),parseSingleChannelDomain(scaleType,domain,model,"x2"),"domain","scale",domainsTieBreaker)}else{return parseSingleChannelDomain(scaleType,domain,model,"x2")}}else if(channel==="y"&&getFieldOrDatumDef(encoding.y2)){if(getFieldOrDatumDef(encoding.y)){return mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,domain,model,"y"),parseSingleChannelDomain(scaleType,domain,model,"y2"),"domain","scale",domainsTieBreaker)}else{return parseSingleChannelDomain(scaleType,domain,model,"y2")}}return parseSingleChannelDomain(scaleType,domain,model,channel)}function mapDomainToDataSignal(domain,type,timeUnit){return domain.map((v=>{const data=valueExpr(v,{timeUnit:timeUnit,type:type});return{signal:`{data: ${data}}`}}))}function convertDomainIfItIsDateTime(domain,type,timeUnit){const normalizedTimeUnit=normalizeTimeUnit(timeUnit)?.unit;if(type==="temporal"||normalizedTimeUnit){return mapDomainToDataSignal(domain,type,normalizedTimeUnit)}return[domain]}function parseSingleChannelDomain(scaleType,domain,model,channel){const{encoding:encoding,markDef:markDef,mark:mark,config:config,stack:stack}=model;const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);const{type:type}=fieldOrDatumDef;const timeUnit=fieldOrDatumDef["timeUnit"];const dataSourceTypeForScaleDomain=getScaleDataSourceForHandlingInvalidValues({invalid:getMarkConfig("invalid",markDef,config),isPath:isPathMark(mark)});if(isDomainUnionWith(domain)){const defaultDomain=parseSingleChannelDomain(scaleType,undefined,model,channel);const unionWith=convertDomainIfItIsDateTime(domain.unionWith,type,timeUnit);return makeExplicit([...unionWith,...defaultDomain.value])}else if(isSignalRef(domain)){return makeExplicit([domain])}else if(domain&&domain!=="unaggregated"&&!isParameterDomain(domain)){return makeExplicit(convertDomainIfItIsDateTime(domain,type,timeUnit))}if(stack&&channel===stack.fieldChannel){if(stack.offset==="normalize"){return makeImplicit([[0,1]])}const data=model.requestDataName(dataSourceTypeForScaleDomain);return makeImplicit([{data:data,field:model.vgField(channel,{suffix:"start"})},{data:data,field:model.vgField(channel,{suffix:"end"})}])}const sort=isScaleChannel(channel)&&isFieldDef(fieldOrDatumDef)?domainSort(model,channel,scaleType):undefined;if(isDatumDef(fieldOrDatumDef)){const d=convertDomainIfItIsDateTime([fieldOrDatumDef.datum],type,timeUnit);return makeImplicit(d)}const fieldDef=fieldOrDatumDef;if(domain==="unaggregated"){const{field:field}=fieldOrDatumDef;return makeImplicit([{data:model.requestDataName(dataSourceTypeForScaleDomain),field:vgField({field:field,aggregate:"min"})},{data:model.requestDataName(dataSourceTypeForScaleDomain),field:vgField({field:field,aggregate:"max"})}])}else if(isBinning(fieldDef.bin)){if(hasDiscreteDomain(scaleType)){if(scaleType==="bin-ordinal"){return makeImplicit([])}return makeImplicit([{data:isBoolean(sort)?model.requestDataName(dataSourceTypeForScaleDomain):model.requestDataName(DataSourceType.Raw),field:model.vgField(channel,binRequiresRange(fieldDef,channel)?{binSuffix:"range"}:{}),sort:sort===true||!isObject(sort)?{field:model.vgField(channel,{}),op:"min"}:sort}])}else{const{bin:bin}=fieldDef;if(isBinning(bin)){const binSignal=getBinSignalName(model,fieldDef.field,bin);return makeImplicit([new SignalRefWrapper((()=>{const signal=model.getSignalName(binSignal);return`[${signal}.start, ${signal}.stop]`}))])}else{return makeImplicit([{data:model.requestDataName(dataSourceTypeForScaleDomain),field:model.vgField(channel,{})}])}}}else if(fieldDef.timeUnit&&contains(["time","utc"],scaleType)){const fieldDef2=encoding[getSecondaryRangeChannel(channel)];if(hasBandEnd(fieldDef,fieldDef2,markDef,config)){const data=model.requestDataName(dataSourceTypeForScaleDomain);const bandPosition=getBandPosition({fieldDef:fieldDef,fieldDef2:fieldDef2,markDef:markDef,config:config});const isRectWithOffset=isRectBasedMark(mark)&&bandPosition!==.5&&isXorY(channel);return makeImplicit([{data:data,field:model.vgField(channel,isRectWithOffset?{suffix:OFFSETTED_RECT_START_SUFFIX}:{})},{data:data,field:model.vgField(channel,{suffix:isRectWithOffset?OFFSETTED_RECT_END_SUFFIX:"end"})}])}}if(sort){return makeImplicit([{data:isBoolean(sort)?model.requestDataName(dataSourceTypeForScaleDomain):model.requestDataName(DataSourceType.Raw),field:model.vgField(channel),sort:sort}])}else{return makeImplicit([{data:model.requestDataName(dataSourceTypeForScaleDomain),field:model.vgField(channel)}])}}function normalizeSortField(sort,isStackedMeasure){const{op:op,field:field,order:order}=sort;return{op:op??(isStackedMeasure?"sum":DEFAULT_SORT_OP),...field?{field:replacePathInField(field)}:{},...order?{order:order}:{}}}function parseSelectionDomain(model,channel){const scale=model.component.scales[channel];const spec=model.specifiedScales[channel].domain;const bin=model.fieldDef(channel)?.bin;const domain=isParameterDomain(spec)?spec:undefined;const extent=isBinParams(bin)&&isParameterExtent(bin.extent)?bin.extent:undefined;if(domain||extent){scale.set("selectionExtent",domain??extent,true)}}function domainSort(model,channel,scaleType){if(!hasDiscreteDomain(scaleType)){return undefined}const fieldDef=model.fieldDef(channel);const sort=fieldDef.sort;if(isSortArray(sort)){return{op:"min",field:sortArrayIndexField(fieldDef,channel),order:"ascending"}}const{stack:stack}=model;const stackDimensions=stack?new Set([...stack.groupbyFields,...stack.stackBy.map((s=>s.fieldDef.field))]):undefined;if(isSortField(sort)){const isStackedMeasure=stack&&!stackDimensions.has(sort.field);return normalizeSortField(sort,isStackedMeasure)}else if(isSortByEncoding(sort)){const{encoding:encoding,order:order}=sort;const fieldDefToSortBy=model.fieldDef(encoding);const{aggregate:aggregate,field:field}=fieldDefToSortBy;const isStackedMeasure=stack&&!stackDimensions.has(field);if(isArgminDef(aggregate)||isArgmaxDef(aggregate)){return normalizeSortField({field:vgField(fieldDefToSortBy),order:order},isStackedMeasure)}else if(isAggregateOp(aggregate)||!aggregate){return normalizeSortField({op:aggregate,field:field,order:order},isStackedMeasure)}}else if(sort==="descending"){return{op:"min",field:model.vgField(channel),order:"descending"}}else if(contains(["ascending",undefined],sort)){return true}return undefined}function canUseUnaggregatedDomain(fieldDef,scaleType){const{aggregate:aggregate,type:type}=fieldDef;if(!aggregate){return{valid:false,reason:unaggregateDomainHasNoEffectForRawField(fieldDef)}}if(isString(aggregate)&&!SHARED_DOMAIN_OPS.has(aggregate)){return{valid:false,reason:unaggregateDomainWithNonSharedDomainOp(aggregate)}}if(type==="quantitative"){if(scaleType==="log"){return{valid:false,reason:unaggregatedDomainWithLogScale(fieldDef)}}}return{valid:true}}function domainsTieBreaker(v1,v2,property,propertyOf){if(v1.explicit&&v2.explicit){warn(mergeConflictingDomainProperty(property,propertyOf,v1.value,v2.value))}return{explicit:v1.explicit,value:[...v1.value,...v2.value]}}function mergeDomains(domains){const uniqueDomains=unique(domains.map((domain=>{if(isDataRefDomain(domain)){const{sort:_s,...domainWithoutSort}=domain;return domainWithoutSort}return domain})),hash);const sorts=unique(domains.map((d=>{if(isDataRefDomain(d)){const s=d.sort;if(s!==undefined&&!isBoolean(s)){if("op"in s&&s.op==="count"){delete s.field}if(s.order==="ascending"){delete s.order}}return s}return undefined})).filter((s=>s!==undefined)),hash);if(uniqueDomains.length===0){return undefined}else if(uniqueDomains.length===1){const domain=domains[0];if(isDataRefDomain(domain)&&sorts.length>0){let sort=sorts[0];if(sorts.length>1){warn(MORE_THAN_ONE_SORT);const filteredSorts=sorts.filter((s=>isObject(s)&&"op"in s&&s.op!=="min"));if(sorts.every((s=>isObject(s)&&"op"in s))&&filteredSorts.length===1){sort=filteredSorts[0]}else{sort=true}}else{if(isObject(sort)&&"field"in sort){const sortField=sort.field;if(domain.field===sortField){sort=sort.order?{order:sort.order}:true}}}return{...domain,sort:sort}}return domain}const unionDomainSorts=unique(sorts.map((s=>{if(isBoolean(s)||!("op"in s)||isString(s.op)&&has$1(MULTIDOMAIN_SORT_OP_INDEX,s.op)){return s}warn(domainSortDropped(s));return true})),hash);let sort;if(unionDomainSorts.length===1){sort=unionDomainSorts[0]}else if(unionDomainSorts.length>1){warn(MORE_THAN_ONE_SORT);sort=true}const allData=unique(domains.map((d=>{if(isDataRefDomain(d)){return d.data}return null})),(x=>x));if(allData.length===1&&allData[0]!==null){const domain={data:allData[0],fields:uniqueDomains.map((d=>d.field)),...sort?{sort:sort}:{}};return domain}return{fields:uniqueDomains,...sort?{sort:sort}:{}}}function getFieldFromDomain(domain){if(isDataRefDomain(domain)&&isString(domain.field)){return domain.field}else if(isDataRefUnionedDomain(domain)){let field;for(const nonUnionDomain of domain.fields){if(isDataRefDomain(nonUnionDomain)&&isString(nonUnionDomain.field)){if(!field){field=nonUnionDomain.field}else if(field!==nonUnionDomain.field){warn(FACETED_INDEPENDENT_DIFFERENT_SOURCES);return field}}}warn(FACETED_INDEPENDENT_SAME_FIELDS_DIFFERENT_SOURCES);return field}else if(isFieldRefUnionDomain(domain)){warn(FACETED_INDEPENDENT_SAME_SOURCE);const field=domain.fields[0];return isString(field)?field:undefined}return undefined}function assembleDomain(model,channel){const scaleComponent=model.component.scales[channel];const domains=scaleComponent.get("domains").map((domain=>{if(isDataRefDomain(domain)){domain.data=model.lookupDataSource(domain.data)}return domain}));return mergeDomains(domains)}function assembleScales(model){if(isLayerModel(model)||isConcatModel(model)){return model.children.reduce(((scales,child)=>scales.concat(assembleScales(child))),assembleScalesForModel(model))}else{return assembleScalesForModel(model)}}function assembleScalesForModel(model){return keys(model.component.scales).reduce(((scales,channel)=>{const scaleComponent=model.component.scales[channel];if(scaleComponent.merged){return scales}const scale=scaleComponent.combine();const{name:name,type:type,selectionExtent:selectionExtent,domains:_d,range:_r,reverse:reverse,...otherScaleProps}=scale;const range=assembleScaleRange(scale.range,name,channel,model);const domain=assembleDomain(model,channel);const domainRaw=selectionExtent?assembleSelectionScaleDomain(model,selectionExtent,scaleComponent,domain):null;scales.push({name:name,type:type,...domain?{domain:domain}:{},...domainRaw?{domainRaw:domainRaw}:{},range:range,...reverse!==undefined?{reverse:reverse}:{},...otherScaleProps});return scales}),[])}function assembleScaleRange(scaleRange,scaleName,channel,model){if(isXorY(channel)){if(isVgRangeStep(scaleRange)){return{step:{signal:`${scaleName}_step`}}}}else if(isObject(scaleRange)&&isDataRefDomain(scaleRange)){return{...scaleRange,data:model.lookupDataSource(scaleRange.data)}}return scaleRange}class ScaleComponent extends Split{constructor(name,typeWithExplicit){super({},{name:name});this.merged=false;this.setWithExplicit("type",typeWithExplicit)}domainHasZero(){const scaleType=this.get("type");if(contains([ScaleType.LOG,ScaleType.TIME,ScaleType.UTC],scaleType)){return"definitely-not"}const scaleZero=this.get("zero");if(scaleZero===true||scaleZero===undefined&&contains([ScaleType.LINEAR,ScaleType.SQRT,ScaleType.POW],scaleType)){return"definitely"}const domains=this.get("domains");if(domains.length>0){let hasExplicitDomainWithZero=false;let hasExplicitDomainWithoutZero=false;let hasDomainBasedOnField=false;for(const d of domains){if(isArray(d)){const first=d[0];const last=d[d.length-1];if(isNumber$1(first)&&isNumber$1(last)){if(first<=0&&last>=0){hasExplicitDomainWithZero=true;continue}else{hasExplicitDomainWithoutZero=true;continue}}}hasDomainBasedOnField=true}if(hasExplicitDomainWithZero){return"definitely"}else if(hasExplicitDomainWithoutZero&&!hasDomainBasedOnField){return"definitely-not"}}return"maybe"}}const RANGE_PROPERTIES=["range","scheme"];function parseUnitScaleRange(model){const localScaleComponents=model.component.scales;for(const channel of SCALE_CHANNELS){const localScaleCmpt=localScaleComponents[channel];if(!localScaleCmpt){continue}const rangeWithExplicit=parseRangeForChannel(channel,model);localScaleCmpt.setWithExplicit("range",rangeWithExplicit)}}function getBinStepSignal(model,channel){const fieldDef=model.fieldDef(channel);if(fieldDef?.bin){const{bin:bin,field:field}=fieldDef;const sizeType=getSizeChannel(channel);const sizeSignal=model.getName(sizeType);if(isObject(bin)&&bin.binned&&bin.step!==undefined){return new SignalRefWrapper((()=>{const scaleName=model.scaleName(channel);const binCount=`(domain("${scaleName}")[1] - domain("${scaleName}")[0]) / ${bin.step}`;return`${model.getSignalName(sizeSignal)} / (${binCount})`}))}else if(isBinning(bin)){const binSignal=getBinSignalName(model,field,bin);return new SignalRefWrapper((()=>{const updatedName=model.getSignalName(binSignal);const binCount=`(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;return`${model.getSignalName(sizeSignal)} / (${binCount})`}))}}return undefined}function parseRangeForChannel(channel,model){const specifiedScale=model.specifiedScales[channel];const{size:size}=model;const mergedScaleCmpt=model.getScaleComponent(channel);const scaleType=mergedScaleCmpt.get("type");for(const property of RANGE_PROPERTIES){if(specifiedScale[property]!==undefined){const supportedByScaleType=scaleTypeSupportProperty(scaleType,property);const channelIncompatability=channelScalePropertyIncompatability(channel,property);if(!supportedByScaleType){warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel))}else if(channelIncompatability){warn(channelIncompatability)}else{switch(property){case"range":{const range=specifiedScale.range;if(isArray(range)){if(isXorY(channel)){return makeExplicit(range.map((v=>{if(v==="width"||v==="height"){const sizeSignal=model.getName(v);const getSignalName=model.getSignalName.bind(model);return SignalRefWrapper.fromName(getSignalName,sizeSignal)}return v})))}}else if(isObject(range)){return makeExplicit({data:model.requestDataName(DataSourceType.Main),field:range.field,sort:{op:"min",field:model.vgField(channel)}})}return makeExplicit(range)}case"scheme":return makeExplicit(parseScheme(specifiedScale[property]))}}}}const sizeChannel=channel===X||channel==="xOffset"?"width":"height";const sizeValue=size[sizeChannel];if(isStep(sizeValue)){if(isXorY(channel)){if(hasDiscreteDomain(scaleType)){const step=getPositionStep(sizeValue,model,channel);if(step){return makeExplicit({step:step})}}else{warn(stepDropped(sizeChannel))}}else if(isXorYOffset(channel)){const positionChannel=channel===XOFFSET?"x":"y";const positionScaleCmpt=model.getScaleComponent(positionChannel);const positionScaleType=positionScaleCmpt.get("type");if(positionScaleType==="band"){const step=getOffsetStep(sizeValue,scaleType);if(step){return makeExplicit(step)}}}}const{rangeMin:rangeMin,rangeMax:rangeMax}=specifiedScale;const d=defaultRange(channel,model);if((rangeMin!==undefined||rangeMax!==undefined)&&scaleTypeSupportProperty(scaleType,"rangeMin")&&isArray(d)&&d.length===2){return makeExplicit([rangeMin??d[0],rangeMax??d[1]])}return makeImplicit(d)}function parseScheme(scheme){if(isExtendedScheme(scheme)){return{scheme:scheme.name,...omit(scheme,["name"])}}return{scheme:scheme}}function fullWidthOrHeightRange(channel,model,scaleType,{center:center}={}){const sizeType=getSizeChannel(channel);const sizeSignal=model.getName(sizeType);const getSignalName=model.getSignalName.bind(model);if(channel===Y&&hasContinuousDomain(scaleType)){return center?[SignalRefWrapper.fromName((name=>`${getSignalName(name)}/2`),sizeSignal),SignalRefWrapper.fromName((name=>`-${getSignalName(name)}/2`),sizeSignal)]:[SignalRefWrapper.fromName(getSignalName,sizeSignal),0]}else{return center?[SignalRefWrapper.fromName((name=>`-${getSignalName(name)}/2`),sizeSignal),SignalRefWrapper.fromName((name=>`${getSignalName(name)}/2`),sizeSignal)]:[0,SignalRefWrapper.fromName(getSignalName,sizeSignal)]}}function defaultRange(channel,model){const{size:size,config:config,mark:mark,encoding:encoding}=model;const{type:type}=getFieldOrDatumDef(encoding[channel]);const mergedScaleCmpt=model.getScaleComponent(channel);const scaleType=mergedScaleCmpt.get("type");const{domain:domain,domainMid:domainMid}=model.specifiedScales[channel];switch(channel){case X:case Y:{if(contains(["point","band"],scaleType)){const positionSize=getDiscretePositionSize(channel,size,config.view);if(isStep(positionSize)){const step=getPositionStep(positionSize,model,channel);return{step:step}}}return fullWidthOrHeightRange(channel,model,scaleType)}case XOFFSET:case YOFFSET:return getOffsetRange(channel,model,scaleType);case SIZE:{const rangeMin=sizeRangeMin(mark,config);const rangeMax=sizeRangeMax(mark,size,model,config);if(isContinuousToDiscrete(scaleType)){return interpolateRange(rangeMin,rangeMax,defaultContinuousToDiscreteCount(scaleType,config,domain,channel))}else{return[rangeMin,rangeMax]}}case THETA:return[0,Math.PI*2];case ANGLE:return[0,360];case RADIUS:{return[0,new SignalRefWrapper((()=>{const w=model.getSignalName(isFacetModel(model.parent)?"child_width":"width");const h=model.getSignalName(isFacetModel(model.parent)?"child_height":"height");return`min(${w},${h})/2`}))]}case STROKEWIDTH:return[config.scale.minStrokeWidth,config.scale.maxStrokeWidth];case STROKEDASH:return[[1,0],[4,2],[2,1],[1,1],[1,2,4,2]];case SHAPE:return"symbol";case COLOR:case FILL:case STROKE:if(scaleType==="ordinal"){return type==="nominal"?"category":"ordinal"}else{if(domainMid!==undefined){return"diverging"}else{return mark==="rect"||mark==="geoshape"?"heatmap":"ramp"}}case OPACITY:case FILLOPACITY:case STROKEOPACITY:return[config.scale.minOpacity,config.scale.maxOpacity]}}function getPositionStep(step,model,channel){const{encoding:encoding}=model;const mergedScaleCmpt=model.getScaleComponent(channel);const offsetChannel=getOffsetScaleChannel(channel);const offsetDef=encoding[offsetChannel];const stepFor=getStepFor({step:step,offsetIsDiscrete:isFieldOrDatumDef(offsetDef)&&isDiscrete$1(offsetDef.type)});if(stepFor==="offset"&&channelHasFieldOrDatum(encoding,offsetChannel)){const offsetScaleCmpt=model.getScaleComponent(offsetChannel);const offsetScaleName=model.scaleName(offsetChannel);let stepCount=`domain('${offsetScaleName}').length`;if(offsetScaleCmpt.get("type")==="band"){const offsetPaddingInner=offsetScaleCmpt.get("paddingInner")??offsetScaleCmpt.get("padding")??0;const offsetPaddingOuter=offsetScaleCmpt.get("paddingOuter")??offsetScaleCmpt.get("padding")??0;stepCount=`bandspace(${stepCount}, ${offsetPaddingInner}, ${offsetPaddingOuter})`}const paddingInner=mergedScaleCmpt.get("paddingInner")??mergedScaleCmpt.get("padding");return{signal:`${step.step} * ${stepCount} / (1-${exprFromSignalRefOrValue(paddingInner)})`}}else{return step.step}}function getOffsetStep(step,offsetScaleType){const stepFor=getStepFor({step:step,offsetIsDiscrete:hasDiscreteDomain(offsetScaleType)});if(stepFor==="offset"){return{step:step.step}}return undefined}function getOffsetRange(channel,model,offsetScaleType){const positionChannel=channel===XOFFSET?"x":"y";const positionScaleCmpt=model.getScaleComponent(positionChannel);if(!positionScaleCmpt){return fullWidthOrHeightRange(positionChannel,model,offsetScaleType,{center:true})}const positionScaleType=positionScaleCmpt.get("type");const positionScaleName=model.scaleName(positionChannel);const{markDef:markDef,config:config}=model;if(positionScaleType==="band"){const size=getDiscretePositionSize(positionChannel,model.size,model.config.view);if(isStep(size)){const step=getOffsetStep(size,offsetScaleType);if(step){return step}}return[0,{signal:`bandwidth('${positionScaleName}')`}]}else{const positionDef=model.encoding[positionChannel];if(isFieldDef(positionDef)&&positionDef.timeUnit){const duration=durationExpr(positionDef.timeUnit,(expr=>`scale('${positionScaleName}', ${expr})`));const padding=model.config.scale.bandWithNestedOffsetPaddingInner;const bandPositionOffset=getBandPosition({fieldDef:positionDef,markDef:markDef,config:config})-.5;const bandPositionOffsetExpr=bandPositionOffset!==0?` + ${bandPositionOffset}`:"";if(padding){const startRatio=isSignalRef(padding)?`${padding.signal}/2`+bandPositionOffsetExpr:`${padding/2+bandPositionOffset}`;const endRatio=isSignalRef(padding)?`(1 - ${padding.signal}/2)`+bandPositionOffsetExpr:`${1-padding/2+bandPositionOffset}`;return[{signal:`${startRatio} * (${duration})`},{signal:`${endRatio} * (${duration})`}]}return[0,{signal:duration}]}return never(`Cannot use ${channel} scale if ${positionChannel} scale is not discrete.`)}}function getDiscretePositionSize(channel,size,viewConfig){const sizeChannel=channel===X?"width":"height";const sizeValue=size[sizeChannel];if(sizeValue){return sizeValue}return getViewConfigDiscreteSize(viewConfig,sizeChannel)}function defaultContinuousToDiscreteCount(scaleType,config,domain,channel){switch(scaleType){case"quantile":return config.scale.quantileCount;case"quantize":return config.scale.quantizeCount;case"threshold":if(domain!==undefined&&isArray(domain)){return domain.length+1}else{warn(domainRequiredForThresholdScale(channel));return 3}}}function interpolateRange(rangeMin,rangeMax,cardinality){const f=()=>{const rMax=signalOrStringValue(rangeMax);const rMin=signalOrStringValue(rangeMin);const step=`(${rMax} - ${rMin}) / (${cardinality} - 1)`;return`sequence(${rMin}, ${rMax} + ${step}, ${step})`};if(isSignalRef(rangeMax)){return new SignalRefWrapper(f)}else{return{signal:f()}}}function sizeRangeMin(mark,config){switch(mark){case"bar":case"tick":return config.scale.minBandSize;case"line":case"trail":case"rule":return config.scale.minStrokeWidth;case"text":return config.scale.minFontSize;case"point":case"square":case"circle":return config.scale.minSize}throw new Error(incompatibleChannel("size",mark))}const MAX_SIZE_RANGE_STEP_RATIO=.95;function sizeRangeMax(mark,size,model,config){const xyStepSignals={x:getBinStepSignal(model,"x"),y:getBinStepSignal(model,"y")};switch(mark){case"bar":case"tick":{if(config.scale.maxBandSize!==undefined){return config.scale.maxBandSize}const min=minXYStep(size,xyStepSignals,config.view);if(isNumber$1(min)){return min-1}else{return new SignalRefWrapper((()=>`${min.signal} - 1`))}}case"line":case"trail":case"rule":return config.scale.maxStrokeWidth;case"text":return config.scale.maxFontSize;case"point":case"square":case"circle":{if(config.scale.maxSize){return config.scale.maxSize}const pointStep=minXYStep(size,xyStepSignals,config.view);if(isNumber$1(pointStep)){return Math.pow(MAX_SIZE_RANGE_STEP_RATIO*pointStep,2)}else{return new SignalRefWrapper((()=>`pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`))}}}throw new Error(incompatibleChannel("size",mark))}function minXYStep(size,xyStepSignals,viewConfig){const widthStep=isStep(size.width)?size.width.step:getViewConfigDiscreteStep(viewConfig,"width");const heightStep=isStep(size.height)?size.height.step:getViewConfigDiscreteStep(viewConfig,"height");if(xyStepSignals.x||xyStepSignals.y){return new SignalRefWrapper((()=>{const exprs=[xyStepSignals.x?xyStepSignals.x.signal:widthStep,xyStepSignals.y?xyStepSignals.y.signal:heightStep];return`min(${exprs.join(", ")})`}))}return Math.min(widthStep,heightStep)}function parseScaleProperty(model,property){if(isUnitModel(model)){parseUnitScaleProperty(model,property)}else{parseNonUnitScaleProperty(model,property)}}function parseUnitScaleProperty(model,property){const localScaleComponents=model.component.scales;const{config:config,encoding:encoding,markDef:markDef,specifiedScales:specifiedScales}=model;for(const channel of keys(localScaleComponents)){const specifiedScale=specifiedScales[channel];const localScaleCmpt=localScaleComponents[channel];const mergedScaleCmpt=model.getScaleComponent(channel);const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);const specifiedValue=specifiedScale[property];const scaleType=mergedScaleCmpt.get("type");const scalePadding=mergedScaleCmpt.get("padding");const scalePaddingInner=mergedScaleCmpt.get("paddingInner");const supportedByScaleType=scaleTypeSupportProperty(scaleType,property);const channelIncompatability=channelScalePropertyIncompatability(channel,property);if(specifiedValue!==undefined){if(!supportedByScaleType){warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel))}else if(channelIncompatability){warn(channelIncompatability)}}if(supportedByScaleType&&channelIncompatability===undefined){if(specifiedValue!==undefined){const timeUnit=fieldOrDatumDef.timeUnit;const type=fieldOrDatumDef.type;switch(property){case"domainMax":case"domainMin":if(isDateTime(specifiedScale[property])||type==="temporal"||timeUnit){localScaleCmpt.set(property,{signal:valueExpr(specifiedScale[property],{type:type,timeUnit:timeUnit})},true)}else{localScaleCmpt.set(property,specifiedScale[property],true)}break;default:localScaleCmpt.copyKeyFromObject(property,specifiedScale)}}else{const value=hasProperty(scaleRules,property)?scaleRules[property]({model:model,channel:channel,fieldOrDatumDef:fieldOrDatumDef,scaleType:scaleType,scalePadding:scalePadding,scalePaddingInner:scalePaddingInner,domain:specifiedScale.domain,domainMin:specifiedScale.domainMin,domainMax:specifiedScale.domainMax,markDef:markDef,config:config,hasNestedOffsetScale:channelHasNestedOffsetScale(encoding,channel),hasSecondaryRangeChannel:!!encoding[getSecondaryRangeChannel(channel)]}):config.scale[property];if(value!==undefined){localScaleCmpt.set(property,value,false)}}}}}const scaleRules={bins:({model:model,fieldOrDatumDef:fieldOrDatumDef})=>isFieldDef(fieldOrDatumDef)?bins(model,fieldOrDatumDef):undefined,interpolate:({channel:channel,fieldOrDatumDef:fieldOrDatumDef})=>interpolate(channel,fieldOrDatumDef.type),nice:({scaleType:scaleType,channel:channel,domain:domain,domainMin:domainMin,domainMax:domainMax,fieldOrDatumDef:fieldOrDatumDef})=>nice(scaleType,channel,domain,domainMin,domainMax,fieldOrDatumDef),padding:({channel:channel,scaleType:scaleType,fieldOrDatumDef:fieldOrDatumDef,markDef:markDef,config:config})=>padding(channel,scaleType,config.scale,fieldOrDatumDef,markDef,config.bar),paddingInner:({scalePadding:scalePadding,channel:channel,markDef:markDef,scaleType:scaleType,config:config,hasNestedOffsetScale:hasNestedOffsetScale})=>paddingInner(scalePadding,channel,markDef.type,scaleType,config.scale,hasNestedOffsetScale),paddingOuter:({scalePadding:scalePadding,channel:channel,scaleType:scaleType,scalePaddingInner:scalePaddingInner,config:config,hasNestedOffsetScale:hasNestedOffsetScale})=>paddingOuter(scalePadding,channel,scaleType,scalePaddingInner,config.scale,hasNestedOffsetScale),reverse:({fieldOrDatumDef:fieldOrDatumDef,scaleType:scaleType,channel:channel,config:config})=>{const sort=isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.sort:undefined;return reverse(scaleType,sort,channel,config.scale)},zero:({channel:channel,fieldOrDatumDef:fieldOrDatumDef,domain:domain,markDef:markDef,scaleType:scaleType,config:config,hasSecondaryRangeChannel:hasSecondaryRangeChannel})=>zero(channel,fieldOrDatumDef,domain,markDef,scaleType,config.scale,hasSecondaryRangeChannel)};function parseScaleRange(model){if(isUnitModel(model)){parseUnitScaleRange(model)}else{parseNonUnitScaleProperty(model,"range")}}function parseNonUnitScaleProperty(model,property){const localScaleComponents=model.component.scales;for(const child of model.children){if(property==="range"){parseScaleRange(child)}else{parseScaleProperty(child,property)}}for(const channel of keys(localScaleComponents)){let valueWithExplicit;for(const child of model.children){const childComponent=child.component.scales[channel];if(childComponent){const childValueWithExplicit=childComponent.getWithExplicit(property);valueWithExplicit=mergeValuesWithExplicit(valueWithExplicit,childValueWithExplicit,property,"scale",tieBreakByComparing(((v1,v2)=>{switch(property){case"range":if(v1.step&&v2.step){return v1.step-v2.step}return 0}return 0})))}}localScaleComponents[channel].setWithExplicit(property,valueWithExplicit)}}function bins(model,fieldDef){const bin=fieldDef.bin;if(isBinning(bin)){const binSignal=getBinSignalName(model,fieldDef.field,bin);return new SignalRefWrapper((()=>model.getSignalName(binSignal)))}else if(isBinned(bin)&&isBinParams(bin)&&bin.step!==undefined){return{step:bin.step}}return undefined}function interpolate(channel,type){if(contains([COLOR,FILL,STROKE],channel)&&type!=="nominal"){return"hcl"}return undefined}function nice(scaleType,channel,specifiedDomain,domainMin,domainMax,fieldOrDatumDef){if(getFieldDef(fieldOrDatumDef)?.bin||isArray(specifiedDomain)||domainMax!=null||domainMin!=null||contains([ScaleType.TIME,ScaleType.UTC],scaleType)){return undefined}return isXorY(channel)?true:undefined}function padding(channel,scaleType,scaleConfig,fieldOrDatumDef,markDef,barConfig){if(isXorY(channel)){if(isContinuousToContinuous(scaleType)){if(scaleConfig.continuousPadding!==undefined){return scaleConfig.continuousPadding}const{type:type,orient:orient}=markDef;if(type==="bar"&&!(isFieldDef(fieldOrDatumDef)&&(fieldOrDatumDef.bin||fieldOrDatumDef.timeUnit))){if(orient==="vertical"&&channel==="x"||orient==="horizontal"&&channel==="y"){return barConfig.continuousBandSize}}}if(scaleType===ScaleType.POINT){return scaleConfig.pointPadding}}return undefined}function paddingInner(paddingValue,channel,mark,scaleType,scaleConfig,hasNestedOffsetScale=false){if(paddingValue!==undefined){return undefined}if(isXorY(channel)){const{bandPaddingInner:bandPaddingInner,barBandPaddingInner:barBandPaddingInner,rectBandPaddingInner:rectBandPaddingInner,tickBandPaddingInner:tickBandPaddingInner,bandWithNestedOffsetPaddingInner:bandWithNestedOffsetPaddingInner}=scaleConfig;if(hasNestedOffsetScale){return bandWithNestedOffsetPaddingInner}return getFirstDefined(bandPaddingInner,mark==="bar"?barBandPaddingInner:mark==="tick"?tickBandPaddingInner:rectBandPaddingInner)}else if(isXorYOffset(channel)){if(scaleType===ScaleType.BAND){return scaleConfig.offsetBandPaddingInner}}return undefined}function paddingOuter(paddingValue,channel,scaleType,paddingInnerValue,scaleConfig,hasNestedOffsetScale=false){if(paddingValue!==undefined){return undefined}if(isXorY(channel)){const{bandPaddingOuter:bandPaddingOuter,bandWithNestedOffsetPaddingOuter:bandWithNestedOffsetPaddingOuter}=scaleConfig;if(hasNestedOffsetScale){return bandWithNestedOffsetPaddingOuter}if(scaleType===ScaleType.BAND){return getFirstDefined(bandPaddingOuter,isSignalRef(paddingInnerValue)?{signal:`${paddingInnerValue.signal}/2`}:paddingInnerValue/2)}}else if(isXorYOffset(channel)){if(scaleType===ScaleType.POINT){return.5}else if(scaleType===ScaleType.BAND){return scaleConfig.offsetBandPaddingOuter}}return undefined}function reverse(scaleType,sort,channel,scaleConfig){if(channel==="x"&&scaleConfig.xReverse!==undefined){if(hasContinuousDomain(scaleType)&&sort==="descending"){if(isSignalRef(scaleConfig.xReverse)){return{signal:`!${scaleConfig.xReverse.signal}`}}else{return!scaleConfig.xReverse}}return scaleConfig.xReverse}if(hasContinuousDomain(scaleType)&&sort==="descending"){return true}return undefined}function zero(channel,fieldDef,specifiedDomain,markDef,scaleType,scaleConfig,hasSecondaryRangeChannel){const hasCustomDomain=!!specifiedDomain&&specifiedDomain!=="unaggregated";if(hasCustomDomain){if(hasContinuousDomain(scaleType)){if(isArray(specifiedDomain)){const first=specifiedDomain[0];const last=specifiedDomain[specifiedDomain.length-1];if(isNumber$1(first)&&first<=0&&isNumber$1(last)&&last>=0){return true}}return false}}if(channel==="size"&&fieldDef.type==="quantitative"&&!isContinuousToDiscrete(scaleType)){return true}if(!(isFieldDef(fieldDef)&&fieldDef.bin)&&contains([...POSITION_SCALE_CHANNELS,...POLAR_POSITION_SCALE_CHANNELS],channel)){const{orient:orient,type:type}=markDef;if(contains(["bar","area","line","trail"],type)){if(orient==="horizontal"&&channel==="y"||orient==="vertical"&&channel==="x"){return false}}if(contains(["bar","area"],type)&&!hasSecondaryRangeChannel){return true}return scaleConfig?.zero}return false}function scaleType(specifiedScale,channel,fieldDef,mark,hasNestedOffsetScale=false){const defaultScaleType=defaultType(channel,fieldDef,mark,hasNestedOffsetScale);const{type:type}=specifiedScale;if(!isScaleChannel(channel)){return null}if(type!==undefined){if(!channelSupportScaleType(channel,type)){warn(scaleTypeNotWorkWithChannel(channel,type,defaultScaleType));return defaultScaleType}if(isFieldDef(fieldDef)&&!scaleTypeSupportDataType(type,fieldDef.type)){warn(scaleTypeNotWorkWithFieldDef(type,defaultScaleType));return defaultScaleType}return type}return defaultScaleType}function defaultType(channel,fieldDef,mark,hasNestedOffsetScale){switch(fieldDef.type){case"nominal":case"ordinal":{if(isColorChannel(channel)||rangeType(channel)==="discrete"){if(channel==="shape"&&fieldDef.type==="ordinal"){warn(discreteChannelCannotEncode(channel,"ordinal"))}return"ordinal"}if(isXorY(channel)||isXorYOffset(channel)){if(contains(["rect","bar","image","rule","tick"],mark.type)){return"band"}if(hasNestedOffsetScale){return"band"}}else if(mark.type==="arc"&&channel in POLAR_POSITION_SCALE_CHANNEL_INDEX){return"band"}const dimensionSize=mark[getSizeChannel(channel)];if(isRelativeBandSize(dimensionSize)){return"band"}if(isPositionFieldOrDatumDef(fieldDef)&&fieldDef.axis?.tickBand){return"band"}return"point"}case"temporal":if(isColorChannel(channel)){return"time"}else if(rangeType(channel)==="discrete"){warn(discreteChannelCannotEncode(channel,"temporal"));return"ordinal"}else if(isFieldDef(fieldDef)&&fieldDef.timeUnit&&normalizeTimeUnit(fieldDef.timeUnit).utc){return"utc"}return"time";case"quantitative":if(isColorChannel(channel)){if(isFieldDef(fieldDef)&&isBinning(fieldDef.bin)){return"bin-ordinal"}return"linear"}else if(rangeType(channel)==="discrete"){warn(discreteChannelCannotEncode(channel,"quantitative"));return"ordinal"}return"linear";case"geojson":return undefined}throw new Error(invalidFieldType(fieldDef.type))}function parseScales(model,{ignoreRange:ignoreRange}={}){parseScaleCore(model);parseScaleDomain(model);for(const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES){parseScaleProperty(model,prop)}if(!ignoreRange){parseScaleRange(model)}}function parseScaleCore(model){if(isUnitModel(model)){model.component.scales=parseUnitScaleCore(model)}else{model.component.scales=parseNonUnitScaleCore(model)}}function parseUnitScaleCore(model){const{encoding:encoding,mark:mark,markDef:markDef}=model;const scaleComponents={};for(const channel of SCALE_CHANNELS){const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);if(fieldOrDatumDef&&mark===GEOSHAPE&&channel===SHAPE&&fieldOrDatumDef.type===GEOJSON){continue}let specifiedScale=fieldOrDatumDef&&fieldOrDatumDef.scale;if(fieldOrDatumDef&&specifiedScale!==null&&specifiedScale!==false){specifiedScale??(specifiedScale={});const hasNestedOffsetScale=channelHasNestedOffsetScale(encoding,channel);const sType=scaleType(specifiedScale,channel,fieldOrDatumDef,markDef,hasNestedOffsetScale);scaleComponents[channel]=new ScaleComponent(model.scaleName(`${channel}`,true),{value:sType,explicit:specifiedScale.type===sType})}}return scaleComponents}const scaleTypeTieBreaker=tieBreakByComparing(((st1,st2)=>scaleTypePrecedence(st1)-scaleTypePrecedence(st2)));function parseNonUnitScaleCore(model){var _a;const scaleComponents=model.component.scales={};const scaleTypeWithExplicitIndex={};const resolve=model.component.resolve;for(const child of model.children){parseScaleCore(child);for(const channel of keys(child.component.scales)){(_a=resolve.scale)[channel]??(_a[channel]=defaultScaleResolve(channel,model));if(resolve.scale[channel]==="shared"){const explicitScaleType=scaleTypeWithExplicitIndex[channel];const childScaleType=child.component.scales[channel].getWithExplicit("type");if(explicitScaleType){if(scaleCompatible(explicitScaleType.value,childScaleType.value)){scaleTypeWithExplicitIndex[channel]=mergeValuesWithExplicit(explicitScaleType,childScaleType,"type","scale",scaleTypeTieBreaker)}else{resolve.scale[channel]="independent";delete scaleTypeWithExplicitIndex[channel]}}else{scaleTypeWithExplicitIndex[channel]=childScaleType}}}}for(const channel of keys(scaleTypeWithExplicitIndex)){const name=model.scaleName(channel,true);const typeWithExplicit=scaleTypeWithExplicitIndex[channel];scaleComponents[channel]=new ScaleComponent(name,typeWithExplicit);for(const child of model.children){const childScale=child.component.scales[channel];if(childScale){child.renameScale(childScale.get("name"),name);childScale.merged=true}}}return scaleComponents}class NameMap{constructor(){this.nameMap={}}rename(oldName,newName){this.nameMap[oldName]=newName}has(name){return this.nameMap[name]!==undefined}get(name){while(this.nameMap[name]&&name!==this.nameMap[name]){name=this.nameMap[name]}return name}}function isUnitModel(model){return model?.type==="unit"}function isFacetModel(model){return model?.type==="facet"}function isConcatModel(model){return model?.type==="concat"}function isLayerModel(model){return model?.type==="layer"}class Model{constructor(spec,type,parent,parentGivenName,config,resolve,view){this.type=type;this.parent=parent;this.config=config;this.correctDataNames=mark=>{if(mark.from?.data){mark.from.data=this.lookupDataSource(mark.from.data)}if(mark.from?.facet?.data){mark.from.facet.data=this.lookupDataSource(mark.from.facet.data)}return mark};this.parent=parent;this.config=config;this.view=replaceExprRef(view);this.name=spec.name??parentGivenName;this.title=isText(spec.title)?{text:spec.title}:spec.title?replaceExprRef(spec.title):undefined;this.scaleNameMap=parent?parent.scaleNameMap:new NameMap;this.projectionNameMap=parent?parent.projectionNameMap:new NameMap;this.signalNameMap=parent?parent.signalNameMap:new NameMap;this.data=spec.data;this.description=spec.description;this.transforms=normalizeTransform(spec.transform??[]);this.layout=type==="layer"||type==="unit"?{}:extractCompositionLayout(spec,type,config);this.component={data:{sources:parent?parent.component.data.sources:[],outputNodes:parent?parent.component.data.outputNodes:{},outputNodeRefCounts:parent?parent.component.data.outputNodeRefCounts:{},isFaceted:isFacetSpec(spec)||parent?.component.data.isFaceted&&spec.data===undefined},layoutSize:new Split,layoutHeaders:{row:{},column:{},facet:{}},mark:null,resolve:{scale:{},axis:{},legend:{},...resolve?duplicate(resolve):{}},selection:null,scales:null,projection:null,axes:{},legends:{}}}get width(){return this.getSizeSignalRef("width")}get height(){return this.getSizeSignalRef("height")}parse(){this.parseScale();this.parseLayoutSize();this.renameTopLevelLayoutSizeSignal();this.parseSelections();this.parseProjection();this.parseData();this.parseAxesAndHeaders();this.parseLegends();this.parseMarkGroup()}parseScale(){parseScales(this)}parseProjection(){parseProjection(this)}renameTopLevelLayoutSizeSignal(){if(this.getName("width")!=="width"){this.renameSignal(this.getName("width"),"width")}if(this.getName("height")!=="height"){this.renameSignal(this.getName("height"),"height")}}parseLegends(){parseLegend(this)}assembleEncodeFromView(view){const{style:_,...baseView}=view;const e={};for(const property of keys(baseView)){const value=baseView[property];if(value!==undefined){e[property]=signalOrValueRef(value)}}return e}assembleGroupEncodeEntry(isTopLevel){let encodeEntry={};if(this.view){encodeEntry=this.assembleEncodeFromView(this.view)}if(!isTopLevel){if(this.description){encodeEntry["description"]=signalOrValueRef(this.description)}if(this.type==="unit"||this.type==="layer"){return{width:this.getSizeSignalRef("width"),height:this.getSizeSignalRef("height"),...encodeEntry}}}return isEmpty(encodeEntry)?undefined:encodeEntry}assembleLayout(){if(!this.layout){return undefined}const{spacing:spacing,...layout}=this.layout;const{component:component,config:config}=this;const titleBand=assembleLayoutTitleBand(component.layoutHeaders,config);return{padding:spacing,...this.assembleDefaultLayout(),...layout,...titleBand?{titleBand:titleBand}:{}}}assembleDefaultLayout(){return{}}assembleHeaderMarks(){const{layoutHeaders:layoutHeaders}=this.component;let headerMarks=[];for(const channel of FACET_CHANNELS){if(layoutHeaders[channel].title){headerMarks.push(assembleTitleGroup(this,channel))}}for(const channel of HEADER_CHANNELS){headerMarks=headerMarks.concat(assembleHeaderGroups(this,channel))}return headerMarks}assembleAxes(){return assembleAxes(this.component.axes,this.config)}assembleLegends(){return assembleLegends(this)}assembleProjections(){return assembleProjections(this)}assembleTitle(){const{encoding:encoding,...titleNoEncoding}=this.title??{};const title={...extractTitleConfig(this.config.title).nonMarkTitleProperties,...titleNoEncoding,...encoding?{encode:{update:encoding}}:{}};if(title.text){if(contains(["unit","layer"],this.type)){if(contains(["middle",undefined],title.anchor)){title.frame??(title.frame="group")}}else{title.anchor??(title.anchor="start")}return isEmpty(title)?undefined:title}return undefined}assembleGroup(signals=[]){const group={};signals=signals.concat(this.assembleSignals());if(signals.length>0){group.signals=signals}const layout=this.assembleLayout();if(layout){group.layout=layout}group.marks=[].concat(this.assembleHeaderMarks(),this.assembleMarks());const scales=!this.parent||isFacetModel(this.parent)?assembleScales(this):[];if(scales.length>0){group.scales=scales}const axes=this.assembleAxes();if(axes.length>0){group.axes=axes}const legends=this.assembleLegends();if(legends.length>0){group.legends=legends}return group}getName(text){return varName((this.name?`${this.name}_`:"")+text)}getDataName(type){return this.getName(DataSourceType[type].toLowerCase())}requestDataName(name){const fullName=this.getDataName(name);const refCounts=this.component.data.outputNodeRefCounts;refCounts[fullName]=(refCounts[fullName]||0)+1;return fullName}getSizeSignalRef(layoutSizeType){if(isFacetModel(this.parent)){const sizeType=getSizeTypeFromLayoutSizeType(layoutSizeType);const channel=getPositionScaleChannel(sizeType);const scaleComponent=this.component.scales[channel];if(scaleComponent&&!scaleComponent.merged){const type=scaleComponent.get("type");const range=scaleComponent.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range)){const scaleName=scaleComponent.get("name");const domain=assembleDomain(this,channel);const field=getFieldFromDomain(domain);if(field){const fieldRef=vgField({aggregate:"distinct",field:field},{expr:"datum"});return{signal:sizeExpr(scaleName,scaleComponent,fieldRef)}}else{warn(unknownField(channel));return null}}}}return{signal:this.signalNameMap.get(this.getName(layoutSizeType))}}lookupDataSource(name){const node=this.component.data.outputNodes[name];if(!node){return name}return node.getSource()}getSignalName(oldSignalName){return this.signalNameMap.get(oldSignalName)}renameSignal(oldName,newName){this.signalNameMap.rename(oldName,newName)}renameScale(oldName,newName){this.scaleNameMap.rename(oldName,newName)}renameProjection(oldName,newName){this.projectionNameMap.rename(oldName,newName)}scaleName(originalScaleName,parse){if(parse){return this.getName(originalScaleName)}if(isChannel(originalScaleName)&&isScaleChannel(originalScaleName)&&this.component.scales[originalScaleName]||this.scaleNameMap.has(this.getName(originalScaleName))){return this.scaleNameMap.get(this.getName(originalScaleName))}return undefined}projectionName(parse){if(parse){return this.getName("projection")}if(this.component.projection&&!this.component.projection.merged||this.projectionNameMap.has(this.getName("projection"))){return this.projectionNameMap.get(this.getName("projection"))}return undefined}getScaleComponent(channel){if(!this.component.scales){throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().")}const localScaleComponent=this.component.scales[channel];if(localScaleComponent&&!localScaleComponent.merged){return localScaleComponent}return this.parent?this.parent.getScaleComponent(channel):undefined}getScaleType(channel){const scaleComponent=this.getScaleComponent(channel);return scaleComponent?scaleComponent.get("type"):undefined}getSelectionComponent(variableName,origName){let sel=this.component.selection[variableName];if(!sel&&this.parent){sel=this.parent.getSelectionComponent(variableName,origName)}if(!sel){throw new Error(selectionNotFound(origName))}return sel}hasAxisOrientSignalRef(){return this.component.axes.x?.some((a=>a.hasOrientSignalRef()))||this.component.axes.y?.some((a=>a.hasOrientSignalRef()))}}class ModelWithField extends Model{vgField(channel,opt={}){const fieldDef=this.fieldDef(channel);if(!fieldDef){return undefined}return vgField(fieldDef,opt)}reduceFieldDef(f,init){return reduce(this.getMapping(),((acc,cd,c)=>{const fieldDef=getFieldDef(cd);if(fieldDef){return f(acc,fieldDef,c)}return acc}),init)}forEachFieldDef(f,t){forEach(this.getMapping(),((cd,c)=>{const fieldDef=getFieldDef(cd);if(fieldDef){f(fieldDef,c)}}),t)}}class DensityTransformNode extends DataFlowNode{clone(){return new DensityTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const specifiedAs=this.transform.as??[undefined,undefined];this.transform.as=[specifiedAs[0]??"value",specifiedAs[1]??"density"];const resolve=this.transform.resolve??"shared";this.transform.resolve=resolve}dependentFields(){return new Set([this.transform.density,...this.transform.groupby??[]])}producedFields(){return new Set(this.transform.as)}hash(){return`DensityTransform ${hash(this.transform)}`}assemble(){const{density:density,...rest}=this.transform;const result={type:"kde",field:density,...rest};result.resolve=this.transform.resolve;return result}}class ExtentTransformNode extends DataFlowNode{clone(){return new ExtentTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform)}dependentFields(){return new Set([this.transform.extent])}producedFields(){return new Set([])}hash(){return`ExtentTransform ${hash(this.transform)}`}assemble(){const{extent:extent,param:param}=this.transform;const result={type:"extent",field:extent,signal:param};return result}}class FlattenTransformNode extends DataFlowNode{clone(){return new FlattenTransformNode(this.parent,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const{flatten:flatten,as:as=[]}=this.transform;this.transform.as=flatten.map(((f,i)=>as[i]??f))}dependentFields(){return new Set(this.transform.flatten)}producedFields(){return new Set(this.transform.as)}hash(){return`FlattenTransform ${hash(this.transform)}`}assemble(){const{flatten:fields,as:as}=this.transform;const result={type:"flatten",fields:fields,as:as};return result}}class FoldTransformNode extends DataFlowNode{clone(){return new FoldTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const specifiedAs=this.transform.as??[undefined,undefined];this.transform.as=[specifiedAs[0]??"key",specifiedAs[1]??"value"]}dependentFields(){return new Set(this.transform.fold)}producedFields(){return new Set(this.transform.as)}hash(){return`FoldTransform ${hash(this.transform)}`}assemble(){const{fold:fold,as:as}=this.transform;const result={type:"fold",fields:fold,as:as};return result}}class GeoJSONNode extends DataFlowNode{clone(){return new GeoJSONNode(null,duplicate(this.fields),this.geojson,this.signal)}static parseAll(parent,model){if(model.component.projection&&!model.component.projection.isFit){return parent}let geoJsonCounter=0;for(const coordinates of[[LONGITUDE,LATITUDE],[LONGITUDE2,LATITUDE2]]){const pair=coordinates.map((channel=>{const def=getFieldOrDatumDef(model.encoding[channel]);return isFieldDef(def)?def.field:isDatumDef(def)?{expr:`${def.datum}`}:isValueDef(def)?{expr:`${def["value"]}`}:undefined}));if(pair[0]||pair[1]){parent=new GeoJSONNode(parent,pair,null,model.getName(`geojson_${geoJsonCounter++}`))}}if(model.channelHasField(SHAPE)){const fieldDef=model.typedFieldDef(SHAPE);if(fieldDef.type===GEOJSON){parent=new GeoJSONNode(parent,null,fieldDef.field,model.getName(`geojson_${geoJsonCounter++}`))}}return parent}constructor(parent,fields,geojson,signal){super(parent);this.fields=fields;this.geojson=geojson;this.signal=signal}dependentFields(){const fields=(this.fields??[]).filter(isString);return new Set([...this.geojson?[this.geojson]:[],...fields])}producedFields(){return new Set}hash(){return`GeoJSON ${this.geojson} ${this.signal} ${hash(this.fields)}`}assemble(){return[...this.geojson?[{type:"filter",expr:`isValid(datum["${this.geojson}"])`}]:[],{type:"geojson",...this.fields?{fields:this.fields}:{},...this.geojson?{geojson:this.geojson}:{},signal:this.signal}]}}class GeoPointNode extends DataFlowNode{clone(){return new GeoPointNode(null,this.projection,duplicate(this.fields),duplicate(this.as))}constructor(parent,projection,fields,as){super(parent);this.projection=projection;this.fields=fields;this.as=as}static parseAll(parent,model){if(!model.projectionName()){return parent}for(const coordinates of[[LONGITUDE,LATITUDE],[LONGITUDE2,LATITUDE2]]){const pair=coordinates.map((channel=>{const def=getFieldOrDatumDef(model.encoding[channel]);return isFieldDef(def)?def.field:isDatumDef(def)?{expr:`${def.datum}`}:isValueDef(def)?{expr:`${def["value"]}`}:undefined}));const suffix=coordinates[0]===LONGITUDE2?"2":"";if(pair[0]||pair[1]){parent=new GeoPointNode(parent,model.projectionName(),pair,[model.getName(`x${suffix}`),model.getName(`y${suffix}`)])}}return parent}dependentFields(){return new Set(this.fields.filter(isString))}producedFields(){return new Set(this.as)}hash(){return`Geopoint ${this.projection} ${hash(this.fields)} ${hash(this.as)}`}assemble(){return{type:"geopoint",projection:this.projection,fields:this.fields,as:this.as}}}class ImputeNode extends DataFlowNode{clone(){return new ImputeNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){return new Set([this.transform.impute,this.transform.key,...this.transform.groupby??[]])}producedFields(){return new Set([this.transform.impute])}processSequence(keyvals){const{start:start=0,stop:stop,step:step}=keyvals;const result=[start,stop,...step?[step]:[]].join(",");return{signal:`sequence(${result})`}}static makeFromTransform(parent,imputeTransform){return new ImputeNode(parent,imputeTransform)}static makeFromEncoding(parent,model){const encoding=model.encoding;const xDef=encoding.x;const yDef=encoding.y;if(isFieldDef(xDef)&&isFieldDef(yDef)){const imputedChannel=xDef.impute?xDef:yDef.impute?yDef:undefined;if(imputedChannel===undefined){return undefined}const keyChannel=xDef.impute?yDef:yDef.impute?xDef:undefined;const{method:method,value:value,frame:frame,keyvals:keyvals}=imputedChannel.impute;const groupbyFields=pathGroupingFields(model.mark,encoding);return new ImputeNode(parent,{impute:imputedChannel.field,key:keyChannel.field,...method?{method:method}:{},...value!==undefined?{value:value}:{},...frame?{frame:frame}:{},...keyvals!==undefined?{keyvals:keyvals}:{},...groupbyFields.length?{groupby:groupbyFields}:{}})}return null}hash(){return`Impute ${hash(this.transform)}`}assemble(){const{impute:impute,key:key,keyvals:keyvals,method:method,groupby:groupby,value:value,frame:frame=[null,null]}=this.transform;const imputeTransform={type:"impute",field:impute,key:key,...keyvals?{keyvals:isImputeSequence(keyvals)?this.processSequence(keyvals):keyvals}:{},method:"value",...groupby?{groupby:groupby}:{},value:!method||method==="value"?value:null};if(method&&method!=="value"){const deriveNewField={type:"window",as:[`imputed_${impute}_value`],ops:[method],fields:[impute],frame:frame,ignorePeers:false,...groupby?{groupby:groupby}:{}};const replaceOriginal={type:"formula",expr:`datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,as:impute};return[imputeTransform,deriveNewField,replaceOriginal]}else{return[imputeTransform]}}}class LoessTransformNode extends DataFlowNode{clone(){return new LoessTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const specifiedAs=this.transform.as??[undefined,undefined];this.transform.as=[specifiedAs[0]??transform.on,specifiedAs[1]??transform.loess]}dependentFields(){return new Set([this.transform.loess,this.transform.on,...this.transform.groupby??[]])}producedFields(){return new Set(this.transform.as)}hash(){return`LoessTransform ${hash(this.transform)}`}assemble(){const{loess:loess,on:on,...rest}=this.transform;const result={type:"loess",x:on,y:loess,...rest};return result}}class LookupNode extends DataFlowNode{clone(){return new LookupNode(null,duplicate(this.transform),this.secondary)}constructor(parent,transform,secondary){super(parent);this.transform=transform;this.secondary=secondary}static make(parent,model,transform,counter){const sources=model.component.data.sources;const{from:from}=transform;let fromOutputNode=null;if(isLookupData(from)){let fromSource=findSource(from.data,sources);if(!fromSource){fromSource=new SourceNode(from.data);sources.push(fromSource)}const fromOutputName=model.getName(`lookup_${counter}`);fromOutputNode=new OutputNode(fromSource,fromOutputName,DataSourceType.Lookup,model.component.data.outputNodeRefCounts);model.component.data.outputNodes[fromOutputName]=fromOutputNode}else if(isLookupSelection(from)){const selName=from.param;transform={as:selName,...transform};let selCmpt;try{selCmpt=model.getSelectionComponent(varName(selName),selName)}catch(e){throw new Error(cannotLookupVariableParameter(selName))}fromOutputNode=selCmpt.materialized;if(!fromOutputNode){throw new Error(noSameUnitLookup(selName))}}return new LookupNode(parent,transform,fromOutputNode.getSource())}dependentFields(){return new Set([this.transform.lookup])}producedFields(){return new Set(this.transform.as?array$5(this.transform.as):this.transform.from.fields)}hash(){return`Lookup ${hash({transform:this.transform,secondary:this.secondary})}`}assemble(){let foreign;if(this.transform.from.fields){foreign={values:this.transform.from.fields,...this.transform.as?{as:array$5(this.transform.as)}:{}}}else{let asName=this.transform.as;if(!isString(asName)){warn(NO_FIELDS_NEEDS_AS);asName="_lookup"}foreign={as:[asName]}}return{type:"lookup",from:this.secondary,key:this.transform.from.key,fields:[this.transform.lookup],...foreign,...this.transform.default?{default:this.transform.default}:{}}}}class QuantileTransformNode extends DataFlowNode{clone(){return new QuantileTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const specifiedAs=this.transform.as??[undefined,undefined];this.transform.as=[specifiedAs[0]??"prob",specifiedAs[1]??"value"]}dependentFields(){return new Set([this.transform.quantile,...this.transform.groupby??[]])}producedFields(){return new Set(this.transform.as)}hash(){return`QuantileTransform ${hash(this.transform)}`}assemble(){const{quantile:quantile,...rest}=this.transform;const result={type:"quantile",field:quantile,...rest};return result}}class RegressionTransformNode extends DataFlowNode{clone(){return new RegressionTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const specifiedAs=this.transform.as??[undefined,undefined];this.transform.as=[specifiedAs[0]??transform.on,specifiedAs[1]??transform.regression]}dependentFields(){return new Set([this.transform.regression,this.transform.on,...this.transform.groupby??[]])}producedFields(){return new Set(this.transform.as)}hash(){return`RegressionTransform ${hash(this.transform)}`}assemble(){const{regression:regression,on:on,...rest}=this.transform;const result={type:"regression",x:on,y:regression,...rest};return result}}class PivotTransformNode extends DataFlowNode{clone(){return new PivotTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique((this.transform.groupby??[]).concat(fields),(d=>d))}producedFields(){return undefined}dependentFields(){return new Set([this.transform.pivot,this.transform.value,...this.transform.groupby??[]])}hash(){return`PivotTransform ${hash(this.transform)}`}assemble(){const{pivot:pivot,value:value,groupby:groupby,limit:limit,op:op}=this.transform;return{type:"pivot",field:pivot,value:value,...limit!==undefined?{limit:limit}:{},...op!==undefined?{op:op}:{},...groupby!==undefined?{groupby:groupby}:{}}}}class SampleTransformNode extends DataFlowNode{clone(){return new SampleTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){return new Set}producedFields(){return new Set}hash(){return`SampleTransform ${hash(this.transform)}`}assemble(){return{type:"sample",size:this.transform.sample}}}function makeWalkTree(data){let datasetIndex=0;function walkTree(node,dataSource){if(node instanceof SourceNode){if(!node.isGenerator&&!isUrlData(node.data)){data.push(dataSource);const newData={name:null,source:dataSource.name,transform:[]};dataSource=newData}}if(node instanceof ParseNode){if(node.parent instanceof SourceNode&&!dataSource.source){dataSource.format={...dataSource.format,parse:node.assembleFormatParse()};dataSource.transform.push(...node.assembleTransforms(true))}else{dataSource.transform.push(...node.assembleTransforms())}}if(node instanceof FacetNode){if(!dataSource.name){dataSource.name=`data_${datasetIndex++}`}if(!dataSource.source||dataSource.transform.length>0){data.push(dataSource);node.data=dataSource.name}else{node.data=dataSource.source}data.push(...node.assemble());return}if(node instanceof GraticuleNode||node instanceof SequenceNode||node instanceof FilterInvalidNode||node instanceof FilterNode||node instanceof CalculateNode||node instanceof GeoPointNode||node instanceof AggregateNode||node instanceof LookupNode||node instanceof WindowTransformNode||node instanceof JoinAggregateTransformNode||node instanceof FoldTransformNode||node instanceof FlattenTransformNode||node instanceof DensityTransformNode||node instanceof LoessTransformNode||node instanceof QuantileTransformNode||node instanceof RegressionTransformNode||node instanceof IdentifierNode||node instanceof SampleTransformNode||node instanceof PivotTransformNode||node instanceof ExtentTransformNode){dataSource.transform.push(node.assemble())}if(node instanceof BinNode||node instanceof TimeUnitNode||node instanceof ImputeNode||node instanceof StackNode||node instanceof GeoJSONNode){dataSource.transform.push(...node.assemble())}if(node instanceof OutputNode){if(dataSource.source&&dataSource.transform.length===0){node.setSource(dataSource.source)}else if(node.parent instanceof OutputNode){node.setSource(dataSource.name)}else{if(!dataSource.name){dataSource.name=`data_${datasetIndex++}`}node.setSource(dataSource.name);if(node.numChildren()===1){data.push(dataSource);const newData={name:null,source:dataSource.name,transform:[]};dataSource=newData}}}switch(node.numChildren()){case 0:if(node instanceof OutputNode&&(!dataSource.source||dataSource.transform.length>0)){data.push(dataSource)}break;case 1:walkTree(node.children[0],dataSource);break;default:{if(!dataSource.name){dataSource.name=`data_${datasetIndex++}`}let source=dataSource.name;if(!dataSource.source||dataSource.transform.length>0){data.push(dataSource)}else{source=dataSource.source}for(const child of node.children){const newData={name:null,source:source,transform:[]};walkTree(child,newData)}break}}}return walkTree}function assembleFacetData(root){const data=[];const walkTree=makeWalkTree(data);for(const child of root.children){walkTree(child,{source:root.name,name:null,transform:[]})}return data}function assembleRootData(dataComponent,datasets){const data=[];const walkTree=makeWalkTree(data);let sourceIndex=0;for(const root of dataComponent.sources){if(!root.hasName()){root.dataName=`source_${sourceIndex++}`}const newData=root.assemble();walkTree(root,newData)}for(const d of data){if(d.transform.length===0){delete d.transform}}let whereTo=0;for(const[i,d]of data.entries()){if((d.transform??[]).length===0&&!d.source){data.splice(whereTo++,0,data.splice(i,1)[0])}}for(const d of data){for(const t of d.transform??[]){if(t.type==="lookup"){t.from=dataComponent.outputNodes[t.from].getSource()}}}for(const d of data){if(d.name in datasets){d.values=datasets[d.name]}}return data}function getHeaderType(orient){if(orient==="top"||orient==="left"||isSignalRef(orient)){return"header"}return"footer"}function parseFacetHeaders(model){for(const channel of FACET_CHANNELS){parseFacetHeader(model,channel)}mergeChildAxis(model,"x");mergeChildAxis(model,"y")}function parseFacetHeader(model,channel){const{facet:facet,config:config,child:child,component:component}=model;if(model.channelHasField(channel)){const fieldDef=facet[channel];const titleConfig=getHeaderProperty("title",null,config,channel);let title$1=title(fieldDef,config,{allowDisabling:true,includeDefault:titleConfig===undefined||!!titleConfig});if(child.component.layoutHeaders[channel].title){title$1=isArray(title$1)?title$1.join(", "):title$1;title$1+=` / ${child.component.layoutHeaders[channel].title}`;child.component.layoutHeaders[channel].title=null}const labelOrient=getHeaderProperty("labelOrient",fieldDef.header,config,channel);const labels=fieldDef.header!==null?getFirstDefined(fieldDef.header?.labels,config.header.labels,true):false;const headerType=contains(["bottom","right"],labelOrient)?"footer":"header";component.layoutHeaders[channel]={title:fieldDef.header!==null?title$1:null,facetFieldDef:fieldDef,[headerType]:channel==="facet"?[]:[makeHeaderComponent(model,channel,labels)]}}}function makeHeaderComponent(model,channel,labels){const sizeType=channel==="row"?"height":"width";return{labels:labels,sizeSignal:model.child.component.layoutSize.get(sizeType)?model.child.getSizeSignalRef(sizeType):undefined,axes:[]}}function mergeChildAxis(model,channel){const{child:child}=model;if(child.component.axes[channel]){const{layoutHeaders:layoutHeaders,resolve:resolve}=model.component;resolve.axis[channel]=parseGuideResolve(resolve,channel);if(resolve.axis[channel]==="shared"){const headerChannel=channel==="x"?"column":"row";const layoutHeader=layoutHeaders[headerChannel];for(const axisComponent of child.component.axes[channel]){const headerType=getHeaderType(axisComponent.get("orient"));layoutHeader[headerType]??(layoutHeader[headerType]=[makeHeaderComponent(model,headerChannel,false)]);const mainAxis=assembleAxis(axisComponent,"main",model.config,{header:true});if(mainAxis){layoutHeader[headerType][0].axes.push(mainAxis)}axisComponent.mainExtracted=true}}}}function parseLayerLayoutSize(model){parseChildrenLayoutSize(model);parseNonUnitLayoutSizeForChannel(model,"width");parseNonUnitLayoutSizeForChannel(model,"height")}function parseConcatLayoutSize(model){parseChildrenLayoutSize(model);const widthType=model.layout.columns===1?"width":"childWidth";const heightType=model.layout.columns===undefined?"height":"childHeight";parseNonUnitLayoutSizeForChannel(model,widthType);parseNonUnitLayoutSizeForChannel(model,heightType)}function parseChildrenLayoutSize(model){for(const child of model.children){child.parseLayoutSize()}}function parseNonUnitLayoutSizeForChannel(model,layoutSizeType){const sizeType=getSizeTypeFromLayoutSizeType(layoutSizeType);const channel=getPositionScaleChannel(sizeType);const resolve=model.component.resolve;const layoutSizeCmpt=model.component.layoutSize;let mergedSize;for(const child of model.children){const childSize=child.component.layoutSize.getWithExplicit(sizeType);const scaleResolve=resolve.scale[channel]??defaultScaleResolve(channel,model);if(scaleResolve==="independent"&&childSize.value==="step"){mergedSize=undefined;break}if(mergedSize){if(scaleResolve==="independent"&&mergedSize.value!==childSize.value){mergedSize=undefined;break}mergedSize=mergeValuesWithExplicit(mergedSize,childSize,sizeType,"")}else{mergedSize=childSize}}if(mergedSize){for(const child of model.children){model.renameSignal(child.getName(sizeType),model.getName(layoutSizeType));child.component.layoutSize.set(sizeType,"merged",false)}layoutSizeCmpt.setWithExplicit(layoutSizeType,mergedSize)}else{layoutSizeCmpt.setWithExplicit(layoutSizeType,{explicit:false,value:undefined})}}function parseUnitLayoutSize(model){const{size:size,component:component}=model;for(const channel of POSITION_SCALE_CHANNELS){const sizeType=getSizeChannel(channel);if(size[sizeType]){const specifiedSize=size[sizeType];component.layoutSize.set(sizeType,isStep(specifiedSize)?"step":specifiedSize,true)}else{const defaultSize=defaultUnitSize(model,sizeType);component.layoutSize.set(sizeType,defaultSize,false)}}}function defaultUnitSize(model,sizeType){const channel=sizeType==="width"?"x":"y";const config=model.config;const scaleComponent=model.getScaleComponent(channel);if(scaleComponent){const scaleType=scaleComponent.get("type");const range=scaleComponent.get("range");if(hasDiscreteDomain(scaleType)){const size=getViewConfigDiscreteSize(config.view,sizeType);if(isVgRangeStep(range)||isStep(size)){return"step"}else{return size}}else{return getViewConfigContinuousSize(config.view,sizeType)}}else if(model.hasProjection||model.mark==="arc"){return getViewConfigContinuousSize(config.view,sizeType)}else{const size=getViewConfigDiscreteSize(config.view,sizeType);return isStep(size)?size.step:size}}function facetSortFieldName(fieldDef,sort,opt){return vgField(sort,{suffix:`by_${vgField(fieldDef)}`,...opt})}class FacetModel extends ModelWithField{constructor(spec,parent,parentGivenName,config){super(spec,"facet",parent,parentGivenName,config,spec.resolve);this.child=buildModel(spec.spec,this,this.getName("child"),undefined,config);this.children=[this.child];this.facet=this.initFacet(spec.facet)}initFacet(facet){if(!isFacetMapping(facet)){return{facet:this.initFacetFieldDef(facet,"facet")}}const channels=keys(facet);const normalizedFacet={};for(const channel of channels){if(![ROW,COLUMN].includes(channel)){warn(incompatibleChannel(channel,"facet"));break}const fieldDef=facet[channel];if(fieldDef.field===undefined){warn(emptyFieldDef(fieldDef,channel));break}normalizedFacet[channel]=this.initFacetFieldDef(fieldDef,channel)}return normalizedFacet}initFacetFieldDef(fieldDef,channel){const facetFieldDef=initFieldDef(fieldDef,channel);if(facetFieldDef.header){facetFieldDef.header=replaceExprRef(facetFieldDef.header)}else if(facetFieldDef.header===null){facetFieldDef.header=null}return facetFieldDef}channelHasField(channel){return hasProperty(this.facet,channel)}fieldDef(channel){return this.facet[channel]}parseData(){this.component.data=parseData(this);this.child.parseData()}parseLayoutSize(){parseChildrenLayoutSize(this)}parseSelections(){this.child.parseSelections();this.component.selection=this.child.component.selection}parseMarkGroup(){this.child.parseMarkGroup()}parseAxesAndHeaders(){this.child.parseAxesAndHeaders();parseFacetHeaders(this)}assembleSelectionTopLevelSignals(signals){return this.child.assembleSelectionTopLevelSignals(signals)}assembleSignals(){this.child.assembleSignals();return[]}assembleSelectionData(data){return this.child.assembleSelectionData(data)}getHeaderLayoutMixins(){const layoutMixins={};for(const channel of FACET_CHANNELS){for(const headerType of HEADER_TYPES){const layoutHeaderComponent=this.component.layoutHeaders[channel];const headerComponent=layoutHeaderComponent[headerType];const{facetFieldDef:facetFieldDef}=layoutHeaderComponent;if(facetFieldDef){const titleOrient=getHeaderProperty("titleOrient",facetFieldDef.header,this.config,channel);if(["right","bottom"].includes(titleOrient)){const headerChannel=getHeaderChannel(channel,titleOrient);layoutMixins.titleAnchor??(layoutMixins.titleAnchor={});layoutMixins.titleAnchor[headerChannel]="end"}}if(headerComponent?.[0]){const sizeType=channel==="row"?"height":"width";const bandType=headerType==="header"?"headerBand":"footerBand";if(channel!=="facet"&&!this.child.component.layoutSize.get(sizeType)){layoutMixins[bandType]??(layoutMixins[bandType]={});layoutMixins[bandType][channel]=.5}if(layoutHeaderComponent.title){layoutMixins.offset??(layoutMixins.offset={});layoutMixins.offset[channel==="row"?"rowTitle":"columnTitle"]=10}}}}return layoutMixins}assembleDefaultLayout(){const{column:column,row:row}=this.facet;const columns=column?this.columnDistinctSignal():row?1:undefined;let align="all";if(!row&&this.component.resolve.scale.x==="independent"){align="none"}else if(!column&&this.component.resolve.scale.y==="independent"){align="none"}return{...this.getHeaderLayoutMixins(),...columns?{columns:columns}:{},bounds:"full",align:align}}assembleLayoutSignals(){return this.child.assembleLayoutSignals()}columnDistinctSignal(){if(this.parent&&this.parent instanceof FacetModel){return undefined}else{const facetLayoutDataName=this.getName("column_domain");return{signal:`length(data('${facetLayoutDataName}'))`}}}assembleGroupStyle(){return undefined}assembleGroup(signals){if(this.parent&&this.parent instanceof FacetModel){return{...this.channelHasField("column")?{encode:{update:{columns:{field:vgField(this.facet.column,{prefix:"distinct"})}}}}:{},...super.assembleGroup(signals)}}return super.assembleGroup(signals)}getCardinalityAggregateForChild(){const fields=[];const ops=[];const as=[];if(this.child instanceof FacetModel){if(this.child.channelHasField("column")){const field=vgField(this.child.facet.column);fields.push(field);ops.push("distinct");as.push(`distinct_${field}`)}}else{for(const channel of POSITION_SCALE_CHANNELS){const childScaleComponent=this.child.component.scales[channel];if(childScaleComponent&&!childScaleComponent.merged){const type=childScaleComponent.get("type");const range=childScaleComponent.get("range");if(hasDiscreteDomain(type)&&isVgRangeStep(range)){const domain=assembleDomain(this.child,channel);const field=getFieldFromDomain(domain);if(field){fields.push(field);ops.push("distinct");as.push(`distinct_${field}`)}else{warn(unknownField(channel))}}}}}return{fields:fields,ops:ops,as:as}}assembleFacet(){const{name:name,data:data}=this.component.data.facetRoot;const{row:row,column:column}=this.facet;const{fields:fields,ops:ops,as:as}=this.getCardinalityAggregateForChild();const groupby=[];for(const channel of FACET_CHANNELS){const fieldDef=this.facet[channel];if(fieldDef){groupby.push(vgField(fieldDef));const{bin:bin,sort:sort}=fieldDef;if(isBinning(bin)){groupby.push(vgField(fieldDef,{binSuffix:"end"}))}if(isSortField(sort)){const{field:field,op:op=DEFAULT_SORT_OP}=sort;const outputName=facetSortFieldName(fieldDef,sort);if(row&&column){fields.push(outputName);ops.push("max");as.push(outputName)}else{fields.push(field);ops.push(op);as.push(outputName)}}else if(isArray(sort)){const outputName=sortArrayIndexField(fieldDef,channel);fields.push(outputName);ops.push("max");as.push(outputName)}}}const cross=!!row&&!!column;return{name:name,data:data,groupby:groupby,...cross||fields.length>0?{aggregate:{...cross?{cross:cross}:{},...fields.length?{fields:fields,ops:ops,as:as}:{}}}:{}}}facetSortFields(channel){const{facet:facet}=this;const fieldDef=facet[channel];if(fieldDef){if(isSortField(fieldDef.sort)){return[facetSortFieldName(fieldDef,fieldDef.sort,{expr:"datum"})]}else if(isArray(fieldDef.sort)){return[sortArrayIndexField(fieldDef,channel,{expr:"datum"})]}return[vgField(fieldDef,{expr:"datum"})]}return[]}facetSortOrder(channel){const{facet:facet}=this;const fieldDef=facet[channel];if(fieldDef){const{sort:sort}=fieldDef;const order=(isSortField(sort)?sort.order:!isArray(sort)&&sort)||"ascending";return[order]}return[]}assembleLabelTitle(){const{facet:facet,config:config}=this;if(facet.facet){return assembleLabelTitle(facet.facet,"facet",config)}const ORTHOGONAL_ORIENT={row:["top","bottom"],column:["left","right"]};for(const channel of HEADER_CHANNELS){if(facet[channel]){const labelOrient=getHeaderProperty("labelOrient",facet[channel]?.header,config,channel);if(ORTHOGONAL_ORIENT[channel].includes(labelOrient)){return assembleLabelTitle(facet[channel],channel,config)}}}return undefined}assembleMarks(){const{child:child}=this;const facetRoot=this.component.data.facetRoot;const data=assembleFacetData(facetRoot);const encodeEntry=child.assembleGroupEncodeEntry(false);const title=this.assembleLabelTitle()||child.assembleTitle();const style=child.assembleGroupStyle();const markGroup={name:this.getName("cell"),type:"group",...title?{title:title}:{},...style?{style:style}:{},from:{facet:this.assembleFacet()},sort:{field:FACET_CHANNELS.map((c=>this.facetSortFields(c))).flat(),order:FACET_CHANNELS.map((c=>this.facetSortOrder(c))).flat()},...data.length>0?{data:data}:{},...encodeEntry?{encode:{update:encodeEntry}}:{},...child.assembleGroup(assembleFacetSignals(this,[]))};return[markGroup]}getMapping(){return this.facet}}function makeJoinAggregateFromFacet(parent,facet){const{row:row,column:column}=facet;if(row&&column){let newParent=null;for(const fieldDef of[row,column]){if(isSortField(fieldDef.sort)){const{field:field,op:op=DEFAULT_SORT_OP}=fieldDef.sort;parent=newParent=new JoinAggregateTransformNode(parent,{joinaggregate:[{op:op,field:field,as:facetSortFieldName(fieldDef,fieldDef.sort,{forAs:true})}],groupby:[vgField(fieldDef)]})}}return newParent}return null}function findSource(data,sources){for(const other of sources){const otherData=other.data;if(data.name&&other.hasName()&&data.name!==other.dataName){continue}const formatMesh=data.format?.mesh;const otherFeature=otherData.format?.feature;if(formatMesh&&otherFeature){continue}const formatFeature=data.format?.feature;if((formatFeature||otherFeature)&&formatFeature!==otherFeature){continue}const otherMesh=otherData.format?.mesh;if((formatMesh||otherMesh)&&formatMesh!==otherMesh){continue}if(isInlineData(data)&&isInlineData(otherData)){if(deepEqual(data.values,otherData.values)){return other}}else if(isUrlData(data)&&isUrlData(otherData)){if(data.url===otherData.url){return other}}else if(isNamedData(data)){if(data.name===other.dataName){return other}}}return null}function parseRoot(model,sources){if(model.data||!model.parent){if(model.data===null){const source=new SourceNode({values:[]});sources.push(source);return source}const existingSource=findSource(model.data,sources);if(existingSource){if(!isGenerator(model.data)){existingSource.data.format=mergeDeep({},model.data.format,existingSource.data.format)}if(!existingSource.hasName()&&model.data.name){existingSource.dataName=model.data.name}return existingSource}else{const source=new SourceNode(model.data);sources.push(source);return source}}else{return model.parent.component.data.facetRoot?model.parent.component.data.facetRoot:model.parent.component.data.main}}function parseTransformArray(head,model,ancestorParse){let lookupCounter=0;for(const t of model.transforms){let derivedType=undefined;let transformNode;if(isCalculate(t)){transformNode=head=new CalculateNode(head,t);derivedType="derived"}else if(isFilter(t)){const implicit=getImplicitFromFilterTransform(t);transformNode=head=ParseNode.makeWithAncestors(head,{},implicit,ancestorParse)??head;head=new FilterNode(head,model,t.filter)}else if(isBin(t)){transformNode=head=BinNode.makeFromTransform(head,t,model);derivedType="number"}else if(isTimeUnit(t)){derivedType="date";const parsedAs=ancestorParse.getWithExplicit(t.field);if(parsedAs.value===undefined){head=new ParseNode(head,{[t.field]:derivedType});ancestorParse.set(t.field,derivedType,false)}transformNode=head=TimeUnitNode.makeFromTransform(head,t)}else if(isAggregate(t)){transformNode=head=AggregateNode.makeFromTransform(head,t);derivedType="number";if(requiresSelectionId(model)){head=new IdentifierNode(head)}}else if(isLookup(t)){transformNode=head=LookupNode.make(head,model,t,lookupCounter++);derivedType="derived"}else if(isWindow(t)){transformNode=head=new WindowTransformNode(head,t);derivedType="number"}else if(isJoinAggregate(t)){transformNode=head=new JoinAggregateTransformNode(head,t);derivedType="number"}else if(isStack(t)){transformNode=head=StackNode.makeFromTransform(head,t);derivedType="derived"}else if(isFold(t)){transformNode=head=new FoldTransformNode(head,t);derivedType="derived"}else if(isExtent(t)){transformNode=head=new ExtentTransformNode(head,t);derivedType="derived"}else if(isFlatten(t)){transformNode=head=new FlattenTransformNode(head,t);derivedType="derived"}else if(isPivot(t)){transformNode=head=new PivotTransformNode(head,t);derivedType="derived"}else if(isSample(t)){head=new SampleTransformNode(head,t)}else if(isImpute(t)){transformNode=head=ImputeNode.makeFromTransform(head,t);derivedType="derived"}else if(isDensity(t)){transformNode=head=new DensityTransformNode(head,t);derivedType="derived"}else if(isQuantile(t)){transformNode=head=new QuantileTransformNode(head,t);derivedType="derived"}else if(isRegression(t)){transformNode=head=new RegressionTransformNode(head,t);derivedType="derived"}else if(isLoess(t)){transformNode=head=new LoessTransformNode(head,t);derivedType="derived"}else{warn(invalidTransformIgnored(t));continue}if(transformNode&&derivedType!==undefined){for(const field of transformNode.producedFields()??[]){ancestorParse.set(field,derivedType,false)}}}return head}function parseData(model){let head=parseRoot(model,model.component.data.sources);const{outputNodes:outputNodes,outputNodeRefCounts:outputNodeRefCounts}=model.component.data;const data=model.data;const newData=data&&(isGenerator(data)||isUrlData(data)||isInlineData(data));const ancestorParse=!newData&&model.parent?model.parent.component.data.ancestorParse.clone():new AncestorParse;if(isGenerator(data)){if(isSequenceGenerator(data)){head=new SequenceNode(head,data.sequence)}else if(isGraticuleGenerator(data)){head=new GraticuleNode(head,data.graticule)}ancestorParse.parseNothing=true}else if(data?.format?.parse===null){ancestorParse.parseNothing=true}head=ParseNode.makeExplicit(head,model,ancestorParse)??head;head=new IdentifierNode(head);const parentIsLayer=model.parent&&isLayerModel(model.parent);if(isUnitModel(model)||isFacetModel(model)){if(parentIsLayer){head=BinNode.makeFromEncoding(head,model)??head}}if(model.transforms.length>0){head=parseTransformArray(head,model,ancestorParse)}const implicitSelection=getImplicitFromSelection(model);const implicitEncoding=getImplicitFromEncoding(model);head=ParseNode.makeWithAncestors(head,{},{...implicitSelection,...implicitEncoding},ancestorParse)??head;if(isUnitModel(model)){head=GeoJSONNode.parseAll(head,model);head=GeoPointNode.parseAll(head,model)}if(isUnitModel(model)||isFacetModel(model)){if(!parentIsLayer){head=BinNode.makeFromEncoding(head,model)??head}head=TimeUnitNode.makeFromEncoding(head,model)??head;head=CalculateNode.parseAllForSortIndex(head,model)}const raw=head=makeOutputNode(DataSourceType.Raw,model,head);if(isUnitModel(model)){const agg=AggregateNode.makeFromEncoding(head,model);if(agg){head=agg;if(requiresSelectionId(model)){head=new IdentifierNode(head)}}head=ImputeNode.makeFromEncoding(head,model)??head;head=StackNode.makeFromEncoding(head,model)??head}let preFilterInvalid;let dataSourcesForHandlingInvalidValues;if(isUnitModel(model)){const{markDef:markDef,mark:mark,config:config}=model;const invalid=getMarkPropOrConfig("invalid",markDef,config);const{marks:marks,scales:scales}=dataSourcesForHandlingInvalidValues=getDataSourcesForHandlingInvalidValues({invalid:invalid,isPath:isPathMark(mark)});if(marks!==scales&&scales==="include-invalid-values"){preFilterInvalid=head=makeOutputNode(DataSourceType.PreFilterInvalid,model,head)}if(marks==="exclude-invalid-values"){head=FilterInvalidNode.make(head,model,dataSourcesForHandlingInvalidValues)??head}}const main=head=makeOutputNode(DataSourceType.Main,model,head);let postFilterInvalid;if(isUnitModel(model)&&dataSourcesForHandlingInvalidValues){const{marks:marks,scales:scales}=dataSourcesForHandlingInvalidValues;if(marks==="include-invalid-values"&&scales==="exclude-invalid-values"){head=FilterInvalidNode.make(head,model,dataSourcesForHandlingInvalidValues)??head;postFilterInvalid=head=makeOutputNode(DataSourceType.PostFilterInvalid,model,head)}}if(isUnitModel(model)){materializeSelections(model,main)}let facetRoot=null;if(isFacetModel(model)){const facetName=model.getName("facet");head=makeJoinAggregateFromFacet(head,model.facet)??head;facetRoot=new FacetNode(head,model,facetName,main.getSource());outputNodes[facetName]=facetRoot}return{...model.component.data,outputNodes:outputNodes,outputNodeRefCounts:outputNodeRefCounts,raw:raw,main:main,facetRoot:facetRoot,ancestorParse:ancestorParse,preFilterInvalid:preFilterInvalid,postFilterInvalid:postFilterInvalid}}function makeOutputNode(dataSourceType,model,head){const{outputNodes:outputNodes,outputNodeRefCounts:outputNodeRefCounts}=model.component.data;const name=model.getDataName(dataSourceType);const node=new OutputNode(head,name,dataSourceType,outputNodeRefCounts);outputNodes[name]=node;return node}class ConcatModel extends Model{constructor(spec,parent,parentGivenName,config){super(spec,"concat",parent,parentGivenName,config,spec.resolve);if(spec.resolve?.axis?.x==="shared"||spec.resolve?.axis?.y==="shared"){warn(CONCAT_CANNOT_SHARE_AXIS)}this.children=this.getChildren(spec).map(((child,i)=>buildModel(child,this,this.getName(`concat_${i}`),undefined,config)))}parseData(){this.component.data=parseData(this);for(const child of this.children){child.parseData()}}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys(child.component.selection)){this.component.selection[key]=child.component.selection[key]}}}parseMarkGroup(){for(const child of this.children){child.parseMarkGroup()}}parseAxesAndHeaders(){for(const child of this.children){child.parseAxesAndHeaders()}}getChildren(spec){if(isVConcatSpec(spec)){return spec.vconcat}else if(isHConcatSpec(spec)){return spec.hconcat}return spec.concat}parseLayoutSize(){parseConcatLayoutSize(this)}parseAxisGroup(){return null}assembleSelectionTopLevelSignals(signals){return this.children.reduce(((sg,child)=>child.assembleSelectionTopLevelSignals(sg)),signals)}assembleSignals(){this.children.forEach((child=>child.assembleSignals()));return[]}assembleLayoutSignals(){const layoutSignals=assembleLayoutSignals(this);for(const child of this.children){layoutSignals.push(...child.assembleLayoutSignals())}return layoutSignals}assembleSelectionData(data){return this.children.reduce(((db,child)=>child.assembleSelectionData(db)),data)}assembleMarks(){return this.children.map((child=>{const title=child.assembleTitle();const style=child.assembleGroupStyle();const encodeEntry=child.assembleGroupEncodeEntry(false);return{type:"group",name:child.getName("group"),...title?{title:title}:{},...style?{style:style}:{},...encodeEntry?{encode:{update:encodeEntry}}:{},...child.assembleGroup()}}))}assembleGroupStyle(){return undefined}assembleDefaultLayout(){const columns=this.layout.columns;return{...columns!=null?{columns:columns}:{},bounds:"full",align:"each"}}}function isFalseOrNull(v){return v===false||v===null}const AXIS_COMPONENT_PROPERTIES_INDEX={disable:1,gridScale:1,scale:1,...COMMON_AXIS_PROPERTIES_INDEX,labelExpr:1,encode:1};const AXIS_COMPONENT_PROPERTIES=keys(AXIS_COMPONENT_PROPERTIES_INDEX);class AxisComponent extends Split{constructor(explicit={},implicit={},mainExtracted=false){super();this.explicit=explicit;this.implicit=implicit;this.mainExtracted=mainExtracted}clone(){return new AxisComponent(duplicate(this.explicit),duplicate(this.implicit),this.mainExtracted)}hasAxisPart(part){if(part==="axis"){return true}if(part==="grid"||part==="title"){return!!this.get(part)}return!isFalseOrNull(this.get(part))}hasOrientSignalRef(){return isSignalRef(this.explicit.orient)}}function labels(model,channel,specifiedLabelsSpec){const{encoding:encoding,config:config}=model;const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel])??getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);const axis=model.axis(channel)||{};const{format:format,formatType:formatType}=axis;if(isCustomFormatType(formatType)){return{text:formatCustomType({fieldOrDatumDef:fieldOrDatumDef,field:"datum.value",format:format,formatType:formatType,config:config}),...specifiedLabelsSpec}}else if(format===undefined&&formatType===undefined&&config.customFormatTypes){if(channelDefType(fieldOrDatumDef)==="quantitative"){if(isPositionFieldOrDatumDef(fieldOrDatumDef)&&fieldOrDatumDef.stack==="normalize"&&config.normalizedNumberFormatType){return{text:formatCustomType({fieldOrDatumDef:fieldOrDatumDef,field:"datum.value",format:config.normalizedNumberFormat,formatType:config.normalizedNumberFormatType,config:config}),...specifiedLabelsSpec}}else if(config.numberFormatType){return{text:formatCustomType({fieldOrDatumDef:fieldOrDatumDef,field:"datum.value",format:config.numberFormat,formatType:config.numberFormatType,config:config}),...specifiedLabelsSpec}}}if(channelDefType(fieldOrDatumDef)==="temporal"&&config.timeFormatType&&isFieldDef(fieldOrDatumDef)&&!fieldOrDatumDef.timeUnit){return{text:formatCustomType({fieldOrDatumDef:fieldOrDatumDef,field:"datum.value",format:config.timeFormat,formatType:config.timeFormatType,config:config}),...specifiedLabelsSpec}}}return specifiedLabelsSpec}function parseUnitAxes(model){return POSITION_SCALE_CHANNELS.reduce(((axis,channel)=>{if(model.component.scales[channel]){axis[channel]=[parseAxis(channel,model)]}return axis}),{})}const OPPOSITE_ORIENT={bottom:"top",top:"bottom",left:"right",right:"left"};function parseLayerAxes(model){const{axes:axes,resolve:resolve}=model.component;const axisCount={top:0,bottom:0,right:0,left:0};for(const child of model.children){child.parseAxesAndHeaders();for(const channel of keys(child.component.axes)){resolve.axis[channel]=parseGuideResolve(model.component.resolve,channel);if(resolve.axis[channel]==="shared"){axes[channel]=mergeAxisComponents(axes[channel],child.component.axes[channel]);if(!axes[channel]){resolve.axis[channel]="independent";delete axes[channel]}}}}for(const channel of POSITION_SCALE_CHANNELS){for(const child of model.children){if(!child.component.axes[channel]){continue}if(resolve.axis[channel]==="independent"){axes[channel]=(axes[channel]??[]).concat(child.component.axes[channel]);for(const axisComponent of child.component.axes[channel]){const{value:orient,explicit:explicit}=axisComponent.getWithExplicit("orient");if(isSignalRef(orient)){continue}if(axisCount[orient]>0&&!explicit){const oppositeOrient=OPPOSITE_ORIENT[orient];if(axisCount[orient]>axisCount[oppositeOrient]){axisComponent.set("orient",oppositeOrient,false)}}axisCount[orient]++}}delete child.component.axes[channel]}if(resolve.axis[channel]==="independent"&&axes[channel]&&axes[channel].length>1){for(const[index,axisCmpt]of(axes[channel]||[]).entries()){if(index>0&&!!axisCmpt.get("grid")&&!axisCmpt.explicit.grid){axisCmpt.implicit.grid=false}}}}}function mergeAxisComponents(mergedAxisCmpts,childAxisCmpts){if(mergedAxisCmpts){if(mergedAxisCmpts.length!==childAxisCmpts.length){return undefined}const length=mergedAxisCmpts.length;for(let i=0;i<length;i++){const merged=mergedAxisCmpts[i];const child=childAxisCmpts[i];if(!!merged!==!!child){return undefined}else if(merged&&child){const mergedOrient=merged.getWithExplicit("orient");const childOrient=child.getWithExplicit("orient");if(mergedOrient.explicit&&childOrient.explicit&&mergedOrient.value!==childOrient.value){return undefined}else{mergedAxisCmpts[i]=mergeAxisComponent(merged,child)}}}}else{return childAxisCmpts.map((axisComponent=>axisComponent.clone()))}return mergedAxisCmpts}function mergeAxisComponent(merged,child){for(const prop of AXIS_COMPONENT_PROPERTIES){const mergedValueWithExplicit=mergeValuesWithExplicit(merged.getWithExplicit(prop),child.getWithExplicit(prop),prop,"axis",((v1,v2)=>{switch(prop){case"title":return mergeTitleComponent(v1,v2);case"gridScale":return{explicit:v1.explicit,value:getFirstDefined(v1.value,v2.value)}}return defaultTieBreaker(v1,v2,prop,"axis")}));merged.setWithExplicit(prop,mergedValueWithExplicit)}return merged}function isExplicit(value,property,axis,model,channel){if(property==="disable"){return axis!==undefined}axis=axis||{};switch(property){case"titleAngle":case"labelAngle":return value===(isSignalRef(axis.labelAngle)?axis.labelAngle:normalizeAngle(axis.labelAngle));case"values":return!!axis.values;case"encode":return!!axis.encoding||!!axis.labelAngle;case"title":if(value===getFieldDefTitle(model,channel)){return true}}return value===axis[property]}const propsToAlwaysIncludeConfig=new Set(["grid","translate","format","formatType","orient","labelExpr","tickCount","position","tickMinStep"]);function parseAxis(channel,model){let axis=model.axis(channel);const axisComponent=new AxisComponent;const fieldOrDatumDef=getFieldOrDatumDef(model.encoding[channel]);const{mark:mark,config:config}=model;const orient=axis?.orient||config[channel==="x"?"axisX":"axisY"]?.orient||config.axis?.orient||defaultOrient(channel);const scaleType=model.getScaleComponent(channel).get("type");const axisConfigs=getAxisConfigs(channel,scaleType,orient,model.config);const disable=axis!==undefined?!axis:getAxisConfig("disable",config.style,axis?.style,axisConfigs).configValue;axisComponent.set("disable",disable,axis!==undefined);if(disable){return axisComponent}axis=axis||{};const labelAngle=getLabelAngle(fieldOrDatumDef,axis,channel,config.style,axisConfigs);const formatType=guideFormatType(axis.formatType,fieldOrDatumDef,scaleType);const format=guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,axis.format,axis.formatType,config,true);const ruleParams={fieldOrDatumDef:fieldOrDatumDef,axis:axis,channel:channel,model:model,scaleType:scaleType,orient:orient,labelAngle:labelAngle,format:format,formatType:formatType,mark:mark,config:config};for(const property of AXIS_COMPONENT_PROPERTIES){const value=property in axisRules?axisRules[property](ruleParams):isAxisProperty(property)?axis[property]:undefined;const hasValue=value!==undefined;const explicit=isExplicit(value,property,axis,model,channel);if(hasValue&&explicit){axisComponent.set(property,value,explicit)}else{const{configValue:configValue=undefined,configFrom:configFrom=undefined}=isAxisProperty(property)&&property!=="values"?getAxisConfig(property,config.style,axis.style,axisConfigs):{};const hasConfigValue=configValue!==undefined;if(hasValue&&!hasConfigValue){axisComponent.set(property,value,explicit)}else if(!(configFrom==="vgAxisConfig")||propsToAlwaysIncludeConfig.has(property)&&hasConfigValue||isConditionalAxisValue(configValue)||isSignalRef(configValue)){axisComponent.set(property,configValue,false)}}}const axisEncoding=axis.encoding??{};const axisEncode=AXIS_PARTS.reduce(((e,part)=>{if(!axisComponent.hasAxisPart(part)){return e}const axisEncodingPart=guideEncodeEntry(axisEncoding[part]??{},model);const value=part==="labels"?labels(model,channel,axisEncodingPart):axisEncodingPart;if(value!==undefined&&!isEmpty(value)){e[part]={update:value}}return e}),{});if(!isEmpty(axisEncode)){axisComponent.set("encode",axisEncode,!!axis.encoding||axis.labelAngle!==undefined)}return axisComponent}function initLayoutSize({encoding:encoding,size:size}){for(const channel of POSITION_SCALE_CHANNELS){const sizeType=getSizeChannel(channel);if(isStep(size[sizeType])){if(isContinuousFieldOrDatumDef(encoding[channel])){delete size[sizeType];warn(stepDropped(sizeType))}}}return size}const arc={vgMark:"arc",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"}),...pointPosition("x",model,{defaultPos:"mid"}),...pointPosition("y",model,{defaultPos:"mid"}),...rectPosition(model,"radius"),...rectPosition(model,"theta")})};const area={vgMark:"area",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"include",size:"ignore",theta:"ignore"}),...pointOrRangePosition("x",model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:model.markDef.orient==="horizontal"}),...pointOrRangePosition("y",model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:model.markDef.orient==="vertical"}),...defined(model)})};const bar={vgMark:"rect",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),...rectPosition(model,"x"),...rectPosition(model,"y")})};const geoshape={vgMark:"shape",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"})}),postEncodingTransform:model=>{const{encoding:encoding}=model;const shapeDef=encoding.shape;const transform={type:"geoshape",projection:model.projectionName(),...shapeDef&&isFieldDef(shapeDef)&&shapeDef.type===GEOJSON?{field:vgField(shapeDef,{expr:"datum"})}:{}};return[transform]}};const image={vgMark:"image",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"ignore",orient:"ignore",size:"ignore",theta:"ignore"}),...rectPosition(model,"x"),...rectPosition(model,"y"),...text$1(model,"url")})};const line={vgMark:"line",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"}),...pointPosition("x",model,{defaultPos:"mid"}),...pointPosition("y",model,{defaultPos:"mid"}),...nonPosition("size",model,{vgChannel:"strokeWidth"}),...defined(model)})};const trail={vgMark:"trail",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"}),...pointPosition("x",model,{defaultPos:"mid"}),...pointPosition("y",model,{defaultPos:"mid"}),...nonPosition("size",model),...defined(model)})};function encodeEntry(model,fixedShape){const{config:config}=model;return{...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"}),...pointPosition("x",model,{defaultPos:"mid"}),...pointPosition("y",model,{defaultPos:"mid"}),...nonPosition("size",model),...nonPosition("angle",model),...shapeMixins(model,config,fixedShape)}}function shapeMixins(model,config,fixedShape){if(fixedShape){return{shape:{value:fixedShape}}}return nonPosition("shape",model)}const point={vgMark:"symbol",encodeEntry:model=>encodeEntry(model)};const circle={vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"circle")};const square={vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"square")};const rect={vgMark:"rect",encodeEntry:model=>({...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),...rectPosition(model,"x"),...rectPosition(model,"y")})};const rule={vgMark:"rule",encodeEntry:model=>{const{markDef:markDef}=model;const orient=markDef.orient;if(!model.encoding.x&&!model.encoding.y&&!model.encoding.latitude&&!model.encoding.longitude){return{}}return{...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),...pointOrRangePosition("x",model,{defaultPos:orient==="horizontal"?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",range:orient!=="vertical"}),...pointOrRangePosition("y",model,{defaultPos:orient==="vertical"?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",range:orient!=="horizontal"}),...nonPosition("size",model,{vgChannel:"strokeWidth"})}}};const text={vgMark:"text",encodeEntry:model=>{const{config:config,encoding:encoding}=model;return{...baseEncodeEntry(model,{align:"include",baseline:"include",color:"include",size:"ignore",orient:"ignore",theta:"include"}),...pointPosition("x",model,{defaultPos:"mid"}),...pointPosition("y",model,{defaultPos:"mid"}),...text$1(model),...nonPosition("size",model,{vgChannel:"fontSize"}),...nonPosition("angle",model),...valueIfDefined("align",align(model.markDef,encoding,config)),...valueIfDefined("baseline",baseline(model.markDef,encoding,config)),...pointPosition("radius",model,{defaultPos:null}),...pointPosition("theta",model,{defaultPos:null})}}};function align(markDef,encoding,config){const a=getMarkPropOrConfig("align",markDef,config);if(a===undefined){return"center"}return undefined}function baseline(markDef,encoding,config){const b=getMarkPropOrConfig("baseline",markDef,config);if(b===undefined){return"middle"}return undefined}const tick={vgMark:"rect",encodeEntry:model=>{const{config:config,markDef:markDef}=model;const orient=markDef.orient;const vgSizeAxisChannel=orient==="horizontal"?"x":"y";const vgThicknessAxisChannel=orient==="horizontal"?"y":"x";const vgThicknessChannel=orient==="horizontal"?"height":"width";return{...baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),...rectPosition(model,vgSizeAxisChannel),...pointPosition(vgThicknessAxisChannel,model,{defaultPos:"mid",vgChannel:vgThicknessAxisChannel==="y"?"yc":"xc"}),[vgThicknessChannel]:signalOrValueRef(getMarkPropOrConfig("thickness",markDef,config))}}};const markCompiler={arc:arc,area:area,bar:bar,circle:circle,geoshape:geoshape,image:image,line:line,point:point,rect:rect,rule:rule,square:square,text:text,tick:tick,trail:trail};function parseMarkGroups(model){if(contains([LINE,AREA,TRAIL],model.mark)){const details=pathGroupingFields(model.mark,model.encoding);if(details.length>0){return getPathGroups(model,details)}}else if(model.mark===BAR){const hasCornerRadius=VG_CORNERRADIUS_CHANNELS.some((prop=>getMarkPropOrConfig(prop,model.markDef,model.config)));if(model.stack&&!model.fieldDef("size")&&hasCornerRadius){return getGroupsForStackedBarWithCornerRadius(model)}}return getMarkGroup(model)}const FACETED_PATH_PREFIX="faceted_path_";function getPathGroups(model,details){return[{name:model.getName("pathgroup"),type:"group",from:{facet:{name:FACETED_PATH_PREFIX+model.requestDataName(DataSourceType.Main),data:model.requestDataName(DataSourceType.Main),groupby:details}},encode:{update:{width:{field:{group:"width"}},height:{field:{group:"height"}}}},marks:getMarkGroup(model,{fromPrefix:FACETED_PATH_PREFIX})}]}const STACK_GROUP_PREFIX="stack_group_";function getGroupsForStackedBarWithCornerRadius(model){const[mark]=getMarkGroup(model,{fromPrefix:STACK_GROUP_PREFIX});const fieldScale=model.scaleName(model.stack.fieldChannel);const stackField=(opt={})=>model.vgField(model.stack.fieldChannel,opt);const stackFieldGroup=(func,expr)=>{const vgFieldMinMax=[stackField({prefix:"min",suffix:"start",expr:expr}),stackField({prefix:"max",suffix:"start",expr:expr}),stackField({prefix:"min",suffix:"end",expr:expr}),stackField({prefix:"max",suffix:"end",expr:expr})];return`${func}(${vgFieldMinMax.map((field=>`scale('${fieldScale}',${field})`)).join(",")})`};let groupUpdate;let innerGroupUpdate;if(model.stack.fieldChannel==="x"){groupUpdate={...pick(mark.encode.update,["y","yc","y2","height",...VG_CORNERRADIUS_CHANNELS]),x:{signal:stackFieldGroup("min","datum")},x2:{signal:stackFieldGroup("max","datum")},clip:{value:true}};innerGroupUpdate={x:{field:{group:"x"},mult:-1},height:{field:{group:"height"}}};mark.encode.update={...omit(mark.encode.update,["y","yc","y2"]),height:{field:{group:"height"}}}}else{groupUpdate={...pick(mark.encode.update,["x","xc","x2","width"]),y:{signal:stackFieldGroup("min","datum")},y2:{signal:stackFieldGroup("max","datum")},clip:{value:true}};innerGroupUpdate={y:{field:{group:"y"},mult:-1},width:{field:{group:"width"}}};mark.encode.update={...omit(mark.encode.update,["x","xc","x2"]),width:{field:{group:"width"}}}}for(const key of VG_CORNERRADIUS_CHANNELS){const configValue=getMarkConfig(key,model.markDef,model.config);if(mark.encode.update[key]){groupUpdate[key]=mark.encode.update[key];delete mark.encode.update[key]}else if(configValue){groupUpdate[key]=signalOrValueRef(configValue)}if(configValue){mark.encode.update[key]={value:0}}}const groupby=[];if(model.stack.groupbyChannels?.length>0){for(const groupbyChannel of model.stack.groupbyChannels){const groupByField=model.fieldDef(groupbyChannel);const field=vgField(groupByField);if(field){groupby.push(field)}if(groupByField?.bin||groupByField?.timeUnit){groupby.push(vgField(groupByField,{binSuffix:"end"}))}}}const strokeProperties=["stroke","strokeWidth","strokeJoin","strokeCap","strokeDash","strokeDashOffset","strokeMiterLimit","strokeOpacity"];groupUpdate=strokeProperties.reduce(((encode,prop)=>{if(mark.encode.update[prop]){return{...encode,[prop]:mark.encode.update[prop]}}else{const configValue=getMarkConfig(prop,model.markDef,model.config);if(configValue!==undefined){return{...encode,[prop]:signalOrValueRef(configValue)}}else{return encode}}}),groupUpdate);if(groupUpdate.stroke){groupUpdate.strokeForeground={value:true};groupUpdate.strokeOffset={value:0}}return[{type:"group",from:{facet:{data:model.requestDataName(DataSourceType.Main),name:STACK_GROUP_PREFIX+model.requestDataName(DataSourceType.Main),groupby:groupby,aggregate:{fields:[stackField({suffix:"start"}),stackField({suffix:"start"}),stackField({suffix:"end"}),stackField({suffix:"end"})],ops:["min","max","min","max"]}}},encode:{update:groupUpdate},marks:[{type:"group",encode:{update:innerGroupUpdate},marks:[mark]}]}]}function getSort(model){const{encoding:encoding,stack:stack,mark:mark,markDef:markDef,config:config}=model;const order=encoding.order;if(!isArray(order)&&isValueDef(order)&&isNullOrFalse(order.value)||!order&&isNullOrFalse(getMarkPropOrConfig("order",markDef,config))){return undefined}else if((isArray(order)||isFieldDef(order))&&!stack){return sortParams(order,{expr:"datum"})}else if(isPathMark(mark)){const dimensionChannel=markDef.orient==="horizontal"?"y":"x";const dimensionChannelDef=encoding[dimensionChannel];if(isFieldDef(dimensionChannelDef)){return{field:dimensionChannel}}}return undefined}function getMarkGroup(model,opt={fromPrefix:""}){const{mark:mark,markDef:markDef,encoding:encoding,config:config}=model;const clip=getFirstDefined(markDef.clip,scaleClip(model),projectionClip(model));const style=getStyles(markDef);const key=encoding.key;const sort=getSort(model);const interactive=interactiveFlag(model);const aria=getMarkPropOrConfig("aria",markDef,config);const postEncodingTransform=markCompiler[mark].postEncodingTransform?markCompiler[mark].postEncodingTransform(model):null;return[{name:model.getName("marks"),type:markCompiler[mark].vgMark,...clip?{clip:clip}:{},...style?{style:style}:{},...key?{key:key.field}:{},...sort?{sort:sort}:{},...interactive?interactive:{},...aria===false?{aria:aria}:{},from:{data:opt.fromPrefix+model.requestDataName(DataSourceType.Main)},encode:{update:markCompiler[mark].encodeEntry(model)},...postEncodingTransform?{transform:postEncodingTransform}:{}}]}function scaleClip(model){const xScale=model.getScaleComponent("x");const yScale=model.getScaleComponent("y");return xScale?.get("selectionExtent")||yScale?.get("selectionExtent")?true:undefined}function projectionClip(model){const projection=model.component.projection;return projection&&!projection.isFit?true:undefined}function interactiveFlag(model){if(!model.component.selection)return null;const unitCount=keys(model.component.selection).length;let parentCount=unitCount;let parent=model.parent;while(parent&&parentCount===0){parentCount=keys(parent.component.selection).length;parent=parent.parent}return parentCount?{interactive:unitCount>0||model.mark==="geoshape"||!!model.encoding.tooltip||!!model.markDef.tooltip}:null}class UnitModel extends ModelWithField{constructor(spec,parent,parentGivenName,parentGivenSize={},config){super(spec,"unit",parent,parentGivenName,config,undefined,isFrameMixins(spec)?spec.view:undefined);this.specifiedScales={};this.specifiedAxes={};this.specifiedLegends={};this.specifiedProjection={};this.selection=[];this.children=[];const markDef=isMarkDef(spec.mark)?{...spec.mark}:{type:spec.mark};const mark=markDef.type;if(markDef.filled===undefined){markDef.filled=defaultFilled(markDef,config,{graticule:spec.data&&isGraticuleGenerator(spec.data)})}const encoding=this.encoding=initEncoding(spec.encoding||{},mark,markDef.filled,config);this.markDef=initMarkdef(markDef,encoding,config);this.size=initLayoutSize({encoding:encoding,size:isFrameMixins(spec)?{...parentGivenSize,...spec.width?{width:spec.width}:{},...spec.height?{height:spec.height}:{}}:parentGivenSize});this.stack=stack(this.markDef,encoding);this.specifiedScales=this.initScales(mark,encoding);this.specifiedAxes=this.initAxes(encoding);this.specifiedLegends=this.initLegends(encoding);this.specifiedProjection=spec.projection;this.selection=(spec.params??[]).filter((p=>isSelectionParameter(p)))}get hasProjection(){const{encoding:encoding}=this;const isGeoShapeMark=this.mark===GEOSHAPE;const hasGeoPosition=encoding&&GEOPOSITION_CHANNELS.some((channel=>isFieldOrDatumDef(encoding[channel])));return isGeoShapeMark||hasGeoPosition}scaleDomain(channel){const scale=this.specifiedScales[channel];return scale?scale.domain:undefined}axis(channel){return this.specifiedAxes[channel]}legend(channel){return this.specifiedLegends[channel]}initScales(mark,encoding){return SCALE_CHANNELS.reduce(((scales,channel)=>{const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);if(fieldOrDatumDef){scales[channel]=this.initScale(fieldOrDatumDef.scale??{})}return scales}),{})}initScale(scale){const{domain:domain,range:range}=scale;const scaleInternal=replaceExprRef(scale);if(isArray(domain)){scaleInternal.domain=domain.map(signalRefOrValue)}if(isArray(range)){scaleInternal.range=range.map(signalRefOrValue)}return scaleInternal}initAxes(encoding){return POSITION_SCALE_CHANNELS.reduce(((_axis,channel)=>{const channelDef=encoding[channel];if(isFieldOrDatumDef(channelDef)||channel===X&&isFieldOrDatumDef(encoding.x2)||channel===Y&&isFieldOrDatumDef(encoding.y2)){const axisSpec=isFieldOrDatumDef(channelDef)?channelDef.axis:undefined;_axis[channel]=axisSpec?this.initAxis({...axisSpec}):axisSpec}return _axis}),{})}initAxis(axis){const props=keys(axis);const axisInternal={};for(const prop of props){const val=axis[prop];axisInternal[prop]=isConditionalAxisValue(val)?signalOrValueRefWithCondition(val):signalRefOrValue(val)}return axisInternal}initLegends(encoding){return NONPOSITION_SCALE_CHANNELS.reduce(((_legend,channel)=>{const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);if(fieldOrDatumDef&&supportLegend(channel)){const legend=fieldOrDatumDef.legend;_legend[channel]=legend?replaceExprRef(legend):legend}return _legend}),{})}parseData(){this.component.data=parseData(this)}parseLayoutSize(){parseUnitLayoutSize(this)}parseSelections(){this.component.selection=parseUnitSelection(this,this.selection)}parseMarkGroup(){this.component.mark=parseMarkGroups(this)}parseAxesAndHeaders(){this.component.axes=parseUnitAxes(this)}assembleSelectionTopLevelSignals(signals){return assembleTopLevelSignals(this,signals)}assembleSignals(){return[...assembleAxisSignals(this),...assembleUnitSelectionSignals(this,[])]}assembleSelectionData(data){return assembleUnitSelectionData(this,data)}assembleLayout(){return null}assembleLayoutSignals(){return assembleLayoutSignals(this)}assembleMarks(){let marks=this.component.mark??[];if(!this.parent||!isLayerModel(this.parent)){marks=assembleUnitSelectionMarks(this,marks)}return marks.map(this.correctDataNames)}assembleGroupStyle(){const{style:style}=this.view||{};if(style!==undefined){return style}if(this.encoding.x||this.encoding.y){return"cell"}else{return"view"}}getMapping(){return this.encoding}get mark(){return this.markDef.type}channelHasField(channel){return channelHasField(this.encoding,channel)}fieldDef(channel){const channelDef=this.encoding[channel];return getFieldDef(channelDef)}typedFieldDef(channel){const fieldDef=this.fieldDef(channel);if(isTypedFieldDef(fieldDef)){return fieldDef}return null}}class LayerModel extends Model{constructor(spec,parent,parentGivenName,parentGivenSize,config){super(spec,"layer",parent,parentGivenName,config,spec.resolve,spec.view);const layoutSize={...parentGivenSize,...spec.width?{width:spec.width}:{},...spec.height?{height:spec.height}:{}};this.children=spec.layer.map(((layer,i)=>{if(isLayerSpec(layer)){return new LayerModel(layer,this,this.getName(`layer_${i}`),layoutSize,config)}else if(isUnitSpec(layer)){return new UnitModel(layer,this,this.getName(`layer_${i}`),layoutSize,config)}throw new Error(invalidSpec(layer))}))}parseData(){this.component.data=parseData(this);for(const child of this.children){child.parseData()}}parseLayoutSize(){parseLayerLayoutSize(this)}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys(child.component.selection)){this.component.selection[key]=child.component.selection[key]}}}parseMarkGroup(){for(const child of this.children){child.parseMarkGroup()}}parseAxesAndHeaders(){parseLayerAxes(this)}assembleSelectionTopLevelSignals(signals){return this.children.reduce(((sg,child)=>child.assembleSelectionTopLevelSignals(sg)),signals)}assembleSignals(){return this.children.reduce(((signals,child)=>signals.concat(child.assembleSignals())),assembleAxisSignals(this))}assembleLayoutSignals(){return this.children.reduce(((signals,child)=>signals.concat(child.assembleLayoutSignals())),assembleLayoutSignals(this))}assembleSelectionData(data){return this.children.reduce(((db,child)=>child.assembleSelectionData(db)),data)}assembleGroupStyle(){const uniqueStyles=new Set;for(const child of this.children){for(const style of array$5(child.assembleGroupStyle())){uniqueStyles.add(style)}}const styles=Array.from(uniqueStyles);return styles.length>1?styles:styles.length===1?styles[0]:undefined}assembleTitle(){let title=super.assembleTitle();if(title){return title}for(const child of this.children){title=child.assembleTitle();if(title){return title}}return undefined}assembleLayout(){return null}assembleMarks(){return assembleLayerSelectionMarks(this,this.children.flatMap((child=>child.assembleMarks())))}assembleLegends(){return this.children.reduce(((legends,child)=>legends.concat(child.assembleLegends())),assembleLegends(this))}}function buildModel(spec,parent,parentGivenName,unitSize,config){if(isFacetSpec(spec)){return new FacetModel(spec,parent,parentGivenName,config)}else if(isLayerSpec(spec)){return new LayerModel(spec,parent,parentGivenName,unitSize,config)}else if(isUnitSpec(spec)){return new UnitModel(spec,parent,parentGivenName,unitSize,config)}else if(isAnyConcatSpec(spec)){return new ConcatModel(spec,parent,parentGivenName,config)}throw new Error(invalidSpec(spec))}function compile(inputSpec,opt={}){if(opt.logger){set(opt.logger)}if(opt.fieldTitle){setTitleFormatter(opt.fieldTitle)}try{const config=initConfig(mergeConfig(opt.config,inputSpec.config));const spec=normalize(inputSpec,config);const model=buildModel(spec,null,"",undefined,config);model.parse();optimizeDataflow(model.component.data,model);const vgSpec=assembleTopLevelModel(model,getTopLevelProperties(inputSpec,spec.autosize,config,model),inputSpec.datasets,inputSpec.usermeta);return{spec:vgSpec,normalized:spec}}finally{if(opt.logger){reset()}if(opt.fieldTitle){resetTitleFormatter()}}}function getTopLevelProperties(inputSpec,autosize,config,model){const width=model.component.layoutSize.get("width");const height=model.component.layoutSize.get("height");if(autosize===undefined){autosize={type:"pad"};if(model.hasAxisOrientSignalRef()){autosize.resize=true}}else if(isString(autosize)){autosize={type:autosize}}if(width&&height&&isFitType(autosize.type)){if(width==="step"&&height==="step"){warn(droppingFit());autosize.type="pad"}else if(width==="step"||height==="step"){const sizeType=width==="step"?"width":"height";warn(droppingFit(getPositionScaleChannel(sizeType)));const inverseSizeType=sizeType==="width"?"height":"width";autosize.type=getFitType(inverseSizeType)}}return{...keys(autosize).length===1&&autosize.type?autosize.type==="pad"?{}:{autosize:autosize.type}:{autosize:autosize},...extractTopLevelProperties(config,false),...extractTopLevelProperties(inputSpec,true)}}function assembleTopLevelModel(model,topLevelProperties,datasets={},usermeta){const vgConfig=model.config?stripAndRedirectConfig(model.config):undefined;const data=[].concat(model.assembleSelectionData([]),assembleRootData(model.component.data,datasets));const projections=model.assembleProjections();const title=model.assembleTitle();const style=model.assembleGroupStyle();const encodeEntry=model.assembleGroupEncodeEntry(true);let layoutSignals=model.assembleLayoutSignals();layoutSignals=layoutSignals.filter((signal=>{if((signal.name==="width"||signal.name==="height")&&signal.value!==undefined){topLevelProperties[signal.name]=+signal.value;return false}return true}));const{params:params,...otherTopLevelProps}=topLevelProperties;return{$schema:"https://vega.github.io/schema/vega/v5.json",...model.description?{description:model.description}:{},...otherTopLevelProps,...title?{title:title}:{},...style?{style:style}:{},...encodeEntry?{encode:{update:encodeEntry}}:{},data:data,...projections.length>0?{projections:projections}:{},...model.assembleGroup([...layoutSignals,...model.assembleSelectionTopLevelSignals([]),...assembleParameterSignals(params)]),...vgConfig?{config:vgConfig}:{},...usermeta?{usermeta:usermeta}:{}}}async function render_vl_helper(yourVlSpec){let vegaspec=compile(yourVlSpec).spec;var view=new View$1(parse(vegaspec),{renderer:"none"});const k=await view.toSVG();return k}export{render_vl_helper};